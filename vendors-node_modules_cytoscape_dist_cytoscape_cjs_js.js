/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_cytoscape_dist_cytoscape_cjs_js"],{

/***/ "../node_modules/cytoscape/dist/cytoscape.cjs.js":
/*!*******************************************************!*\
  !*** ../node_modules/cytoscape/dist/cytoscape.cjs.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) 2016-2023, The Cytoscape Consortium.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the “Software”), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n\nvar debounce = __webpack_require__(/*! lodash/debounce */ \"../node_modules/lodash/debounce.js\");\nvar Heap = __webpack_require__(/*! heap */ \"../node_modules/heap/index.js\");\nvar get = __webpack_require__(/*! lodash/get */ \"../node_modules/lodash/get.js\");\nvar set = __webpack_require__(/*! lodash/set */ \"../node_modules/lodash/set.js\");\nvar toPath = __webpack_require__(/*! lodash/toPath */ \"../node_modules/lodash/toPath.js\");\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar debounce__default = /*#__PURE__*/_interopDefaultLegacy(debounce);\nvar Heap__default = /*#__PURE__*/_interopDefaultLegacy(Heap);\nvar get__default = /*#__PURE__*/_interopDefaultLegacy(get);\nvar set__default = /*#__PURE__*/_interopDefaultLegacy(set);\nvar toPath__default = /*#__PURE__*/_interopDefaultLegacy(toPath);\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar _window = typeof window === 'undefined' ? null : window; // eslint-disable-line no-undef\n\nvar navigator = _window ? _window.navigator : null;\n_window ? _window.document : null;\n\nvar typeofstr = _typeof('');\n\nvar typeofobj = _typeof({});\n\nvar typeoffn = _typeof(function () {});\n\nvar typeofhtmlele = typeof HTMLElement === \"undefined\" ? \"undefined\" : _typeof(HTMLElement);\n\nvar instanceStr = function instanceStr(obj) {\n  return obj && obj.instanceString && fn$6(obj.instanceString) ? obj.instanceString() : null;\n};\n\nvar string = function string(obj) {\n  return obj != null && _typeof(obj) == typeofstr;\n};\nvar fn$6 = function fn(obj) {\n  return obj != null && _typeof(obj) === typeoffn;\n};\nvar array = function array(obj) {\n  return !elementOrCollection(obj) && (Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array);\n};\nvar plainObject = function plainObject(obj) {\n  return obj != null && _typeof(obj) === typeofobj && !array(obj) && obj.constructor === Object;\n};\nvar object = function object(obj) {\n  return obj != null && _typeof(obj) === typeofobj;\n};\nvar number$1 = function number(obj) {\n  return obj != null && _typeof(obj) === _typeof(1) && !isNaN(obj);\n};\nvar integer = function integer(obj) {\n  return number$1(obj) && Math.floor(obj) === obj;\n};\nvar htmlElement = function htmlElement(obj) {\n  if ('undefined' === typeofhtmlele) {\n    return undefined;\n  } else {\n    return null != obj && obj instanceof HTMLElement;\n  }\n};\nvar elementOrCollection = function elementOrCollection(obj) {\n  return element(obj) || collection(obj);\n};\nvar element = function element(obj) {\n  return instanceStr(obj) === 'collection' && obj._private.single;\n};\nvar collection = function collection(obj) {\n  return instanceStr(obj) === 'collection' && !obj._private.single;\n};\nvar core = function core(obj) {\n  return instanceStr(obj) === 'core';\n};\nvar stylesheet = function stylesheet(obj) {\n  return instanceStr(obj) === 'stylesheet';\n};\nvar event = function event(obj) {\n  return instanceStr(obj) === 'event';\n};\nvar emptyString = function emptyString(obj) {\n  if (obj === undefined || obj === null) {\n    // null is empty\n    return true;\n  } else if (obj === '' || obj.match(/^\\s+$/)) {\n    return true; // empty string is empty\n  }\n\n  return false; // otherwise, we don't know what we've got\n};\nvar domElement = function domElement(obj) {\n  if (typeof HTMLElement === 'undefined') {\n    return false; // we're not in a browser so it doesn't matter\n  } else {\n    return obj instanceof HTMLElement;\n  }\n};\nvar boundingBox = function boundingBox(obj) {\n  return plainObject(obj) && number$1(obj.x1) && number$1(obj.x2) && number$1(obj.y1) && number$1(obj.y2);\n};\nvar promise = function promise(obj) {\n  return object(obj) && fn$6(obj.then);\n};\nvar ms = function ms() {\n  return navigator && navigator.userAgent.match(/msie|trident|edge/i);\n}; // probably a better way to detect this...\n\nvar memoize = function memoize(fn, keyFn) {\n  if (!keyFn) {\n    keyFn = function keyFn() {\n      if (arguments.length === 1) {\n        return arguments[0];\n      } else if (arguments.length === 0) {\n        return 'undefined';\n      }\n\n      var args = [];\n\n      for (var i = 0; i < arguments.length; i++) {\n        args.push(arguments[i]);\n      }\n\n      return args.join('$');\n    };\n  }\n\n  var memoizedFn = function memoizedFn() {\n    var self = this;\n    var args = arguments;\n    var ret;\n    var k = keyFn.apply(self, args);\n    var cache = memoizedFn.cache;\n\n    if (!(ret = cache[k])) {\n      ret = cache[k] = fn.apply(self, args);\n    }\n\n    return ret;\n  };\n\n  memoizedFn.cache = {};\n  return memoizedFn;\n};\n\nvar camel2dash = memoize(function (str) {\n  return str.replace(/([A-Z])/g, function (v) {\n    return '-' + v.toLowerCase();\n  });\n});\nvar dash2camel = memoize(function (str) {\n  return str.replace(/(-\\w)/g, function (v) {\n    return v[1].toUpperCase();\n  });\n});\nvar prependCamel = memoize(function (prefix, str) {\n  return prefix + str[0].toUpperCase() + str.substring(1);\n}, function (prefix, str) {\n  return prefix + '$' + str;\n});\nvar capitalize = function capitalize(str) {\n  if (emptyString(str)) {\n    return str;\n  }\n\n  return str.charAt(0).toUpperCase() + str.substring(1);\n};\n\nvar number = '(?:[-+]?(?:(?:\\\\d+|\\\\d*\\\\.\\\\d+)(?:[Ee][+-]?\\\\d+)?))';\nvar rgba = 'rgb[a]?\\\\((' + number + '[%]?)\\\\s*,\\\\s*(' + number + '[%]?)\\\\s*,\\\\s*(' + number + '[%]?)(?:\\\\s*,\\\\s*(' + number + '))?\\\\)';\nvar rgbaNoBackRefs = 'rgb[a]?\\\\((?:' + number + '[%]?)\\\\s*,\\\\s*(?:' + number + '[%]?)\\\\s*,\\\\s*(?:' + number + '[%]?)(?:\\\\s*,\\\\s*(?:' + number + '))?\\\\)';\nvar hsla = 'hsl[a]?\\\\((' + number + ')\\\\s*,\\\\s*(' + number + '[%])\\\\s*,\\\\s*(' + number + '[%])(?:\\\\s*,\\\\s*(' + number + '))?\\\\)';\nvar hslaNoBackRefs = 'hsl[a]?\\\\((?:' + number + ')\\\\s*,\\\\s*(?:' + number + '[%])\\\\s*,\\\\s*(?:' + number + '[%])(?:\\\\s*,\\\\s*(?:' + number + '))?\\\\)';\nvar hex3 = '\\\\#[0-9a-fA-F]{3}';\nvar hex6 = '\\\\#[0-9a-fA-F]{6}';\n\nvar ascending = function ascending(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else {\n    return 0;\n  }\n};\nvar descending = function descending(a, b) {\n  return -1 * ascending(a, b);\n};\n\nvar extend = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {\n  var args = arguments;\n\n  for (var i = 1; i < args.length; i++) {\n    var obj = args[i];\n\n    if (obj == null) {\n      continue;\n    }\n\n    var keys = Object.keys(obj);\n\n    for (var j = 0; j < keys.length; j++) {\n      var k = keys[j];\n      tgt[k] = obj[k];\n    }\n  }\n\n  return tgt;\n};\n\nvar hex2tuple = function hex2tuple(hex) {\n  if (!(hex.length === 4 || hex.length === 7) || hex[0] !== '#') {\n    return;\n  }\n\n  var shortHex = hex.length === 4;\n  var r, g, b;\n  var base = 16;\n\n  if (shortHex) {\n    r = parseInt(hex[1] + hex[1], base);\n    g = parseInt(hex[2] + hex[2], base);\n    b = parseInt(hex[3] + hex[3], base);\n  } else {\n    r = parseInt(hex[1] + hex[2], base);\n    g = parseInt(hex[3] + hex[4], base);\n    b = parseInt(hex[5] + hex[6], base);\n  }\n\n  return [r, g, b];\n}; // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)\n\nvar hsl2tuple = function hsl2tuple(hsl) {\n  var ret;\n  var h, s, l, a, r, g, b;\n\n  function hue2rgb(p, q, t) {\n    if (t < 0) t += 1;\n    if (t > 1) t -= 1;\n    if (t < 1 / 6) return p + (q - p) * 6 * t;\n    if (t < 1 / 2) return q;\n    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n  }\n\n  var m = new RegExp('^' + hsla + '$').exec(hsl);\n\n  if (m) {\n    // get hue\n    h = parseInt(m[1]);\n\n    if (h < 0) {\n      h = (360 - -1 * h % 360) % 360;\n    } else if (h > 360) {\n      h = h % 360;\n    }\n\n    h /= 360; // normalise on [0, 1]\n\n    s = parseFloat(m[2]);\n\n    if (s < 0 || s > 100) {\n      return;\n    } // saturation is [0, 100]\n\n\n    s = s / 100; // normalise on [0, 1]\n\n    l = parseFloat(m[3]);\n\n    if (l < 0 || l > 100) {\n      return;\n    } // lightness is [0, 100]\n\n\n    l = l / 100; // normalise on [0, 1]\n\n    a = m[4];\n\n    if (a !== undefined) {\n      a = parseFloat(a);\n\n      if (a < 0 || a > 1) {\n        return;\n      } // alpha is [0, 1]\n\n    } // now, convert to rgb\n    // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript\n\n\n    if (s === 0) {\n      r = g = b = Math.round(l * 255); // achromatic\n    } else {\n      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      var p = 2 * l - q;\n      r = Math.round(255 * hue2rgb(p, q, h + 1 / 3));\n      g = Math.round(255 * hue2rgb(p, q, h));\n      b = Math.round(255 * hue2rgb(p, q, h - 1 / 3));\n    }\n\n    ret = [r, g, b, a];\n  }\n\n  return ret;\n}; // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)\n\nvar rgb2tuple = function rgb2tuple(rgb) {\n  var ret;\n  var m = new RegExp('^' + rgba + '$').exec(rgb);\n\n  if (m) {\n    ret = [];\n    var isPct = [];\n\n    for (var i = 1; i <= 3; i++) {\n      var channel = m[i];\n\n      if (channel[channel.length - 1] === '%') {\n        isPct[i] = true;\n      }\n\n      channel = parseFloat(channel);\n\n      if (isPct[i]) {\n        channel = channel / 100 * 255; // normalise to [0, 255]\n      }\n\n      if (channel < 0 || channel > 255) {\n        return;\n      } // invalid channel value\n\n\n      ret.push(Math.floor(channel));\n    }\n\n    var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];\n    var allArePct = isPct[1] && isPct[2] && isPct[3];\n\n    if (atLeastOneIsPct && !allArePct) {\n      return;\n    } // must all be percent values if one is\n\n\n    var alpha = m[4];\n\n    if (alpha !== undefined) {\n      alpha = parseFloat(alpha);\n\n      if (alpha < 0 || alpha > 1) {\n        return;\n      } // invalid alpha value\n\n\n      ret.push(alpha);\n    }\n  }\n\n  return ret;\n};\nvar colorname2tuple = function colorname2tuple(color) {\n  return colors[color.toLowerCase()];\n};\nvar color2tuple = function color2tuple(color) {\n  return (array(color) ? color : null) || colorname2tuple(color) || hex2tuple(color) || rgb2tuple(color) || hsl2tuple(color);\n};\nvar colors = {\n  // special colour names\n  transparent: [0, 0, 0, 0],\n  // NB alpha === 0\n  // regular colours\n  aliceblue: [240, 248, 255],\n  antiquewhite: [250, 235, 215],\n  aqua: [0, 255, 255],\n  aquamarine: [127, 255, 212],\n  azure: [240, 255, 255],\n  beige: [245, 245, 220],\n  bisque: [255, 228, 196],\n  black: [0, 0, 0],\n  blanchedalmond: [255, 235, 205],\n  blue: [0, 0, 255],\n  blueviolet: [138, 43, 226],\n  brown: [165, 42, 42],\n  burlywood: [222, 184, 135],\n  cadetblue: [95, 158, 160],\n  chartreuse: [127, 255, 0],\n  chocolate: [210, 105, 30],\n  coral: [255, 127, 80],\n  cornflowerblue: [100, 149, 237],\n  cornsilk: [255, 248, 220],\n  crimson: [220, 20, 60],\n  cyan: [0, 255, 255],\n  darkblue: [0, 0, 139],\n  darkcyan: [0, 139, 139],\n  darkgoldenrod: [184, 134, 11],\n  darkgray: [169, 169, 169],\n  darkgreen: [0, 100, 0],\n  darkgrey: [169, 169, 169],\n  darkkhaki: [189, 183, 107],\n  darkmagenta: [139, 0, 139],\n  darkolivegreen: [85, 107, 47],\n  darkorange: [255, 140, 0],\n  darkorchid: [153, 50, 204],\n  darkred: [139, 0, 0],\n  darksalmon: [233, 150, 122],\n  darkseagreen: [143, 188, 143],\n  darkslateblue: [72, 61, 139],\n  darkslategray: [47, 79, 79],\n  darkslategrey: [47, 79, 79],\n  darkturquoise: [0, 206, 209],\n  darkviolet: [148, 0, 211],\n  deeppink: [255, 20, 147],\n  deepskyblue: [0, 191, 255],\n  dimgray: [105, 105, 105],\n  dimgrey: [105, 105, 105],\n  dodgerblue: [30, 144, 255],\n  firebrick: [178, 34, 34],\n  floralwhite: [255, 250, 240],\n  forestgreen: [34, 139, 34],\n  fuchsia: [255, 0, 255],\n  gainsboro: [220, 220, 220],\n  ghostwhite: [248, 248, 255],\n  gold: [255, 215, 0],\n  goldenrod: [218, 165, 32],\n  gray: [128, 128, 128],\n  grey: [128, 128, 128],\n  green: [0, 128, 0],\n  greenyellow: [173, 255, 47],\n  honeydew: [240, 255, 240],\n  hotpink: [255, 105, 180],\n  indianred: [205, 92, 92],\n  indigo: [75, 0, 130],\n  ivory: [255, 255, 240],\n  khaki: [240, 230, 140],\n  lavender: [230, 230, 250],\n  lavenderblush: [255, 240, 245],\n  lawngreen: [124, 252, 0],\n  lemonchiffon: [255, 250, 205],\n  lightblue: [173, 216, 230],\n  lightcoral: [240, 128, 128],\n  lightcyan: [224, 255, 255],\n  lightgoldenrodyellow: [250, 250, 210],\n  lightgray: [211, 211, 211],\n  lightgreen: [144, 238, 144],\n  lightgrey: [211, 211, 211],\n  lightpink: [255, 182, 193],\n  lightsalmon: [255, 160, 122],\n  lightseagreen: [32, 178, 170],\n  lightskyblue: [135, 206, 250],\n  lightslategray: [119, 136, 153],\n  lightslategrey: [119, 136, 153],\n  lightsteelblue: [176, 196, 222],\n  lightyellow: [255, 255, 224],\n  lime: [0, 255, 0],\n  limegreen: [50, 205, 50],\n  linen: [250, 240, 230],\n  magenta: [255, 0, 255],\n  maroon: [128, 0, 0],\n  mediumaquamarine: [102, 205, 170],\n  mediumblue: [0, 0, 205],\n  mediumorchid: [186, 85, 211],\n  mediumpurple: [147, 112, 219],\n  mediumseagreen: [60, 179, 113],\n  mediumslateblue: [123, 104, 238],\n  mediumspringgreen: [0, 250, 154],\n  mediumturquoise: [72, 209, 204],\n  mediumvioletred: [199, 21, 133],\n  midnightblue: [25, 25, 112],\n  mintcream: [245, 255, 250],\n  mistyrose: [255, 228, 225],\n  moccasin: [255, 228, 181],\n  navajowhite: [255, 222, 173],\n  navy: [0, 0, 128],\n  oldlace: [253, 245, 230],\n  olive: [128, 128, 0],\n  olivedrab: [107, 142, 35],\n  orange: [255, 165, 0],\n  orangered: [255, 69, 0],\n  orchid: [218, 112, 214],\n  palegoldenrod: [238, 232, 170],\n  palegreen: [152, 251, 152],\n  paleturquoise: [175, 238, 238],\n  palevioletred: [219, 112, 147],\n  papayawhip: [255, 239, 213],\n  peachpuff: [255, 218, 185],\n  peru: [205, 133, 63],\n  pink: [255, 192, 203],\n  plum: [221, 160, 221],\n  powderblue: [176, 224, 230],\n  purple: [128, 0, 128],\n  red: [255, 0, 0],\n  rosybrown: [188, 143, 143],\n  royalblue: [65, 105, 225],\n  saddlebrown: [139, 69, 19],\n  salmon: [250, 128, 114],\n  sandybrown: [244, 164, 96],\n  seagreen: [46, 139, 87],\n  seashell: [255, 245, 238],\n  sienna: [160, 82, 45],\n  silver: [192, 192, 192],\n  skyblue: [135, 206, 235],\n  slateblue: [106, 90, 205],\n  slategray: [112, 128, 144],\n  slategrey: [112, 128, 144],\n  snow: [255, 250, 250],\n  springgreen: [0, 255, 127],\n  steelblue: [70, 130, 180],\n  tan: [210, 180, 140],\n  teal: [0, 128, 128],\n  thistle: [216, 191, 216],\n  tomato: [255, 99, 71],\n  turquoise: [64, 224, 208],\n  violet: [238, 130, 238],\n  wheat: [245, 222, 179],\n  white: [255, 255, 255],\n  whitesmoke: [245, 245, 245],\n  yellow: [255, 255, 0],\n  yellowgreen: [154, 205, 50]\n};\n\nvar setMap = function setMap(options) {\n  var obj = options.map;\n  var keys = options.keys;\n  var l = keys.length;\n\n  for (var i = 0; i < l; i++) {\n    var key = keys[i];\n\n    if (plainObject(key)) {\n      throw Error('Tried to set map with object key');\n    }\n\n    if (i < keys.length - 1) {\n      // extend the map if necessary\n      if (obj[key] == null) {\n        obj[key] = {};\n      }\n\n      obj = obj[key];\n    } else {\n      // set the value\n      obj[key] = options.value;\n    }\n  }\n}; // gets the value in a map even if it's not built in places\n\nvar getMap = function getMap(options) {\n  var obj = options.map;\n  var keys = options.keys;\n  var l = keys.length;\n\n  for (var i = 0; i < l; i++) {\n    var key = keys[i];\n\n    if (plainObject(key)) {\n      throw Error('Tried to get map with object key');\n    }\n\n    obj = obj[key];\n\n    if (obj == null) {\n      return obj;\n    }\n  }\n\n  return obj;\n}; // deletes the entry in the map\n\nvar performance = _window ? _window.performance : null;\nvar pnow = performance && performance.now ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n};\n\nvar raf = function () {\n  if (_window) {\n    if (_window.requestAnimationFrame) {\n      return function (fn) {\n        _window.requestAnimationFrame(fn);\n      };\n    } else if (_window.mozRequestAnimationFrame) {\n      return function (fn) {\n        _window.mozRequestAnimationFrame(fn);\n      };\n    } else if (_window.webkitRequestAnimationFrame) {\n      return function (fn) {\n        _window.webkitRequestAnimationFrame(fn);\n      };\n    } else if (_window.msRequestAnimationFrame) {\n      return function (fn) {\n        _window.msRequestAnimationFrame(fn);\n      };\n    }\n  }\n\n  return function (fn) {\n    if (fn) {\n      setTimeout(function () {\n        fn(pnow());\n      }, 1000 / 60);\n    }\n  };\n}();\n\nvar requestAnimationFrame = function requestAnimationFrame(fn) {\n  return raf(fn);\n};\nvar performanceNow = pnow;\n\nvar DEFAULT_HASH_SEED = 9261;\nvar K = 65599; // 37 also works pretty well\n\nvar DEFAULT_HASH_SEED_ALT = 5381;\nvar hashIterableInts = function hashIterableInts(iterator) {\n  var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED;\n  // sdbm/string-hash\n  var hash = seed;\n  var entry;\n\n  for (;;) {\n    entry = iterator.next();\n\n    if (entry.done) {\n      break;\n    }\n\n    hash = hash * K + entry.value | 0;\n  }\n\n  return hash;\n};\nvar hashInt = function hashInt(num) {\n  var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED;\n  // sdbm/string-hash\n  return seed * K + num | 0;\n};\nvar hashIntAlt = function hashIntAlt(num) {\n  var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED_ALT;\n  // djb2/string-hash\n  return (seed << 5) + seed + num | 0;\n};\nvar combineHashes = function combineHashes(hash1, hash2) {\n  return hash1 * 0x200000 + hash2;\n};\nvar combineHashesArray = function combineHashesArray(hashes) {\n  return hashes[0] * 0x200000 + hashes[1];\n};\nvar hashArrays = function hashArrays(hashes1, hashes2) {\n  return [hashInt(hashes1[0], hashes2[0]), hashIntAlt(hashes1[1], hashes2[1])];\n};\nvar hashIntsArray = function hashIntsArray(ints, seed) {\n  var entry = {\n    value: 0,\n    done: false\n  };\n  var i = 0;\n  var length = ints.length;\n  var iterator = {\n    next: function next() {\n      if (i < length) {\n        entry.value = ints[i++];\n      } else {\n        entry.done = true;\n      }\n\n      return entry;\n    }\n  };\n  return hashIterableInts(iterator, seed);\n};\nvar hashString = function hashString(str, seed) {\n  var entry = {\n    value: 0,\n    done: false\n  };\n  var i = 0;\n  var length = str.length;\n  var iterator = {\n    next: function next() {\n      if (i < length) {\n        entry.value = str.charCodeAt(i++);\n      } else {\n        entry.done = true;\n      }\n\n      return entry;\n    }\n  };\n  return hashIterableInts(iterator, seed);\n};\nvar hashStrings = function hashStrings() {\n  return hashStringsArray(arguments);\n};\nvar hashStringsArray = function hashStringsArray(strs) {\n  var hash;\n\n  for (var i = 0; i < strs.length; i++) {\n    var str = strs[i];\n\n    if (i === 0) {\n      hash = hashString(str);\n    } else {\n      hash = hashString(str, hash);\n    }\n  }\n\n  return hash;\n};\n\n/*global console */\nvar warningsEnabled = true;\nvar warnSupported = console.warn != null; // eslint-disable-line no-console\n\nvar traceSupported = console.trace != null; // eslint-disable-line no-console\n\nvar MAX_INT$1 = Number.MAX_SAFE_INTEGER || 9007199254740991;\nvar trueify = function trueify() {\n  return true;\n};\nvar falsify = function falsify() {\n  return false;\n};\nvar zeroify = function zeroify() {\n  return 0;\n};\nvar noop$1 = function noop() {};\nvar error = function error(msg) {\n  throw new Error(msg);\n};\nvar warnings = function warnings(enabled) {\n  if (enabled !== undefined) {\n    warningsEnabled = !!enabled;\n  } else {\n    return warningsEnabled;\n  }\n};\nvar warn = function warn(msg) {\n  /* eslint-disable no-console */\n  if (!warnings()) {\n    return;\n  }\n\n  if (warnSupported) {\n    console.warn(msg);\n  } else {\n    console.log(msg);\n\n    if (traceSupported) {\n      console.trace();\n    }\n  }\n};\n/* eslint-enable */\n\nvar clone = function clone(obj) {\n  return extend({}, obj);\n}; // gets a shallow copy of the argument\n\nvar copy = function copy(obj) {\n  if (obj == null) {\n    return obj;\n  }\n\n  if (array(obj)) {\n    return obj.slice();\n  } else if (plainObject(obj)) {\n    return clone(obj);\n  } else {\n    return obj;\n  }\n};\nvar copyArray = function copyArray(arr) {\n  return arr.slice();\n};\nvar uuid = function uuid(a, b\n/* placeholders */\n) {\n  for ( // loop :)\n  b = a = ''; // b - result , a - numeric letiable\n  a++ < 36; //\n  b += a * 51 & 52 // if \"a\" is not 9 or 14 or 19 or 24\n  ? //  return a random number or 4\n  (a ^ 15 // if \"a\" is not 15\n  ? // generate a random number from 0 to 15\n  8 ^ Math.random() * (a ^ 20 ? 16 : 4) // unless \"a\" is 20, in which case a random number from 8 to 11\n  : 4 //  otherwise 4\n  ).toString(16) : '-' //  in other cases (if \"a\" is 9,14,19,24) insert \"-\"\n  ) {\n  }\n\n  return b;\n};\nvar _staticEmptyObject = {};\nvar staticEmptyObject = function staticEmptyObject() {\n  return _staticEmptyObject;\n};\nvar defaults$g = function defaults(_defaults) {\n  var keys = Object.keys(_defaults);\n  return function (opts) {\n    var filledOpts = {};\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var optVal = opts == null ? undefined : opts[key];\n      filledOpts[key] = optVal === undefined ? _defaults[key] : optVal;\n    }\n\n    return filledOpts;\n  };\n};\nvar removeFromArray = function removeFromArray(arr, ele, oneCopy) {\n  for (var i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] === ele) {\n      arr.splice(i, 1);\n\n      if (oneCopy) {\n        break;\n      }\n    }\n  }\n};\nvar clearArray = function clearArray(arr) {\n  arr.splice(0, arr.length);\n};\nvar push = function push(arr, otherArr) {\n  for (var i = 0; i < otherArr.length; i++) {\n    var el = otherArr[i];\n    arr.push(el);\n  }\n};\nvar getPrefixedProperty = function getPrefixedProperty(obj, propName, prefix) {\n  if (prefix) {\n    propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth\n  }\n\n  return obj[propName];\n};\nvar setPrefixedProperty = function setPrefixedProperty(obj, propName, prefix, value) {\n  if (prefix) {\n    propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth\n  }\n\n  obj[propName] = value;\n};\n\n/* global Map */\nvar ObjectMap = /*#__PURE__*/function () {\n  function ObjectMap() {\n    _classCallCheck(this, ObjectMap);\n\n    this._obj = {};\n  }\n\n  _createClass(ObjectMap, [{\n    key: \"set\",\n    value: function set(key, val) {\n      this._obj[key] = val;\n      return this;\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      this._obj[key] = undefined;\n      return this;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._obj = {};\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return this._obj[key] !== undefined;\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      return this._obj[key];\n    }\n  }]);\n\n  return ObjectMap;\n}();\n\nvar Map$1 = typeof Map !== 'undefined' ? Map : ObjectMap;\n\n/* global Set */\nvar undef = \"undefined\" ;\n\nvar ObjectSet = /*#__PURE__*/function () {\n  function ObjectSet(arrayOrObjectSet) {\n    _classCallCheck(this, ObjectSet);\n\n    this._obj = Object.create(null);\n    this.size = 0;\n\n    if (arrayOrObjectSet != null) {\n      var arr;\n\n      if (arrayOrObjectSet.instanceString != null && arrayOrObjectSet.instanceString() === this.instanceString()) {\n        arr = arrayOrObjectSet.toArray();\n      } else {\n        arr = arrayOrObjectSet;\n      }\n\n      for (var i = 0; i < arr.length; i++) {\n        this.add(arr[i]);\n      }\n    }\n  }\n\n  _createClass(ObjectSet, [{\n    key: \"instanceString\",\n    value: function instanceString() {\n      return 'set';\n    }\n  }, {\n    key: \"add\",\n    value: function add(val) {\n      var o = this._obj;\n\n      if (o[val] !== 1) {\n        o[val] = 1;\n        this.size++;\n      }\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(val) {\n      var o = this._obj;\n\n      if (o[val] === 1) {\n        o[val] = 0;\n        this.size--;\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._obj = Object.create(null);\n    }\n  }, {\n    key: \"has\",\n    value: function has(val) {\n      return this._obj[val] === 1;\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      var _this = this;\n\n      return Object.keys(this._obj).filter(function (key) {\n        return _this.has(key);\n      });\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(callback, thisArg) {\n      return this.toArray().forEach(callback, thisArg);\n    }\n  }]);\n\n  return ObjectSet;\n}();\n\nvar Set$1 = (typeof Set === \"undefined\" ? \"undefined\" : _typeof(Set)) !== undef ? Set : ObjectSet;\n\nvar Element = function Element(cy, params) {\n  var restore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  if (cy === undefined || params === undefined || !core(cy)) {\n    error('An element must have a core reference and parameters set');\n    return;\n  }\n\n  var group = params.group; // try to automatically infer the group if unspecified\n\n  if (group == null) {\n    if (params.data && params.data.source != null && params.data.target != null) {\n      group = 'edges';\n    } else {\n      group = 'nodes';\n    }\n  } // validate group\n\n\n  if (group !== 'nodes' && group !== 'edges') {\n    error('An element must be of type `nodes` or `edges`; you specified `' + group + '`');\n    return;\n  } // make the element array-like, just like a collection\n\n\n  this.length = 1;\n  this[0] = this; // NOTE: when something is added here, add also to ele.json()\n\n  var _p = this._private = {\n    cy: cy,\n    single: true,\n    // indicates this is an element\n    data: params.data || {},\n    // data object\n    position: params.position || {\n      x: 0,\n      y: 0\n    },\n    // (x, y) position pair\n    autoWidth: undefined,\n    // width and height of nodes calculated by the renderer when set to special 'auto' value\n    autoHeight: undefined,\n    autoPadding: undefined,\n    compoundBoundsClean: false,\n    // whether the compound dimensions need to be recalculated the next time dimensions are read\n    listeners: [],\n    // array of bound listeners\n    group: group,\n    // string; 'nodes' or 'edges'\n    style: {},\n    // properties as set by the style\n    rstyle: {},\n    // properties for style sent from the renderer to the core\n    styleCxts: [],\n    // applied style contexts from the styler\n    styleKeys: {},\n    // per-group keys of style property values\n    removed: true,\n    // whether it's inside the vis; true if removed (set true here since we call restore)\n    selected: params.selected ? true : false,\n    // whether it's selected\n    selectable: params.selectable === undefined ? true : params.selectable ? true : false,\n    // whether it's selectable\n    locked: params.locked ? true : false,\n    // whether the element is locked (cannot be moved)\n    grabbed: false,\n    // whether the element is grabbed by the mouse; renderer sets this privately\n    grabbable: params.grabbable === undefined ? true : params.grabbable ? true : false,\n    // whether the element can be grabbed\n    pannable: params.pannable === undefined ? group === 'edges' ? true : false : params.pannable ? true : false,\n    // whether the element has passthrough panning enabled\n    active: false,\n    // whether the element is active from user interaction\n    classes: new Set$1(),\n    // map ( className => true )\n    animation: {\n      // object for currently-running animations\n      current: [],\n      queue: []\n    },\n    rscratch: {},\n    // object in which the renderer can store information\n    scratch: params.scratch || {},\n    // scratch objects\n    edges: [],\n    // array of connected edges\n    children: [],\n    // array of children\n    parent: params.parent && params.parent.isNode() ? params.parent : null,\n    // parent ref\n    traversalCache: {},\n    // cache of output of traversal functions\n    backgrounding: false,\n    // whether background images are loading\n    bbCache: null,\n    // cache of the current bounding box\n    bbCacheShift: {\n      x: 0,\n      y: 0\n    },\n    // shift applied to cached bb to be applied on next get\n    bodyBounds: null,\n    // bounds cache of element body, w/o overlay\n    overlayBounds: null,\n    // bounds cache of element body, including overlay\n    labelBounds: {\n      // bounds cache of labels\n      all: null,\n      source: null,\n      target: null,\n      main: null\n    },\n    arrowBounds: {\n      // bounds cache of edge arrows\n      source: null,\n      target: null,\n      'mid-source': null,\n      'mid-target': null\n    }\n  };\n\n  if (_p.position.x == null) {\n    _p.position.x = 0;\n  }\n\n  if (_p.position.y == null) {\n    _p.position.y = 0;\n  } // renderedPosition overrides if specified\n\n\n  if (params.renderedPosition) {\n    var rpos = params.renderedPosition;\n    var pan = cy.pan();\n    var zoom = cy.zoom();\n    _p.position = {\n      x: (rpos.x - pan.x) / zoom,\n      y: (rpos.y - pan.y) / zoom\n    };\n  }\n\n  var classes = [];\n\n  if (array(params.classes)) {\n    classes = params.classes;\n  } else if (string(params.classes)) {\n    classes = params.classes.split(/\\s+/);\n  }\n\n  for (var i = 0, l = classes.length; i < l; i++) {\n    var cls = classes[i];\n\n    if (!cls || cls === '') {\n      continue;\n    }\n\n    _p.classes.add(cls);\n  }\n\n  this.createEmitter();\n  var bypass = params.style || params.css;\n\n  if (bypass) {\n    warn('Setting a `style` bypass at element creation should be done only when absolutely necessary.  Try to use the stylesheet instead.');\n    this.style(bypass);\n  }\n\n  if (restore === undefined || restore) {\n    this.restore();\n  }\n};\n\nvar defineSearch = function defineSearch(params) {\n  params = {\n    bfs: params.bfs || !params.dfs,\n    dfs: params.dfs || !params.bfs\n  }; // from pseudocode on wikipedia\n\n  return function searchFn(roots, fn, directed) {\n    var options;\n\n    if (plainObject(roots) && !elementOrCollection(roots)) {\n      options = roots;\n      roots = options.roots || options.root;\n      fn = options.visit;\n      directed = options.directed;\n    }\n\n    directed = arguments.length === 2 && !fn$6(fn) ? fn : directed;\n    fn = fn$6(fn) ? fn : function () {};\n    var cy = this._private.cy;\n    var v = roots = string(roots) ? this.filter(roots) : roots;\n    var Q = [];\n    var connectedNodes = [];\n    var connectedBy = {};\n    var id2depth = {};\n    var V = {};\n    var j = 0;\n    var found;\n\n    var _this$byGroup = this.byGroup(),\n        nodes = _this$byGroup.nodes,\n        edges = _this$byGroup.edges; // enqueue v\n\n\n    for (var i = 0; i < v.length; i++) {\n      var vi = v[i];\n      var viId = vi.id();\n\n      if (vi.isNode()) {\n        Q.unshift(vi);\n\n        if (params.bfs) {\n          V[viId] = true;\n          connectedNodes.push(vi);\n        }\n\n        id2depth[viId] = 0;\n      }\n    }\n\n    var _loop = function _loop() {\n      var v = params.bfs ? Q.shift() : Q.pop();\n      var vId = v.id();\n\n      if (params.dfs) {\n        if (V[vId]) {\n          return \"continue\";\n        }\n\n        V[vId] = true;\n        connectedNodes.push(v);\n      }\n\n      var depth = id2depth[vId];\n      var prevEdge = connectedBy[vId];\n      var src = prevEdge != null ? prevEdge.source() : null;\n      var tgt = prevEdge != null ? prevEdge.target() : null;\n      var prevNode = prevEdge == null ? undefined : v.same(src) ? tgt[0] : src[0];\n      var ret = void 0;\n      ret = fn(v, prevEdge, prevNode, j++, depth);\n\n      if (ret === true) {\n        found = v;\n        return \"break\";\n      }\n\n      if (ret === false) {\n        return \"break\";\n      }\n\n      var vwEdges = v.connectedEdges().filter(function (e) {\n        return (!directed || e.source().same(v)) && edges.has(e);\n      });\n\n      for (var _i2 = 0; _i2 < vwEdges.length; _i2++) {\n        var e = vwEdges[_i2];\n        var w = e.connectedNodes().filter(function (n) {\n          return !n.same(v) && nodes.has(n);\n        });\n        var wId = w.id();\n\n        if (w.length !== 0 && !V[wId]) {\n          w = w[0];\n          Q.push(w);\n\n          if (params.bfs) {\n            V[wId] = true;\n            connectedNodes.push(w);\n          }\n\n          connectedBy[wId] = e;\n          id2depth[wId] = id2depth[vId] + 1;\n        }\n      }\n    };\n\n    while (Q.length !== 0) {\n      var _ret = _loop();\n\n      if (_ret === \"continue\") continue;\n      if (_ret === \"break\") break;\n    }\n\n    var connectedEles = cy.collection();\n\n    for (var _i = 0; _i < connectedNodes.length; _i++) {\n      var node = connectedNodes[_i];\n      var edge = connectedBy[node.id()];\n\n      if (edge != null) {\n        connectedEles.push(edge);\n      }\n\n      connectedEles.push(node);\n    }\n\n    return {\n      path: cy.collection(connectedEles),\n      found: cy.collection(found)\n    };\n  };\n}; // search, spanning trees, etc\n\n\nvar elesfn$v = {\n  breadthFirstSearch: defineSearch({\n    bfs: true\n  }),\n  depthFirstSearch: defineSearch({\n    dfs: true\n  })\n}; // nice, short mathematical alias\n\nelesfn$v.bfs = elesfn$v.breadthFirstSearch;\nelesfn$v.dfs = elesfn$v.depthFirstSearch;\n\nvar dijkstraDefaults = defaults$g({\n  root: null,\n  weight: function weight(edge) {\n    return 1;\n  },\n  directed: false\n});\nvar elesfn$u = {\n  dijkstra: function dijkstra(options) {\n    if (!plainObject(options)) {\n      var args = arguments;\n      options = {\n        root: args[0],\n        weight: args[1],\n        directed: args[2]\n      };\n    }\n\n    var _dijkstraDefaults = dijkstraDefaults(options),\n        root = _dijkstraDefaults.root,\n        weight = _dijkstraDefaults.weight,\n        directed = _dijkstraDefaults.directed;\n\n    var eles = this;\n    var weightFn = weight;\n    var source = string(root) ? this.filter(root)[0] : root[0];\n    var dist = {};\n    var prev = {};\n    var knownDist = {};\n\n    var _this$byGroup = this.byGroup(),\n        nodes = _this$byGroup.nodes,\n        edges = _this$byGroup.edges;\n\n    edges.unmergeBy(function (ele) {\n      return ele.isLoop();\n    });\n\n    var getDist = function getDist(node) {\n      return dist[node.id()];\n    };\n\n    var setDist = function setDist(node, d) {\n      dist[node.id()] = d;\n      Q.updateItem(node);\n    };\n\n    var Q = new Heap__default[\"default\"](function (a, b) {\n      return getDist(a) - getDist(b);\n    });\n\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n      dist[node.id()] = node.same(source) ? 0 : Infinity;\n      Q.push(node);\n    }\n\n    var distBetween = function distBetween(u, v) {\n      var uvs = (directed ? u.edgesTo(v) : u.edgesWith(v)).intersect(edges);\n      var smallestDistance = Infinity;\n      var smallestEdge;\n\n      for (var _i = 0; _i < uvs.length; _i++) {\n        var edge = uvs[_i];\n\n        var _weight = weightFn(edge);\n\n        if (_weight < smallestDistance || !smallestEdge) {\n          smallestDistance = _weight;\n          smallestEdge = edge;\n        }\n      }\n\n      return {\n        edge: smallestEdge,\n        dist: smallestDistance\n      };\n    };\n\n    while (Q.size() > 0) {\n      var u = Q.pop();\n      var smalletsDist = getDist(u);\n      var uid = u.id();\n      knownDist[uid] = smalletsDist;\n\n      if (smalletsDist === Infinity) {\n        continue;\n      }\n\n      var neighbors = u.neighborhood().intersect(nodes);\n\n      for (var _i2 = 0; _i2 < neighbors.length; _i2++) {\n        var v = neighbors[_i2];\n        var vid = v.id();\n        var vDist = distBetween(u, v);\n        var alt = smalletsDist + vDist.dist;\n\n        if (alt < getDist(v)) {\n          setDist(v, alt);\n          prev[vid] = {\n            node: u,\n            edge: vDist.edge\n          };\n        }\n      } // for\n\n    } // while\n\n\n    return {\n      distanceTo: function distanceTo(node) {\n        var target = string(node) ? nodes.filter(node)[0] : node[0];\n        return knownDist[target.id()];\n      },\n      pathTo: function pathTo(node) {\n        var target = string(node) ? nodes.filter(node)[0] : node[0];\n        var S = [];\n        var u = target;\n        var uid = u.id();\n\n        if (target.length > 0) {\n          S.unshift(target);\n\n          while (prev[uid]) {\n            var p = prev[uid];\n            S.unshift(p.edge);\n            S.unshift(p.node);\n            u = p.node;\n            uid = u.id();\n          }\n        }\n\n        return eles.spawn(S);\n      }\n    };\n  }\n};\n\nvar elesfn$t = {\n  // kruskal's algorithm (finds min spanning tree, assuming undirected graph)\n  // implemented from pseudocode from wikipedia\n  kruskal: function kruskal(weightFn) {\n    weightFn = weightFn || function (edge) {\n      return 1;\n    };\n\n    var _this$byGroup = this.byGroup(),\n        nodes = _this$byGroup.nodes,\n        edges = _this$byGroup.edges;\n\n    var numNodes = nodes.length;\n    var forest = new Array(numNodes);\n    var A = nodes; // assumes byGroup() creates new collections that can be safely mutated\n\n    var findSetIndex = function findSetIndex(ele) {\n      for (var i = 0; i < forest.length; i++) {\n        var eles = forest[i];\n\n        if (eles.has(ele)) {\n          return i;\n        }\n      }\n    }; // start with one forest per node\n\n\n    for (var i = 0; i < numNodes; i++) {\n      forest[i] = this.spawn(nodes[i]);\n    }\n\n    var S = edges.sort(function (a, b) {\n      return weightFn(a) - weightFn(b);\n    });\n\n    for (var _i = 0; _i < S.length; _i++) {\n      var edge = S[_i];\n      var u = edge.source()[0];\n      var v = edge.target()[0];\n      var setUIndex = findSetIndex(u);\n      var setVIndex = findSetIndex(v);\n      var setU = forest[setUIndex];\n      var setV = forest[setVIndex];\n\n      if (setUIndex !== setVIndex) {\n        A.merge(edge); // combine forests for u and v\n\n        setU.merge(setV);\n        forest.splice(setVIndex, 1);\n      }\n    }\n\n    return A;\n  }\n};\n\nvar aStarDefaults = defaults$g({\n  root: null,\n  goal: null,\n  weight: function weight(edge) {\n    return 1;\n  },\n  heuristic: function heuristic(edge) {\n    return 0;\n  },\n  directed: false\n});\nvar elesfn$s = {\n  // Implemented from pseudocode from wikipedia\n  aStar: function aStar(options) {\n    var cy = this.cy();\n\n    var _aStarDefaults = aStarDefaults(options),\n        root = _aStarDefaults.root,\n        goal = _aStarDefaults.goal,\n        heuristic = _aStarDefaults.heuristic,\n        directed = _aStarDefaults.directed,\n        weight = _aStarDefaults.weight;\n\n    root = cy.collection(root)[0];\n    goal = cy.collection(goal)[0];\n    var sid = root.id();\n    var tid = goal.id();\n    var gScore = {};\n    var fScore = {};\n    var closedSetIds = {};\n    var openSet = new Heap__default[\"default\"](function (a, b) {\n      return fScore[a.id()] - fScore[b.id()];\n    });\n    var openSetIds = new Set$1();\n    var cameFrom = {};\n    var cameFromEdge = {};\n\n    var addToOpenSet = function addToOpenSet(ele, id) {\n      openSet.push(ele);\n      openSetIds.add(id);\n    };\n\n    var cMin, cMinId;\n\n    var popFromOpenSet = function popFromOpenSet() {\n      cMin = openSet.pop();\n      cMinId = cMin.id();\n      openSetIds[\"delete\"](cMinId);\n    };\n\n    var isInOpenSet = function isInOpenSet(id) {\n      return openSetIds.has(id);\n    };\n\n    addToOpenSet(root, sid);\n    gScore[sid] = 0;\n    fScore[sid] = heuristic(root); // Counter\n\n    var steps = 0; // Main loop\n\n    while (openSet.size() > 0) {\n      popFromOpenSet();\n      steps++; // If we've found our goal, then we are done\n\n      if (cMinId === tid) {\n        var path = [];\n        var pathNode = goal;\n        var pathNodeId = tid;\n        var pathEdge = cameFromEdge[pathNodeId];\n\n        for (;;) {\n          path.unshift(pathNode);\n\n          if (pathEdge != null) {\n            path.unshift(pathEdge);\n          }\n\n          pathNode = cameFrom[pathNodeId];\n\n          if (pathNode == null) {\n            break;\n          }\n\n          pathNodeId = pathNode.id();\n          pathEdge = cameFromEdge[pathNodeId];\n        }\n\n        return {\n          found: true,\n          distance: gScore[cMinId],\n          path: this.spawn(path),\n          steps: steps\n        };\n      } // Add cMin to processed nodes\n\n\n      closedSetIds[cMinId] = true; // Update scores for neighbors of cMin\n      // Take into account if graph is directed or not\n\n      var vwEdges = cMin._private.edges;\n\n      for (var i = 0; i < vwEdges.length; i++) {\n        var e = vwEdges[i]; // edge must be in set of calling eles\n\n        if (!this.hasElementWithId(e.id())) {\n          continue;\n        } // cMin must be the source of edge if directed\n\n\n        if (directed && e.data('source') !== cMinId) {\n          continue;\n        }\n\n        var wSrc = e.source();\n        var wTgt = e.target();\n        var w = wSrc.id() !== cMinId ? wSrc : wTgt;\n        var wid = w.id(); // node must be in set of calling eles\n\n        if (!this.hasElementWithId(wid)) {\n          continue;\n        } // if node is in closedSet, ignore it\n\n\n        if (closedSetIds[wid]) {\n          continue;\n        } // New tentative score for node w\n\n\n        var tempScore = gScore[cMinId] + weight(e); // Update gScore for node w if:\n        //   w not present in openSet\n        // OR\n        //   tentative gScore is less than previous value\n        // w not in openSet\n\n        if (!isInOpenSet(wid)) {\n          gScore[wid] = tempScore;\n          fScore[wid] = tempScore + heuristic(w);\n          addToOpenSet(w, wid);\n          cameFrom[wid] = cMin;\n          cameFromEdge[wid] = e;\n          continue;\n        } // w already in openSet, but with greater gScore\n\n\n        if (tempScore < gScore[wid]) {\n          gScore[wid] = tempScore;\n          fScore[wid] = tempScore + heuristic(w);\n          cameFrom[wid] = cMin;\n          cameFromEdge[wid] = e;\n        }\n      } // End of neighbors update\n\n    } // End of main loop\n    // If we've reached here, then we've not reached our goal\n\n\n    return {\n      found: false,\n      distance: undefined,\n      path: undefined,\n      steps: steps\n    };\n  }\n}; // elesfn\n\nvar floydWarshallDefaults = defaults$g({\n  weight: function weight(edge) {\n    return 1;\n  },\n  directed: false\n});\nvar elesfn$r = {\n  // Implemented from pseudocode from wikipedia\n  floydWarshall: function floydWarshall(options) {\n    var cy = this.cy();\n\n    var _floydWarshallDefault = floydWarshallDefaults(options),\n        weight = _floydWarshallDefault.weight,\n        directed = _floydWarshallDefault.directed;\n\n    var weightFn = weight;\n\n    var _this$byGroup = this.byGroup(),\n        nodes = _this$byGroup.nodes,\n        edges = _this$byGroup.edges;\n\n    var N = nodes.length;\n    var Nsq = N * N;\n\n    var indexOf = function indexOf(node) {\n      return nodes.indexOf(node);\n    };\n\n    var atIndex = function atIndex(i) {\n      return nodes[i];\n    }; // Initialize distance matrix\n\n\n    var dist = new Array(Nsq);\n\n    for (var n = 0; n < Nsq; n++) {\n      var j = n % N;\n      var i = (n - j) / N;\n\n      if (i === j) {\n        dist[n] = 0;\n      } else {\n        dist[n] = Infinity;\n      }\n    } // Initialize matrix used for path reconstruction\n    // Initialize distance matrix\n\n\n    var next = new Array(Nsq);\n    var edgeNext = new Array(Nsq); // Process edges\n\n    for (var _i = 0; _i < edges.length; _i++) {\n      var edge = edges[_i];\n      var src = edge.source()[0];\n      var tgt = edge.target()[0];\n\n      if (src === tgt) {\n        continue;\n      } // exclude loops\n\n\n      var s = indexOf(src);\n      var t = indexOf(tgt);\n      var st = s * N + t; // source to target index\n\n      var _weight = weightFn(edge); // Check if already process another edge between same 2 nodes\n\n\n      if (dist[st] > _weight) {\n        dist[st] = _weight;\n        next[st] = t;\n        edgeNext[st] = edge;\n      } // If undirected graph, process 'reversed' edge\n\n\n      if (!directed) {\n        var ts = t * N + s; // target to source index\n\n        if (!directed && dist[ts] > _weight) {\n          dist[ts] = _weight;\n          next[ts] = s;\n          edgeNext[ts] = edge;\n        }\n      }\n    } // Main loop\n\n\n    for (var k = 0; k < N; k++) {\n      for (var _i2 = 0; _i2 < N; _i2++) {\n        var ik = _i2 * N + k;\n\n        for (var _j = 0; _j < N; _j++) {\n          var ij = _i2 * N + _j;\n          var kj = k * N + _j;\n\n          if (dist[ik] + dist[kj] < dist[ij]) {\n            dist[ij] = dist[ik] + dist[kj];\n            next[ij] = next[ik];\n          }\n        }\n      }\n    }\n\n    var getArgEle = function getArgEle(ele) {\n      return (string(ele) ? cy.filter(ele) : ele)[0];\n    };\n\n    var indexOfArgEle = function indexOfArgEle(ele) {\n      return indexOf(getArgEle(ele));\n    };\n\n    var res = {\n      distance: function distance(from, to) {\n        var i = indexOfArgEle(from);\n        var j = indexOfArgEle(to);\n        return dist[i * N + j];\n      },\n      path: function path(from, to) {\n        var i = indexOfArgEle(from);\n        var j = indexOfArgEle(to);\n        var fromNode = atIndex(i);\n\n        if (i === j) {\n          return fromNode.collection();\n        }\n\n        if (next[i * N + j] == null) {\n          return cy.collection();\n        }\n\n        var path = cy.collection();\n        var prev = i;\n        var edge;\n        path.merge(fromNode);\n\n        while (i !== j) {\n          prev = i;\n          i = next[i * N + j];\n          edge = edgeNext[prev * N + i];\n          path.merge(edge);\n          path.merge(atIndex(i));\n        }\n\n        return path;\n      }\n    };\n    return res;\n  } // floydWarshall\n\n}; // elesfn\n\nvar bellmanFordDefaults = defaults$g({\n  weight: function weight(edge) {\n    return 1;\n  },\n  directed: false,\n  root: null\n});\nvar elesfn$q = {\n  // Implemented from pseudocode from wikipedia\n  bellmanFord: function bellmanFord(options) {\n    var _this = this;\n\n    var _bellmanFordDefaults = bellmanFordDefaults(options),\n        weight = _bellmanFordDefaults.weight,\n        directed = _bellmanFordDefaults.directed,\n        root = _bellmanFordDefaults.root;\n\n    var weightFn = weight;\n    var eles = this;\n    var cy = this.cy();\n\n    var _this$byGroup = this.byGroup(),\n        edges = _this$byGroup.edges,\n        nodes = _this$byGroup.nodes;\n\n    var numNodes = nodes.length;\n    var infoMap = new Map$1();\n    var hasNegativeWeightCycle = false;\n    var negativeWeightCycles = [];\n    root = cy.collection(root)[0]; // in case selector passed\n\n    edges.unmergeBy(function (edge) {\n      return edge.isLoop();\n    });\n    var numEdges = edges.length;\n\n    var getInfo = function getInfo(node) {\n      var obj = infoMap.get(node.id());\n\n      if (!obj) {\n        obj = {};\n        infoMap.set(node.id(), obj);\n      }\n\n      return obj;\n    };\n\n    var getNodeFromTo = function getNodeFromTo(to) {\n      return (string(to) ? cy.$(to) : to)[0];\n    };\n\n    var distanceTo = function distanceTo(to) {\n      return getInfo(getNodeFromTo(to)).dist;\n    };\n\n    var pathTo = function pathTo(to) {\n      var thisStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : root;\n      var end = getNodeFromTo(to);\n      var path = [];\n      var node = end;\n\n      for (;;) {\n        if (node == null) {\n          return _this.spawn();\n        }\n\n        var _getInfo = getInfo(node),\n            edge = _getInfo.edge,\n            pred = _getInfo.pred;\n\n        path.unshift(node[0]);\n\n        if (node.same(thisStart) && path.length > 0) {\n          break;\n        }\n\n        if (edge != null) {\n          path.unshift(edge);\n        }\n\n        node = pred;\n      }\n\n      return eles.spawn(path);\n    }; // Initializations { dist, pred, edge }\n\n\n    for (var i = 0; i < numNodes; i++) {\n      var node = nodes[i];\n      var info = getInfo(node);\n\n      if (node.same(root)) {\n        info.dist = 0;\n      } else {\n        info.dist = Infinity;\n      }\n\n      info.pred = null;\n      info.edge = null;\n    } // Edges relaxation\n\n\n    var replacedEdge = false;\n\n    var checkForEdgeReplacement = function checkForEdgeReplacement(node1, node2, edge, info1, info2, weight) {\n      var dist = info1.dist + weight;\n\n      if (dist < info2.dist && !edge.same(info1.edge)) {\n        info2.dist = dist;\n        info2.pred = node1;\n        info2.edge = edge;\n        replacedEdge = true;\n      }\n    };\n\n    for (var _i = 1; _i < numNodes; _i++) {\n      replacedEdge = false;\n\n      for (var e = 0; e < numEdges; e++) {\n        var edge = edges[e];\n        var src = edge.source();\n        var tgt = edge.target();\n\n        var _weight = weightFn(edge);\n\n        var srcInfo = getInfo(src);\n        var tgtInfo = getInfo(tgt);\n        checkForEdgeReplacement(src, tgt, edge, srcInfo, tgtInfo, _weight); // If undirected graph, we need to take into account the 'reverse' edge\n\n        if (!directed) {\n          checkForEdgeReplacement(tgt, src, edge, tgtInfo, srcInfo, _weight);\n        }\n      }\n\n      if (!replacedEdge) {\n        break;\n      }\n    }\n\n    if (replacedEdge) {\n      // Check for negative weight cycles\n      var negativeWeightCycleIds = [];\n\n      for (var _e = 0; _e < numEdges; _e++) {\n        var _edge = edges[_e];\n\n        var _src = _edge.source();\n\n        var _tgt = _edge.target();\n\n        var _weight2 = weightFn(_edge);\n\n        var srcDist = getInfo(_src).dist;\n        var tgtDist = getInfo(_tgt).dist;\n\n        if (srcDist + _weight2 < tgtDist || !directed && tgtDist + _weight2 < srcDist) {\n          if (!hasNegativeWeightCycle) {\n            warn('Graph contains a negative weight cycle for Bellman-Ford');\n            hasNegativeWeightCycle = true;\n          }\n\n          if (options.findNegativeWeightCycles !== false) {\n            var negativeNodes = [];\n\n            if (srcDist + _weight2 < tgtDist) {\n              negativeNodes.push(_src);\n            }\n\n            if (!directed && tgtDist + _weight2 < srcDist) {\n              negativeNodes.push(_tgt);\n            }\n\n            var numNegativeNodes = negativeNodes.length;\n\n            for (var n = 0; n < numNegativeNodes; n++) {\n              var start = negativeNodes[n];\n              var cycle = [start];\n              cycle.push(getInfo(start).edge);\n              var _node = getInfo(start).pred;\n\n              while (cycle.indexOf(_node) === -1) {\n                cycle.push(_node);\n                cycle.push(getInfo(_node).edge);\n                _node = getInfo(_node).pred;\n              }\n\n              cycle = cycle.slice(cycle.indexOf(_node));\n              var smallestId = cycle[0].id();\n              var smallestIndex = 0;\n\n              for (var c = 2; c < cycle.length; c += 2) {\n                if (cycle[c].id() < smallestId) {\n                  smallestId = cycle[c].id();\n                  smallestIndex = c;\n                }\n              }\n\n              cycle = cycle.slice(smallestIndex).concat(cycle.slice(0, smallestIndex));\n              cycle.push(cycle[0]);\n              var cycleId = cycle.map(function (el) {\n                return el.id();\n              }).join(\",\");\n\n              if (negativeWeightCycleIds.indexOf(cycleId) === -1) {\n                negativeWeightCycles.push(eles.spawn(cycle));\n                negativeWeightCycleIds.push(cycleId);\n              }\n            }\n          } else {\n            break;\n          }\n        }\n      }\n    }\n\n    return {\n      distanceTo: distanceTo,\n      pathTo: pathTo,\n      hasNegativeWeightCycle: hasNegativeWeightCycle,\n      negativeWeightCycles: negativeWeightCycles\n    };\n  } // bellmanFord\n\n}; // elesfn\n\nvar sqrt2 = Math.sqrt(2); // Function which colapses 2 (meta) nodes into one\n// Updates the remaining edge lists\n// Receives as a paramater the edge which causes the collapse\n\nvar collapse = function collapse(edgeIndex, nodeMap, remainingEdges) {\n  if (remainingEdges.length === 0) {\n    error(\"Karger-Stein must be run on a connected (sub)graph\");\n  }\n\n  var edgeInfo = remainingEdges[edgeIndex];\n  var sourceIn = edgeInfo[1];\n  var targetIn = edgeInfo[2];\n  var partition1 = nodeMap[sourceIn];\n  var partition2 = nodeMap[targetIn];\n  var newEdges = remainingEdges; // re-use array\n  // Delete all edges between partition1 and partition2\n\n  for (var i = newEdges.length - 1; i >= 0; i--) {\n    var edge = newEdges[i];\n    var src = edge[1];\n    var tgt = edge[2];\n\n    if (nodeMap[src] === partition1 && nodeMap[tgt] === partition2 || nodeMap[src] === partition2 && nodeMap[tgt] === partition1) {\n      newEdges.splice(i, 1);\n    }\n  } // All edges pointing to partition2 should now point to partition1\n\n\n  for (var _i = 0; _i < newEdges.length; _i++) {\n    var _edge = newEdges[_i];\n\n    if (_edge[1] === partition2) {\n      // Check source\n      newEdges[_i] = _edge.slice(); // copy\n\n      newEdges[_i][1] = partition1;\n    } else if (_edge[2] === partition2) {\n      // Check target\n      newEdges[_i] = _edge.slice(); // copy\n\n      newEdges[_i][2] = partition1;\n    }\n  } // Move all nodes from partition2 to partition1\n\n\n  for (var _i2 = 0; _i2 < nodeMap.length; _i2++) {\n    if (nodeMap[_i2] === partition2) {\n      nodeMap[_i2] = partition1;\n    }\n  }\n\n  return newEdges;\n}; // Contracts a graph until we reach a certain number of meta nodes\n\n\nvar contractUntil = function contractUntil(metaNodeMap, remainingEdges, size, sizeLimit) {\n  while (size > sizeLimit) {\n    // Choose an edge randomly\n    var edgeIndex = Math.floor(Math.random() * remainingEdges.length); // Collapse graph based on edge\n\n    remainingEdges = collapse(edgeIndex, metaNodeMap, remainingEdges);\n    size--;\n  }\n\n  return remainingEdges;\n};\n\nvar elesfn$p = {\n  // Computes the minimum cut of an undirected graph\n  // Returns the correct answer with high probability\n  kargerStein: function kargerStein() {\n    var _this = this;\n\n    var _this$byGroup = this.byGroup(),\n        nodes = _this$byGroup.nodes,\n        edges = _this$byGroup.edges;\n\n    edges.unmergeBy(function (edge) {\n      return edge.isLoop();\n    });\n    var numNodes = nodes.length;\n    var numEdges = edges.length;\n    var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));\n    var stopSize = Math.floor(numNodes / sqrt2);\n\n    if (numNodes < 2) {\n      error('At least 2 nodes are required for Karger-Stein algorithm');\n      return undefined;\n    } // Now store edge destination as indexes\n    // Format for each edge (edge index, source node index, target node index)\n\n\n    var edgeIndexes = [];\n\n    for (var i = 0; i < numEdges; i++) {\n      var e = edges[i];\n      edgeIndexes.push([i, nodes.indexOf(e.source()), nodes.indexOf(e.target())]);\n    } // We will store the best cut found here\n\n\n    var minCutSize = Infinity;\n    var minCutEdgeIndexes = [];\n    var minCutNodeMap = new Array(numNodes); // Initial meta node partition\n\n    var metaNodeMap = new Array(numNodes);\n    var metaNodeMap2 = new Array(numNodes);\n\n    var copyNodesMap = function copyNodesMap(from, to) {\n      for (var _i3 = 0; _i3 < numNodes; _i3++) {\n        to[_i3] = from[_i3];\n      }\n    }; // Main loop\n\n\n    for (var iter = 0; iter <= numIter; iter++) {\n      // Reset meta node partition\n      for (var _i4 = 0; _i4 < numNodes; _i4++) {\n        metaNodeMap[_i4] = _i4;\n      } // Contract until stop point (stopSize nodes)\n\n\n      var edgesState = contractUntil(metaNodeMap, edgeIndexes.slice(), numNodes, stopSize);\n      var edgesState2 = edgesState.slice(); // copy\n      // Create a copy of the colapsed nodes state\n\n      copyNodesMap(metaNodeMap, metaNodeMap2); // Run 2 iterations starting in the stop state\n\n      var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);\n      var res2 = contractUntil(metaNodeMap2, edgesState2, stopSize, 2); // Is any of the 2 results the best cut so far?\n\n      if (res1.length <= res2.length && res1.length < minCutSize) {\n        minCutSize = res1.length;\n        minCutEdgeIndexes = res1;\n        copyNodesMap(metaNodeMap, minCutNodeMap);\n      } else if (res2.length <= res1.length && res2.length < minCutSize) {\n        minCutSize = res2.length;\n        minCutEdgeIndexes = res2;\n        copyNodesMap(metaNodeMap2, minCutNodeMap);\n      }\n    } // end of main loop\n    // Construct result\n\n\n    var cut = this.spawn(minCutEdgeIndexes.map(function (e) {\n      return edges[e[0]];\n    }));\n    var partition1 = this.spawn();\n    var partition2 = this.spawn(); // traverse metaNodeMap for best cut\n\n    var witnessNodePartition = minCutNodeMap[0];\n\n    for (var _i5 = 0; _i5 < minCutNodeMap.length; _i5++) {\n      var partitionId = minCutNodeMap[_i5];\n      var node = nodes[_i5];\n\n      if (partitionId === witnessNodePartition) {\n        partition1.merge(node);\n      } else {\n        partition2.merge(node);\n      }\n    } // construct components corresponding to each disjoint subset of nodes\n\n\n    var constructComponent = function constructComponent(subset) {\n      var component = _this.spawn();\n\n      subset.forEach(function (node) {\n        component.merge(node);\n        node.connectedEdges().forEach(function (edge) {\n          // ensure edge is within calling collection and edge is not in cut\n          if (_this.contains(edge) && !cut.contains(edge)) {\n            component.merge(edge);\n          }\n        });\n      });\n      return component;\n    };\n\n    var components = [constructComponent(partition1), constructComponent(partition2)];\n    var ret = {\n      cut: cut,\n      components: components,\n      // n.b. partitions are included to be compatible with the old api spec\n      // (could be removed in a future major version)\n      partition1: partition1,\n      partition2: partition2\n    };\n    return ret;\n  }\n}; // elesfn\n\nvar copyPosition = function copyPosition(p) {\n  return {\n    x: p.x,\n    y: p.y\n  };\n};\nvar modelToRenderedPosition = function modelToRenderedPosition(p, zoom, pan) {\n  return {\n    x: p.x * zoom + pan.x,\n    y: p.y * zoom + pan.y\n  };\n};\nvar renderedToModelPosition = function renderedToModelPosition(p, zoom, pan) {\n  return {\n    x: (p.x - pan.x) / zoom,\n    y: (p.y - pan.y) / zoom\n  };\n};\nvar array2point = function array2point(arr) {\n  return {\n    x: arr[0],\n    y: arr[1]\n  };\n};\nvar min = function min(arr) {\n  var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n  var min = Infinity;\n\n  for (var i = begin; i < end; i++) {\n    var val = arr[i];\n\n    if (isFinite(val)) {\n      min = Math.min(val, min);\n    }\n  }\n\n  return min;\n};\nvar max = function max(arr) {\n  var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n  var max = -Infinity;\n\n  for (var i = begin; i < end; i++) {\n    var val = arr[i];\n\n    if (isFinite(val)) {\n      max = Math.max(val, max);\n    }\n  }\n\n  return max;\n};\nvar mean = function mean(arr) {\n  var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n  var total = 0;\n  var n = 0;\n\n  for (var i = begin; i < end; i++) {\n    var val = arr[i];\n\n    if (isFinite(val)) {\n      total += val;\n      n++;\n    }\n  }\n\n  return total / n;\n};\nvar median = function median(arr) {\n  var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n  var copy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var sort = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  var includeHoles = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n  if (copy) {\n    arr = arr.slice(begin, end);\n  } else {\n    if (end < arr.length) {\n      arr.splice(end, arr.length - end);\n    }\n\n    if (begin > 0) {\n      arr.splice(0, begin);\n    }\n  } // all non finite (e.g. Infinity, NaN) elements must be -Infinity so they go to the start\n\n\n  var off = 0; // offset from non-finite values\n\n  for (var i = arr.length - 1; i >= 0; i--) {\n    var v = arr[i];\n\n    if (includeHoles) {\n      if (!isFinite(v)) {\n        arr[i] = -Infinity;\n        off++;\n      }\n    } else {\n      // just remove it if we don't want to consider holes\n      arr.splice(i, 1);\n    }\n  }\n\n  if (sort) {\n    arr.sort(function (a, b) {\n      return a - b;\n    }); // requires copy = true if you don't want to change the orig\n  }\n\n  var len = arr.length;\n  var mid = Math.floor(len / 2);\n\n  if (len % 2 !== 0) {\n    return arr[mid + 1 + off];\n  } else {\n    return (arr[mid - 1 + off] + arr[mid + off]) / 2;\n  }\n};\nvar deg2rad = function deg2rad(deg) {\n  return Math.PI * deg / 180;\n};\nvar getAngleFromDisp = function getAngleFromDisp(dispX, dispY) {\n  return Math.atan2(dispY, dispX) - Math.PI / 2;\n};\nvar log2 = Math.log2 || function (n) {\n  return Math.log(n) / Math.log(2);\n};\nvar signum = function signum(x) {\n  if (x > 0) {\n    return 1;\n  } else if (x < 0) {\n    return -1;\n  } else {\n    return 0;\n  }\n};\nvar dist = function dist(p1, p2) {\n  return Math.sqrt(sqdist(p1, p2));\n};\nvar sqdist = function sqdist(p1, p2) {\n  var dx = p2.x - p1.x;\n  var dy = p2.y - p1.y;\n  return dx * dx + dy * dy;\n};\nvar inPlaceSumNormalize = function inPlaceSumNormalize(v) {\n  var length = v.length; // First, get sum of all elements\n\n  var total = 0;\n\n  for (var i = 0; i < length; i++) {\n    total += v[i];\n  } // Now, divide each by the sum of all elements\n\n\n  for (var _i = 0; _i < length; _i++) {\n    v[_i] = v[_i] / total;\n  }\n\n  return v;\n};\n\nvar qbezierAt = function qbezierAt(p0, p1, p2, t) {\n  return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;\n};\nvar qbezierPtAt = function qbezierPtAt(p0, p1, p2, t) {\n  return {\n    x: qbezierAt(p0.x, p1.x, p2.x, t),\n    y: qbezierAt(p0.y, p1.y, p2.y, t)\n  };\n};\nvar lineAt = function lineAt(p0, p1, t, d) {\n  var vec = {\n    x: p1.x - p0.x,\n    y: p1.y - p0.y\n  };\n  var vecDist = dist(p0, p1);\n  var normVec = {\n    x: vec.x / vecDist,\n    y: vec.y / vecDist\n  };\n  t = t == null ? 0 : t;\n  d = d != null ? d : t * vecDist;\n  return {\n    x: p0.x + normVec.x * d,\n    y: p0.y + normVec.y * d\n  };\n};\nvar bound = function bound(min, val, max) {\n  return Math.max(min, Math.min(max, val));\n}; // makes a full bb (x1, y1, x2, y2, w, h) from implicit params\n\nvar makeBoundingBox = function makeBoundingBox(bb) {\n  if (bb == null) {\n    return {\n      x1: Infinity,\n      y1: Infinity,\n      x2: -Infinity,\n      y2: -Infinity,\n      w: 0,\n      h: 0\n    };\n  } else if (bb.x1 != null && bb.y1 != null) {\n    if (bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1) {\n      return {\n        x1: bb.x1,\n        y1: bb.y1,\n        x2: bb.x2,\n        y2: bb.y2,\n        w: bb.x2 - bb.x1,\n        h: bb.y2 - bb.y1\n      };\n    } else if (bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0) {\n      return {\n        x1: bb.x1,\n        y1: bb.y1,\n        x2: bb.x1 + bb.w,\n        y2: bb.y1 + bb.h,\n        w: bb.w,\n        h: bb.h\n      };\n    }\n  }\n};\nvar copyBoundingBox = function copyBoundingBox(bb) {\n  return {\n    x1: bb.x1,\n    x2: bb.x2,\n    w: bb.w,\n    y1: bb.y1,\n    y2: bb.y2,\n    h: bb.h\n  };\n};\nvar clearBoundingBox = function clearBoundingBox(bb) {\n  bb.x1 = Infinity;\n  bb.y1 = Infinity;\n  bb.x2 = -Infinity;\n  bb.y2 = -Infinity;\n  bb.w = 0;\n  bb.h = 0;\n};\nvar updateBoundingBox = function updateBoundingBox(bb1, bb2) {\n  // update bb1 with bb2 bounds\n  bb1.x1 = Math.min(bb1.x1, bb2.x1);\n  bb1.x2 = Math.max(bb1.x2, bb2.x2);\n  bb1.w = bb1.x2 - bb1.x1;\n  bb1.y1 = Math.min(bb1.y1, bb2.y1);\n  bb1.y2 = Math.max(bb1.y2, bb2.y2);\n  bb1.h = bb1.y2 - bb1.y1;\n};\nvar expandBoundingBoxByPoint = function expandBoundingBoxByPoint(bb, x, y) {\n  bb.x1 = Math.min(bb.x1, x);\n  bb.x2 = Math.max(bb.x2, x);\n  bb.w = bb.x2 - bb.x1;\n  bb.y1 = Math.min(bb.y1, y);\n  bb.y2 = Math.max(bb.y2, y);\n  bb.h = bb.y2 - bb.y1;\n};\nvar expandBoundingBox = function expandBoundingBox(bb) {\n  var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  bb.x1 -= padding;\n  bb.x2 += padding;\n  bb.y1 -= padding;\n  bb.y2 += padding;\n  bb.w = bb.x2 - bb.x1;\n  bb.h = bb.y2 - bb.y1;\n  return bb;\n};\nvar expandBoundingBoxSides = function expandBoundingBoxSides(bb) {\n  var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0];\n  var top, right, bottom, left;\n\n  if (padding.length === 1) {\n    top = right = bottom = left = padding[0];\n  } else if (padding.length === 2) {\n    top = bottom = padding[0];\n    left = right = padding[1];\n  } else if (padding.length === 4) {\n    var _padding = _slicedToArray(padding, 4);\n\n    top = _padding[0];\n    right = _padding[1];\n    bottom = _padding[2];\n    left = _padding[3];\n  }\n\n  bb.x1 -= left;\n  bb.x2 += right;\n  bb.y1 -= top;\n  bb.y2 += bottom;\n  bb.w = bb.x2 - bb.x1;\n  bb.h = bb.y2 - bb.y1;\n  return bb;\n};\n\nvar assignBoundingBox = function assignBoundingBox(bb1, bb2) {\n  bb1.x1 = bb2.x1;\n  bb1.y1 = bb2.y1;\n  bb1.x2 = bb2.x2;\n  bb1.y2 = bb2.y2;\n  bb1.w = bb1.x2 - bb1.x1;\n  bb1.h = bb1.y2 - bb1.y1;\n};\nvar boundingBoxesIntersect = function boundingBoxesIntersect(bb1, bb2) {\n  // case: one bb to right of other\n  if (bb1.x1 > bb2.x2) {\n    return false;\n  }\n\n  if (bb2.x1 > bb1.x2) {\n    return false;\n  } // case: one bb to left of other\n\n\n  if (bb1.x2 < bb2.x1) {\n    return false;\n  }\n\n  if (bb2.x2 < bb1.x1) {\n    return false;\n  } // case: one bb above other\n\n\n  if (bb1.y2 < bb2.y1) {\n    return false;\n  }\n\n  if (bb2.y2 < bb1.y1) {\n    return false;\n  } // case: one bb below other\n\n\n  if (bb1.y1 > bb2.y2) {\n    return false;\n  }\n\n  if (bb2.y1 > bb1.y2) {\n    return false;\n  } // otherwise, must have some overlap\n\n\n  return true;\n};\nvar inBoundingBox = function inBoundingBox(bb, x, y) {\n  return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;\n};\nvar pointInBoundingBox = function pointInBoundingBox(bb, pt) {\n  return inBoundingBox(bb, pt.x, pt.y);\n};\nvar boundingBoxInBoundingBox = function boundingBoxInBoundingBox(bb1, bb2) {\n  return inBoundingBox(bb1, bb2.x1, bb2.y1) && inBoundingBox(bb1, bb2.x2, bb2.y2);\n};\nvar roundRectangleIntersectLine = function roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding) {\n  var cornerRadius = getRoundRectangleRadius(width, height);\n  var halfWidth = width / 2;\n  var halfHeight = height / 2; // Check intersections with straight line segments\n\n  var straightLineIntersections; // Top segment, left to right\n\n  {\n    var topStartX = nodeX - halfWidth + cornerRadius - padding;\n    var topStartY = nodeY - halfHeight - padding;\n    var topEndX = nodeX + halfWidth - cornerRadius + padding;\n    var topEndY = topStartY;\n    straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);\n\n    if (straightLineIntersections.length > 0) {\n      return straightLineIntersections;\n    }\n  } // Right segment, top to bottom\n\n  {\n    var rightStartX = nodeX + halfWidth + padding;\n    var rightStartY = nodeY - halfHeight + cornerRadius - padding;\n    var rightEndX = rightStartX;\n    var rightEndY = nodeY + halfHeight - cornerRadius + padding;\n    straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);\n\n    if (straightLineIntersections.length > 0) {\n      return straightLineIntersections;\n    }\n  } // Bottom segment, left to right\n\n  {\n    var bottomStartX = nodeX - halfWidth + cornerRadius - padding;\n    var bottomStartY = nodeY + halfHeight + padding;\n    var bottomEndX = nodeX + halfWidth - cornerRadius + padding;\n    var bottomEndY = bottomStartY;\n    straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);\n\n    if (straightLineIntersections.length > 0) {\n      return straightLineIntersections;\n    }\n  } // Left segment, top to bottom\n\n  {\n    var leftStartX = nodeX - halfWidth - padding;\n    var leftStartY = nodeY - halfHeight + cornerRadius - padding;\n    var leftEndX = leftStartX;\n    var leftEndY = nodeY + halfHeight - cornerRadius + padding;\n    straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);\n\n    if (straightLineIntersections.length > 0) {\n      return straightLineIntersections;\n    }\n  } // Check intersections with arc segments\n\n  var arcIntersections; // Top Left\n\n  {\n    var topLeftCenterX = nodeX - halfWidth + cornerRadius;\n    var topLeftCenterY = nodeY - halfHeight + cornerRadius;\n    arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topLeftCenterX, topLeftCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle\n\n    if (arcIntersections.length > 0 && arcIntersections[0] <= topLeftCenterX && arcIntersections[1] <= topLeftCenterY) {\n      return [arcIntersections[0], arcIntersections[1]];\n    }\n  } // Top Right\n\n  {\n    var topRightCenterX = nodeX + halfWidth - cornerRadius;\n    var topRightCenterY = nodeY - halfHeight + cornerRadius;\n    arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topRightCenterX, topRightCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle\n\n    if (arcIntersections.length > 0 && arcIntersections[0] >= topRightCenterX && arcIntersections[1] <= topRightCenterY) {\n      return [arcIntersections[0], arcIntersections[1]];\n    }\n  } // Bottom Right\n\n  {\n    var bottomRightCenterX = nodeX + halfWidth - cornerRadius;\n    var bottomRightCenterY = nodeY + halfHeight - cornerRadius;\n    arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomRightCenterX, bottomRightCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle\n\n    if (arcIntersections.length > 0 && arcIntersections[0] >= bottomRightCenterX && arcIntersections[1] >= bottomRightCenterY) {\n      return [arcIntersections[0], arcIntersections[1]];\n    }\n  } // Bottom Left\n\n  {\n    var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;\n    var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;\n    arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle\n\n    if (arcIntersections.length > 0 && arcIntersections[0] <= bottomLeftCenterX && arcIntersections[1] >= bottomLeftCenterY) {\n      return [arcIntersections[0], arcIntersections[1]];\n    }\n  }\n  return []; // if nothing\n};\nvar inLineVicinity = function inLineVicinity(x, y, lx1, ly1, lx2, ly2, tolerance) {\n  var t = tolerance;\n  var x1 = Math.min(lx1, lx2);\n  var x2 = Math.max(lx1, lx2);\n  var y1 = Math.min(ly1, ly2);\n  var y2 = Math.max(ly1, ly2);\n  return x1 - t <= x && x <= x2 + t && y1 - t <= y && y <= y2 + t;\n};\nvar inBezierVicinity = function inBezierVicinity(x, y, x1, y1, x2, y2, x3, y3, tolerance) {\n  var bb = {\n    x1: Math.min(x1, x3, x2) - tolerance,\n    x2: Math.max(x1, x3, x2) + tolerance,\n    y1: Math.min(y1, y3, y2) - tolerance,\n    y2: Math.max(y1, y3, y2) + tolerance\n  }; // if outside the rough bounding box for the bezier, then it can't be a hit\n\n  if (x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2) {\n    // console.log('bezier out of rough bb')\n    return false;\n  } else {\n    // console.log('do more expensive check');\n    return true;\n  }\n};\nvar solveQuadratic = function solveQuadratic(a, b, c, val) {\n  c -= val;\n  var r = b * b - 4 * a * c;\n\n  if (r < 0) {\n    return [];\n  }\n\n  var sqrtR = Math.sqrt(r);\n  var denom = 2 * a;\n  var root1 = (-b + sqrtR) / denom;\n  var root2 = (-b - sqrtR) / denom;\n  return [root1, root2];\n};\nvar solveCubic = function solveCubic(a, b, c, d, result) {\n  // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where\n  // r is the real component, i is the imaginary component\n  // An implementation of the Cardano method from the year 1545\n  // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots\n  var epsilon = 0.00001; // avoid division by zero while keeping the overall expression close in value\n\n  if (a === 0) {\n    a = epsilon;\n  }\n\n  b /= a;\n  c /= a;\n  d /= a;\n  var discriminant, q, r, dum1, s, t, term1, r13;\n  q = (3.0 * c - b * b) / 9.0;\n  r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));\n  r /= 54.0;\n  discriminant = q * q * q + r * r;\n  result[1] = 0;\n  term1 = b / 3.0;\n\n  if (discriminant > 0) {\n    s = r + Math.sqrt(discriminant);\n    s = s < 0 ? -Math.pow(-s, 1.0 / 3.0) : Math.pow(s, 1.0 / 3.0);\n    t = r - Math.sqrt(discriminant);\n    t = t < 0 ? -Math.pow(-t, 1.0 / 3.0) : Math.pow(t, 1.0 / 3.0);\n    result[0] = -term1 + s + t;\n    term1 += (s + t) / 2.0;\n    result[4] = result[2] = -term1;\n    term1 = Math.sqrt(3.0) * (-t + s) / 2;\n    result[3] = term1;\n    result[5] = -term1;\n    return;\n  }\n\n  result[5] = result[3] = 0;\n\n  if (discriminant === 0) {\n    r13 = r < 0 ? -Math.pow(-r, 1.0 / 3.0) : Math.pow(r, 1.0 / 3.0);\n    result[0] = -term1 + 2.0 * r13;\n    result[4] = result[2] = -(r13 + term1);\n    return;\n  }\n\n  q = -q;\n  dum1 = q * q * q;\n  dum1 = Math.acos(r / Math.sqrt(dum1));\n  r13 = 2.0 * Math.sqrt(q);\n  result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);\n  result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);\n  result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);\n  return;\n};\nvar sqdistToQuadraticBezier = function sqdistToQuadraticBezier(x, y, x1, y1, x2, y2, x3, y3) {\n  // Find minimum distance by using the minimum of the distance\n  // function between the given point and the curve\n  // This gives the coefficients of the resulting cubic equation\n  // whose roots tell us where a possible minimum is\n  // (Coefficients are divided by 4)\n  var a = 1.0 * x1 * x1 - 4 * x1 * x2 + 2 * x1 * x3 + 4 * x2 * x2 - 4 * x2 * x3 + x3 * x3 + y1 * y1 - 4 * y1 * y2 + 2 * y1 * y3 + 4 * y2 * y2 - 4 * y2 * y3 + y3 * y3;\n  var b = 1.0 * 9 * x1 * x2 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x2 * x2 + 3 * x2 * x3 + 9 * y1 * y2 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y2 * y2 + 3 * y2 * y3;\n  var c = 1.0 * 3 * x1 * x1 - 6 * x1 * x2 + x1 * x3 - x1 * x + 2 * x2 * x2 + 2 * x2 * x - x3 * x + 3 * y1 * y1 - 6 * y1 * y2 + y1 * y3 - y1 * y + 2 * y2 * y2 + 2 * y2 * y - y3 * y;\n  var d = 1.0 * x1 * x2 - x1 * x1 + x1 * x - x2 * x + y1 * y2 - y1 * y1 + y1 * y - y2 * y; // debug(\"coefficients: \" + a / a + \", \" + b / a + \", \" + c / a + \", \" + d / a);\n\n  var roots = []; // Use the cubic solving algorithm\n\n  solveCubic(a, b, c, d, roots);\n  var zeroThreshold = 0.0000001;\n  var params = [];\n\n  for (var index = 0; index < 6; index += 2) {\n    if (Math.abs(roots[index + 1]) < zeroThreshold && roots[index] >= 0 && roots[index] <= 1.0) {\n      params.push(roots[index]);\n    }\n  }\n\n  params.push(1.0);\n  params.push(0.0);\n  var minDistanceSquared = -1;\n  var curX, curY, distSquared;\n\n  for (var i = 0; i < params.length; i++) {\n    curX = Math.pow(1.0 - params[i], 2.0) * x1 + 2.0 * (1 - params[i]) * params[i] * x2 + params[i] * params[i] * x3;\n    curY = Math.pow(1 - params[i], 2.0) * y1 + 2 * (1.0 - params[i]) * params[i] * y2 + params[i] * params[i] * y3;\n    distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2); // debug('distance for param ' + params[i] + \": \" + Math.sqrt(distSquared));\n\n    if (minDistanceSquared >= 0) {\n      if (distSquared < minDistanceSquared) {\n        minDistanceSquared = distSquared;\n      }\n    } else {\n      minDistanceSquared = distSquared;\n    }\n  }\n\n  return minDistanceSquared;\n};\nvar sqdistToFiniteLine = function sqdistToFiniteLine(x, y, x1, y1, x2, y2) {\n  var offset = [x - x1, y - y1];\n  var line = [x2 - x1, y2 - y1];\n  var lineSq = line[0] * line[0] + line[1] * line[1];\n  var hypSq = offset[0] * offset[0] + offset[1] * offset[1];\n  var dotProduct = offset[0] * line[0] + offset[1] * line[1];\n  var adjSq = dotProduct * dotProduct / lineSq;\n\n  if (dotProduct < 0) {\n    return hypSq;\n  }\n\n  if (adjSq > lineSq) {\n    return (x - x2) * (x - x2) + (y - y2) * (y - y2);\n  }\n\n  return hypSq - adjSq;\n};\nvar pointInsidePolygonPoints = function pointInsidePolygonPoints(x, y, points) {\n  var x1, y1, x2, y2;\n  var y3; // Intersect with vertical line through (x, y)\n\n  var up = 0; // let down = 0;\n\n  for (var i = 0; i < points.length / 2; i++) {\n    x1 = points[i * 2];\n    y1 = points[i * 2 + 1];\n\n    if (i + 1 < points.length / 2) {\n      x2 = points[(i + 1) * 2];\n      y2 = points[(i + 1) * 2 + 1];\n    } else {\n      x2 = points[(i + 1 - points.length / 2) * 2];\n      y2 = points[(i + 1 - points.length / 2) * 2 + 1];\n    }\n\n    if (x1 == x && x2 == x) ; else if (x1 >= x && x >= x2 || x1 <= x && x <= x2) {\n      y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;\n\n      if (y3 > y) {\n        up++;\n      } // if( y3 < y ){\n      // down++;\n      // }\n\n    } else {\n      continue;\n    }\n  }\n\n  if (up % 2 === 0) {\n    return false;\n  } else {\n    return true;\n  }\n};\nvar pointInsidePolygon = function pointInsidePolygon(x, y, basePoints, centerX, centerY, width, height, direction, padding) {\n  var transformedPoints = new Array(basePoints.length); // Gives negative angle\n\n  var angle;\n\n  if (direction[0] != null) {\n    angle = Math.atan(direction[1] / direction[0]);\n\n    if (direction[0] < 0) {\n      angle = angle + Math.PI / 2;\n    } else {\n      angle = -angle - Math.PI / 2;\n    }\n  } else {\n    angle = direction;\n  }\n\n  var cos = Math.cos(-angle);\n  var sin = Math.sin(-angle); //    console.log(\"base: \" + basePoints);\n\n  for (var i = 0; i < transformedPoints.length / 2; i++) {\n    transformedPoints[i * 2] = width / 2 * (basePoints[i * 2] * cos - basePoints[i * 2 + 1] * sin);\n    transformedPoints[i * 2 + 1] = height / 2 * (basePoints[i * 2 + 1] * cos + basePoints[i * 2] * sin);\n    transformedPoints[i * 2] += centerX;\n    transformedPoints[i * 2 + 1] += centerY;\n  }\n\n  var points;\n\n  if (padding > 0) {\n    var expandedLineSet = expandPolygon(transformedPoints, -padding);\n    points = joinLines(expandedLineSet);\n  } else {\n    points = transformedPoints;\n  }\n\n  return pointInsidePolygonPoints(x, y, points);\n};\nvar pointInsideRoundPolygon = function pointInsideRoundPolygon(x, y, basePoints, centerX, centerY, width, height) {\n  var cutPolygonPoints = new Array(basePoints.length);\n  var halfW = width / 2;\n  var halfH = height / 2;\n  var cornerRadius = getRoundPolygonRadius(width, height);\n  var squaredCornerRadius = cornerRadius * cornerRadius;\n\n  for (var i = 0; i < basePoints.length / 4; i++) {\n    var sourceUv = void 0,\n        destUv = void 0;\n\n    if (i === 0) {\n      sourceUv = basePoints.length - 2;\n    } else {\n      sourceUv = i * 4 - 2;\n    }\n\n    destUv = i * 4 + 2;\n    var px = centerX + halfW * basePoints[i * 4];\n    var py = centerY + halfH * basePoints[i * 4 + 1];\n    var cosTheta = -basePoints[sourceUv] * basePoints[destUv] - basePoints[sourceUv + 1] * basePoints[destUv + 1];\n    var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);\n    var cp0x = px - offset * basePoints[sourceUv];\n    var cp0y = py - offset * basePoints[sourceUv + 1];\n    var cp1x = px + offset * basePoints[destUv];\n    var cp1y = py + offset * basePoints[destUv + 1];\n    cutPolygonPoints[i * 4] = cp0x;\n    cutPolygonPoints[i * 4 + 1] = cp0y;\n    cutPolygonPoints[i * 4 + 2] = cp1x;\n    cutPolygonPoints[i * 4 + 3] = cp1y;\n    var orthx = basePoints[sourceUv + 1];\n    var orthy = -basePoints[sourceUv];\n    var cosAlpha = orthx * basePoints[destUv] + orthy * basePoints[destUv + 1];\n\n    if (cosAlpha < 0) {\n      orthx *= -1;\n      orthy *= -1;\n    }\n\n    var cx = cp0x + orthx * cornerRadius;\n    var cy = cp0y + orthy * cornerRadius;\n    var squaredDistance = Math.pow(cx - x, 2) + Math.pow(cy - y, 2);\n\n    if (squaredDistance <= squaredCornerRadius) {\n      return true;\n    }\n  }\n\n  return pointInsidePolygonPoints(x, y, cutPolygonPoints);\n};\nvar joinLines = function joinLines(lineSet) {\n  var vertices = new Array(lineSet.length / 2);\n  var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;\n  var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;\n\n  for (var i = 0; i < lineSet.length / 4; i++) {\n    currentLineStartX = lineSet[i * 4];\n    currentLineStartY = lineSet[i * 4 + 1];\n    currentLineEndX = lineSet[i * 4 + 2];\n    currentLineEndY = lineSet[i * 4 + 3];\n\n    if (i < lineSet.length / 4 - 1) {\n      nextLineStartX = lineSet[(i + 1) * 4];\n      nextLineStartY = lineSet[(i + 1) * 4 + 1];\n      nextLineEndX = lineSet[(i + 1) * 4 + 2];\n      nextLineEndY = lineSet[(i + 1) * 4 + 3];\n    } else {\n      nextLineStartX = lineSet[0];\n      nextLineStartY = lineSet[1];\n      nextLineEndX = lineSet[2];\n      nextLineEndY = lineSet[3];\n    }\n\n    var intersection = finiteLinesIntersect(currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY, nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY, true);\n    vertices[i * 2] = intersection[0];\n    vertices[i * 2 + 1] = intersection[1];\n  }\n\n  return vertices;\n};\nvar expandPolygon = function expandPolygon(points, pad) {\n  var expandedLineSet = new Array(points.length * 2);\n  var currentPointX, currentPointY, nextPointX, nextPointY;\n\n  for (var i = 0; i < points.length / 2; i++) {\n    currentPointX = points[i * 2];\n    currentPointY = points[i * 2 + 1];\n\n    if (i < points.length / 2 - 1) {\n      nextPointX = points[(i + 1) * 2];\n      nextPointY = points[(i + 1) * 2 + 1];\n    } else {\n      nextPointX = points[0];\n      nextPointY = points[1];\n    } // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]\n    // Assume CCW polygon winding\n\n\n    var offsetX = nextPointY - currentPointY;\n    var offsetY = -(nextPointX - currentPointX); // Normalize\n\n    var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);\n    var normalizedOffsetX = offsetX / offsetLength;\n    var normalizedOffsetY = offsetY / offsetLength;\n    expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;\n    expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;\n    expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;\n    expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;\n  }\n\n  return expandedLineSet;\n};\nvar intersectLineEllipse = function intersectLineEllipse(x, y, centerX, centerY, ellipseWradius, ellipseHradius) {\n  var dispX = centerX - x;\n  var dispY = centerY - y;\n  dispX /= ellipseWradius;\n  dispY /= ellipseHradius;\n  var len = Math.sqrt(dispX * dispX + dispY * dispY);\n  var newLength = len - 1;\n\n  if (newLength < 0) {\n    return [];\n  }\n\n  var lenProportion = newLength / len;\n  return [(centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y];\n};\nvar checkInEllipse = function checkInEllipse(x, y, width, height, centerX, centerY, padding) {\n  x -= centerX;\n  y -= centerY;\n  x /= width / 2 + padding;\n  y /= height / 2 + padding;\n  return x * x + y * y <= 1;\n}; // Returns intersections of increasing distance from line's start point\n\nvar intersectLineCircle = function intersectLineCircle(x1, y1, x2, y2, centerX, centerY, radius) {\n  // Calculate d, direction vector of line\n  var d = [x2 - x1, y2 - y1]; // Direction vector of line\n\n  var f = [x1 - centerX, y1 - centerY];\n  var a = d[0] * d[0] + d[1] * d[1];\n  var b = 2 * (f[0] * d[0] + f[1] * d[1]);\n  var c = f[0] * f[0] + f[1] * f[1] - radius * radius;\n  var discriminant = b * b - 4 * a * c;\n\n  if (discriminant < 0) {\n    return [];\n  }\n\n  var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);\n  var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);\n  var tMin = Math.min(t1, t2);\n  var tMax = Math.max(t1, t2);\n  var inRangeParams = [];\n\n  if (tMin >= 0 && tMin <= 1) {\n    inRangeParams.push(tMin);\n  }\n\n  if (tMax >= 0 && tMax <= 1) {\n    inRangeParams.push(tMax);\n  }\n\n  if (inRangeParams.length === 0) {\n    return [];\n  }\n\n  var nearIntersectionX = inRangeParams[0] * d[0] + x1;\n  var nearIntersectionY = inRangeParams[0] * d[1] + y1;\n\n  if (inRangeParams.length > 1) {\n    if (inRangeParams[0] == inRangeParams[1]) {\n      return [nearIntersectionX, nearIntersectionY];\n    } else {\n      var farIntersectionX = inRangeParams[1] * d[0] + x1;\n      var farIntersectionY = inRangeParams[1] * d[1] + y1;\n      return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];\n    }\n  } else {\n    return [nearIntersectionX, nearIntersectionY];\n  }\n};\nvar midOfThree = function midOfThree(a, b, c) {\n  if (b <= a && a <= c || c <= a && a <= b) {\n    return a;\n  } else if (a <= b && b <= c || c <= b && b <= a) {\n    return b;\n  } else {\n    return c;\n  }\n}; // (x1,y1)=>(x2,y2) intersect with (x3,y3)=>(x4,y4)\n\nvar finiteLinesIntersect = function finiteLinesIntersect(x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {\n  var dx13 = x1 - x3;\n  var dx21 = x2 - x1;\n  var dx43 = x4 - x3;\n  var dy13 = y1 - y3;\n  var dy21 = y2 - y1;\n  var dy43 = y4 - y3;\n  var ua_t = dx43 * dy13 - dy43 * dx13;\n  var ub_t = dx21 * dy13 - dy21 * dx13;\n  var u_b = dy43 * dx21 - dx43 * dy21;\n\n  if (u_b !== 0) {\n    var ua = ua_t / u_b;\n    var ub = ub_t / u_b;\n    var flptThreshold = 0.001;\n\n    var _min = 0 - flptThreshold;\n\n    var _max = 1 + flptThreshold;\n\n    if (_min <= ua && ua <= _max && _min <= ub && ub <= _max) {\n      return [x1 + ua * dx21, y1 + ua * dy21];\n    } else {\n      if (!infiniteLines) {\n        return [];\n      } else {\n        return [x1 + ua * dx21, y1 + ua * dy21];\n      }\n    }\n  } else {\n    if (ua_t === 0 || ub_t === 0) {\n      // Parallel, coincident lines. Check if overlap\n      // Check endpoint of second line\n      if (midOfThree(x1, x2, x4) === x4) {\n        return [x4, y4];\n      } // Check start point of second line\n\n\n      if (midOfThree(x1, x2, x3) === x3) {\n        return [x3, y3];\n      } // Endpoint of first line\n\n\n      if (midOfThree(x3, x4, x2) === x2) {\n        return [x2, y2];\n      }\n\n      return [];\n    } else {\n      // Parallel, non-coincident\n      return [];\n    }\n  }\n}; // math.polygonIntersectLine( x, y, basePoints, centerX, centerY, width, height, padding )\n// intersect a node polygon (pts transformed)\n//\n// math.polygonIntersectLine( x, y, basePoints, centerX, centerY )\n// intersect the points (no transform)\n\nvar polygonIntersectLine = function polygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding) {\n  var intersections = [];\n  var intersection;\n  var transformedPoints = new Array(basePoints.length);\n  var doTransform = true;\n\n  if (width == null) {\n    doTransform = false;\n  }\n\n  var points;\n\n  if (doTransform) {\n    for (var i = 0; i < transformedPoints.length / 2; i++) {\n      transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;\n      transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;\n    }\n\n    if (padding > 0) {\n      var expandedLineSet = expandPolygon(transformedPoints, -padding);\n      points = joinLines(expandedLineSet);\n    } else {\n      points = transformedPoints;\n    }\n  } else {\n    points = basePoints;\n  }\n\n  var currentX, currentY, nextX, nextY;\n\n  for (var _i2 = 0; _i2 < points.length / 2; _i2++) {\n    currentX = points[_i2 * 2];\n    currentY = points[_i2 * 2 + 1];\n\n    if (_i2 < points.length / 2 - 1) {\n      nextX = points[(_i2 + 1) * 2];\n      nextY = points[(_i2 + 1) * 2 + 1];\n    } else {\n      nextX = points[0];\n      nextY = points[1];\n    }\n\n    intersection = finiteLinesIntersect(x, y, centerX, centerY, currentX, currentY, nextX, nextY);\n\n    if (intersection.length !== 0) {\n      intersections.push(intersection[0], intersection[1]);\n    }\n  }\n\n  return intersections;\n};\nvar roundPolygonIntersectLine = function roundPolygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding) {\n  var intersections = [];\n  var intersection;\n  var lines = new Array(basePoints.length);\n  var halfW = width / 2;\n  var halfH = height / 2;\n  var cornerRadius = getRoundPolygonRadius(width, height);\n\n  for (var i = 0; i < basePoints.length / 4; i++) {\n    var sourceUv = void 0,\n        destUv = void 0;\n\n    if (i === 0) {\n      sourceUv = basePoints.length - 2;\n    } else {\n      sourceUv = i * 4 - 2;\n    }\n\n    destUv = i * 4 + 2;\n    var px = centerX + halfW * basePoints[i * 4];\n    var py = centerY + halfH * basePoints[i * 4 + 1];\n    var cosTheta = -basePoints[sourceUv] * basePoints[destUv] - basePoints[sourceUv + 1] * basePoints[destUv + 1];\n    var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);\n    var cp0x = px - offset * basePoints[sourceUv];\n    var cp0y = py - offset * basePoints[sourceUv + 1];\n    var cp1x = px + offset * basePoints[destUv];\n    var cp1y = py + offset * basePoints[destUv + 1];\n\n    if (i === 0) {\n      lines[basePoints.length - 2] = cp0x;\n      lines[basePoints.length - 1] = cp0y;\n    } else {\n      lines[i * 4 - 2] = cp0x;\n      lines[i * 4 - 1] = cp0y;\n    }\n\n    lines[i * 4] = cp1x;\n    lines[i * 4 + 1] = cp1y;\n    var orthx = basePoints[sourceUv + 1];\n    var orthy = -basePoints[sourceUv];\n    var cosAlpha = orthx * basePoints[destUv] + orthy * basePoints[destUv + 1];\n\n    if (cosAlpha < 0) {\n      orthx *= -1;\n      orthy *= -1;\n    }\n\n    var cx = cp0x + orthx * cornerRadius;\n    var cy = cp0y + orthy * cornerRadius;\n    intersection = intersectLineCircle(x, y, centerX, centerY, cx, cy, cornerRadius);\n\n    if (intersection.length !== 0) {\n      intersections.push(intersection[0], intersection[1]);\n    }\n  }\n\n  for (var _i3 = 0; _i3 < lines.length / 4; _i3++) {\n    intersection = finiteLinesIntersect(x, y, centerX, centerY, lines[_i3 * 4], lines[_i3 * 4 + 1], lines[_i3 * 4 + 2], lines[_i3 * 4 + 3], false);\n\n    if (intersection.length !== 0) {\n      intersections.push(intersection[0], intersection[1]);\n    }\n  }\n\n  if (intersections.length > 2) {\n    var lowestIntersection = [intersections[0], intersections[1]];\n    var lowestSquaredDistance = Math.pow(lowestIntersection[0] - x, 2) + Math.pow(lowestIntersection[1] - y, 2);\n\n    for (var _i4 = 1; _i4 < intersections.length / 2; _i4++) {\n      var squaredDistance = Math.pow(intersections[_i4 * 2] - x, 2) + Math.pow(intersections[_i4 * 2 + 1] - y, 2);\n\n      if (squaredDistance <= lowestSquaredDistance) {\n        lowestIntersection[0] = intersections[_i4 * 2];\n        lowestIntersection[1] = intersections[_i4 * 2 + 1];\n        lowestSquaredDistance = squaredDistance;\n      }\n    }\n\n    return lowestIntersection;\n  }\n\n  return intersections;\n};\nvar shortenIntersection = function shortenIntersection(intersection, offset, amount) {\n  var disp = [intersection[0] - offset[0], intersection[1] - offset[1]];\n  var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);\n  var lenRatio = (length - amount) / length;\n\n  if (lenRatio < 0) {\n    lenRatio = 0.00001;\n  }\n\n  return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];\n};\nvar generateUnitNgonPointsFitToSquare = function generateUnitNgonPointsFitToSquare(sides, rotationRadians) {\n  var points = generateUnitNgonPoints(sides, rotationRadians);\n  points = fitPolygonToSquare(points);\n  return points;\n};\nvar fitPolygonToSquare = function fitPolygonToSquare(points) {\n  var x, y;\n  var sides = points.length / 2;\n  var minX = Infinity,\n      minY = Infinity,\n      maxX = -Infinity,\n      maxY = -Infinity;\n\n  for (var i = 0; i < sides; i++) {\n    x = points[2 * i];\n    y = points[2 * i + 1];\n    minX = Math.min(minX, x);\n    maxX = Math.max(maxX, x);\n    minY = Math.min(minY, y);\n    maxY = Math.max(maxY, y);\n  } // stretch factors\n\n\n  var sx = 2 / (maxX - minX);\n  var sy = 2 / (maxY - minY);\n\n  for (var _i5 = 0; _i5 < sides; _i5++) {\n    x = points[2 * _i5] = points[2 * _i5] * sx;\n    y = points[2 * _i5 + 1] = points[2 * _i5 + 1] * sy;\n    minX = Math.min(minX, x);\n    maxX = Math.max(maxX, x);\n    minY = Math.min(minY, y);\n    maxY = Math.max(maxY, y);\n  }\n\n  if (minY < -1) {\n    for (var _i6 = 0; _i6 < sides; _i6++) {\n      y = points[2 * _i6 + 1] = points[2 * _i6 + 1] + (-1 - minY);\n    }\n  }\n\n  return points;\n};\nvar generateUnitNgonPoints = function generateUnitNgonPoints(sides, rotationRadians) {\n  var increment = 1.0 / sides * 2 * Math.PI;\n  var startAngle = sides % 2 === 0 ? Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;\n  startAngle += rotationRadians;\n  var points = new Array(sides * 2);\n  var currentAngle;\n\n  for (var i = 0; i < sides; i++) {\n    currentAngle = i * increment + startAngle;\n    points[2 * i] = Math.cos(currentAngle); // x\n\n    points[2 * i + 1] = Math.sin(-currentAngle); // y\n  }\n\n  return points;\n}; // Set the default radius, unless half of width or height is smaller than default\n\nvar getRoundRectangleRadius = function getRoundRectangleRadius(width, height) {\n  return Math.min(width / 4, height / 4, 8);\n}; // Set the default radius\n\nvar getRoundPolygonRadius = function getRoundPolygonRadius(width, height) {\n  return Math.min(width / 10, height / 10, 8);\n};\nvar getCutRectangleCornerLength = function getCutRectangleCornerLength() {\n  return 8;\n};\nvar bezierPtsToQuadCoeff = function bezierPtsToQuadCoeff(p0, p1, p2) {\n  return [p0 - 2 * p1 + p2, 2 * (p1 - p0), p0];\n}; // get curve width, height, and control point position offsets as a percentage of node height / width\n\nvar getBarrelCurveConstants = function getBarrelCurveConstants(width, height) {\n  return {\n    heightOffset: Math.min(15, 0.05 * height),\n    widthOffset: Math.min(100, 0.25 * width),\n    ctrlPtOffsetPct: 0.05\n  };\n};\n\nvar pageRankDefaults = defaults$g({\n  dampingFactor: 0.8,\n  precision: 0.000001,\n  iterations: 200,\n  weight: function weight(edge) {\n    return 1;\n  }\n});\nvar elesfn$o = {\n  pageRank: function pageRank(options) {\n    var _pageRankDefaults = pageRankDefaults(options),\n        dampingFactor = _pageRankDefaults.dampingFactor,\n        precision = _pageRankDefaults.precision,\n        iterations = _pageRankDefaults.iterations,\n        weight = _pageRankDefaults.weight;\n\n    var cy = this._private.cy;\n\n    var _this$byGroup = this.byGroup(),\n        nodes = _this$byGroup.nodes,\n        edges = _this$byGroup.edges;\n\n    var numNodes = nodes.length;\n    var numNodesSqd = numNodes * numNodes;\n    var numEdges = edges.length; // Construct transposed adjacency matrix\n    // First lets have a zeroed matrix of the right size\n    // We'll also keep track of the sum of each column\n\n    var matrix = new Array(numNodesSqd);\n    var columnSum = new Array(numNodes);\n    var additionalProb = (1 - dampingFactor) / numNodes; // Create null matrix\n\n    for (var i = 0; i < numNodes; i++) {\n      for (var j = 0; j < numNodes; j++) {\n        var n = i * numNodes + j;\n        matrix[n] = 0;\n      }\n\n      columnSum[i] = 0;\n    } // Now, process edges\n\n\n    for (var _i = 0; _i < numEdges; _i++) {\n      var edge = edges[_i];\n      var srcId = edge.data('source');\n      var tgtId = edge.data('target'); // Don't include loops in the matrix\n\n      if (srcId === tgtId) {\n        continue;\n      }\n\n      var s = nodes.indexOfId(srcId);\n      var t = nodes.indexOfId(tgtId);\n      var w = weight(edge);\n\n      var _n = t * numNodes + s; // Update matrix\n\n\n      matrix[_n] += w; // Update column sum\n\n      columnSum[s] += w;\n    } // Add additional probability based on damping factor\n    // Also, take into account columns that have sum = 0\n\n\n    var p = 1.0 / numNodes + additionalProb; // Shorthand\n    // Traverse matrix, column by column\n\n    for (var _j = 0; _j < numNodes; _j++) {\n      if (columnSum[_j] === 0) {\n        // No 'links' out from node jth, assume equal probability for each possible node\n        for (var _i2 = 0; _i2 < numNodes; _i2++) {\n          var _n2 = _i2 * numNodes + _j;\n\n          matrix[_n2] = p;\n        }\n      } else {\n        // Node jth has outgoing link, compute normalized probabilities\n        for (var _i3 = 0; _i3 < numNodes; _i3++) {\n          var _n3 = _i3 * numNodes + _j;\n\n          matrix[_n3] = matrix[_n3] / columnSum[_j] + additionalProb;\n        }\n      }\n    } // Compute dominant eigenvector using power method\n\n\n    var eigenvector = new Array(numNodes);\n    var temp = new Array(numNodes);\n    var previous; // Start with a vector of all 1's\n    // Also, initialize a null vector which will be used as shorthand\n\n    for (var _i4 = 0; _i4 < numNodes; _i4++) {\n      eigenvector[_i4] = 1;\n    }\n\n    for (var iter = 0; iter < iterations; iter++) {\n      // Temp array with all 0's\n      for (var _i5 = 0; _i5 < numNodes; _i5++) {\n        temp[_i5] = 0;\n      } // Multiply matrix with previous result\n\n\n      for (var _i6 = 0; _i6 < numNodes; _i6++) {\n        for (var _j2 = 0; _j2 < numNodes; _j2++) {\n          var _n4 = _i6 * numNodes + _j2;\n\n          temp[_i6] += matrix[_n4] * eigenvector[_j2];\n        }\n      }\n\n      inPlaceSumNormalize(temp);\n      previous = eigenvector;\n      eigenvector = temp;\n      temp = previous;\n      var diff = 0; // Compute difference (squared module) of both vectors\n\n      for (var _i7 = 0; _i7 < numNodes; _i7++) {\n        var delta = previous[_i7] - eigenvector[_i7];\n        diff += delta * delta;\n      } // If difference is less than the desired threshold, stop iterating\n\n\n      if (diff < precision) {\n        break;\n      }\n    } // Construct result\n\n\n    var res = {\n      rank: function rank(node) {\n        node = cy.collection(node)[0];\n        return eigenvector[nodes.indexOf(node)];\n      }\n    };\n    return res;\n  } // pageRank\n\n}; // elesfn\n\nvar defaults$f = defaults$g({\n  root: null,\n  weight: function weight(edge) {\n    return 1;\n  },\n  directed: false,\n  alpha: 0\n});\nvar elesfn$n = {\n  degreeCentralityNormalized: function degreeCentralityNormalized(options) {\n    options = defaults$f(options);\n    var cy = this.cy();\n    var nodes = this.nodes();\n    var numNodes = nodes.length;\n\n    if (!options.directed) {\n      var degrees = {};\n      var maxDegree = 0;\n\n      for (var i = 0; i < numNodes; i++) {\n        var node = nodes[i]; // add current node to the current options object and call degreeCentrality\n\n        options.root = node;\n        var currDegree = this.degreeCentrality(options);\n\n        if (maxDegree < currDegree.degree) {\n          maxDegree = currDegree.degree;\n        }\n\n        degrees[node.id()] = currDegree.degree;\n      }\n\n      return {\n        degree: function degree(node) {\n          if (maxDegree === 0) {\n            return 0;\n          }\n\n          if (string(node)) {\n            // from is a selector string\n            node = cy.filter(node);\n          }\n\n          return degrees[node.id()] / maxDegree;\n        }\n      };\n    } else {\n      var indegrees = {};\n      var outdegrees = {};\n      var maxIndegree = 0;\n      var maxOutdegree = 0;\n\n      for (var _i = 0; _i < numNodes; _i++) {\n        var _node = nodes[_i];\n\n        var id = _node.id(); // add current node to the current options object and call degreeCentrality\n\n\n        options.root = _node;\n\n        var _currDegree = this.degreeCentrality(options);\n\n        if (maxIndegree < _currDegree.indegree) maxIndegree = _currDegree.indegree;\n        if (maxOutdegree < _currDegree.outdegree) maxOutdegree = _currDegree.outdegree;\n        indegrees[id] = _currDegree.indegree;\n        outdegrees[id] = _currDegree.outdegree;\n      }\n\n      return {\n        indegree: function indegree(node) {\n          if (maxIndegree == 0) {\n            return 0;\n          }\n\n          if (string(node)) {\n            // from is a selector string\n            node = cy.filter(node);\n          }\n\n          return indegrees[node.id()] / maxIndegree;\n        },\n        outdegree: function outdegree(node) {\n          if (maxOutdegree === 0) {\n            return 0;\n          }\n\n          if (string(node)) {\n            // from is a selector string\n            node = cy.filter(node);\n          }\n\n          return outdegrees[node.id()] / maxOutdegree;\n        }\n      };\n    }\n  },\n  // degreeCentralityNormalized\n  // Implemented from the algorithm in Opsahl's paper\n  // \"Node centrality in weighted networks: Generalizing degree and shortest paths\"\n  // check the heading 2 \"Degree\"\n  degreeCentrality: function degreeCentrality(options) {\n    options = defaults$f(options);\n    var cy = this.cy();\n    var callingEles = this;\n    var _options = options,\n        root = _options.root,\n        weight = _options.weight,\n        directed = _options.directed,\n        alpha = _options.alpha;\n    root = cy.collection(root)[0];\n\n    if (!directed) {\n      var connEdges = root.connectedEdges().intersection(callingEles);\n      var k = connEdges.length;\n      var s = 0; // Now, sum edge weights\n\n      for (var i = 0; i < connEdges.length; i++) {\n        s += weight(connEdges[i]);\n      }\n\n      return {\n        degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)\n      };\n    } else {\n      var edges = root.connectedEdges();\n      var incoming = edges.filter(function (edge) {\n        return edge.target().same(root) && callingEles.has(edge);\n      });\n      var outgoing = edges.filter(function (edge) {\n        return edge.source().same(root) && callingEles.has(edge);\n      });\n      var k_in = incoming.length;\n      var k_out = outgoing.length;\n      var s_in = 0;\n      var s_out = 0; // Now, sum incoming edge weights\n\n      for (var _i2 = 0; _i2 < incoming.length; _i2++) {\n        s_in += weight(incoming[_i2]);\n      } // Now, sum outgoing edge weights\n\n\n      for (var _i3 = 0; _i3 < outgoing.length; _i3++) {\n        s_out += weight(outgoing[_i3]);\n      }\n\n      return {\n        indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),\n        outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)\n      };\n    }\n  } // degreeCentrality\n\n}; // elesfn\n// nice, short mathematical alias\n\nelesfn$n.dc = elesfn$n.degreeCentrality;\nelesfn$n.dcn = elesfn$n.degreeCentralityNormalised = elesfn$n.degreeCentralityNormalized;\n\nvar defaults$e = defaults$g({\n  harmonic: true,\n  weight: function weight() {\n    return 1;\n  },\n  directed: false,\n  root: null\n});\nvar elesfn$m = {\n  closenessCentralityNormalized: function closenessCentralityNormalized(options) {\n    var _defaults = defaults$e(options),\n        harmonic = _defaults.harmonic,\n        weight = _defaults.weight,\n        directed = _defaults.directed;\n\n    var cy = this.cy();\n    var closenesses = {};\n    var maxCloseness = 0;\n    var nodes = this.nodes();\n    var fw = this.floydWarshall({\n      weight: weight,\n      directed: directed\n    }); // Compute closeness for every node and find the maximum closeness\n\n    for (var i = 0; i < nodes.length; i++) {\n      var currCloseness = 0;\n      var node_i = nodes[i];\n\n      for (var j = 0; j < nodes.length; j++) {\n        if (i !== j) {\n          var d = fw.distance(node_i, nodes[j]);\n\n          if (harmonic) {\n            currCloseness += 1 / d;\n          } else {\n            currCloseness += d;\n          }\n        }\n      }\n\n      if (!harmonic) {\n        currCloseness = 1 / currCloseness;\n      }\n\n      if (maxCloseness < currCloseness) {\n        maxCloseness = currCloseness;\n      }\n\n      closenesses[node_i.id()] = currCloseness;\n    }\n\n    return {\n      closeness: function closeness(node) {\n        if (maxCloseness == 0) {\n          return 0;\n        }\n\n        if (string(node)) {\n          // from is a selector string\n          node = cy.filter(node)[0].id();\n        } else {\n          // from is a node\n          node = node.id();\n        }\n\n        return closenesses[node] / maxCloseness;\n      }\n    };\n  },\n  // Implemented from pseudocode from wikipedia\n  closenessCentrality: function closenessCentrality(options) {\n    var _defaults2 = defaults$e(options),\n        root = _defaults2.root,\n        weight = _defaults2.weight,\n        directed = _defaults2.directed,\n        harmonic = _defaults2.harmonic;\n\n    root = this.filter(root)[0]; // we need distance from this node to every other node\n\n    var dijkstra = this.dijkstra({\n      root: root,\n      weight: weight,\n      directed: directed\n    });\n    var totalDistance = 0;\n    var nodes = this.nodes();\n\n    for (var i = 0; i < nodes.length; i++) {\n      var n = nodes[i];\n\n      if (!n.same(root)) {\n        var d = dijkstra.distanceTo(n);\n\n        if (harmonic) {\n          totalDistance += 1 / d;\n        } else {\n          totalDistance += d;\n        }\n      }\n    }\n\n    return harmonic ? totalDistance : 1 / totalDistance;\n  } // closenessCentrality\n\n}; // elesfn\n// nice, short mathematical alias\n\nelesfn$m.cc = elesfn$m.closenessCentrality;\nelesfn$m.ccn = elesfn$m.closenessCentralityNormalised = elesfn$m.closenessCentralityNormalized;\n\nvar defaults$d = defaults$g({\n  weight: null,\n  directed: false\n});\nvar elesfn$l = {\n  // Implemented from the algorithm in the paper \"On Variants of Shortest-Path Betweenness Centrality and their Generic Computation\" by Ulrik Brandes\n  betweennessCentrality: function betweennessCentrality(options) {\n    var _defaults = defaults$d(options),\n        directed = _defaults.directed,\n        weight = _defaults.weight;\n\n    var weighted = weight != null;\n    var cy = this.cy(); // starting\n\n    var V = this.nodes();\n    var A = {};\n    var _C = {};\n    var max = 0;\n    var C = {\n      set: function set(key, val) {\n        _C[key] = val;\n\n        if (val > max) {\n          max = val;\n        }\n      },\n      get: function get(key) {\n        return _C[key];\n      }\n    }; // A contains the neighborhoods of every node\n\n    for (var i = 0; i < V.length; i++) {\n      var v = V[i];\n      var vid = v.id();\n\n      if (directed) {\n        A[vid] = v.outgoers().nodes(); // get outgoers of every node\n      } else {\n        A[vid] = v.openNeighborhood().nodes(); // get neighbors of every node\n      }\n\n      C.set(vid, 0);\n    }\n\n    var _loop = function _loop(s) {\n      var sid = V[s].id();\n      var S = []; // stack\n\n      var P = {};\n      var g = {};\n      var d = {};\n      var Q = new Heap__default[\"default\"](function (a, b) {\n        return d[a] - d[b];\n      }); // queue\n      // init dictionaries\n\n      for (var _i = 0; _i < V.length; _i++) {\n        var _vid = V[_i].id();\n\n        P[_vid] = [];\n        g[_vid] = 0;\n        d[_vid] = Infinity;\n      }\n\n      g[sid] = 1; // sigma\n\n      d[sid] = 0; // distance to s\n\n      Q.push(sid);\n\n      while (!Q.empty()) {\n        var _v = Q.pop();\n\n        S.push(_v);\n\n        if (weighted) {\n          for (var j = 0; j < A[_v].length; j++) {\n            var w = A[_v][j];\n            var vEle = cy.getElementById(_v);\n            var edge = void 0;\n\n            if (vEle.edgesTo(w).length > 0) {\n              edge = vEle.edgesTo(w)[0];\n            } else {\n              edge = w.edgesTo(vEle)[0];\n            }\n\n            var edgeWeight = weight(edge);\n            w = w.id();\n\n            if (d[w] > d[_v] + edgeWeight) {\n              d[w] = d[_v] + edgeWeight;\n\n              if (Q.nodes.indexOf(w) < 0) {\n                //if w is not in Q\n                Q.push(w);\n              } else {\n                // update position if w is in Q\n                Q.updateItem(w);\n              }\n\n              g[w] = 0;\n              P[w] = [];\n            }\n\n            if (d[w] == d[_v] + edgeWeight) {\n              g[w] = g[w] + g[_v];\n              P[w].push(_v);\n            }\n          }\n        } else {\n          for (var _j = 0; _j < A[_v].length; _j++) {\n            var _w = A[_v][_j].id();\n\n            if (d[_w] == Infinity) {\n              Q.push(_w);\n              d[_w] = d[_v] + 1;\n            }\n\n            if (d[_w] == d[_v] + 1) {\n              g[_w] = g[_w] + g[_v];\n\n              P[_w].push(_v);\n            }\n          }\n        }\n      }\n\n      var e = {};\n\n      for (var _i2 = 0; _i2 < V.length; _i2++) {\n        e[V[_i2].id()] = 0;\n      }\n\n      while (S.length > 0) {\n        var _w2 = S.pop();\n\n        for (var _j2 = 0; _j2 < P[_w2].length; _j2++) {\n          var _v2 = P[_w2][_j2];\n          e[_v2] = e[_v2] + g[_v2] / g[_w2] * (1 + e[_w2]);\n        }\n\n        if (_w2 != V[s].id()) {\n          C.set(_w2, C.get(_w2) + e[_w2]);\n        }\n      }\n    };\n\n    for (var s = 0; s < V.length; s++) {\n      _loop(s);\n    }\n\n    var ret = {\n      betweenness: function betweenness(node) {\n        var id = cy.collection(node).id();\n        return C.get(id);\n      },\n      betweennessNormalized: function betweennessNormalized(node) {\n        if (max == 0) {\n          return 0;\n        }\n\n        var id = cy.collection(node).id();\n        return C.get(id) / max;\n      }\n    }; // alias\n\n    ret.betweennessNormalised = ret.betweennessNormalized;\n    return ret;\n  } // betweennessCentrality\n\n}; // elesfn\n// nice, short mathematical alias\n\nelesfn$l.bc = elesfn$l.betweennessCentrality;\n\n// Implemented by Zoe Xi @zoexi for GSOC 2016\n/* eslint-disable no-unused-vars */\n\nvar defaults$c = defaults$g({\n  expandFactor: 2,\n  // affects time of computation and cluster granularity to some extent: M * M\n  inflateFactor: 2,\n  // affects cluster granularity (the greater the value, the more clusters): M(i,j) / E(j)\n  multFactor: 1,\n  // optional self loops for each node. Use a neutral value to improve cluster computations.\n  maxIterations: 20,\n  // maximum number of iterations of the MCL algorithm in a single run\n  attributes: [// attributes/features used to group nodes, ie. similarity values between nodes\n  function (edge) {\n    return 1;\n  }]\n});\n/* eslint-enable */\n\nvar setOptions$3 = function setOptions(options) {\n  return defaults$c(options);\n};\n/* eslint-enable */\n\n\nvar getSimilarity$1 = function getSimilarity(edge, attributes) {\n  var total = 0;\n\n  for (var i = 0; i < attributes.length; i++) {\n    total += attributes[i](edge);\n  }\n\n  return total;\n};\n\nvar addLoops = function addLoops(M, n, val) {\n  for (var i = 0; i < n; i++) {\n    M[i * n + i] = val;\n  }\n};\n\nvar normalize = function normalize(M, n) {\n  var sum;\n\n  for (var col = 0; col < n; col++) {\n    sum = 0;\n\n    for (var row = 0; row < n; row++) {\n      sum += M[row * n + col];\n    }\n\n    for (var _row = 0; _row < n; _row++) {\n      M[_row * n + col] = M[_row * n + col] / sum;\n    }\n  }\n}; // TODO: blocked matrix multiplication?\n\n\nvar mmult = function mmult(A, B, n) {\n  var C = new Array(n * n);\n\n  for (var i = 0; i < n; i++) {\n    for (var j = 0; j < n; j++) {\n      C[i * n + j] = 0;\n    }\n\n    for (var k = 0; k < n; k++) {\n      for (var _j = 0; _j < n; _j++) {\n        C[i * n + _j] += A[i * n + k] * B[k * n + _j];\n      }\n    }\n  }\n\n  return C;\n};\n\nvar expand = function expand(M, n, expandFactor\n/** power **/\n) {\n  var _M = M.slice(0);\n\n  for (var p = 1; p < expandFactor; p++) {\n    M = mmult(M, _M, n);\n  }\n\n  return M;\n};\n\nvar inflate = function inflate(M, n, inflateFactor\n/** r **/\n) {\n  var _M = new Array(n * n); // M(i,j) ^ inflatePower\n\n\n  for (var i = 0; i < n * n; i++) {\n    _M[i] = Math.pow(M[i], inflateFactor);\n  }\n\n  normalize(_M, n);\n  return _M;\n};\n\nvar hasConverged = function hasConverged(M, _M, n2, roundFactor) {\n  // Check that both matrices have the same elements (i,j)\n  for (var i = 0; i < n2; i++) {\n    var v1 = Math.round(M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor); // truncate to 'roundFactor' decimal places\n\n    var v2 = Math.round(_M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor);\n\n    if (v1 !== v2) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nvar assign$2 = function assign(M, n, nodes, cy) {\n  var clusters = [];\n\n  for (var i = 0; i < n; i++) {\n    var cluster = [];\n\n    for (var j = 0; j < n; j++) {\n      // Row-wise attractors and elements that they attract belong in same cluster\n      if (Math.round(M[i * n + j] * 1000) / 1000 > 0) {\n        cluster.push(nodes[j]);\n      }\n    }\n\n    if (cluster.length !== 0) {\n      clusters.push(cy.collection(cluster));\n    }\n  }\n\n  return clusters;\n};\n\nvar isDuplicate = function isDuplicate(c1, c2) {\n  for (var i = 0; i < c1.length; i++) {\n    if (!c2[i] || c1[i].id() !== c2[i].id()) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nvar removeDuplicates = function removeDuplicates(clusters) {\n  for (var i = 0; i < clusters.length; i++) {\n    for (var j = 0; j < clusters.length; j++) {\n      if (i != j && isDuplicate(clusters[i], clusters[j])) {\n        clusters.splice(j, 1);\n      }\n    }\n  }\n\n  return clusters;\n};\n\nvar markovClustering = function markovClustering(options) {\n  var nodes = this.nodes();\n  var edges = this.edges();\n  var cy = this.cy(); // Set parameters of algorithm:\n\n  var opts = setOptions$3(options); // Map each node to its position in node array\n\n  var id2position = {};\n\n  for (var i = 0; i < nodes.length; i++) {\n    id2position[nodes[i].id()] = i;\n  } // Generate stochastic matrix M from input graph G (should be symmetric/undirected)\n\n\n  var n = nodes.length,\n      n2 = n * n;\n\n  var M = new Array(n2),\n      _M;\n\n  for (var _i = 0; _i < n2; _i++) {\n    M[_i] = 0;\n  }\n\n  for (var e = 0; e < edges.length; e++) {\n    var edge = edges[e];\n    var _i2 = id2position[edge.source().id()];\n    var j = id2position[edge.target().id()];\n    var sim = getSimilarity$1(edge, opts.attributes);\n    M[_i2 * n + j] += sim; // G should be symmetric and undirected\n\n    M[j * n + _i2] += sim;\n  } // Begin Markov cluster algorithm\n  // Step 1: Add self loops to each node, ie. add multFactor to matrix diagonal\n\n\n  addLoops(M, n, opts.multFactor); // Step 2: M = normalize( M );\n\n  normalize(M, n);\n  var isStillMoving = true;\n  var iterations = 0;\n\n  while (isStillMoving && iterations < opts.maxIterations) {\n    isStillMoving = false; // Step 3:\n\n    _M = expand(M, n, opts.expandFactor); // Step 4:\n\n    M = inflate(_M, n, opts.inflateFactor); // Step 5: check to see if ~steady state has been reached\n\n    if (!hasConverged(M, _M, n2, 4)) {\n      isStillMoving = true;\n    }\n\n    iterations++;\n  } // Build clusters from matrix\n\n\n  var clusters = assign$2(M, n, nodes, cy); // Remove duplicate clusters due to symmetry of graph and M matrix\n\n  clusters = removeDuplicates(clusters);\n  return clusters;\n};\n\nvar markovClustering$1 = {\n  markovClustering: markovClustering,\n  mcl: markovClustering\n};\n\n// Common distance metrics for clustering algorithms\n\nvar identity = function identity(x) {\n  return x;\n};\n\nvar absDiff = function absDiff(p, q) {\n  return Math.abs(q - p);\n};\n\nvar addAbsDiff = function addAbsDiff(total, p, q) {\n  return total + absDiff(p, q);\n};\n\nvar addSquaredDiff = function addSquaredDiff(total, p, q) {\n  return total + Math.pow(q - p, 2);\n};\n\nvar sqrt = function sqrt(x) {\n  return Math.sqrt(x);\n};\n\nvar maxAbsDiff = function maxAbsDiff(currentMax, p, q) {\n  return Math.max(currentMax, absDiff(p, q));\n};\n\nvar getDistance = function getDistance(length, getP, getQ, init, visit) {\n  var post = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : identity;\n  var ret = init;\n  var p, q;\n\n  for (var dim = 0; dim < length; dim++) {\n    p = getP(dim);\n    q = getQ(dim);\n    ret = visit(ret, p, q);\n  }\n\n  return post(ret);\n};\n\nvar distances = {\n  euclidean: function euclidean(length, getP, getQ) {\n    if (length >= 2) {\n      return getDistance(length, getP, getQ, 0, addSquaredDiff, sqrt);\n    } else {\n      // for single attr case, more efficient to avoid sqrt\n      return getDistance(length, getP, getQ, 0, addAbsDiff);\n    }\n  },\n  squaredEuclidean: function squaredEuclidean(length, getP, getQ) {\n    return getDistance(length, getP, getQ, 0, addSquaredDiff);\n  },\n  manhattan: function manhattan(length, getP, getQ) {\n    return getDistance(length, getP, getQ, 0, addAbsDiff);\n  },\n  max: function max(length, getP, getQ) {\n    return getDistance(length, getP, getQ, -Infinity, maxAbsDiff);\n  }\n}; // in case the user accidentally doesn't use camel case\n\ndistances['squared-euclidean'] = distances['squaredEuclidean'];\ndistances['squaredeuclidean'] = distances['squaredEuclidean'];\nfunction clusteringDistance (method, length, getP, getQ, nodeP, nodeQ) {\n  var impl;\n\n  if (fn$6(method)) {\n    impl = method;\n  } else {\n    impl = distances[method] || distances.euclidean;\n  }\n\n  if (length === 0 && fn$6(method)) {\n    return impl(nodeP, nodeQ);\n  } else {\n    return impl(length, getP, getQ, nodeP, nodeQ);\n  }\n}\n\nvar defaults$b = defaults$g({\n  k: 2,\n  m: 2,\n  sensitivityThreshold: 0.0001,\n  distance: 'euclidean',\n  maxIterations: 10,\n  attributes: [],\n  testMode: false,\n  testCentroids: null\n});\n\nvar setOptions$2 = function setOptions(options) {\n  return defaults$b(options);\n};\n/* eslint-enable */\n\n\nvar getDist = function getDist(type, node, centroid, attributes, mode) {\n  var noNodeP = mode !== 'kMedoids';\n  var getP = noNodeP ? function (i) {\n    return centroid[i];\n  } : function (i) {\n    return attributes[i](centroid);\n  };\n\n  var getQ = function getQ(i) {\n    return attributes[i](node);\n  };\n\n  var nodeP = centroid;\n  var nodeQ = node;\n  return clusteringDistance(type, attributes.length, getP, getQ, nodeP, nodeQ);\n};\n\nvar randomCentroids = function randomCentroids(nodes, k, attributes) {\n  var ndim = attributes.length;\n  var min = new Array(ndim);\n  var max = new Array(ndim);\n  var centroids = new Array(k);\n  var centroid = null; // Find min, max values for each attribute dimension\n\n  for (var i = 0; i < ndim; i++) {\n    min[i] = nodes.min(attributes[i]).value;\n    max[i] = nodes.max(attributes[i]).value;\n  } // Build k centroids, each represented as an n-dim feature vector\n\n\n  for (var c = 0; c < k; c++) {\n    centroid = [];\n\n    for (var _i = 0; _i < ndim; _i++) {\n      centroid[_i] = Math.random() * (max[_i] - min[_i]) + min[_i]; // random initial value\n    }\n\n    centroids[c] = centroid;\n  }\n\n  return centroids;\n};\n\nvar classify = function classify(node, centroids, distance, attributes, type) {\n  var min = Infinity;\n  var index = 0;\n\n  for (var i = 0; i < centroids.length; i++) {\n    var dist = getDist(distance, node, centroids[i], attributes, type);\n\n    if (dist < min) {\n      min = dist;\n      index = i;\n    }\n  }\n\n  return index;\n};\n\nvar buildCluster = function buildCluster(centroid, nodes, assignment) {\n  var cluster = [];\n  var node = null;\n\n  for (var n = 0; n < nodes.length; n++) {\n    node = nodes[n];\n\n    if (assignment[node.id()] === centroid) {\n      //console.log(\"Node \" + node.id() + \" is associated with medoid #: \" + m);\n      cluster.push(node);\n    }\n  }\n\n  return cluster;\n};\n\nvar haveValuesConverged = function haveValuesConverged(v1, v2, sensitivityThreshold) {\n  return Math.abs(v2 - v1) <= sensitivityThreshold;\n};\n\nvar haveMatricesConverged = function haveMatricesConverged(v1, v2, sensitivityThreshold) {\n  for (var i = 0; i < v1.length; i++) {\n    for (var j = 0; j < v1[i].length; j++) {\n      var diff = Math.abs(v1[i][j] - v2[i][j]);\n\n      if (diff > sensitivityThreshold) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n};\n\nvar seenBefore = function seenBefore(node, medoids, n) {\n  for (var i = 0; i < n; i++) {\n    if (node === medoids[i]) return true;\n  }\n\n  return false;\n};\n\nvar randomMedoids = function randomMedoids(nodes, k) {\n  var medoids = new Array(k); // For small data sets, the probability of medoid conflict is greater,\n  // so we need to check to see if we've already seen or chose this node before.\n\n  if (nodes.length < 50) {\n    // Randomly select k medoids from the n nodes\n    for (var i = 0; i < k; i++) {\n      var node = nodes[Math.floor(Math.random() * nodes.length)]; // If we've already chosen this node to be a medoid, don't choose it again (for small data sets).\n      // Instead choose a different random node.\n\n      while (seenBefore(node, medoids, i)) {\n        node = nodes[Math.floor(Math.random() * nodes.length)];\n      }\n\n      medoids[i] = node;\n    }\n  } else {\n    // Relatively large data set, so pretty safe to not check and just select random nodes\n    for (var _i2 = 0; _i2 < k; _i2++) {\n      medoids[_i2] = nodes[Math.floor(Math.random() * nodes.length)];\n    }\n  }\n\n  return medoids;\n};\n\nvar findCost = function findCost(potentialNewMedoid, cluster, attributes) {\n  var cost = 0;\n\n  for (var n = 0; n < cluster.length; n++) {\n    cost += getDist('manhattan', cluster[n], potentialNewMedoid, attributes, 'kMedoids');\n  }\n\n  return cost;\n};\n\nvar kMeans = function kMeans(options) {\n  var cy = this.cy();\n  var nodes = this.nodes();\n  var node = null; // Set parameters of algorithm: # of clusters, distance metric, etc.\n\n  var opts = setOptions$2(options); // Begin k-means algorithm\n\n  var clusters = new Array(opts.k);\n  var assignment = {};\n  var centroids; // Step 1: Initialize centroid positions\n\n  if (opts.testMode) {\n    if (typeof opts.testCentroids === 'number') {\n      // TODO: implement a seeded random number generator.\n      opts.testCentroids;\n      centroids = randomCentroids(nodes, opts.k, opts.attributes);\n    } else if (_typeof(opts.testCentroids) === 'object') {\n      centroids = opts.testCentroids;\n    } else {\n      centroids = randomCentroids(nodes, opts.k, opts.attributes);\n    }\n  } else {\n    centroids = randomCentroids(nodes, opts.k, opts.attributes);\n  }\n\n  var isStillMoving = true;\n  var iterations = 0;\n\n  while (isStillMoving && iterations < opts.maxIterations) {\n    // Step 2: Assign nodes to the nearest centroid\n    for (var n = 0; n < nodes.length; n++) {\n      node = nodes[n]; // Determine which cluster this node belongs to: node id => cluster #\n\n      assignment[node.id()] = classify(node, centroids, opts.distance, opts.attributes, 'kMeans');\n    } // Step 3: For each of the k clusters, update its centroid\n\n\n    isStillMoving = false;\n\n    for (var c = 0; c < opts.k; c++) {\n      // Get all nodes that belong to this cluster\n      var cluster = buildCluster(c, nodes, assignment);\n\n      if (cluster.length === 0) {\n        // If cluster is empty, break out early & move to next cluster\n        continue;\n      } // Update centroids by calculating avg of all nodes within the cluster.\n\n\n      var ndim = opts.attributes.length;\n      var centroid = centroids[c]; // [ dim_1, dim_2, dim_3, ... , dim_n ]\n\n      var newCentroid = new Array(ndim);\n      var sum = new Array(ndim);\n\n      for (var d = 0; d < ndim; d++) {\n        sum[d] = 0.0;\n\n        for (var i = 0; i < cluster.length; i++) {\n          node = cluster[i];\n          sum[d] += opts.attributes[d](node);\n        }\n\n        newCentroid[d] = sum[d] / cluster.length; // Check to see if algorithm has converged, i.e. when centroids no longer change\n\n        if (!haveValuesConverged(newCentroid[d], centroid[d], opts.sensitivityThreshold)) {\n          isStillMoving = true;\n        }\n      }\n\n      centroids[c] = newCentroid;\n      clusters[c] = cy.collection(cluster);\n    }\n\n    iterations++;\n  }\n\n  return clusters;\n};\n\nvar kMedoids = function kMedoids(options) {\n  var cy = this.cy();\n  var nodes = this.nodes();\n  var node = null;\n  var opts = setOptions$2(options); // Begin k-medoids algorithm\n\n  var clusters = new Array(opts.k);\n  var medoids;\n  var assignment = {};\n  var curCost;\n  var minCosts = new Array(opts.k); // minimum cost configuration for each cluster\n  // Step 1: Initialize k medoids\n\n  if (opts.testMode) {\n    if (typeof opts.testCentroids === 'number') ; else if (_typeof(opts.testCentroids) === 'object') {\n      medoids = opts.testCentroids;\n    } else {\n      medoids = randomMedoids(nodes, opts.k);\n    }\n  } else {\n    medoids = randomMedoids(nodes, opts.k);\n  }\n\n  var isStillMoving = true;\n  var iterations = 0;\n\n  while (isStillMoving && iterations < opts.maxIterations) {\n    // Step 2: Assign nodes to the nearest medoid\n    for (var n = 0; n < nodes.length; n++) {\n      node = nodes[n]; // Determine which cluster this node belongs to: node id => cluster #\n\n      assignment[node.id()] = classify(node, medoids, opts.distance, opts.attributes, 'kMedoids');\n    }\n\n    isStillMoving = false; // Step 3: For each medoid m, and for each node associated with mediod m,\n    // select the node with the lowest configuration cost as new medoid.\n\n    for (var m = 0; m < medoids.length; m++) {\n      // Get all nodes that belong to this medoid\n      var cluster = buildCluster(m, nodes, assignment);\n\n      if (cluster.length === 0) {\n        // If cluster is empty, break out early & move to next cluster\n        continue;\n      }\n\n      minCosts[m] = findCost(medoids[m], cluster, opts.attributes); // original cost\n      // Select different medoid if its configuration has the lowest cost\n\n      for (var _n = 0; _n < cluster.length; _n++) {\n        curCost = findCost(cluster[_n], cluster, opts.attributes);\n\n        if (curCost < minCosts[m]) {\n          minCosts[m] = curCost;\n          medoids[m] = cluster[_n];\n          isStillMoving = true;\n        }\n      }\n\n      clusters[m] = cy.collection(cluster);\n    }\n\n    iterations++;\n  }\n\n  return clusters;\n};\n\nvar updateCentroids = function updateCentroids(centroids, nodes, U, weight, opts) {\n  var numerator, denominator;\n\n  for (var n = 0; n < nodes.length; n++) {\n    for (var c = 0; c < centroids.length; c++) {\n      weight[n][c] = Math.pow(U[n][c], opts.m);\n    }\n  }\n\n  for (var _c = 0; _c < centroids.length; _c++) {\n    for (var dim = 0; dim < opts.attributes.length; dim++) {\n      numerator = 0;\n      denominator = 0;\n\n      for (var _n2 = 0; _n2 < nodes.length; _n2++) {\n        numerator += weight[_n2][_c] * opts.attributes[dim](nodes[_n2]);\n        denominator += weight[_n2][_c];\n      }\n\n      centroids[_c][dim] = numerator / denominator;\n    }\n  }\n};\n\nvar updateMembership = function updateMembership(U, _U, centroids, nodes, opts) {\n  // Save previous step\n  for (var i = 0; i < U.length; i++) {\n    _U[i] = U[i].slice();\n  }\n\n  var sum, numerator, denominator;\n  var pow = 2 / (opts.m - 1);\n\n  for (var c = 0; c < centroids.length; c++) {\n    for (var n = 0; n < nodes.length; n++) {\n      sum = 0;\n\n      for (var k = 0; k < centroids.length; k++) {\n        // against all other centroids\n        numerator = getDist(opts.distance, nodes[n], centroids[c], opts.attributes, 'cmeans');\n        denominator = getDist(opts.distance, nodes[n], centroids[k], opts.attributes, 'cmeans');\n        sum += Math.pow(numerator / denominator, pow);\n      }\n\n      U[n][c] = 1 / sum;\n    }\n  }\n};\n\nvar assign$1 = function assign(nodes, U, opts, cy) {\n  var clusters = new Array(opts.k);\n\n  for (var c = 0; c < clusters.length; c++) {\n    clusters[c] = [];\n  }\n\n  var max;\n  var index;\n\n  for (var n = 0; n < U.length; n++) {\n    // for each node (U is N x C matrix)\n    max = -Infinity;\n    index = -1; // Determine which cluster the node is most likely to belong in\n\n    for (var _c2 = 0; _c2 < U[0].length; _c2++) {\n      if (U[n][_c2] > max) {\n        max = U[n][_c2];\n        index = _c2;\n      }\n    }\n\n    clusters[index].push(nodes[n]);\n  } // Turn every array into a collection of nodes\n\n\n  for (var _c3 = 0; _c3 < clusters.length; _c3++) {\n    clusters[_c3] = cy.collection(clusters[_c3]);\n  }\n\n  return clusters;\n};\n\nvar fuzzyCMeans = function fuzzyCMeans(options) {\n  var cy = this.cy();\n  var nodes = this.nodes();\n  var opts = setOptions$2(options); // Begin fuzzy c-means algorithm\n\n  var clusters;\n  var centroids;\n  var U;\n\n  var _U;\n\n  var weight; // Step 1: Initialize letiables.\n\n  _U = new Array(nodes.length);\n\n  for (var i = 0; i < nodes.length; i++) {\n    // N x C matrix\n    _U[i] = new Array(opts.k);\n  }\n\n  U = new Array(nodes.length);\n\n  for (var _i3 = 0; _i3 < nodes.length; _i3++) {\n    // N x C matrix\n    U[_i3] = new Array(opts.k);\n  }\n\n  for (var _i4 = 0; _i4 < nodes.length; _i4++) {\n    var total = 0;\n\n    for (var j = 0; j < opts.k; j++) {\n      U[_i4][j] = Math.random();\n      total += U[_i4][j];\n    }\n\n    for (var _j = 0; _j < opts.k; _j++) {\n      U[_i4][_j] = U[_i4][_j] / total;\n    }\n  }\n\n  centroids = new Array(opts.k);\n\n  for (var _i5 = 0; _i5 < opts.k; _i5++) {\n    centroids[_i5] = new Array(opts.attributes.length);\n  }\n\n  weight = new Array(nodes.length);\n\n  for (var _i6 = 0; _i6 < nodes.length; _i6++) {\n    // N x C matrix\n    weight[_i6] = new Array(opts.k);\n  } // end init FCM\n\n\n  var isStillMoving = true;\n  var iterations = 0;\n\n  while (isStillMoving && iterations < opts.maxIterations) {\n    isStillMoving = false; // Step 2: Calculate the centroids for each step.\n\n    updateCentroids(centroids, nodes, U, weight, opts); // Step 3: Update the partition matrix U.\n\n    updateMembership(U, _U, centroids, nodes, opts); // Step 4: Check for convergence.\n\n    if (!haveMatricesConverged(U, _U, opts.sensitivityThreshold)) {\n      isStillMoving = true;\n    }\n\n    iterations++;\n  } // Assign nodes to clusters with highest probability.\n\n\n  clusters = assign$1(nodes, U, opts, cy);\n  return {\n    clusters: clusters,\n    degreeOfMembership: U\n  };\n};\n\nvar kClustering = {\n  kMeans: kMeans,\n  kMedoids: kMedoids,\n  fuzzyCMeans: fuzzyCMeans,\n  fcm: fuzzyCMeans\n};\n\n// Implemented by Zoe Xi @zoexi for GSOC 2016\nvar defaults$a = defaults$g({\n  distance: 'euclidean',\n  // distance metric to compare nodes\n  linkage: 'min',\n  // linkage criterion : how to determine the distance between clusters of nodes\n  mode: 'threshold',\n  // mode:'threshold' => clusters must be threshold distance apart\n  threshold: Infinity,\n  // the distance threshold\n  // mode:'dendrogram' => the nodes are organised as leaves in a tree (siblings are close), merging makes clusters\n  addDendrogram: false,\n  // whether to add the dendrogram to the graph for viz\n  dendrogramDepth: 0,\n  // depth at which dendrogram branches are merged into the returned clusters\n  attributes: [] // array of attr functions\n\n});\nvar linkageAliases = {\n  'single': 'min',\n  'complete': 'max'\n};\n\nvar setOptions$1 = function setOptions(options) {\n  var opts = defaults$a(options);\n  var preferredAlias = linkageAliases[opts.linkage];\n\n  if (preferredAlias != null) {\n    opts.linkage = preferredAlias;\n  }\n\n  return opts;\n};\n\nvar mergeClosest = function mergeClosest(clusters, index, dists, mins, opts) {\n  // Find two closest clusters from cached mins\n  var minKey = 0;\n  var min = Infinity;\n  var dist;\n  var attrs = opts.attributes;\n\n  var getDist = function getDist(n1, n2) {\n    return clusteringDistance(opts.distance, attrs.length, function (i) {\n      return attrs[i](n1);\n    }, function (i) {\n      return attrs[i](n2);\n    }, n1, n2);\n  };\n\n  for (var i = 0; i < clusters.length; i++) {\n    var key = clusters[i].key;\n    var _dist = dists[key][mins[key]];\n\n    if (_dist < min) {\n      minKey = key;\n      min = _dist;\n    }\n  }\n\n  if (opts.mode === 'threshold' && min >= opts.threshold || opts.mode === 'dendrogram' && clusters.length === 1) {\n    return false;\n  }\n\n  var c1 = index[minKey];\n  var c2 = index[mins[minKey]];\n  var merged; // Merge two closest clusters\n\n  if (opts.mode === 'dendrogram') {\n    merged = {\n      left: c1,\n      right: c2,\n      key: c1.key\n    };\n  } else {\n    merged = {\n      value: c1.value.concat(c2.value),\n      key: c1.key\n    };\n  }\n\n  clusters[c1.index] = merged;\n  clusters.splice(c2.index, 1);\n  index[c1.key] = merged; // Update distances with new merged cluster\n\n  for (var _i = 0; _i < clusters.length; _i++) {\n    var cur = clusters[_i];\n\n    if (c1.key === cur.key) {\n      dist = Infinity;\n    } else if (opts.linkage === 'min') {\n      dist = dists[c1.key][cur.key];\n\n      if (dists[c1.key][cur.key] > dists[c2.key][cur.key]) {\n        dist = dists[c2.key][cur.key];\n      }\n    } else if (opts.linkage === 'max') {\n      dist = dists[c1.key][cur.key];\n\n      if (dists[c1.key][cur.key] < dists[c2.key][cur.key]) {\n        dist = dists[c2.key][cur.key];\n      }\n    } else if (opts.linkage === 'mean') {\n      dist = (dists[c1.key][cur.key] * c1.size + dists[c2.key][cur.key] * c2.size) / (c1.size + c2.size);\n    } else {\n      if (opts.mode === 'dendrogram') dist = getDist(cur.value, c1.value);else dist = getDist(cur.value[0], c1.value[0]);\n    }\n\n    dists[c1.key][cur.key] = dists[cur.key][c1.key] = dist; // distance matrix is symmetric\n  } // Update cached mins\n\n\n  for (var _i2 = 0; _i2 < clusters.length; _i2++) {\n    var key1 = clusters[_i2].key;\n\n    if (mins[key1] === c1.key || mins[key1] === c2.key) {\n      var _min = key1;\n\n      for (var j = 0; j < clusters.length; j++) {\n        var key2 = clusters[j].key;\n\n        if (dists[key1][key2] < dists[key1][_min]) {\n          _min = key2;\n        }\n      }\n\n      mins[key1] = _min;\n    }\n\n    clusters[_i2].index = _i2;\n  } // Clean up meta data used for clustering\n\n\n  c1.key = c2.key = c1.index = c2.index = null;\n  return true;\n};\n\nvar getAllChildren = function getAllChildren(root, arr, cy) {\n  if (!root) return;\n\n  if (root.value) {\n    arr.push(root.value);\n  } else {\n    if (root.left) getAllChildren(root.left, arr);\n    if (root.right) getAllChildren(root.right, arr);\n  }\n};\n\nvar buildDendrogram = function buildDendrogram(root, cy) {\n  if (!root) return '';\n\n  if (root.left && root.right) {\n    var leftStr = buildDendrogram(root.left, cy);\n    var rightStr = buildDendrogram(root.right, cy);\n    var node = cy.add({\n      group: 'nodes',\n      data: {\n        id: leftStr + ',' + rightStr\n      }\n    });\n    cy.add({\n      group: 'edges',\n      data: {\n        source: leftStr,\n        target: node.id()\n      }\n    });\n    cy.add({\n      group: 'edges',\n      data: {\n        source: rightStr,\n        target: node.id()\n      }\n    });\n    return node.id();\n  } else if (root.value) {\n    return root.value.id();\n  }\n};\n\nvar buildClustersFromTree = function buildClustersFromTree(root, k, cy) {\n  if (!root) return [];\n  var left = [],\n      right = [],\n      leaves = [];\n\n  if (k === 0) {\n    // don't cut tree, simply return all nodes as 1 single cluster\n    if (root.left) getAllChildren(root.left, left);\n    if (root.right) getAllChildren(root.right, right);\n    leaves = left.concat(right);\n    return [cy.collection(leaves)];\n  } else if (k === 1) {\n    // cut at root\n    if (root.value) {\n      // leaf node\n      return [cy.collection(root.value)];\n    } else {\n      if (root.left) getAllChildren(root.left, left);\n      if (root.right) getAllChildren(root.right, right);\n      return [cy.collection(left), cy.collection(right)];\n    }\n  } else {\n    if (root.value) {\n      return [cy.collection(root.value)];\n    } else {\n      if (root.left) left = buildClustersFromTree(root.left, k - 1, cy);\n      if (root.right) right = buildClustersFromTree(root.right, k - 1, cy);\n      return left.concat(right);\n    }\n  }\n};\n/* eslint-enable */\n\n\nvar hierarchicalClustering = function hierarchicalClustering(options) {\n  var cy = this.cy();\n  var nodes = this.nodes(); // Set parameters of algorithm: linkage type, distance metric, etc.\n\n  var opts = setOptions$1(options);\n  var attrs = opts.attributes;\n\n  var getDist = function getDist(n1, n2) {\n    return clusteringDistance(opts.distance, attrs.length, function (i) {\n      return attrs[i](n1);\n    }, function (i) {\n      return attrs[i](n2);\n    }, n1, n2);\n  }; // Begin hierarchical algorithm\n\n\n  var clusters = [];\n  var dists = []; // distances between each pair of clusters\n\n  var mins = []; // closest cluster for each cluster\n\n  var index = []; // hash of all clusters by key\n  // In agglomerative (bottom-up) clustering, each node starts as its own cluster\n\n  for (var n = 0; n < nodes.length; n++) {\n    var cluster = {\n      value: opts.mode === 'dendrogram' ? nodes[n] : [nodes[n]],\n      key: n,\n      index: n\n    };\n    clusters[n] = cluster;\n    index[n] = cluster;\n    dists[n] = [];\n    mins[n] = 0;\n  } // Calculate the distance between each pair of clusters\n\n\n  for (var i = 0; i < clusters.length; i++) {\n    for (var j = 0; j <= i; j++) {\n      var dist = void 0;\n\n      if (opts.mode === 'dendrogram') {\n        // modes store cluster values differently\n        dist = i === j ? Infinity : getDist(clusters[i].value, clusters[j].value);\n      } else {\n        dist = i === j ? Infinity : getDist(clusters[i].value[0], clusters[j].value[0]);\n      }\n\n      dists[i][j] = dist;\n      dists[j][i] = dist;\n\n      if (dist < dists[i][mins[i]]) {\n        mins[i] = j; // Cache mins: closest cluster to cluster i is cluster j\n      }\n    }\n  } // Find the closest pair of clusters and merge them into a single cluster.\n  // Update distances between new cluster and each of the old clusters, and loop until threshold reached.\n\n\n  var merged = mergeClosest(clusters, index, dists, mins, opts);\n\n  while (merged) {\n    merged = mergeClosest(clusters, index, dists, mins, opts);\n  }\n\n  var retClusters; // Dendrogram mode builds the hierarchy and adds intermediary nodes + edges\n  // in addition to returning the clusters.\n\n  if (opts.mode === 'dendrogram') {\n    retClusters = buildClustersFromTree(clusters[0], opts.dendrogramDepth, cy);\n    if (opts.addDendrogram) buildDendrogram(clusters[0], cy);\n  } else {\n    // Regular mode simply returns the clusters\n    retClusters = new Array(clusters.length);\n    clusters.forEach(function (cluster, i) {\n      // Clean up meta data used for clustering\n      cluster.key = cluster.index = null;\n      retClusters[i] = cy.collection(cluster.value);\n    });\n  }\n\n  return retClusters;\n};\n\nvar hierarchicalClustering$1 = {\n  hierarchicalClustering: hierarchicalClustering,\n  hca: hierarchicalClustering\n};\n\n// Implemented by Zoe Xi @zoexi for GSOC 2016\nvar defaults$9 = defaults$g({\n  distance: 'euclidean',\n  // distance metric to compare attributes between two nodes\n  preference: 'median',\n  // suitability of a data point to serve as an exemplar\n  damping: 0.8,\n  // damping factor between [0.5, 1)\n  maxIterations: 1000,\n  // max number of iterations to run\n  minIterations: 100,\n  // min number of iterations to run in order for clustering to stop\n  attributes: [// functions to quantify the similarity between any two points\n    // e.g. node => node.data('weight')\n  ]\n});\n\nvar setOptions = function setOptions(options) {\n  var dmp = options.damping;\n  var pref = options.preference;\n\n  if (!(0.5 <= dmp && dmp < 1)) {\n    error(\"Damping must range on [0.5, 1).  Got: \".concat(dmp));\n  }\n\n  var validPrefs = ['median', 'mean', 'min', 'max'];\n\n  if (!(validPrefs.some(function (v) {\n    return v === pref;\n  }) || number$1(pref))) {\n    error(\"Preference must be one of [\".concat(validPrefs.map(function (p) {\n      return \"'\".concat(p, \"'\");\n    }).join(', '), \"] or a number.  Got: \").concat(pref));\n  }\n\n  return defaults$9(options);\n};\n/* eslint-enable */\n\n\nvar getSimilarity = function getSimilarity(type, n1, n2, attributes) {\n  var attr = function attr(n, i) {\n    return attributes[i](n);\n  }; // nb negative because similarity should have an inverse relationship to distance\n\n\n  return -clusteringDistance(type, attributes.length, function (i) {\n    return attr(n1, i);\n  }, function (i) {\n    return attr(n2, i);\n  }, n1, n2);\n};\n\nvar getPreference = function getPreference(S, preference) {\n  // larger preference = greater # of clusters\n  var p = null;\n\n  if (preference === 'median') {\n    p = median(S);\n  } else if (preference === 'mean') {\n    p = mean(S);\n  } else if (preference === 'min') {\n    p = min(S);\n  } else if (preference === 'max') {\n    p = max(S);\n  } else {\n    // Custom preference number, as set by user\n    p = preference;\n  }\n\n  return p;\n};\n\nvar findExemplars = function findExemplars(n, R, A) {\n  var indices = [];\n\n  for (var i = 0; i < n; i++) {\n    if (R[i * n + i] + A[i * n + i] > 0) {\n      indices.push(i);\n    }\n  }\n\n  return indices;\n};\n\nvar assignClusters = function assignClusters(n, S, exemplars) {\n  var clusters = [];\n\n  for (var i = 0; i < n; i++) {\n    var index = -1;\n    var max = -Infinity;\n\n    for (var ei = 0; ei < exemplars.length; ei++) {\n      var e = exemplars[ei];\n\n      if (S[i * n + e] > max) {\n        index = e;\n        max = S[i * n + e];\n      }\n    }\n\n    if (index > 0) {\n      clusters.push(index);\n    }\n  }\n\n  for (var _ei = 0; _ei < exemplars.length; _ei++) {\n    clusters[exemplars[_ei]] = exemplars[_ei];\n  }\n\n  return clusters;\n};\n\nvar assign = function assign(n, S, exemplars) {\n  var clusters = assignClusters(n, S, exemplars);\n\n  for (var ei = 0; ei < exemplars.length; ei++) {\n    var ii = [];\n\n    for (var c = 0; c < clusters.length; c++) {\n      if (clusters[c] === exemplars[ei]) {\n        ii.push(c);\n      }\n    }\n\n    var maxI = -1;\n    var maxSum = -Infinity;\n\n    for (var i = 0; i < ii.length; i++) {\n      var sum = 0;\n\n      for (var j = 0; j < ii.length; j++) {\n        sum += S[ii[j] * n + ii[i]];\n      }\n\n      if (sum > maxSum) {\n        maxI = i;\n        maxSum = sum;\n      }\n    }\n\n    exemplars[ei] = ii[maxI];\n  }\n\n  clusters = assignClusters(n, S, exemplars);\n  return clusters;\n};\n\nvar affinityPropagation = function affinityPropagation(options) {\n  var cy = this.cy();\n  var nodes = this.nodes();\n  var opts = setOptions(options); // Map each node to its position in node array\n\n  var id2position = {};\n\n  for (var i = 0; i < nodes.length; i++) {\n    id2position[nodes[i].id()] = i;\n  } // Begin affinity propagation algorithm\n\n\n  var n; // number of data points\n\n  var n2; // size of matrices\n\n  var S; // similarity matrix (1D array)\n\n  var p; // preference/suitability of a data point to serve as an exemplar\n\n  var R; // responsibility matrix (1D array)\n\n  var A; // availability matrix (1D array)\n\n  n = nodes.length;\n  n2 = n * n; // Initialize and build S similarity matrix\n\n  S = new Array(n2);\n\n  for (var _i = 0; _i < n2; _i++) {\n    S[_i] = -Infinity; // for cases where two data points shouldn't be linked together\n  }\n\n  for (var _i2 = 0; _i2 < n; _i2++) {\n    for (var j = 0; j < n; j++) {\n      if (_i2 !== j) {\n        S[_i2 * n + j] = getSimilarity(opts.distance, nodes[_i2], nodes[j], opts.attributes);\n      }\n    }\n  } // Place preferences on the diagonal of S\n\n\n  p = getPreference(S, opts.preference);\n\n  for (var _i3 = 0; _i3 < n; _i3++) {\n    S[_i3 * n + _i3] = p;\n  } // Initialize R responsibility matrix\n\n\n  R = new Array(n2);\n\n  for (var _i4 = 0; _i4 < n2; _i4++) {\n    R[_i4] = 0.0;\n  } // Initialize A availability matrix\n\n\n  A = new Array(n2);\n\n  for (var _i5 = 0; _i5 < n2; _i5++) {\n    A[_i5] = 0.0;\n  }\n\n  var old = new Array(n);\n  var Rp = new Array(n);\n  var se = new Array(n);\n\n  for (var _i6 = 0; _i6 < n; _i6++) {\n    old[_i6] = 0.0;\n    Rp[_i6] = 0.0;\n    se[_i6] = 0;\n  }\n\n  var e = new Array(n * opts.minIterations);\n\n  for (var _i7 = 0; _i7 < e.length; _i7++) {\n    e[_i7] = 0;\n  }\n\n  var iter;\n\n  for (iter = 0; iter < opts.maxIterations; iter++) {\n    // main algorithmic loop\n    // Update R responsibility matrix\n    for (var _i8 = 0; _i8 < n; _i8++) {\n      var max = -Infinity,\n          max2 = -Infinity,\n          maxI = -1,\n          AS = 0.0;\n\n      for (var _j = 0; _j < n; _j++) {\n        old[_j] = R[_i8 * n + _j];\n        AS = A[_i8 * n + _j] + S[_i8 * n + _j];\n\n        if (AS >= max) {\n          max2 = max;\n          max = AS;\n          maxI = _j;\n        } else if (AS > max2) {\n          max2 = AS;\n        }\n      }\n\n      for (var _j2 = 0; _j2 < n; _j2++) {\n        R[_i8 * n + _j2] = (1 - opts.damping) * (S[_i8 * n + _j2] - max) + opts.damping * old[_j2];\n      }\n\n      R[_i8 * n + maxI] = (1 - opts.damping) * (S[_i8 * n + maxI] - max2) + opts.damping * old[maxI];\n    } // Update A availability matrix\n\n\n    for (var _i9 = 0; _i9 < n; _i9++) {\n      var sum = 0;\n\n      for (var _j3 = 0; _j3 < n; _j3++) {\n        old[_j3] = A[_j3 * n + _i9];\n        Rp[_j3] = Math.max(0, R[_j3 * n + _i9]);\n        sum += Rp[_j3];\n      }\n\n      sum -= Rp[_i9];\n      Rp[_i9] = R[_i9 * n + _i9];\n      sum += Rp[_i9];\n\n      for (var _j4 = 0; _j4 < n; _j4++) {\n        A[_j4 * n + _i9] = (1 - opts.damping) * Math.min(0, sum - Rp[_j4]) + opts.damping * old[_j4];\n      }\n\n      A[_i9 * n + _i9] = (1 - opts.damping) * (sum - Rp[_i9]) + opts.damping * old[_i9];\n    } // Check for convergence\n\n\n    var K = 0;\n\n    for (var _i10 = 0; _i10 < n; _i10++) {\n      var E = A[_i10 * n + _i10] + R[_i10 * n + _i10] > 0 ? 1 : 0;\n      e[iter % opts.minIterations * n + _i10] = E;\n      K += E;\n    }\n\n    if (K > 0 && (iter >= opts.minIterations - 1 || iter == opts.maxIterations - 1)) {\n      var _sum = 0;\n\n      for (var _i11 = 0; _i11 < n; _i11++) {\n        se[_i11] = 0;\n\n        for (var _j5 = 0; _j5 < opts.minIterations; _j5++) {\n          se[_i11] += e[_j5 * n + _i11];\n        }\n\n        if (se[_i11] === 0 || se[_i11] === opts.minIterations) {\n          _sum++;\n        }\n      }\n\n      if (_sum === n) {\n        // then we have convergence\n        break;\n      }\n    }\n  } // Identify exemplars (cluster centers)\n\n\n  var exemplarsIndices = findExemplars(n, R, A); // Assign nodes to clusters\n\n  var clusterIndices = assign(n, S, exemplarsIndices);\n  var clusters = {};\n\n  for (var c = 0; c < exemplarsIndices.length; c++) {\n    clusters[exemplarsIndices[c]] = [];\n  }\n\n  for (var _i12 = 0; _i12 < nodes.length; _i12++) {\n    var pos = id2position[nodes[_i12].id()];\n\n    var clusterIndex = clusterIndices[pos];\n\n    if (clusterIndex != null) {\n      // the node may have not been assigned a cluster if no valid attributes were specified\n      clusters[clusterIndex].push(nodes[_i12]);\n    }\n  }\n\n  var retClusters = new Array(exemplarsIndices.length);\n\n  for (var _c = 0; _c < exemplarsIndices.length; _c++) {\n    retClusters[_c] = cy.collection(clusters[exemplarsIndices[_c]]);\n  }\n\n  return retClusters;\n};\n\nvar affinityPropagation$1 = {\n  affinityPropagation: affinityPropagation,\n  ap: affinityPropagation\n};\n\nvar hierholzerDefaults = defaults$g({\n  root: undefined,\n  directed: false\n});\nvar elesfn$k = {\n  hierholzer: function hierholzer(options) {\n    if (!plainObject(options)) {\n      var args = arguments;\n      options = {\n        root: args[0],\n        directed: args[1]\n      };\n    }\n\n    var _hierholzerDefaults = hierholzerDefaults(options),\n        root = _hierholzerDefaults.root,\n        directed = _hierholzerDefaults.directed;\n\n    var eles = this;\n    var dflag = false;\n    var oddIn;\n    var oddOut;\n    var startVertex;\n    if (root) startVertex = string(root) ? this.filter(root)[0].id() : root[0].id();\n    var nodes = {};\n    var edges = {};\n\n    if (directed) {\n      eles.forEach(function (ele) {\n        var id = ele.id();\n\n        if (ele.isNode()) {\n          var ind = ele.indegree(true);\n          var outd = ele.outdegree(true);\n          var d1 = ind - outd;\n          var d2 = outd - ind;\n\n          if (d1 == 1) {\n            if (oddIn) dflag = true;else oddIn = id;\n          } else if (d2 == 1) {\n            if (oddOut) dflag = true;else oddOut = id;\n          } else if (d2 > 1 || d1 > 1) {\n            dflag = true;\n          }\n\n          nodes[id] = [];\n          ele.outgoers().forEach(function (e) {\n            if (e.isEdge()) nodes[id].push(e.id());\n          });\n        } else {\n          edges[id] = [undefined, ele.target().id()];\n        }\n      });\n    } else {\n      eles.forEach(function (ele) {\n        var id = ele.id();\n\n        if (ele.isNode()) {\n          var d = ele.degree(true);\n\n          if (d % 2) {\n            if (!oddIn) oddIn = id;else if (!oddOut) oddOut = id;else dflag = true;\n          }\n\n          nodes[id] = [];\n          ele.connectedEdges().forEach(function (e) {\n            return nodes[id].push(e.id());\n          });\n        } else {\n          edges[id] = [ele.source().id(), ele.target().id()];\n        }\n      });\n    }\n\n    var result = {\n      found: false,\n      trail: undefined\n    };\n    if (dflag) return result;else if (oddOut && oddIn) {\n      if (directed) {\n        if (startVertex && oddOut != startVertex) {\n          return result;\n        }\n\n        startVertex = oddOut;\n      } else {\n        if (startVertex && oddOut != startVertex && oddIn != startVertex) {\n          return result;\n        } else if (!startVertex) {\n          startVertex = oddOut;\n        }\n      }\n    } else {\n      if (!startVertex) startVertex = eles[0].id();\n    }\n\n    var walk = function walk(v) {\n      var currentNode = v;\n      var subtour = [v];\n      var adj, adjTail, adjHead;\n\n      while (nodes[currentNode].length) {\n        adj = nodes[currentNode].shift();\n        adjTail = edges[adj][0];\n        adjHead = edges[adj][1];\n\n        if (currentNode != adjHead) {\n          nodes[adjHead] = nodes[adjHead].filter(function (e) {\n            return e != adj;\n          });\n          currentNode = adjHead;\n        } else if (!directed && currentNode != adjTail) {\n          nodes[adjTail] = nodes[adjTail].filter(function (e) {\n            return e != adj;\n          });\n          currentNode = adjTail;\n        }\n\n        subtour.unshift(adj);\n        subtour.unshift(currentNode);\n      }\n\n      return subtour;\n    };\n\n    var trail = [];\n    var subtour = [];\n    subtour = walk(startVertex);\n\n    while (subtour.length != 1) {\n      if (nodes[subtour[0]].length == 0) {\n        trail.unshift(eles.getElementById(subtour.shift()));\n        trail.unshift(eles.getElementById(subtour.shift()));\n      } else {\n        subtour = walk(subtour.shift()).concat(subtour);\n      }\n    }\n\n    trail.unshift(eles.getElementById(subtour.shift())); // final node\n\n    for (var d in nodes) {\n      if (nodes[d].length) {\n        return result;\n      }\n    }\n\n    result.found = true;\n    result.trail = this.spawn(trail, true);\n    return result;\n  }\n};\n\nvar hopcroftTarjanBiconnected = function hopcroftTarjanBiconnected() {\n  var eles = this;\n  var nodes = {};\n  var id = 0;\n  var edgeCount = 0;\n  var components = [];\n  var stack = [];\n  var visitedEdges = {};\n\n  var buildComponent = function buildComponent(x, y) {\n    var i = stack.length - 1;\n    var cutset = [];\n    var component = eles.spawn();\n\n    while (stack[i].x != x || stack[i].y != y) {\n      cutset.push(stack.pop().edge);\n      i--;\n    }\n\n    cutset.push(stack.pop().edge);\n    cutset.forEach(function (edge) {\n      var connectedNodes = edge.connectedNodes().intersection(eles);\n      component.merge(edge);\n      connectedNodes.forEach(function (node) {\n        var nodeId = node.id();\n        var connectedEdges = node.connectedEdges().intersection(eles);\n        component.merge(node);\n\n        if (!nodes[nodeId].cutVertex) {\n          component.merge(connectedEdges);\n        } else {\n          component.merge(connectedEdges.filter(function (edge) {\n            return edge.isLoop();\n          }));\n        }\n      });\n    });\n    components.push(component);\n  };\n\n  var biconnectedSearch = function biconnectedSearch(root, currentNode, parent) {\n    if (root === parent) edgeCount += 1;\n    nodes[currentNode] = {\n      id: id,\n      low: id++,\n      cutVertex: false\n    };\n    var edges = eles.getElementById(currentNode).connectedEdges().intersection(eles);\n\n    if (edges.size() === 0) {\n      components.push(eles.spawn(eles.getElementById(currentNode)));\n    } else {\n      var sourceId, targetId, otherNodeId, edgeId;\n      edges.forEach(function (edge) {\n        sourceId = edge.source().id();\n        targetId = edge.target().id();\n        otherNodeId = sourceId === currentNode ? targetId : sourceId;\n\n        if (otherNodeId !== parent) {\n          edgeId = edge.id();\n\n          if (!visitedEdges[edgeId]) {\n            visitedEdges[edgeId] = true;\n            stack.push({\n              x: currentNode,\n              y: otherNodeId,\n              edge: edge\n            });\n          }\n\n          if (!(otherNodeId in nodes)) {\n            biconnectedSearch(root, otherNodeId, currentNode);\n            nodes[currentNode].low = Math.min(nodes[currentNode].low, nodes[otherNodeId].low);\n\n            if (nodes[currentNode].id <= nodes[otherNodeId].low) {\n              nodes[currentNode].cutVertex = true;\n              buildComponent(currentNode, otherNodeId);\n            }\n          } else {\n            nodes[currentNode].low = Math.min(nodes[currentNode].low, nodes[otherNodeId].id);\n          }\n        }\n      });\n    }\n  };\n\n  eles.forEach(function (ele) {\n    if (ele.isNode()) {\n      var nodeId = ele.id();\n\n      if (!(nodeId in nodes)) {\n        edgeCount = 0;\n        biconnectedSearch(nodeId, nodeId);\n        nodes[nodeId].cutVertex = edgeCount > 1;\n      }\n    }\n  });\n  var cutVertices = Object.keys(nodes).filter(function (id) {\n    return nodes[id].cutVertex;\n  }).map(function (id) {\n    return eles.getElementById(id);\n  });\n  return {\n    cut: eles.spawn(cutVertices),\n    components: components\n  };\n};\n\nvar hopcroftTarjanBiconnected$1 = {\n  hopcroftTarjanBiconnected: hopcroftTarjanBiconnected,\n  htbc: hopcroftTarjanBiconnected,\n  htb: hopcroftTarjanBiconnected,\n  hopcroftTarjanBiconnectedComponents: hopcroftTarjanBiconnected\n};\n\nvar tarjanStronglyConnected = function tarjanStronglyConnected() {\n  var eles = this;\n  var nodes = {};\n  var index = 0;\n  var components = [];\n  var stack = [];\n  var cut = eles.spawn(eles);\n\n  var stronglyConnectedSearch = function stronglyConnectedSearch(sourceNodeId) {\n    stack.push(sourceNodeId);\n    nodes[sourceNodeId] = {\n      index: index,\n      low: index++,\n      explored: false\n    };\n    var connectedEdges = eles.getElementById(sourceNodeId).connectedEdges().intersection(eles);\n    connectedEdges.forEach(function (edge) {\n      var targetNodeId = edge.target().id();\n\n      if (targetNodeId !== sourceNodeId) {\n        if (!(targetNodeId in nodes)) {\n          stronglyConnectedSearch(targetNodeId);\n        }\n\n        if (!nodes[targetNodeId].explored) {\n          nodes[sourceNodeId].low = Math.min(nodes[sourceNodeId].low, nodes[targetNodeId].low);\n        }\n      }\n    });\n\n    if (nodes[sourceNodeId].index === nodes[sourceNodeId].low) {\n      var componentNodes = eles.spawn();\n\n      for (;;) {\n        var nodeId = stack.pop();\n        componentNodes.merge(eles.getElementById(nodeId));\n        nodes[nodeId].low = nodes[sourceNodeId].index;\n        nodes[nodeId].explored = true;\n\n        if (nodeId === sourceNodeId) {\n          break;\n        }\n      }\n\n      var componentEdges = componentNodes.edgesWith(componentNodes);\n      var component = componentNodes.merge(componentEdges);\n      components.push(component);\n      cut = cut.difference(component);\n    }\n  };\n\n  eles.forEach(function (ele) {\n    if (ele.isNode()) {\n      var nodeId = ele.id();\n\n      if (!(nodeId in nodes)) {\n        stronglyConnectedSearch(nodeId);\n      }\n    }\n  });\n  return {\n    cut: cut,\n    components: components\n  };\n};\n\nvar tarjanStronglyConnected$1 = {\n  tarjanStronglyConnected: tarjanStronglyConnected,\n  tsc: tarjanStronglyConnected,\n  tscc: tarjanStronglyConnected,\n  tarjanStronglyConnectedComponents: tarjanStronglyConnected\n};\n\nvar elesfn$j = {};\n[elesfn$v, elesfn$u, elesfn$t, elesfn$s, elesfn$r, elesfn$q, elesfn$p, elesfn$o, elesfn$n, elesfn$m, elesfn$l, markovClustering$1, kClustering, hierarchicalClustering$1, affinityPropagation$1, elesfn$k, hopcroftTarjanBiconnected$1, tarjanStronglyConnected$1].forEach(function (props) {\n  extend(elesfn$j, props);\n});\n\n/*!\nEmbeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable\nCopyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)\nLicensed under The MIT License (http://opensource.org/licenses/MIT)\n*/\n\n/*  promise states [Promises/A+ 2.1]  */\nvar STATE_PENDING = 0;\n/*  [Promises/A+ 2.1.1]  */\n\nvar STATE_FULFILLED = 1;\n/*  [Promises/A+ 2.1.2]  */\n\nvar STATE_REJECTED = 2;\n/*  [Promises/A+ 2.1.3]  */\n\n/*  promise object constructor  */\n\nvar api = function api(executor) {\n  /*  optionally support non-constructor/plain-function call  */\n  if (!(this instanceof api)) return new api(executor);\n  /*  initialize object  */\n\n  this.id = 'Thenable/1.0.7';\n  this.state = STATE_PENDING;\n  /*  initial state  */\n\n  this.fulfillValue = undefined;\n  /*  initial value  */\n\n  /*  [Promises/A+ 1.3, 2.1.2.2]  */\n\n  this.rejectReason = undefined;\n  /*  initial reason */\n\n  /*  [Promises/A+ 1.5, 2.1.3.2]  */\n\n  this.onFulfilled = [];\n  /*  initial handlers  */\n\n  this.onRejected = [];\n  /*  initial handlers  */\n\n  /*  provide optional information-hiding proxy  */\n\n  this.proxy = {\n    then: this.then.bind(this)\n  };\n  /*  support optional executor function  */\n\n  if (typeof executor === 'function') executor.call(this, this.fulfill.bind(this), this.reject.bind(this));\n};\n/*  promise API methods  */\n\n\napi.prototype = {\n  /*  promise resolving methods  */\n  fulfill: function fulfill(value) {\n    return deliver(this, STATE_FULFILLED, 'fulfillValue', value);\n  },\n  reject: function reject(value) {\n    return deliver(this, STATE_REJECTED, 'rejectReason', value);\n  },\n\n  /*  \"The then Method\" [Promises/A+ 1.1, 1.2, 2.2]  */\n  then: function then(onFulfilled, onRejected) {\n    var curr = this;\n    var next = new api();\n    /*  [Promises/A+ 2.2.7]  */\n\n    curr.onFulfilled.push(resolver(onFulfilled, next, 'fulfill'));\n    /*  [Promises/A+ 2.2.2/2.2.6]  */\n\n    curr.onRejected.push(resolver(onRejected, next, 'reject'));\n    /*  [Promises/A+ 2.2.3/2.2.6]  */\n\n    execute(curr);\n    return next.proxy;\n    /*  [Promises/A+ 2.2.7, 3.3]  */\n  }\n};\n/*  deliver an action  */\n\nvar deliver = function deliver(curr, state, name, value) {\n  if (curr.state === STATE_PENDING) {\n    curr.state = state;\n    /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */\n\n    curr[name] = value;\n    /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */\n\n    execute(curr);\n  }\n\n  return curr;\n};\n/*  execute all handlers  */\n\n\nvar execute = function execute(curr) {\n  if (curr.state === STATE_FULFILLED) execute_handlers(curr, 'onFulfilled', curr.fulfillValue);else if (curr.state === STATE_REJECTED) execute_handlers(curr, 'onRejected', curr.rejectReason);\n};\n/*  execute particular set of handlers  */\n\n\nvar execute_handlers = function execute_handlers(curr, name, value) {\n  /* global setImmediate: true */\n\n  /* global setTimeout: true */\n\n  /*  short-circuit processing  */\n  if (curr[name].length === 0) return;\n  /*  iterate over all handlers, exactly once  */\n\n  var handlers = curr[name];\n  curr[name] = [];\n  /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */\n\n  var func = function func() {\n    for (var i = 0; i < handlers.length; i++) {\n      handlers[i](value);\n    }\n    /*  [Promises/A+ 2.2.5]  */\n\n  };\n  /*  execute procedure asynchronously  */\n\n  /*  [Promises/A+ 2.2.4, 3.1]  */\n\n\n  if (typeof setImmediate === 'function') setImmediate(func);else setTimeout(func, 0);\n};\n/*  generate a resolver function  */\n\n\nvar resolver = function resolver(cb, next, method) {\n  return function (value) {\n    if (typeof cb !== 'function')\n      /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */\n      next[method].call(next, value);\n      /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */\n    else {\n      var result;\n\n      try {\n        result = cb(value);\n      }\n      /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */\n      catch (e) {\n        next.reject(e);\n        /*  [Promises/A+ 2.2.7.2]  */\n\n        return;\n      }\n\n      resolve(next, result);\n      /*  [Promises/A+ 2.2.7.1]  */\n    }\n  };\n};\n/*  \"Promise Resolution Procedure\"  */\n\n/*  [Promises/A+ 2.3]  */\n\n\nvar resolve = function resolve(promise, x) {\n  /*  sanity check arguments  */\n\n  /*  [Promises/A+ 2.3.1]  */\n  if (promise === x || promise.proxy === x) {\n    promise.reject(new TypeError('cannot resolve promise with itself'));\n    return;\n  }\n  /*  surgically check for a \"then\" method\n    (mainly to just call the \"getter\" of \"then\" only once)  */\n\n\n  var then;\n\n  if (_typeof(x) === 'object' && x !== null || typeof x === 'function') {\n    try {\n      then = x.then;\n    }\n    /*  [Promises/A+ 2.3.3.1, 3.5]  */\n    catch (e) {\n      promise.reject(e);\n      /*  [Promises/A+ 2.3.3.2]  */\n\n      return;\n    }\n  }\n  /*  handle own Thenables    [Promises/A+ 2.3.2]\n    and similar \"thenables\" [Promises/A+ 2.3.3]  */\n\n\n  if (typeof then === 'function') {\n    var resolved = false;\n\n    try {\n      /*  call retrieved \"then\" method */\n\n      /*  [Promises/A+ 2.3.3.3]  */\n      then.call(x,\n      /*  resolvePromise  */\n\n      /*  [Promises/A+ 2.3.3.3.1]  */\n      function (y) {\n        if (resolved) return;\n        resolved = true;\n        /*  [Promises/A+ 2.3.3.3.3]  */\n\n        if (y === x)\n          /*  [Promises/A+ 3.6]  */\n          promise.reject(new TypeError('circular thenable chain'));else resolve(promise, y);\n      },\n      /*  rejectPromise  */\n\n      /*  [Promises/A+ 2.3.3.3.2]  */\n      function (r) {\n        if (resolved) return;\n        resolved = true;\n        /*  [Promises/A+ 2.3.3.3.3]  */\n\n        promise.reject(r);\n      });\n    } catch (e) {\n      if (!resolved)\n        /*  [Promises/A+ 2.3.3.3.3]  */\n        promise.reject(e);\n      /*  [Promises/A+ 2.3.3.3.4]  */\n    }\n\n    return;\n  }\n  /*  handle other values  */\n\n\n  promise.fulfill(x);\n  /*  [Promises/A+ 2.3.4, 2.3.3.4]  */\n}; // so we always have Promise.all()\n\n\napi.all = function (ps) {\n  return new api(function (resolveAll, rejectAll) {\n    var vals = new Array(ps.length);\n    var doneCount = 0;\n\n    var fulfill = function fulfill(i, val) {\n      vals[i] = val;\n      doneCount++;\n\n      if (doneCount === ps.length) {\n        resolveAll(vals);\n      }\n    };\n\n    for (var i = 0; i < ps.length; i++) {\n      (function (i) {\n        var p = ps[i];\n        var isPromise = p != null && p.then != null;\n\n        if (isPromise) {\n          p.then(function (val) {\n            fulfill(i, val);\n          }, function (err) {\n            rejectAll(err);\n          });\n        } else {\n          var val = p;\n          fulfill(i, val);\n        }\n      })(i);\n    }\n  });\n};\n\napi.resolve = function (val) {\n  return new api(function (resolve, reject) {\n    resolve(val);\n  });\n};\n\napi.reject = function (val) {\n  return new api(function (resolve, reject) {\n    reject(val);\n  });\n};\n\nvar Promise$1 = typeof Promise !== 'undefined' ? Promise : api; // eslint-disable-line no-undef\n\nvar Animation = function Animation(target, opts, opts2) {\n  var isCore = core(target);\n  var isEle = !isCore;\n\n  var _p = this._private = extend({\n    duration: 1000\n  }, opts, opts2);\n\n  _p.target = target;\n  _p.style = _p.style || _p.css;\n  _p.started = false;\n  _p.playing = false;\n  _p.hooked = false;\n  _p.applying = false;\n  _p.progress = 0;\n  _p.completes = [];\n  _p.frames = [];\n\n  if (_p.complete && fn$6(_p.complete)) {\n    _p.completes.push(_p.complete);\n  }\n\n  if (isEle) {\n    var pos = target.position();\n    _p.startPosition = _p.startPosition || {\n      x: pos.x,\n      y: pos.y\n    };\n    _p.startStyle = _p.startStyle || target.cy().style().getAnimationStartStyle(target, _p.style);\n  }\n\n  if (isCore) {\n    var pan = target.pan();\n    _p.startPan = {\n      x: pan.x,\n      y: pan.y\n    };\n    _p.startZoom = target.zoom();\n  } // for future timeline/animations impl\n\n\n  this.length = 1;\n  this[0] = this;\n};\n\nvar anifn = Animation.prototype;\nextend(anifn, {\n  instanceString: function instanceString() {\n    return 'animation';\n  },\n  hook: function hook() {\n    var _p = this._private;\n\n    if (!_p.hooked) {\n      // add to target's animation queue\n      var q;\n      var tAni = _p.target._private.animation;\n\n      if (_p.queue) {\n        q = tAni.queue;\n      } else {\n        q = tAni.current;\n      }\n\n      q.push(this); // add to the animation loop pool\n\n      if (elementOrCollection(_p.target)) {\n        _p.target.cy().addToAnimationPool(_p.target);\n      }\n\n      _p.hooked = true;\n    }\n\n    return this;\n  },\n  play: function play() {\n    var _p = this._private; // autorewind\n\n    if (_p.progress === 1) {\n      _p.progress = 0;\n    }\n\n    _p.playing = true;\n    _p.started = false; // needs to be started by animation loop\n\n    _p.stopped = false;\n    this.hook(); // the animation loop will start the animation...\n\n    return this;\n  },\n  playing: function playing() {\n    return this._private.playing;\n  },\n  apply: function apply() {\n    var _p = this._private;\n    _p.applying = true;\n    _p.started = false; // needs to be started by animation loop\n\n    _p.stopped = false;\n    this.hook(); // the animation loop will apply the animation at this progress\n\n    return this;\n  },\n  applying: function applying() {\n    return this._private.applying;\n  },\n  pause: function pause() {\n    var _p = this._private;\n    _p.playing = false;\n    _p.started = false;\n    return this;\n  },\n  stop: function stop() {\n    var _p = this._private;\n    _p.playing = false;\n    _p.started = false;\n    _p.stopped = true; // to be removed from animation queues\n\n    return this;\n  },\n  rewind: function rewind() {\n    return this.progress(0);\n  },\n  fastforward: function fastforward() {\n    return this.progress(1);\n  },\n  time: function time(t) {\n    var _p = this._private;\n\n    if (t === undefined) {\n      return _p.progress * _p.duration;\n    } else {\n      return this.progress(t / _p.duration);\n    }\n  },\n  progress: function progress(p) {\n    var _p = this._private;\n    var wasPlaying = _p.playing;\n\n    if (p === undefined) {\n      return _p.progress;\n    } else {\n      if (wasPlaying) {\n        this.pause();\n      }\n\n      _p.progress = p;\n      _p.started = false;\n\n      if (wasPlaying) {\n        this.play();\n      }\n    }\n\n    return this;\n  },\n  completed: function completed() {\n    return this._private.progress === 1;\n  },\n  reverse: function reverse() {\n    var _p = this._private;\n    var wasPlaying = _p.playing;\n\n    if (wasPlaying) {\n      this.pause();\n    }\n\n    _p.progress = 1 - _p.progress;\n    _p.started = false;\n\n    var swap = function swap(a, b) {\n      var _pa = _p[a];\n\n      if (_pa == null) {\n        return;\n      }\n\n      _p[a] = _p[b];\n      _p[b] = _pa;\n    };\n\n    swap('zoom', 'startZoom');\n    swap('pan', 'startPan');\n    swap('position', 'startPosition'); // swap styles\n\n    if (_p.style) {\n      for (var i = 0; i < _p.style.length; i++) {\n        var prop = _p.style[i];\n        var name = prop.name;\n        var startStyleProp = _p.startStyle[name];\n        _p.startStyle[name] = prop;\n        _p.style[i] = startStyleProp;\n      }\n    }\n\n    if (wasPlaying) {\n      this.play();\n    }\n\n    return this;\n  },\n  promise: function promise(type) {\n    var _p = this._private;\n    var arr;\n\n    switch (type) {\n      case 'frame':\n        arr = _p.frames;\n        break;\n\n      default:\n      case 'complete':\n      case 'completed':\n        arr = _p.completes;\n    }\n\n    return new Promise$1(function (resolve, reject) {\n      arr.push(function () {\n        resolve();\n      });\n    });\n  }\n});\nanifn.complete = anifn.completed;\nanifn.run = anifn.play;\nanifn.running = anifn.playing;\n\nvar define$3 = {\n  animated: function animated() {\n    return function animatedImpl() {\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\n      var cy = this._private.cy || this;\n\n      if (!cy.styleEnabled()) {\n        return false;\n      }\n\n      var ele = all[0];\n\n      if (ele) {\n        return ele._private.animation.current.length > 0;\n      }\n    };\n  },\n  // animated\n  clearQueue: function clearQueue() {\n    return function clearQueueImpl() {\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\n      var cy = this._private.cy || this;\n\n      if (!cy.styleEnabled()) {\n        return this;\n      }\n\n      for (var i = 0; i < all.length; i++) {\n        var ele = all[i];\n        ele._private.animation.queue = [];\n      }\n\n      return this;\n    };\n  },\n  // clearQueue\n  delay: function delay() {\n    return function delayImpl(time, complete) {\n      var cy = this._private.cy || this;\n\n      if (!cy.styleEnabled()) {\n        return this;\n      }\n\n      return this.animate({\n        delay: time,\n        duration: time,\n        complete: complete\n      });\n    };\n  },\n  // delay\n  delayAnimation: function delayAnimation() {\n    return function delayAnimationImpl(time, complete) {\n      var cy = this._private.cy || this;\n\n      if (!cy.styleEnabled()) {\n        return this;\n      }\n\n      return this.animation({\n        delay: time,\n        duration: time,\n        complete: complete\n      });\n    };\n  },\n  // delay\n  animation: function animation() {\n    return function animationImpl(properties, params) {\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\n      var cy = this._private.cy || this;\n      var isCore = !selfIsArrayLike;\n      var isEles = !isCore;\n\n      if (!cy.styleEnabled()) {\n        return this;\n      }\n\n      var style = cy.style();\n      properties = extend({}, properties, params);\n      var propertiesEmpty = Object.keys(properties).length === 0;\n\n      if (propertiesEmpty) {\n        return new Animation(all[0], properties); // nothing to animate\n      }\n\n      if (properties.duration === undefined) {\n        properties.duration = 400;\n      }\n\n      switch (properties.duration) {\n        case 'slow':\n          properties.duration = 600;\n          break;\n\n        case 'fast':\n          properties.duration = 200;\n          break;\n      }\n\n      if (isEles) {\n        properties.style = style.getPropsList(properties.style || properties.css);\n        properties.css = undefined;\n      }\n\n      if (isEles && properties.renderedPosition != null) {\n        var rpos = properties.renderedPosition;\n        var pan = cy.pan();\n        var zoom = cy.zoom();\n        properties.position = renderedToModelPosition(rpos, zoom, pan);\n      } // override pan w/ panBy if set\n\n\n      if (isCore && properties.panBy != null) {\n        var panBy = properties.panBy;\n        var cyPan = cy.pan();\n        properties.pan = {\n          x: cyPan.x + panBy.x,\n          y: cyPan.y + panBy.y\n        };\n      } // override pan w/ center if set\n\n\n      var center = properties.center || properties.centre;\n\n      if (isCore && center != null) {\n        var centerPan = cy.getCenterPan(center.eles, properties.zoom);\n\n        if (centerPan != null) {\n          properties.pan = centerPan;\n        }\n      } // override pan & zoom w/ fit if set\n\n\n      if (isCore && properties.fit != null) {\n        var fit = properties.fit;\n        var fitVp = cy.getFitViewport(fit.eles || fit.boundingBox, fit.padding);\n\n        if (fitVp != null) {\n          properties.pan = fitVp.pan;\n          properties.zoom = fitVp.zoom;\n        }\n      } // override zoom (& potentially pan) w/ zoom obj if set\n\n\n      if (isCore && plainObject(properties.zoom)) {\n        var vp = cy.getZoomedViewport(properties.zoom);\n\n        if (vp != null) {\n          if (vp.zoomed) {\n            properties.zoom = vp.zoom;\n          }\n\n          if (vp.panned) {\n            properties.pan = vp.pan;\n          }\n        } else {\n          properties.zoom = null; // an inavalid zoom (e.g. no delta) gets automatically destroyed\n        }\n      }\n\n      return new Animation(all[0], properties);\n    };\n  },\n  // animate\n  animate: function animate() {\n    return function animateImpl(properties, params) {\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\n      var cy = this._private.cy || this;\n\n      if (!cy.styleEnabled()) {\n        return this;\n      }\n\n      if (params) {\n        properties = extend({}, properties, params);\n      } // manually hook and run the animation\n\n\n      for (var i = 0; i < all.length; i++) {\n        var ele = all[i];\n        var queue = ele.animated() && (properties.queue === undefined || properties.queue);\n        var ani = ele.animation(properties, queue ? {\n          queue: true\n        } : undefined);\n        ani.play();\n      }\n\n      return this; // chaining\n    };\n  },\n  // animate\n  stop: function stop() {\n    return function stopImpl(clearQueue, jumpToEnd) {\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\n      var cy = this._private.cy || this;\n\n      if (!cy.styleEnabled()) {\n        return this;\n      }\n\n      for (var i = 0; i < all.length; i++) {\n        var ele = all[i];\n        var _p = ele._private;\n        var anis = _p.animation.current;\n\n        for (var j = 0; j < anis.length; j++) {\n          var ani = anis[j];\n          var ani_p = ani._private;\n\n          if (jumpToEnd) {\n            // next iteration of the animation loop, the animation\n            // will go straight to the end and be removed\n            ani_p.duration = 0;\n          }\n        } // clear the queue of future animations\n\n\n        if (clearQueue) {\n          _p.animation.queue = [];\n        }\n\n        if (!jumpToEnd) {\n          _p.animation.current = [];\n        }\n      } // we have to notify (the animation loop doesn't do it for us on `stop`)\n\n\n      cy.notify('draw');\n      return this;\n    };\n  } // stop\n\n}; // define\n\nvar define$2 = {\n  // access data field\n  data: function data(params) {\n    var defaults = {\n      field: 'data',\n      bindingEvent: 'data',\n      allowBinding: false,\n      allowSetting: false,\n      allowGetting: false,\n      settingEvent: 'data',\n      settingTriggersEvent: false,\n      triggerFnName: 'trigger',\n      immutableKeys: {},\n      // key => true if immutable\n      updateStyle: false,\n      beforeGet: function beforeGet(self) {},\n      beforeSet: function beforeSet(self, obj) {},\n      onSet: function onSet(self) {},\n      canSet: function canSet(self) {\n        return true;\n      }\n    };\n    params = extend({}, defaults, params);\n    return function dataImpl(name, value) {\n      var p = params;\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\n      var single = selfIsArrayLike ? self[0] : self; // .data('foo', ...)\n\n      if (string(name)) {\n        // set or get property\n        var isPathLike = name.indexOf('.') !== -1; // there might be a normal field with a dot \n\n        var path = isPathLike && toPath__default[\"default\"](name); // .data('foo')\n\n        if (p.allowGetting && value === undefined) {\n          // get\n          var ret;\n\n          if (single) {\n            p.beforeGet(single); // check if it's path and a field with the same name doesn't exist\n\n            if (path && single._private[p.field][name] === undefined) {\n              ret = get__default[\"default\"](single._private[p.field], path);\n            } else {\n              ret = single._private[p.field][name];\n            }\n          }\n\n          return ret; // .data('foo', 'bar')\n        } else if (p.allowSetting && value !== undefined) {\n          // set\n          var valid = !p.immutableKeys[name];\n\n          if (valid) {\n            var change = _defineProperty({}, name, value);\n\n            p.beforeSet(self, change);\n\n            for (var i = 0, l = all.length; i < l; i++) {\n              var ele = all[i];\n\n              if (p.canSet(ele)) {\n                if (path && single._private[p.field][name] === undefined) {\n                  set__default[\"default\"](ele._private[p.field], path, value);\n                } else {\n                  ele._private[p.field][name] = value;\n                }\n              }\n            } // update mappers if asked\n\n\n            if (p.updateStyle) {\n              self.updateStyle();\n            } // call onSet callback\n\n\n            p.onSet(self);\n\n            if (p.settingTriggersEvent) {\n              self[p.triggerFnName](p.settingEvent);\n            }\n          }\n        } // .data({ 'foo': 'bar' })\n\n      } else if (p.allowSetting && plainObject(name)) {\n        // extend\n        var obj = name;\n        var k, v;\n        var keys = Object.keys(obj);\n        p.beforeSet(self, obj);\n\n        for (var _i = 0; _i < keys.length; _i++) {\n          k = keys[_i];\n          v = obj[k];\n\n          var _valid = !p.immutableKeys[k];\n\n          if (_valid) {\n            for (var j = 0; j < all.length; j++) {\n              var _ele = all[j];\n\n              if (p.canSet(_ele)) {\n                _ele._private[p.field][k] = v;\n              }\n            }\n          }\n        } // update mappers if asked\n\n\n        if (p.updateStyle) {\n          self.updateStyle();\n        } // call onSet callback\n\n\n        p.onSet(self);\n\n        if (p.settingTriggersEvent) {\n          self[p.triggerFnName](p.settingEvent);\n        } // .data(function(){ ... })\n\n      } else if (p.allowBinding && fn$6(name)) {\n        // bind to event\n        var fn = name;\n        self.on(p.bindingEvent, fn); // .data()\n      } else if (p.allowGetting && name === undefined) {\n        // get whole object\n        var _ret;\n\n        if (single) {\n          p.beforeGet(single);\n          _ret = single._private[p.field];\n        }\n\n        return _ret;\n      }\n\n      return self; // maintain chainability\n    }; // function\n  },\n  // data\n  // remove data field\n  removeData: function removeData(params) {\n    var defaults = {\n      field: 'data',\n      event: 'data',\n      triggerFnName: 'trigger',\n      triggerEvent: false,\n      immutableKeys: {} // key => true if immutable\n\n    };\n    params = extend({}, defaults, params);\n    return function removeDataImpl(names) {\n      var p = params;\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n      // .removeData('foo bar')\n\n      if (string(names)) {\n        // then get the list of keys, and delete them\n        var keys = names.split(/\\s+/);\n        var l = keys.length;\n\n        for (var i = 0; i < l; i++) {\n          // delete each non-empty key\n          var key = keys[i];\n\n          if (emptyString(key)) {\n            continue;\n          }\n\n          var valid = !p.immutableKeys[key]; // not valid if immutable\n\n          if (valid) {\n            for (var i_a = 0, l_a = all.length; i_a < l_a; i_a++) {\n              all[i_a]._private[p.field][key] = undefined;\n            }\n          }\n        }\n\n        if (p.triggerEvent) {\n          self[p.triggerFnName](p.event);\n        } // .removeData()\n\n      } else if (names === undefined) {\n        // then delete all keys\n        for (var _i_a = 0, _l_a = all.length; _i_a < _l_a; _i_a++) {\n          var _privateFields = all[_i_a]._private[p.field];\n\n          var _keys = Object.keys(_privateFields);\n\n          for (var _i2 = 0; _i2 < _keys.length; _i2++) {\n            var _key = _keys[_i2];\n            var validKeyToDelete = !p.immutableKeys[_key];\n\n            if (validKeyToDelete) {\n              _privateFields[_key] = undefined;\n            }\n          }\n        }\n\n        if (p.triggerEvent) {\n          self[p.triggerFnName](p.event);\n        }\n      }\n\n      return self; // maintain chaining\n    }; // function\n  } // removeData\n\n}; // define\n\nvar define$1 = {\n  eventAliasesOn: function eventAliasesOn(proto) {\n    var p = proto;\n    p.addListener = p.listen = p.bind = p.on;\n    p.unlisten = p.unbind = p.off = p.removeListener;\n    p.trigger = p.emit; // this is just a wrapper alias of .on()\n\n    p.pon = p.promiseOn = function (events, selector) {\n      var self = this;\n      var args = Array.prototype.slice.call(arguments, 0);\n      return new Promise$1(function (resolve, reject) {\n        var callback = function callback(e) {\n          self.off.apply(self, offArgs);\n          resolve(e);\n        };\n\n        var onArgs = args.concat([callback]);\n        var offArgs = onArgs.concat([]);\n        self.on.apply(self, onArgs);\n      });\n    };\n  }\n}; // define\n\n// use this module to cherry pick functions into your prototype\nvar define = {};\n[define$3, define$2, define$1].forEach(function (m) {\n  extend(define, m);\n});\n\nvar elesfn$i = {\n  animate: define.animate(),\n  animation: define.animation(),\n  animated: define.animated(),\n  clearQueue: define.clearQueue(),\n  delay: define.delay(),\n  delayAnimation: define.delayAnimation(),\n  stop: define.stop()\n};\n\nvar elesfn$h = {\n  classes: function classes(_classes) {\n    var self = this;\n\n    if (_classes === undefined) {\n      var ret = [];\n\n      self[0]._private.classes.forEach(function (cls) {\n        return ret.push(cls);\n      });\n\n      return ret;\n    } else if (!array(_classes)) {\n      // extract classes from string\n      _classes = (_classes || '').match(/\\S+/g) || [];\n    }\n\n    var changed = [];\n    var classesSet = new Set$1(_classes); // check and update each ele\n\n    for (var j = 0; j < self.length; j++) {\n      var ele = self[j];\n      var _p = ele._private;\n      var eleClasses = _p.classes;\n      var changedEle = false; // check if ele has all of the passed classes\n\n      for (var i = 0; i < _classes.length; i++) {\n        var cls = _classes[i];\n        var eleHasClass = eleClasses.has(cls);\n\n        if (!eleHasClass) {\n          changedEle = true;\n          break;\n        }\n      } // check if ele has classes outside of those passed\n\n\n      if (!changedEle) {\n        changedEle = eleClasses.size !== _classes.length;\n      }\n\n      if (changedEle) {\n        _p.classes = classesSet;\n        changed.push(ele);\n      }\n    } // trigger update style on those eles that had class changes\n\n\n    if (changed.length > 0) {\n      this.spawn(changed).updateStyle().emit('class');\n    }\n\n    return self;\n  },\n  addClass: function addClass(classes) {\n    return this.toggleClass(classes, true);\n  },\n  hasClass: function hasClass(className) {\n    var ele = this[0];\n    return ele != null && ele._private.classes.has(className);\n  },\n  toggleClass: function toggleClass(classes, toggle) {\n    if (!array(classes)) {\n      // extract classes from string\n      classes = classes.match(/\\S+/g) || [];\n    }\n\n    var self = this;\n    var toggleUndefd = toggle === undefined;\n    var changed = []; // eles who had classes changed\n\n    for (var i = 0, il = self.length; i < il; i++) {\n      var ele = self[i];\n      var eleClasses = ele._private.classes;\n      var changedEle = false;\n\n      for (var j = 0; j < classes.length; j++) {\n        var cls = classes[j];\n        var hasClass = eleClasses.has(cls);\n        var changedNow = false;\n\n        if (toggle || toggleUndefd && !hasClass) {\n          eleClasses.add(cls);\n          changedNow = true;\n        } else if (!toggle || toggleUndefd && hasClass) {\n          eleClasses[\"delete\"](cls);\n          changedNow = true;\n        }\n\n        if (!changedEle && changedNow) {\n          changed.push(ele);\n          changedEle = true;\n        }\n      } // for j classes\n\n    } // for i eles\n    // trigger update style on those eles that had class changes\n\n\n    if (changed.length > 0) {\n      this.spawn(changed).updateStyle().emit('class');\n    }\n\n    return self;\n  },\n  removeClass: function removeClass(classes) {\n    return this.toggleClass(classes, false);\n  },\n  flashClass: function flashClass(classes, duration) {\n    var self = this;\n\n    if (duration == null) {\n      duration = 250;\n    } else if (duration === 0) {\n      return self; // nothing to do really\n    }\n\n    self.addClass(classes);\n    setTimeout(function () {\n      self.removeClass(classes);\n    }, duration);\n    return self;\n  }\n};\nelesfn$h.className = elesfn$h.classNames = elesfn$h.classes;\n\nvar tokens = {\n  metaChar: '[\\\\!\\\\\"\\\\#\\\\$\\\\%\\\\&\\\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\.\\\\/\\\\:\\\\;\\\\<\\\\=\\\\>\\\\?\\\\@\\\\[\\\\]\\\\^\\\\`\\\\{\\\\|\\\\}\\\\~]',\n  // chars we need to escape in let names, etc\n  comparatorOp: '=|\\\\!=|>|>=|<|<=|\\\\$=|\\\\^=|\\\\*=',\n  // binary comparison op (used in data selectors)\n  boolOp: '\\\\?|\\\\!|\\\\^',\n  // boolean (unary) operators (used in data selectors)\n  string: '\"(?:\\\\\\\\\"|[^\"])*\"' + '|' + \"'(?:\\\\\\\\'|[^'])*'\",\n  // string literals (used in data selectors) -- doublequotes | singlequotes\n  number: number,\n  // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123\n  meta: 'degree|indegree|outdegree',\n  // allowed metadata fields (i.e. allowed functions to use from Collection)\n  separator: '\\\\s*,\\\\s*',\n  // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass\n  descendant: '\\\\s+',\n  child: '\\\\s+>\\\\s+',\n  subject: '\\\\$',\n  group: 'node|edge|\\\\*',\n  directedEdge: '\\\\s+->\\\\s+',\n  undirectedEdge: '\\\\s+<->\\\\s+'\n};\ntokens.variable = '(?:[\\\\w-.]|(?:\\\\\\\\' + tokens.metaChar + '))+'; // a variable name can have letters, numbers, dashes, and periods\n\ntokens.className = '(?:[\\\\w-]|(?:\\\\\\\\' + tokens.metaChar + '))+'; // a class name has the same rules as a variable except it can't have a '.' in the name\n\ntokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number\n\ntokens.id = tokens.variable; // an element id (follows variable conventions)\n\n(function () {\n  var ops, op, i; // add @ variants to comparatorOp\n\n  ops = tokens.comparatorOp.split('|');\n\n  for (i = 0; i < ops.length; i++) {\n    op = ops[i];\n    tokens.comparatorOp += '|@' + op;\n  } // add ! variants to comparatorOp\n\n\n  ops = tokens.comparatorOp.split('|');\n\n  for (i = 0; i < ops.length; i++) {\n    op = ops[i];\n\n    if (op.indexOf('!') >= 0) {\n      continue;\n    } // skip ops that explicitly contain !\n\n\n    if (op === '=') {\n      continue;\n    } // skip = b/c != is explicitly defined\n\n\n    tokens.comparatorOp += '|\\\\!' + op;\n  }\n})();\n\n/**\n * Make a new query object\n *\n * @prop type {Type} The type enum (int) of the query\n * @prop checks List of checks to make against an ele to test for a match\n */\nvar newQuery = function newQuery() {\n  return {\n    checks: []\n  };\n};\n\n/**\n * A check type enum-like object.  Uses integer values for fast match() lookup.\n * The ordering does not matter as long as the ints are unique.\n */\nvar Type = {\n  /** E.g. node */\n  GROUP: 0,\n\n  /** A collection of elements */\n  COLLECTION: 1,\n\n  /** A filter(ele) function */\n  FILTER: 2,\n\n  /** E.g. [foo > 1] */\n  DATA_COMPARE: 3,\n\n  /** E.g. [foo] */\n  DATA_EXIST: 4,\n\n  /** E.g. [?foo] */\n  DATA_BOOL: 5,\n\n  /** E.g. [[degree > 2]] */\n  META_COMPARE: 6,\n\n  /** E.g. :selected */\n  STATE: 7,\n\n  /** E.g. #foo */\n  ID: 8,\n\n  /** E.g. .foo */\n  CLASS: 9,\n\n  /** E.g. #foo <-> #bar */\n  UNDIRECTED_EDGE: 10,\n\n  /** E.g. #foo -> #bar */\n  DIRECTED_EDGE: 11,\n\n  /** E.g. $#foo -> #bar */\n  NODE_SOURCE: 12,\n\n  /** E.g. #foo -> $#bar */\n  NODE_TARGET: 13,\n\n  /** E.g. $#foo <-> #bar */\n  NODE_NEIGHBOR: 14,\n\n  /** E.g. #foo > #bar */\n  CHILD: 15,\n\n  /** E.g. #foo #bar */\n  DESCENDANT: 16,\n\n  /** E.g. $#foo > #bar */\n  PARENT: 17,\n\n  /** E.g. $#foo #bar */\n  ANCESTOR: 18,\n\n  /** E.g. #foo > $bar > #baz */\n  COMPOUND_SPLIT: 19,\n\n  /** Always matches, useful placeholder for subject in `COMPOUND_SPLIT` */\n  TRUE: 20\n};\n\nvar stateSelectors = [{\n  selector: ':selected',\n  matches: function matches(ele) {\n    return ele.selected();\n  }\n}, {\n  selector: ':unselected',\n  matches: function matches(ele) {\n    return !ele.selected();\n  }\n}, {\n  selector: ':selectable',\n  matches: function matches(ele) {\n    return ele.selectable();\n  }\n}, {\n  selector: ':unselectable',\n  matches: function matches(ele) {\n    return !ele.selectable();\n  }\n}, {\n  selector: ':locked',\n  matches: function matches(ele) {\n    return ele.locked();\n  }\n}, {\n  selector: ':unlocked',\n  matches: function matches(ele) {\n    return !ele.locked();\n  }\n}, {\n  selector: ':visible',\n  matches: function matches(ele) {\n    return ele.visible();\n  }\n}, {\n  selector: ':hidden',\n  matches: function matches(ele) {\n    return !ele.visible();\n  }\n}, {\n  selector: ':transparent',\n  matches: function matches(ele) {\n    return ele.transparent();\n  }\n}, {\n  selector: ':grabbed',\n  matches: function matches(ele) {\n    return ele.grabbed();\n  }\n}, {\n  selector: ':free',\n  matches: function matches(ele) {\n    return !ele.grabbed();\n  }\n}, {\n  selector: ':removed',\n  matches: function matches(ele) {\n    return ele.removed();\n  }\n}, {\n  selector: ':inside',\n  matches: function matches(ele) {\n    return !ele.removed();\n  }\n}, {\n  selector: ':grabbable',\n  matches: function matches(ele) {\n    return ele.grabbable();\n  }\n}, {\n  selector: ':ungrabbable',\n  matches: function matches(ele) {\n    return !ele.grabbable();\n  }\n}, {\n  selector: ':animated',\n  matches: function matches(ele) {\n    return ele.animated();\n  }\n}, {\n  selector: ':unanimated',\n  matches: function matches(ele) {\n    return !ele.animated();\n  }\n}, {\n  selector: ':parent',\n  matches: function matches(ele) {\n    return ele.isParent();\n  }\n}, {\n  selector: ':childless',\n  matches: function matches(ele) {\n    return ele.isChildless();\n  }\n}, {\n  selector: ':child',\n  matches: function matches(ele) {\n    return ele.isChild();\n  }\n}, {\n  selector: ':orphan',\n  matches: function matches(ele) {\n    return ele.isOrphan();\n  }\n}, {\n  selector: ':nonorphan',\n  matches: function matches(ele) {\n    return ele.isChild();\n  }\n}, {\n  selector: ':compound',\n  matches: function matches(ele) {\n    if (ele.isNode()) {\n      return ele.isParent();\n    } else {\n      return ele.source().isParent() || ele.target().isParent();\n    }\n  }\n}, {\n  selector: ':loop',\n  matches: function matches(ele) {\n    return ele.isLoop();\n  }\n}, {\n  selector: ':simple',\n  matches: function matches(ele) {\n    return ele.isSimple();\n  }\n}, {\n  selector: ':active',\n  matches: function matches(ele) {\n    return ele.active();\n  }\n}, {\n  selector: ':inactive',\n  matches: function matches(ele) {\n    return !ele.active();\n  }\n}, {\n  selector: ':backgrounding',\n  matches: function matches(ele) {\n    return ele.backgrounding();\n  }\n}, {\n  selector: ':nonbackgrounding',\n  matches: function matches(ele) {\n    return !ele.backgrounding();\n  }\n}].sort(function (a, b) {\n  // n.b. selectors that are starting substrings of others must have the longer ones first\n  return descending(a.selector, b.selector);\n});\n\nvar lookup = function () {\n  var selToFn = {};\n  var s;\n\n  for (var i = 0; i < stateSelectors.length; i++) {\n    s = stateSelectors[i];\n    selToFn[s.selector] = s.matches;\n  }\n\n  return selToFn;\n}();\n\nvar stateSelectorMatches = function stateSelectorMatches(sel, ele) {\n  return lookup[sel](ele);\n};\nvar stateSelectorRegex = '(' + stateSelectors.map(function (s) {\n  return s.selector;\n}).join('|') + ')';\n\n// so that values get compared properly in Selector.filter()\n\nvar cleanMetaChars = function cleanMetaChars(str) {\n  return str.replace(new RegExp('\\\\\\\\(' + tokens.metaChar + ')', 'g'), function (match, $1) {\n    return $1;\n  });\n};\n\nvar replaceLastQuery = function replaceLastQuery(selector, examiningQuery, replacementQuery) {\n  selector[selector.length - 1] = replacementQuery;\n}; // NOTE: add new expression syntax here to have it recognised by the parser;\n// - a query contains all adjacent (i.e. no separator in between) expressions;\n// - the current query is stored in selector[i]\n// - you need to check the query objects in match() for it actually filter properly, but that's pretty straight forward\n\n\nvar exprs = [{\n  name: 'group',\n  // just used for identifying when debugging\n  query: true,\n  regex: '(' + tokens.group + ')',\n  populate: function populate(selector, query, _ref) {\n    var _ref2 = _slicedToArray(_ref, 1),\n        group = _ref2[0];\n\n    query.checks.push({\n      type: Type.GROUP,\n      value: group === '*' ? group : group + 's'\n    });\n  }\n}, {\n  name: 'state',\n  query: true,\n  regex: stateSelectorRegex,\n  populate: function populate(selector, query, _ref3) {\n    var _ref4 = _slicedToArray(_ref3, 1),\n        state = _ref4[0];\n\n    query.checks.push({\n      type: Type.STATE,\n      value: state\n    });\n  }\n}, {\n  name: 'id',\n  query: true,\n  regex: '\\\\#(' + tokens.id + ')',\n  populate: function populate(selector, query, _ref5) {\n    var _ref6 = _slicedToArray(_ref5, 1),\n        id = _ref6[0];\n\n    query.checks.push({\n      type: Type.ID,\n      value: cleanMetaChars(id)\n    });\n  }\n}, {\n  name: 'className',\n  query: true,\n  regex: '\\\\.(' + tokens.className + ')',\n  populate: function populate(selector, query, _ref7) {\n    var _ref8 = _slicedToArray(_ref7, 1),\n        className = _ref8[0];\n\n    query.checks.push({\n      type: Type.CLASS,\n      value: cleanMetaChars(className)\n    });\n  }\n}, {\n  name: 'dataExists',\n  query: true,\n  regex: '\\\\[\\\\s*(' + tokens.variable + ')\\\\s*\\\\]',\n  populate: function populate(selector, query, _ref9) {\n    var _ref10 = _slicedToArray(_ref9, 1),\n        variable = _ref10[0];\n\n    query.checks.push({\n      type: Type.DATA_EXIST,\n      field: cleanMetaChars(variable)\n    });\n  }\n}, {\n  name: 'dataCompare',\n  query: true,\n  regex: '\\\\[\\\\s*(' + tokens.variable + ')\\\\s*(' + tokens.comparatorOp + ')\\\\s*(' + tokens.value + ')\\\\s*\\\\]',\n  populate: function populate(selector, query, _ref11) {\n    var _ref12 = _slicedToArray(_ref11, 3),\n        variable = _ref12[0],\n        comparatorOp = _ref12[1],\n        value = _ref12[2];\n\n    var valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;\n\n    if (valueIsString) {\n      value = value.substring(1, value.length - 1);\n    } else {\n      value = parseFloat(value);\n    }\n\n    query.checks.push({\n      type: Type.DATA_COMPARE,\n      field: cleanMetaChars(variable),\n      operator: comparatorOp,\n      value: value\n    });\n  }\n}, {\n  name: 'dataBool',\n  query: true,\n  regex: '\\\\[\\\\s*(' + tokens.boolOp + ')\\\\s*(' + tokens.variable + ')\\\\s*\\\\]',\n  populate: function populate(selector, query, _ref13) {\n    var _ref14 = _slicedToArray(_ref13, 2),\n        boolOp = _ref14[0],\n        variable = _ref14[1];\n\n    query.checks.push({\n      type: Type.DATA_BOOL,\n      field: cleanMetaChars(variable),\n      operator: boolOp\n    });\n  }\n}, {\n  name: 'metaCompare',\n  query: true,\n  regex: '\\\\[\\\\[\\\\s*(' + tokens.meta + ')\\\\s*(' + tokens.comparatorOp + ')\\\\s*(' + tokens.number + ')\\\\s*\\\\]\\\\]',\n  populate: function populate(selector, query, _ref15) {\n    var _ref16 = _slicedToArray(_ref15, 3),\n        meta = _ref16[0],\n        comparatorOp = _ref16[1],\n        number = _ref16[2];\n\n    query.checks.push({\n      type: Type.META_COMPARE,\n      field: cleanMetaChars(meta),\n      operator: comparatorOp,\n      value: parseFloat(number)\n    });\n  }\n}, {\n  name: 'nextQuery',\n  separator: true,\n  regex: tokens.separator,\n  populate: function populate(selector, query) {\n    var currentSubject = selector.currentSubject;\n    var edgeCount = selector.edgeCount;\n    var compoundCount = selector.compoundCount;\n    var lastQ = selector[selector.length - 1];\n\n    if (currentSubject != null) {\n      lastQ.subject = currentSubject;\n      selector.currentSubject = null;\n    }\n\n    lastQ.edgeCount = edgeCount;\n    lastQ.compoundCount = compoundCount;\n    selector.edgeCount = 0;\n    selector.compoundCount = 0; // go on to next query\n\n    var nextQuery = selector[selector.length++] = newQuery();\n    return nextQuery; // this is the new query to be filled by the following exprs\n  }\n}, {\n  name: 'directedEdge',\n  separator: true,\n  regex: tokens.directedEdge,\n  populate: function populate(selector, query) {\n    if (selector.currentSubject == null) {\n      // undirected edge\n      var edgeQuery = newQuery();\n      var source = query;\n      var target = newQuery();\n      edgeQuery.checks.push({\n        type: Type.DIRECTED_EDGE,\n        source: source,\n        target: target\n      }); // the query in the selector should be the edge rather than the source\n\n      replaceLastQuery(selector, query, edgeQuery);\n      selector.edgeCount++; // we're now populating the target query with expressions that follow\n\n      return target;\n    } else {\n      // source/target\n      var srcTgtQ = newQuery();\n      var _source = query;\n\n      var _target = newQuery();\n\n      srcTgtQ.checks.push({\n        type: Type.NODE_SOURCE,\n        source: _source,\n        target: _target\n      }); // the query in the selector should be the neighbourhood rather than the node\n\n      replaceLastQuery(selector, query, srcTgtQ);\n      selector.edgeCount++;\n      return _target; // now populating the target with the following expressions\n    }\n  }\n}, {\n  name: 'undirectedEdge',\n  separator: true,\n  regex: tokens.undirectedEdge,\n  populate: function populate(selector, query) {\n    if (selector.currentSubject == null) {\n      // undirected edge\n      var edgeQuery = newQuery();\n      var source = query;\n      var target = newQuery();\n      edgeQuery.checks.push({\n        type: Type.UNDIRECTED_EDGE,\n        nodes: [source, target]\n      }); // the query in the selector should be the edge rather than the source\n\n      replaceLastQuery(selector, query, edgeQuery);\n      selector.edgeCount++; // we're now populating the target query with expressions that follow\n\n      return target;\n    } else {\n      // neighbourhood\n      var nhoodQ = newQuery();\n      var node = query;\n      var neighbor = newQuery();\n      nhoodQ.checks.push({\n        type: Type.NODE_NEIGHBOR,\n        node: node,\n        neighbor: neighbor\n      }); // the query in the selector should be the neighbourhood rather than the node\n\n      replaceLastQuery(selector, query, nhoodQ);\n      return neighbor; // now populating the neighbor with following expressions\n    }\n  }\n}, {\n  name: 'child',\n  separator: true,\n  regex: tokens.child,\n  populate: function populate(selector, query) {\n    if (selector.currentSubject == null) {\n      // default: child query\n      var parentChildQuery = newQuery();\n      var child = newQuery();\n      var parent = selector[selector.length - 1];\n      parentChildQuery.checks.push({\n        type: Type.CHILD,\n        parent: parent,\n        child: child\n      }); // the query in the selector should be the '>' itself\n\n      replaceLastQuery(selector, query, parentChildQuery);\n      selector.compoundCount++; // we're now populating the child query with expressions that follow\n\n      return child;\n    } else if (selector.currentSubject === query) {\n      // compound split query\n      var compound = newQuery();\n      var left = selector[selector.length - 1];\n      var right = newQuery();\n      var subject = newQuery();\n\n      var _child = newQuery();\n\n      var _parent = newQuery(); // set up the root compound q\n\n\n      compound.checks.push({\n        type: Type.COMPOUND_SPLIT,\n        left: left,\n        right: right,\n        subject: subject\n      }); // populate the subject and replace the q at the old spot (within left) with TRUE\n\n      subject.checks = query.checks; // take the checks from the left\n\n      query.checks = [{\n        type: Type.TRUE\n      }]; // checks under left refs the subject implicitly\n      // set up the right q\n\n      _parent.checks.push({\n        type: Type.TRUE\n      }); // parent implicitly refs the subject\n\n\n      right.checks.push({\n        type: Type.PARENT,\n        // type is swapped on right side queries\n        parent: _parent,\n        child: _child // empty for now\n\n      });\n      replaceLastQuery(selector, left, compound); // update the ref since we moved things around for `query`\n\n      selector.currentSubject = subject;\n      selector.compoundCount++;\n      return _child; // now populating the right side's child\n    } else {\n      // parent query\n      // info for parent query\n      var _parent2 = newQuery();\n\n      var _child2 = newQuery();\n\n      var pcQChecks = [{\n        type: Type.PARENT,\n        parent: _parent2,\n        child: _child2\n      }]; // the parent-child query takes the place of the query previously being populated\n\n      _parent2.checks = query.checks; // the previous query contains the checks for the parent\n\n      query.checks = pcQChecks; // pc query takes over\n\n      selector.compoundCount++;\n      return _child2; // we're now populating the child\n    }\n  }\n}, {\n  name: 'descendant',\n  separator: true,\n  regex: tokens.descendant,\n  populate: function populate(selector, query) {\n    if (selector.currentSubject == null) {\n      // default: descendant query\n      var ancChQuery = newQuery();\n      var descendant = newQuery();\n      var ancestor = selector[selector.length - 1];\n      ancChQuery.checks.push({\n        type: Type.DESCENDANT,\n        ancestor: ancestor,\n        descendant: descendant\n      }); // the query in the selector should be the '>' itself\n\n      replaceLastQuery(selector, query, ancChQuery);\n      selector.compoundCount++; // we're now populating the descendant query with expressions that follow\n\n      return descendant;\n    } else if (selector.currentSubject === query) {\n      // compound split query\n      var compound = newQuery();\n      var left = selector[selector.length - 1];\n      var right = newQuery();\n      var subject = newQuery();\n\n      var _descendant = newQuery();\n\n      var _ancestor = newQuery(); // set up the root compound q\n\n\n      compound.checks.push({\n        type: Type.COMPOUND_SPLIT,\n        left: left,\n        right: right,\n        subject: subject\n      }); // populate the subject and replace the q at the old spot (within left) with TRUE\n\n      subject.checks = query.checks; // take the checks from the left\n\n      query.checks = [{\n        type: Type.TRUE\n      }]; // checks under left refs the subject implicitly\n      // set up the right q\n\n      _ancestor.checks.push({\n        type: Type.TRUE\n      }); // ancestor implicitly refs the subject\n\n\n      right.checks.push({\n        type: Type.ANCESTOR,\n        // type is swapped on right side queries\n        ancestor: _ancestor,\n        descendant: _descendant // empty for now\n\n      });\n      replaceLastQuery(selector, left, compound); // update the ref since we moved things around for `query`\n\n      selector.currentSubject = subject;\n      selector.compoundCount++;\n      return _descendant; // now populating the right side's descendant\n    } else {\n      // ancestor query\n      // info for parent query\n      var _ancestor2 = newQuery();\n\n      var _descendant2 = newQuery();\n\n      var adQChecks = [{\n        type: Type.ANCESTOR,\n        ancestor: _ancestor2,\n        descendant: _descendant2\n      }]; // the parent-child query takes the place of the query previously being populated\n\n      _ancestor2.checks = query.checks; // the previous query contains the checks for the parent\n\n      query.checks = adQChecks; // pc query takes over\n\n      selector.compoundCount++;\n      return _descendant2; // we're now populating the child\n    }\n  }\n}, {\n  name: 'subject',\n  modifier: true,\n  regex: tokens.subject,\n  populate: function populate(selector, query) {\n    if (selector.currentSubject != null && selector.currentSubject !== query) {\n      warn('Redefinition of subject in selector `' + selector.toString() + '`');\n      return false;\n    }\n\n    selector.currentSubject = query;\n    var topQ = selector[selector.length - 1];\n    var topChk = topQ.checks[0];\n    var topType = topChk == null ? null : topChk.type;\n\n    if (topType === Type.DIRECTED_EDGE) {\n      // directed edge with subject on the target\n      // change to target node check\n      topChk.type = Type.NODE_TARGET;\n    } else if (topType === Type.UNDIRECTED_EDGE) {\n      // undirected edge with subject on the second node\n      // change to neighbor check\n      topChk.type = Type.NODE_NEIGHBOR;\n      topChk.node = topChk.nodes[1]; // second node is subject\n\n      topChk.neighbor = topChk.nodes[0]; // clean up unused fields for new type\n\n      topChk.nodes = null;\n    }\n  }\n}];\nexprs.forEach(function (e) {\n  return e.regexObj = new RegExp('^' + e.regex);\n});\n\n/**\n * Of all the expressions, find the first match in the remaining text.\n * @param {string} remaining The remaining text to parse\n * @returns The matched expression and the newly remaining text `{ expr, match, name, remaining }`\n */\n\nvar consumeExpr = function consumeExpr(remaining) {\n  var expr;\n  var match;\n  var name;\n\n  for (var j = 0; j < exprs.length; j++) {\n    var e = exprs[j];\n    var n = e.name;\n    var m = remaining.match(e.regexObj);\n\n    if (m != null) {\n      match = m;\n      expr = e;\n      name = n;\n      var consumed = m[0];\n      remaining = remaining.substring(consumed.length);\n      break; // we've consumed one expr, so we can return now\n    }\n  }\n\n  return {\n    expr: expr,\n    match: match,\n    name: name,\n    remaining: remaining\n  };\n};\n/**\n * Consume all the leading whitespace\n * @param {string} remaining The text to consume\n * @returns The text with the leading whitespace removed\n */\n\n\nvar consumeWhitespace = function consumeWhitespace(remaining) {\n  var match = remaining.match(/^\\s+/);\n\n  if (match) {\n    var consumed = match[0];\n    remaining = remaining.substring(consumed.length);\n  }\n\n  return remaining;\n};\n/**\n * Parse the string and store the parsed representation in the Selector.\n * @param {string} selector The selector string\n * @returns `true` if the selector was successfully parsed, `false` otherwise\n */\n\n\nvar parse = function parse(selector) {\n  var self = this;\n  var remaining = self.inputText = selector;\n  var currentQuery = self[0] = newQuery();\n  self.length = 1;\n  remaining = consumeWhitespace(remaining); // get rid of leading whitespace\n\n  for (;;) {\n    var exprInfo = consumeExpr(remaining);\n\n    if (exprInfo.expr == null) {\n      warn('The selector `' + selector + '`is invalid');\n      return false;\n    } else {\n      var args = exprInfo.match.slice(1); // let the token populate the selector object in currentQuery\n\n      var ret = exprInfo.expr.populate(self, currentQuery, args);\n\n      if (ret === false) {\n        return false; // exit if population failed\n      } else if (ret != null) {\n        currentQuery = ret; // change the current query to be filled if the expr specifies\n      }\n    }\n\n    remaining = exprInfo.remaining; // we're done when there's nothing left to parse\n\n    if (remaining.match(/^\\s*$/)) {\n      break;\n    }\n  }\n\n  var lastQ = self[self.length - 1];\n\n  if (self.currentSubject != null) {\n    lastQ.subject = self.currentSubject;\n  }\n\n  lastQ.edgeCount = self.edgeCount;\n  lastQ.compoundCount = self.compoundCount;\n\n  for (var i = 0; i < self.length; i++) {\n    var q = self[i]; // in future, this could potentially be allowed if there were operator precedence and detection of invalid combinations\n\n    if (q.compoundCount > 0 && q.edgeCount > 0) {\n      warn('The selector `' + selector + '` is invalid because it uses both a compound selector and an edge selector');\n      return false;\n    }\n\n    if (q.edgeCount > 1) {\n      warn('The selector `' + selector + '` is invalid because it uses multiple edge selectors');\n      return false;\n    } else if (q.edgeCount === 1) {\n      warn('The selector `' + selector + '` is deprecated.  Edge selectors do not take effect on changes to source and target nodes after an edge is added, for performance reasons.  Use a class or data selector on edges instead, updating the class or data of an edge when your app detects a change in source or target nodes.');\n    }\n  }\n\n  return true; // success\n};\n/**\n * Get the selector represented as a string.  This value uses default formatting,\n * so things like spacing may differ from the input text passed to the constructor.\n * @returns {string} The selector string\n */\n\n\nvar toString = function toString() {\n  if (this.toStringCache != null) {\n    return this.toStringCache;\n  }\n\n  var clean = function clean(obj) {\n    if (obj == null) {\n      return '';\n    } else {\n      return obj;\n    }\n  };\n\n  var cleanVal = function cleanVal(val) {\n    if (string(val)) {\n      return '\"' + val + '\"';\n    } else {\n      return clean(val);\n    }\n  };\n\n  var space = function space(val) {\n    return ' ' + val + ' ';\n  };\n\n  var checkToString = function checkToString(check, subject) {\n    var type = check.type,\n        value = check.value;\n\n    switch (type) {\n      case Type.GROUP:\n        {\n          var group = clean(value);\n          return group.substring(0, group.length - 1);\n        }\n\n      case Type.DATA_COMPARE:\n        {\n          var field = check.field,\n              operator = check.operator;\n          return '[' + field + space(clean(operator)) + cleanVal(value) + ']';\n        }\n\n      case Type.DATA_BOOL:\n        {\n          var _operator = check.operator,\n              _field = check.field;\n          return '[' + clean(_operator) + _field + ']';\n        }\n\n      case Type.DATA_EXIST:\n        {\n          var _field2 = check.field;\n          return '[' + _field2 + ']';\n        }\n\n      case Type.META_COMPARE:\n        {\n          var _operator2 = check.operator,\n              _field3 = check.field;\n          return '[[' + _field3 + space(clean(_operator2)) + cleanVal(value) + ']]';\n        }\n\n      case Type.STATE:\n        {\n          return value;\n        }\n\n      case Type.ID:\n        {\n          return '#' + value;\n        }\n\n      case Type.CLASS:\n        {\n          return '.' + value;\n        }\n\n      case Type.PARENT:\n      case Type.CHILD:\n        {\n          return queryToString(check.parent, subject) + space('>') + queryToString(check.child, subject);\n        }\n\n      case Type.ANCESTOR:\n      case Type.DESCENDANT:\n        {\n          return queryToString(check.ancestor, subject) + ' ' + queryToString(check.descendant, subject);\n        }\n\n      case Type.COMPOUND_SPLIT:\n        {\n          var lhs = queryToString(check.left, subject);\n          var sub = queryToString(check.subject, subject);\n          var rhs = queryToString(check.right, subject);\n          return lhs + (lhs.length > 0 ? ' ' : '') + sub + rhs;\n        }\n\n      case Type.TRUE:\n        {\n          return '';\n        }\n    }\n  };\n\n  var queryToString = function queryToString(query, subject) {\n    return query.checks.reduce(function (str, chk, i) {\n      return str + (subject === query && i === 0 ? '$' : '') + checkToString(chk, subject);\n    }, '');\n  };\n\n  var str = '';\n\n  for (var i = 0; i < this.length; i++) {\n    var query = this[i];\n    str += queryToString(query, query.subject);\n\n    if (this.length > 1 && i < this.length - 1) {\n      str += ', ';\n    }\n  }\n\n  this.toStringCache = str;\n  return str;\n};\nvar parse$1 = {\n  parse: parse,\n  toString: toString\n};\n\nvar valCmp = function valCmp(fieldVal, operator, value) {\n  var matches;\n  var isFieldStr = string(fieldVal);\n  var isFieldNum = number$1(fieldVal);\n  var isValStr = string(value);\n  var fieldStr, valStr;\n  var caseInsensitive = false;\n  var notExpr = false;\n  var isIneqCmp = false;\n\n  if (operator.indexOf('!') >= 0) {\n    operator = operator.replace('!', '');\n    notExpr = true;\n  }\n\n  if (operator.indexOf('@') >= 0) {\n    operator = operator.replace('@', '');\n    caseInsensitive = true;\n  }\n\n  if (isFieldStr || isValStr || caseInsensitive) {\n    fieldStr = !isFieldStr && !isFieldNum ? '' : '' + fieldVal;\n    valStr = '' + value;\n  } // if we're doing a case insensitive comparison, then we're using a STRING comparison\n  // even if we're comparing numbers\n\n\n  if (caseInsensitive) {\n    fieldVal = fieldStr = fieldStr.toLowerCase();\n    value = valStr = valStr.toLowerCase();\n  }\n\n  switch (operator) {\n    case '*=':\n      matches = fieldStr.indexOf(valStr) >= 0;\n      break;\n\n    case '$=':\n      matches = fieldStr.indexOf(valStr, fieldStr.length - valStr.length) >= 0;\n      break;\n\n    case '^=':\n      matches = fieldStr.indexOf(valStr) === 0;\n      break;\n\n    case '=':\n      matches = fieldVal === value;\n      break;\n\n    case '>':\n      isIneqCmp = true;\n      matches = fieldVal > value;\n      break;\n\n    case '>=':\n      isIneqCmp = true;\n      matches = fieldVal >= value;\n      break;\n\n    case '<':\n      isIneqCmp = true;\n      matches = fieldVal < value;\n      break;\n\n    case '<=':\n      isIneqCmp = true;\n      matches = fieldVal <= value;\n      break;\n\n    default:\n      matches = false;\n      break;\n  } // apply the not op, but null vals for inequalities should always stay non-matching\n\n\n  if (notExpr && (fieldVal != null || !isIneqCmp)) {\n    matches = !matches;\n  }\n\n  return matches;\n};\nvar boolCmp = function boolCmp(fieldVal, operator) {\n  switch (operator) {\n    case '?':\n      return fieldVal ? true : false;\n\n    case '!':\n      return fieldVal ? false : true;\n\n    case '^':\n      return fieldVal === undefined;\n  }\n};\nvar existCmp = function existCmp(fieldVal) {\n  return fieldVal !== undefined;\n};\nvar data$1 = function data(ele, field) {\n  return ele.data(field);\n};\nvar meta = function meta(ele, field) {\n  return ele[field]();\n};\n\n/** A lookup of `match(check, ele)` functions by `Type` int */\n\nvar match = [];\n/**\n * Returns whether the query matches for the element\n * @param query The `{ type, value, ... }` query object\n * @param ele The element to compare against\n*/\n\nvar matches$1 = function matches(query, ele) {\n  return query.checks.every(function (chk) {\n    return match[chk.type](chk, ele);\n  });\n};\n\nmatch[Type.GROUP] = function (check, ele) {\n  var group = check.value;\n  return group === '*' || group === ele.group();\n};\n\nmatch[Type.STATE] = function (check, ele) {\n  var stateSelector = check.value;\n  return stateSelectorMatches(stateSelector, ele);\n};\n\nmatch[Type.ID] = function (check, ele) {\n  var id = check.value;\n  return ele.id() === id;\n};\n\nmatch[Type.CLASS] = function (check, ele) {\n  var cls = check.value;\n  return ele.hasClass(cls);\n};\n\nmatch[Type.META_COMPARE] = function (check, ele) {\n  var field = check.field,\n      operator = check.operator,\n      value = check.value;\n  return valCmp(meta(ele, field), operator, value);\n};\n\nmatch[Type.DATA_COMPARE] = function (check, ele) {\n  var field = check.field,\n      operator = check.operator,\n      value = check.value;\n  return valCmp(data$1(ele, field), operator, value);\n};\n\nmatch[Type.DATA_BOOL] = function (check, ele) {\n  var field = check.field,\n      operator = check.operator;\n  return boolCmp(data$1(ele, field), operator);\n};\n\nmatch[Type.DATA_EXIST] = function (check, ele) {\n  var field = check.field;\n      check.operator;\n  return existCmp(data$1(ele, field));\n};\n\nmatch[Type.UNDIRECTED_EDGE] = function (check, ele) {\n  var qA = check.nodes[0];\n  var qB = check.nodes[1];\n  var src = ele.source();\n  var tgt = ele.target();\n  return matches$1(qA, src) && matches$1(qB, tgt) || matches$1(qB, src) && matches$1(qA, tgt);\n};\n\nmatch[Type.NODE_NEIGHBOR] = function (check, ele) {\n  return matches$1(check.node, ele) && ele.neighborhood().some(function (n) {\n    return n.isNode() && matches$1(check.neighbor, n);\n  });\n};\n\nmatch[Type.DIRECTED_EDGE] = function (check, ele) {\n  return matches$1(check.source, ele.source()) && matches$1(check.target, ele.target());\n};\n\nmatch[Type.NODE_SOURCE] = function (check, ele) {\n  return matches$1(check.source, ele) && ele.outgoers().some(function (n) {\n    return n.isNode() && matches$1(check.target, n);\n  });\n};\n\nmatch[Type.NODE_TARGET] = function (check, ele) {\n  return matches$1(check.target, ele) && ele.incomers().some(function (n) {\n    return n.isNode() && matches$1(check.source, n);\n  });\n};\n\nmatch[Type.CHILD] = function (check, ele) {\n  return matches$1(check.child, ele) && matches$1(check.parent, ele.parent());\n};\n\nmatch[Type.PARENT] = function (check, ele) {\n  return matches$1(check.parent, ele) && ele.children().some(function (c) {\n    return matches$1(check.child, c);\n  });\n};\n\nmatch[Type.DESCENDANT] = function (check, ele) {\n  return matches$1(check.descendant, ele) && ele.ancestors().some(function (a) {\n    return matches$1(check.ancestor, a);\n  });\n};\n\nmatch[Type.ANCESTOR] = function (check, ele) {\n  return matches$1(check.ancestor, ele) && ele.descendants().some(function (d) {\n    return matches$1(check.descendant, d);\n  });\n};\n\nmatch[Type.COMPOUND_SPLIT] = function (check, ele) {\n  return matches$1(check.subject, ele) && matches$1(check.left, ele) && matches$1(check.right, ele);\n};\n\nmatch[Type.TRUE] = function () {\n  return true;\n};\n\nmatch[Type.COLLECTION] = function (check, ele) {\n  var collection = check.value;\n  return collection.has(ele);\n};\n\nmatch[Type.FILTER] = function (check, ele) {\n  var filter = check.value;\n  return filter(ele);\n};\n\nvar filter = function filter(collection) {\n  var self = this; // for 1 id #foo queries, just get the element\n\n  if (self.length === 1 && self[0].checks.length === 1 && self[0].checks[0].type === Type.ID) {\n    return collection.getElementById(self[0].checks[0].value).collection();\n  }\n\n  var selectorFunction = function selectorFunction(element) {\n    for (var j = 0; j < self.length; j++) {\n      var query = self[j];\n\n      if (matches$1(query, element)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  if (self.text() == null) {\n    selectorFunction = function selectorFunction() {\n      return true;\n    };\n  }\n\n  return collection.filter(selectorFunction);\n}; // filter\n// does selector match a single element?\n\n\nvar matches = function matches(ele) {\n  var self = this;\n\n  for (var j = 0; j < self.length; j++) {\n    var query = self[j];\n\n    if (matches$1(query, ele)) {\n      return true;\n    }\n  }\n\n  return false;\n}; // matches\n\n\nvar matching = {\n  matches: matches,\n  filter: filter\n};\n\nvar Selector = function Selector(selector) {\n  this.inputText = selector;\n  this.currentSubject = null;\n  this.compoundCount = 0;\n  this.edgeCount = 0;\n  this.length = 0;\n\n  if (selector == null || string(selector) && selector.match(/^\\s*$/)) ; else if (elementOrCollection(selector)) {\n    this.addQuery({\n      checks: [{\n        type: Type.COLLECTION,\n        value: selector.collection()\n      }]\n    });\n  } else if (fn$6(selector)) {\n    this.addQuery({\n      checks: [{\n        type: Type.FILTER,\n        value: selector\n      }]\n    });\n  } else if (string(selector)) {\n    if (!this.parse(selector)) {\n      this.invalid = true;\n    }\n  } else {\n    error('A selector must be created from a string; found ');\n  }\n};\n\nvar selfn = Selector.prototype;\n[parse$1, matching].forEach(function (p) {\n  return extend(selfn, p);\n});\n\nselfn.text = function () {\n  return this.inputText;\n};\n\nselfn.size = function () {\n  return this.length;\n};\n\nselfn.eq = function (i) {\n  return this[i];\n};\n\nselfn.sameText = function (otherSel) {\n  return !this.invalid && !otherSel.invalid && this.text() === otherSel.text();\n};\n\nselfn.addQuery = function (q) {\n  this[this.length++] = q;\n};\n\nselfn.selector = selfn.toString;\n\nvar elesfn$g = {\n  allAre: function allAre(selector) {\n    var selObj = new Selector(selector);\n    return this.every(function (ele) {\n      return selObj.matches(ele);\n    });\n  },\n  is: function is(selector) {\n    var selObj = new Selector(selector);\n    return this.some(function (ele) {\n      return selObj.matches(ele);\n    });\n  },\n  some: function some(fn, thisArg) {\n    for (var i = 0; i < this.length; i++) {\n      var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);\n\n      if (ret) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n  every: function every(fn, thisArg) {\n    for (var i = 0; i < this.length; i++) {\n      var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);\n\n      if (!ret) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n  same: function same(collection) {\n    // cheap collection ref check\n    if (this === collection) {\n      return true;\n    }\n\n    collection = this.cy().collection(collection);\n    var thisLength = this.length;\n    var collectionLength = collection.length; // cheap length check\n\n    if (thisLength !== collectionLength) {\n      return false;\n    } // cheap element ref check\n\n\n    if (thisLength === 1) {\n      return this[0] === collection[0];\n    }\n\n    return this.every(function (ele) {\n      return collection.hasElementWithId(ele.id());\n    });\n  },\n  anySame: function anySame(collection) {\n    collection = this.cy().collection(collection);\n    return this.some(function (ele) {\n      return collection.hasElementWithId(ele.id());\n    });\n  },\n  allAreNeighbors: function allAreNeighbors(collection) {\n    collection = this.cy().collection(collection);\n    var nhood = this.neighborhood();\n    return collection.every(function (ele) {\n      return nhood.hasElementWithId(ele.id());\n    });\n  },\n  contains: function contains(collection) {\n    collection = this.cy().collection(collection);\n    var self = this;\n    return collection.every(function (ele) {\n      return self.hasElementWithId(ele.id());\n    });\n  }\n};\nelesfn$g.allAreNeighbours = elesfn$g.allAreNeighbors;\nelesfn$g.has = elesfn$g.contains;\nelesfn$g.equal = elesfn$g.equals = elesfn$g.same;\n\nvar cache = function cache(fn, name) {\n  return function traversalCache(arg1, arg2, arg3, arg4) {\n    var selectorOrEles = arg1;\n    var eles = this;\n    var key;\n\n    if (selectorOrEles == null) {\n      key = '';\n    } else if (elementOrCollection(selectorOrEles) && selectorOrEles.length === 1) {\n      key = selectorOrEles.id();\n    }\n\n    if (eles.length === 1 && key) {\n      var _p = eles[0]._private;\n      var tch = _p.traversalCache = _p.traversalCache || {};\n      var ch = tch[name] = tch[name] || [];\n      var hash = hashString(key);\n      var cacheHit = ch[hash];\n\n      if (cacheHit) {\n        return cacheHit;\n      } else {\n        return ch[hash] = fn.call(eles, arg1, arg2, arg3, arg4);\n      }\n    } else {\n      return fn.call(eles, arg1, arg2, arg3, arg4);\n    }\n  };\n};\n\nvar elesfn$f = {\n  parent: function parent(selector) {\n    var parents = []; // optimisation for single ele call\n\n    if (this.length === 1) {\n      var parent = this[0]._private.parent;\n\n      if (parent) {\n        return parent;\n      }\n    }\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      var _parent = ele._private.parent;\n\n      if (_parent) {\n        parents.push(_parent);\n      }\n    }\n\n    return this.spawn(parents, true).filter(selector);\n  },\n  parents: function parents(selector) {\n    var parents = [];\n    var eles = this.parent();\n\n    while (eles.nonempty()) {\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        parents.push(ele);\n      }\n\n      eles = eles.parent();\n    }\n\n    return this.spawn(parents, true).filter(selector);\n  },\n  commonAncestors: function commonAncestors(selector) {\n    var ancestors;\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      var parents = ele.parents();\n      ancestors = ancestors || parents;\n      ancestors = ancestors.intersect(parents); // current list must be common with current ele parents set\n    }\n\n    return ancestors.filter(selector);\n  },\n  orphans: function orphans(selector) {\n    return this.stdFilter(function (ele) {\n      return ele.isOrphan();\n    }).filter(selector);\n  },\n  nonorphans: function nonorphans(selector) {\n    return this.stdFilter(function (ele) {\n      return ele.isChild();\n    }).filter(selector);\n  },\n  children: cache(function (selector) {\n    var children = [];\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      var eleChildren = ele._private.children;\n\n      for (var j = 0; j < eleChildren.length; j++) {\n        children.push(eleChildren[j]);\n      }\n    }\n\n    return this.spawn(children, true).filter(selector);\n  }, 'children'),\n  siblings: function siblings(selector) {\n    return this.parent().children().not(this).filter(selector);\n  },\n  isParent: function isParent() {\n    var ele = this[0];\n\n    if (ele) {\n      return ele.isNode() && ele._private.children.length !== 0;\n    }\n  },\n  isChildless: function isChildless() {\n    var ele = this[0];\n\n    if (ele) {\n      return ele.isNode() && ele._private.children.length === 0;\n    }\n  },\n  isChild: function isChild() {\n    var ele = this[0];\n\n    if (ele) {\n      return ele.isNode() && ele._private.parent != null;\n    }\n  },\n  isOrphan: function isOrphan() {\n    var ele = this[0];\n\n    if (ele) {\n      return ele.isNode() && ele._private.parent == null;\n    }\n  },\n  descendants: function descendants(selector) {\n    var elements = [];\n\n    function add(eles) {\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        elements.push(ele);\n\n        if (ele.children().nonempty()) {\n          add(ele.children());\n        }\n      }\n    }\n\n    add(this.children());\n    return this.spawn(elements, true).filter(selector);\n  }\n};\n\nfunction forEachCompound(eles, fn, includeSelf, recursiveStep) {\n  var q = [];\n  var did = new Set$1();\n  var cy = eles.cy();\n  var hasCompounds = cy.hasCompoundNodes();\n\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n\n    if (includeSelf) {\n      q.push(ele);\n    } else if (hasCompounds) {\n      recursiveStep(q, did, ele);\n    }\n  }\n\n  while (q.length > 0) {\n    var _ele = q.shift();\n\n    fn(_ele);\n    did.add(_ele.id());\n\n    if (hasCompounds) {\n      recursiveStep(q, did, _ele);\n    }\n  }\n\n  return eles;\n}\n\nfunction addChildren(q, did, ele) {\n  if (ele.isParent()) {\n    var children = ele._private.children;\n\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n\n      if (!did.has(child.id())) {\n        q.push(child);\n      }\n    }\n  }\n} // very efficient version of eles.add( eles.descendants() ).forEach()\n// for internal use\n\n\nelesfn$f.forEachDown = function (fn) {\n  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return forEachCompound(this, fn, includeSelf, addChildren);\n};\n\nfunction addParent(q, did, ele) {\n  if (ele.isChild()) {\n    var parent = ele._private.parent;\n\n    if (!did.has(parent.id())) {\n      q.push(parent);\n    }\n  }\n}\n\nelesfn$f.forEachUp = function (fn) {\n  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return forEachCompound(this, fn, includeSelf, addParent);\n};\n\nfunction addParentAndChildren(q, did, ele) {\n  addParent(q, did, ele);\n  addChildren(q, did, ele);\n}\n\nelesfn$f.forEachUpAndDown = function (fn) {\n  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return forEachCompound(this, fn, includeSelf, addParentAndChildren);\n}; // aliases\n\n\nelesfn$f.ancestors = elesfn$f.parents;\n\nvar fn$5, elesfn$e;\nfn$5 = elesfn$e = {\n  data: define.data({\n    field: 'data',\n    bindingEvent: 'data',\n    allowBinding: true,\n    allowSetting: true,\n    settingEvent: 'data',\n    settingTriggersEvent: true,\n    triggerFnName: 'trigger',\n    allowGetting: true,\n    immutableKeys: {\n      'id': true,\n      'source': true,\n      'target': true,\n      'parent': true\n    },\n    updateStyle: true\n  }),\n  removeData: define.removeData({\n    field: 'data',\n    event: 'data',\n    triggerFnName: 'trigger',\n    triggerEvent: true,\n    immutableKeys: {\n      'id': true,\n      'source': true,\n      'target': true,\n      'parent': true\n    },\n    updateStyle: true\n  }),\n  scratch: define.data({\n    field: 'scratch',\n    bindingEvent: 'scratch',\n    allowBinding: true,\n    allowSetting: true,\n    settingEvent: 'scratch',\n    settingTriggersEvent: true,\n    triggerFnName: 'trigger',\n    allowGetting: true,\n    updateStyle: true\n  }),\n  removeScratch: define.removeData({\n    field: 'scratch',\n    event: 'scratch',\n    triggerFnName: 'trigger',\n    triggerEvent: true,\n    updateStyle: true\n  }),\n  rscratch: define.data({\n    field: 'rscratch',\n    allowBinding: false,\n    allowSetting: true,\n    settingTriggersEvent: false,\n    allowGetting: true\n  }),\n  removeRscratch: define.removeData({\n    field: 'rscratch',\n    triggerEvent: false\n  }),\n  id: function id() {\n    var ele = this[0];\n\n    if (ele) {\n      return ele._private.data.id;\n    }\n  }\n}; // aliases\n\nfn$5.attr = fn$5.data;\nfn$5.removeAttr = fn$5.removeData;\nvar data = elesfn$e;\n\nvar elesfn$d = {};\n\nfunction defineDegreeFunction(callback) {\n  return function (includeLoops) {\n    var self = this;\n\n    if (includeLoops === undefined) {\n      includeLoops = true;\n    }\n\n    if (self.length === 0) {\n      return;\n    }\n\n    if (self.isNode() && !self.removed()) {\n      var degree = 0;\n      var node = self[0];\n      var connectedEdges = node._private.edges;\n\n      for (var i = 0; i < connectedEdges.length; i++) {\n        var edge = connectedEdges[i];\n\n        if (!includeLoops && edge.isLoop()) {\n          continue;\n        }\n\n        degree += callback(node, edge);\n      }\n\n      return degree;\n    } else {\n      return;\n    }\n  };\n}\n\nextend(elesfn$d, {\n  degree: defineDegreeFunction(function (node, edge) {\n    if (edge.source().same(edge.target())) {\n      return 2;\n    } else {\n      return 1;\n    }\n  }),\n  indegree: defineDegreeFunction(function (node, edge) {\n    if (edge.target().same(node)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }),\n  outdegree: defineDegreeFunction(function (node, edge) {\n    if (edge.source().same(node)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  })\n});\n\nfunction defineDegreeBoundsFunction(degreeFn, callback) {\n  return function (includeLoops) {\n    var ret;\n    var nodes = this.nodes();\n\n    for (var i = 0; i < nodes.length; i++) {\n      var ele = nodes[i];\n      var degree = ele[degreeFn](includeLoops);\n\n      if (degree !== undefined && (ret === undefined || callback(degree, ret))) {\n        ret = degree;\n      }\n    }\n\n    return ret;\n  };\n}\n\nextend(elesfn$d, {\n  minDegree: defineDegreeBoundsFunction('degree', function (degree, min) {\n    return degree < min;\n  }),\n  maxDegree: defineDegreeBoundsFunction('degree', function (degree, max) {\n    return degree > max;\n  }),\n  minIndegree: defineDegreeBoundsFunction('indegree', function (degree, min) {\n    return degree < min;\n  }),\n  maxIndegree: defineDegreeBoundsFunction('indegree', function (degree, max) {\n    return degree > max;\n  }),\n  minOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, min) {\n    return degree < min;\n  }),\n  maxOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, max) {\n    return degree > max;\n  })\n});\nextend(elesfn$d, {\n  totalDegree: function totalDegree(includeLoops) {\n    var total = 0;\n    var nodes = this.nodes();\n\n    for (var i = 0; i < nodes.length; i++) {\n      total += nodes[i].degree(includeLoops);\n    }\n\n    return total;\n  }\n});\n\nvar fn$4, elesfn$c;\n\nvar beforePositionSet = function beforePositionSet(eles, newPos, silent) {\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n\n    if (!ele.locked()) {\n      var oldPos = ele._private.position;\n      var delta = {\n        x: newPos.x != null ? newPos.x - oldPos.x : 0,\n        y: newPos.y != null ? newPos.y - oldPos.y : 0\n      };\n\n      if (ele.isParent() && !(delta.x === 0 && delta.y === 0)) {\n        ele.children().shift(delta, silent);\n      }\n\n      ele.dirtyBoundingBoxCache();\n    }\n  }\n};\n\nvar positionDef = {\n  field: 'position',\n  bindingEvent: 'position',\n  allowBinding: true,\n  allowSetting: true,\n  settingEvent: 'position',\n  settingTriggersEvent: true,\n  triggerFnName: 'emitAndNotify',\n  allowGetting: true,\n  validKeys: ['x', 'y'],\n  beforeGet: function beforeGet(ele) {\n    ele.updateCompoundBounds();\n  },\n  beforeSet: function beforeSet(eles, newPos) {\n    beforePositionSet(eles, newPos, false);\n  },\n  onSet: function onSet(eles) {\n    eles.dirtyCompoundBoundsCache();\n  },\n  canSet: function canSet(ele) {\n    return !ele.locked();\n  }\n};\nfn$4 = elesfn$c = {\n  position: define.data(positionDef),\n  // position but no notification to renderer\n  silentPosition: define.data(extend({}, positionDef, {\n    allowBinding: false,\n    allowSetting: true,\n    settingTriggersEvent: false,\n    allowGetting: false,\n    beforeSet: function beforeSet(eles, newPos) {\n      beforePositionSet(eles, newPos, true);\n    },\n    onSet: function onSet(eles) {\n      eles.dirtyCompoundBoundsCache();\n    }\n  })),\n  positions: function positions(pos, silent) {\n    if (plainObject(pos)) {\n      if (silent) {\n        this.silentPosition(pos);\n      } else {\n        this.position(pos);\n      }\n    } else if (fn$6(pos)) {\n      var _fn = pos;\n      var cy = this.cy();\n      cy.startBatch();\n\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n\n        var _pos = void 0;\n\n        if (_pos = _fn(ele, i)) {\n          if (silent) {\n            ele.silentPosition(_pos);\n          } else {\n            ele.position(_pos);\n          }\n        }\n      }\n\n      cy.endBatch();\n    }\n\n    return this; // chaining\n  },\n  silentPositions: function silentPositions(pos) {\n    return this.positions(pos, true);\n  },\n  shift: function shift(dim, val, silent) {\n    var delta;\n\n    if (plainObject(dim)) {\n      delta = {\n        x: number$1(dim.x) ? dim.x : 0,\n        y: number$1(dim.y) ? dim.y : 0\n      };\n      silent = val;\n    } else if (string(dim) && number$1(val)) {\n      delta = {\n        x: 0,\n        y: 0\n      };\n      delta[dim] = val;\n    }\n\n    if (delta != null) {\n      var cy = this.cy();\n      cy.startBatch();\n\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i]; // exclude any node that is a descendant of the calling collection\n\n        if (cy.hasCompoundNodes() && ele.isChild() && ele.ancestors().anySame(this)) {\n          continue;\n        }\n\n        var pos = ele.position();\n        var newPos = {\n          x: pos.x + delta.x,\n          y: pos.y + delta.y\n        };\n\n        if (silent) {\n          ele.silentPosition(newPos);\n        } else {\n          ele.position(newPos);\n        }\n      }\n\n      cy.endBatch();\n    }\n\n    return this;\n  },\n  silentShift: function silentShift(dim, val) {\n    if (plainObject(dim)) {\n      this.shift(dim, true);\n    } else if (string(dim) && number$1(val)) {\n      this.shift(dim, val, true);\n    }\n\n    return this;\n  },\n  // get/set the rendered (i.e. on screen) positon of the element\n  renderedPosition: function renderedPosition(dim, val) {\n    var ele = this[0];\n    var cy = this.cy();\n    var zoom = cy.zoom();\n    var pan = cy.pan();\n    var rpos = plainObject(dim) ? dim : undefined;\n    var setting = rpos !== undefined || val !== undefined && string(dim);\n\n    if (ele && ele.isNode()) {\n      // must have an element and must be a node to return position\n      if (setting) {\n        for (var i = 0; i < this.length; i++) {\n          var _ele = this[i];\n\n          if (val !== undefined) {\n            // set one dimension\n            _ele.position(dim, (val - pan[dim]) / zoom);\n          } else if (rpos !== undefined) {\n            // set whole position\n            _ele.position(renderedToModelPosition(rpos, zoom, pan));\n          }\n        }\n      } else {\n        // getting\n        var pos = ele.position();\n        rpos = modelToRenderedPosition(pos, zoom, pan);\n\n        if (dim === undefined) {\n          // then return the whole rendered position\n          return rpos;\n        } else {\n          // then return the specified dimension\n          return rpos[dim];\n        }\n      }\n    } else if (!setting) {\n      return undefined; // for empty collection case\n    }\n\n    return this; // chaining\n  },\n  // get/set the position relative to the parent\n  relativePosition: function relativePosition(dim, val) {\n    var ele = this[0];\n    var cy = this.cy();\n    var ppos = plainObject(dim) ? dim : undefined;\n    var setting = ppos !== undefined || val !== undefined && string(dim);\n    var hasCompoundNodes = cy.hasCompoundNodes();\n\n    if (ele && ele.isNode()) {\n      // must have an element and must be a node to return position\n      if (setting) {\n        for (var i = 0; i < this.length; i++) {\n          var _ele2 = this[i];\n          var parent = hasCompoundNodes ? _ele2.parent() : null;\n          var hasParent = parent && parent.length > 0;\n          var relativeToParent = hasParent;\n\n          if (hasParent) {\n            parent = parent[0];\n          }\n\n          var origin = relativeToParent ? parent.position() : {\n            x: 0,\n            y: 0\n          };\n\n          if (val !== undefined) {\n            // set one dimension\n            _ele2.position(dim, val + origin[dim]);\n          } else if (ppos !== undefined) {\n            // set whole position\n            _ele2.position({\n              x: ppos.x + origin.x,\n              y: ppos.y + origin.y\n            });\n          }\n        }\n      } else {\n        // getting\n        var pos = ele.position();\n\n        var _parent = hasCompoundNodes ? ele.parent() : null;\n\n        var _hasParent = _parent && _parent.length > 0;\n\n        var _relativeToParent = _hasParent;\n\n        if (_hasParent) {\n          _parent = _parent[0];\n        }\n\n        var _origin = _relativeToParent ? _parent.position() : {\n          x: 0,\n          y: 0\n        };\n\n        ppos = {\n          x: pos.x - _origin.x,\n          y: pos.y - _origin.y\n        };\n\n        if (dim === undefined) {\n          // then return the whole rendered position\n          return ppos;\n        } else {\n          // then return the specified dimension\n          return ppos[dim];\n        }\n      }\n    } else if (!setting) {\n      return undefined; // for empty collection case\n    }\n\n    return this; // chaining\n  }\n}; // aliases\n\nfn$4.modelPosition = fn$4.point = fn$4.position;\nfn$4.modelPositions = fn$4.points = fn$4.positions;\nfn$4.renderedPoint = fn$4.renderedPosition;\nfn$4.relativePoint = fn$4.relativePosition;\nvar position = elesfn$c;\n\nvar fn$3, elesfn$b;\nfn$3 = elesfn$b = {};\n\nelesfn$b.renderedBoundingBox = function (options) {\n  var bb = this.boundingBox(options);\n  var cy = this.cy();\n  var zoom = cy.zoom();\n  var pan = cy.pan();\n  var x1 = bb.x1 * zoom + pan.x;\n  var x2 = bb.x2 * zoom + pan.x;\n  var y1 = bb.y1 * zoom + pan.y;\n  var y2 = bb.y2 * zoom + pan.y;\n  return {\n    x1: x1,\n    x2: x2,\n    y1: y1,\n    y2: y2,\n    w: x2 - x1,\n    h: y2 - y1\n  };\n};\n\nelesfn$b.dirtyCompoundBoundsCache = function () {\n  var silent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  var cy = this.cy();\n\n  if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {\n    return this;\n  }\n\n  this.forEachUp(function (ele) {\n    if (ele.isParent()) {\n      var _p = ele._private;\n      _p.compoundBoundsClean = false;\n      _p.bbCache = null;\n\n      if (!silent) {\n        ele.emitAndNotify('bounds');\n      }\n    }\n  });\n  return this;\n};\n\nelesfn$b.updateCompoundBounds = function () {\n  var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  var cy = this.cy(); // not possible to do on non-compound graphs or with the style disabled\n\n  if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {\n    return this;\n  } // save cycles when batching -- but bounds will be stale (or not exist yet)\n\n\n  if (!force && cy.batching()) {\n    return this;\n  }\n\n  function update(parent) {\n    if (!parent.isParent()) {\n      return;\n    }\n\n    var _p = parent._private;\n    var children = parent.children();\n    var includeLabels = parent.pstyle('compound-sizing-wrt-labels').value === 'include';\n    var min = {\n      width: {\n        val: parent.pstyle('min-width').pfValue,\n        left: parent.pstyle('min-width-bias-left'),\n        right: parent.pstyle('min-width-bias-right')\n      },\n      height: {\n        val: parent.pstyle('min-height').pfValue,\n        top: parent.pstyle('min-height-bias-top'),\n        bottom: parent.pstyle('min-height-bias-bottom')\n      }\n    };\n    var bb = children.boundingBox({\n      includeLabels: includeLabels,\n      includeOverlays: false,\n      // updating the compound bounds happens outside of the regular\n      // cache cycle (i.e. before fired events)\n      useCache: false\n    });\n    var pos = _p.position; // if children take up zero area then keep position and fall back on stylesheet w/h\n\n    if (bb.w === 0 || bb.h === 0) {\n      bb = {\n        w: parent.pstyle('width').pfValue,\n        h: parent.pstyle('height').pfValue\n      };\n      bb.x1 = pos.x - bb.w / 2;\n      bb.x2 = pos.x + bb.w / 2;\n      bb.y1 = pos.y - bb.h / 2;\n      bb.y2 = pos.y + bb.h / 2;\n    }\n\n    function computeBiasValues(propDiff, propBias, propBiasComplement) {\n      var biasDiff = 0;\n      var biasComplementDiff = 0;\n      var biasTotal = propBias + propBiasComplement;\n\n      if (propDiff > 0 && biasTotal > 0) {\n        biasDiff = propBias / biasTotal * propDiff;\n        biasComplementDiff = propBiasComplement / biasTotal * propDiff;\n      }\n\n      return {\n        biasDiff: biasDiff,\n        biasComplementDiff: biasComplementDiff\n      };\n    }\n\n    function computePaddingValues(width, height, paddingObject, relativeTo) {\n      // Assuming percentage is number from 0 to 1\n      if (paddingObject.units === '%') {\n        switch (relativeTo) {\n          case 'width':\n            return width > 0 ? paddingObject.pfValue * width : 0;\n\n          case 'height':\n            return height > 0 ? paddingObject.pfValue * height : 0;\n\n          case 'average':\n            return width > 0 && height > 0 ? paddingObject.pfValue * (width + height) / 2 : 0;\n\n          case 'min':\n            return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * height : paddingObject.pfValue * width : 0;\n\n          case 'max':\n            return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * width : paddingObject.pfValue * height : 0;\n\n          default:\n            return 0;\n        }\n      } else if (paddingObject.units === 'px') {\n        return paddingObject.pfValue;\n      } else {\n        return 0;\n      }\n    }\n\n    var leftVal = min.width.left.value;\n\n    if (min.width.left.units === 'px' && min.width.val > 0) {\n      leftVal = leftVal * 100 / min.width.val;\n    }\n\n    var rightVal = min.width.right.value;\n\n    if (min.width.right.units === 'px' && min.width.val > 0) {\n      rightVal = rightVal * 100 / min.width.val;\n    }\n\n    var topVal = min.height.top.value;\n\n    if (min.height.top.units === 'px' && min.height.val > 0) {\n      topVal = topVal * 100 / min.height.val;\n    }\n\n    var bottomVal = min.height.bottom.value;\n\n    if (min.height.bottom.units === 'px' && min.height.val > 0) {\n      bottomVal = bottomVal * 100 / min.height.val;\n    }\n\n    var widthBiasDiffs = computeBiasValues(min.width.val - bb.w, leftVal, rightVal);\n    var diffLeft = widthBiasDiffs.biasDiff;\n    var diffRight = widthBiasDiffs.biasComplementDiff;\n    var heightBiasDiffs = computeBiasValues(min.height.val - bb.h, topVal, bottomVal);\n    var diffTop = heightBiasDiffs.biasDiff;\n    var diffBottom = heightBiasDiffs.biasComplementDiff;\n    _p.autoPadding = computePaddingValues(bb.w, bb.h, parent.pstyle('padding'), parent.pstyle('padding-relative-to').value);\n    _p.autoWidth = Math.max(bb.w, min.width.val);\n    pos.x = (-diffLeft + bb.x1 + bb.x2 + diffRight) / 2;\n    _p.autoHeight = Math.max(bb.h, min.height.val);\n    pos.y = (-diffTop + bb.y1 + bb.y2 + diffBottom) / 2;\n  }\n\n  for (var i = 0; i < this.length; i++) {\n    var ele = this[i];\n    var _p = ele._private;\n\n    if (!_p.compoundBoundsClean || force) {\n      update(ele);\n\n      if (!cy.batching()) {\n        _p.compoundBoundsClean = true;\n      }\n    }\n  }\n\n  return this;\n};\n\nvar noninf = function noninf(x) {\n  if (x === Infinity || x === -Infinity) {\n    return 0;\n  }\n\n  return x;\n};\n\nvar updateBounds = function updateBounds(b, x1, y1, x2, y2) {\n  // don't update with zero area boxes\n  if (x2 - x1 === 0 || y2 - y1 === 0) {\n    return;\n  } // don't update with null dim\n\n\n  if (x1 == null || y1 == null || x2 == null || y2 == null) {\n    return;\n  }\n\n  b.x1 = x1 < b.x1 ? x1 : b.x1;\n  b.x2 = x2 > b.x2 ? x2 : b.x2;\n  b.y1 = y1 < b.y1 ? y1 : b.y1;\n  b.y2 = y2 > b.y2 ? y2 : b.y2;\n  b.w = b.x2 - b.x1;\n  b.h = b.y2 - b.y1;\n};\n\nvar updateBoundsFromBox = function updateBoundsFromBox(b, b2) {\n  if (b2 == null) {\n    return b;\n  }\n\n  return updateBounds(b, b2.x1, b2.y1, b2.x2, b2.y2);\n};\n\nvar prefixedProperty = function prefixedProperty(obj, field, prefix) {\n  return getPrefixedProperty(obj, field, prefix);\n};\n\nvar updateBoundsFromArrow = function updateBoundsFromArrow(bounds, ele, prefix) {\n  if (ele.cy().headless()) {\n    return;\n  }\n\n  var _p = ele._private;\n  var rstyle = _p.rstyle;\n  var halfArW = rstyle.arrowWidth / 2;\n  var arrowType = ele.pstyle(prefix + '-arrow-shape').value;\n  var x;\n  var y;\n\n  if (arrowType !== 'none') {\n    if (prefix === 'source') {\n      x = rstyle.srcX;\n      y = rstyle.srcY;\n    } else if (prefix === 'target') {\n      x = rstyle.tgtX;\n      y = rstyle.tgtY;\n    } else {\n      x = rstyle.midX;\n      y = rstyle.midY;\n    } // always store the individual arrow bounds\n\n\n    var bbs = _p.arrowBounds = _p.arrowBounds || {};\n    var bb = bbs[prefix] = bbs[prefix] || {};\n    bb.x1 = x - halfArW;\n    bb.y1 = y - halfArW;\n    bb.x2 = x + halfArW;\n    bb.y2 = y + halfArW;\n    bb.w = bb.x2 - bb.x1;\n    bb.h = bb.y2 - bb.y1;\n    expandBoundingBox(bb, 1);\n    updateBounds(bounds, bb.x1, bb.y1, bb.x2, bb.y2);\n  }\n};\n\nvar updateBoundsFromLabel = function updateBoundsFromLabel(bounds, ele, prefix) {\n  if (ele.cy().headless()) {\n    return;\n  }\n\n  var prefixDash;\n\n  if (prefix) {\n    prefixDash = prefix + '-';\n  } else {\n    prefixDash = '';\n  }\n\n  var _p = ele._private;\n  var rstyle = _p.rstyle;\n  var label = ele.pstyle(prefixDash + 'label').strValue;\n\n  if (label) {\n    var halign = ele.pstyle('text-halign');\n    var valign = ele.pstyle('text-valign');\n    var labelWidth = prefixedProperty(rstyle, 'labelWidth', prefix);\n    var labelHeight = prefixedProperty(rstyle, 'labelHeight', prefix);\n    var labelX = prefixedProperty(rstyle, 'labelX', prefix);\n    var labelY = prefixedProperty(rstyle, 'labelY', prefix);\n    var marginX = ele.pstyle(prefixDash + 'text-margin-x').pfValue;\n    var marginY = ele.pstyle(prefixDash + 'text-margin-y').pfValue;\n    var isEdge = ele.isEdge();\n    var rotation = ele.pstyle(prefixDash + 'text-rotation');\n    var outlineWidth = ele.pstyle('text-outline-width').pfValue;\n    var borderWidth = ele.pstyle('text-border-width').pfValue;\n    var halfBorderWidth = borderWidth / 2;\n    var padding = ele.pstyle('text-background-padding').pfValue;\n    var marginOfError = 2; // expand to work around browser dimension inaccuracies\n\n    var lh = labelHeight;\n    var lw = labelWidth;\n    var lw_2 = lw / 2;\n    var lh_2 = lh / 2;\n    var lx1, lx2, ly1, ly2;\n\n    if (isEdge) {\n      lx1 = labelX - lw_2;\n      lx2 = labelX + lw_2;\n      ly1 = labelY - lh_2;\n      ly2 = labelY + lh_2;\n    } else {\n      switch (halign.value) {\n        case 'left':\n          lx1 = labelX - lw;\n          lx2 = labelX;\n          break;\n\n        case 'center':\n          lx1 = labelX - lw_2;\n          lx2 = labelX + lw_2;\n          break;\n\n        case 'right':\n          lx1 = labelX;\n          lx2 = labelX + lw;\n          break;\n      }\n\n      switch (valign.value) {\n        case 'top':\n          ly1 = labelY - lh;\n          ly2 = labelY;\n          break;\n\n        case 'center':\n          ly1 = labelY - lh_2;\n          ly2 = labelY + lh_2;\n          break;\n\n        case 'bottom':\n          ly1 = labelY;\n          ly2 = labelY + lh;\n          break;\n      }\n    } // shift by margin and expand by outline and border\n\n\n    lx1 += marginX - Math.max(outlineWidth, halfBorderWidth) - padding - marginOfError;\n    lx2 += marginX + Math.max(outlineWidth, halfBorderWidth) + padding + marginOfError;\n    ly1 += marginY - Math.max(outlineWidth, halfBorderWidth) - padding - marginOfError;\n    ly2 += marginY + Math.max(outlineWidth, halfBorderWidth) + padding + marginOfError; // always store the unrotated label bounds separately\n\n    var bbPrefix = prefix || 'main';\n    var bbs = _p.labelBounds;\n    var bb = bbs[bbPrefix] = bbs[bbPrefix] || {};\n    bb.x1 = lx1;\n    bb.y1 = ly1;\n    bb.x2 = lx2;\n    bb.y2 = ly2;\n    bb.w = lx2 - lx1;\n    bb.h = ly2 - ly1;\n    var isAutorotate = isEdge && rotation.strValue === 'autorotate';\n    var isPfValue = rotation.pfValue != null && rotation.pfValue !== 0;\n\n    if (isAutorotate || isPfValue) {\n      var theta = isAutorotate ? prefixedProperty(_p.rstyle, 'labelAngle', prefix) : rotation.pfValue;\n      var cos = Math.cos(theta);\n      var sin = Math.sin(theta); // rotation point (default value for center-center)\n\n      var xo = (lx1 + lx2) / 2;\n      var yo = (ly1 + ly2) / 2;\n\n      if (!isEdge) {\n        switch (halign.value) {\n          case 'left':\n            xo = lx2;\n            break;\n\n          case 'right':\n            xo = lx1;\n            break;\n        }\n\n        switch (valign.value) {\n          case 'top':\n            yo = ly2;\n            break;\n\n          case 'bottom':\n            yo = ly1;\n            break;\n        }\n      }\n\n      var rotate = function rotate(x, y) {\n        x = x - xo;\n        y = y - yo;\n        return {\n          x: x * cos - y * sin + xo,\n          y: x * sin + y * cos + yo\n        };\n      };\n\n      var px1y1 = rotate(lx1, ly1);\n      var px1y2 = rotate(lx1, ly2);\n      var px2y1 = rotate(lx2, ly1);\n      var px2y2 = rotate(lx2, ly2);\n      lx1 = Math.min(px1y1.x, px1y2.x, px2y1.x, px2y2.x);\n      lx2 = Math.max(px1y1.x, px1y2.x, px2y1.x, px2y2.x);\n      ly1 = Math.min(px1y1.y, px1y2.y, px2y1.y, px2y2.y);\n      ly2 = Math.max(px1y1.y, px1y2.y, px2y1.y, px2y2.y);\n    }\n\n    var bbPrefixRot = bbPrefix + 'Rot';\n    var bbRot = bbs[bbPrefixRot] = bbs[bbPrefixRot] || {};\n    bbRot.x1 = lx1;\n    bbRot.y1 = ly1;\n    bbRot.x2 = lx2;\n    bbRot.y2 = ly2;\n    bbRot.w = lx2 - lx1;\n    bbRot.h = ly2 - ly1;\n    updateBounds(bounds, lx1, ly1, lx2, ly2);\n    updateBounds(_p.labelBounds.all, lx1, ly1, lx2, ly2);\n  }\n\n  return bounds;\n}; // get the bounding box of the elements (in raw model position)\n\n\nvar boundingBoxImpl = function boundingBoxImpl(ele, options) {\n  var cy = ele._private.cy;\n  var styleEnabled = cy.styleEnabled();\n  var headless = cy.headless();\n  var bounds = makeBoundingBox();\n  var _p = ele._private;\n  var isNode = ele.isNode();\n  var isEdge = ele.isEdge();\n  var ex1, ex2, ey1, ey2; // extrema of body / lines\n\n  var x, y; // node pos\n\n  var rstyle = _p.rstyle;\n  var manualExpansion = isNode && styleEnabled ? ele.pstyle('bounds-expansion').pfValue : [0]; // must use `display` prop only, as reading `compound.width()` causes recursion\n  // (other factors like width values will be considered later in this function anyway)\n\n  var isDisplayed = function isDisplayed(ele) {\n    return ele.pstyle('display').value !== 'none';\n  };\n\n  var displayed = !styleEnabled || isDisplayed(ele) // must take into account connected nodes b/c of implicit edge hiding on display:none node\n  && (!isEdge || isDisplayed(ele.source()) && isDisplayed(ele.target()));\n\n  if (displayed) {\n    // displayed suffices, since we will find zero area eles anyway\n    var overlayOpacity = 0;\n    var overlayPadding = 0;\n\n    if (styleEnabled && options.includeOverlays) {\n      overlayOpacity = ele.pstyle('overlay-opacity').value;\n\n      if (overlayOpacity !== 0) {\n        overlayPadding = ele.pstyle('overlay-padding').value;\n      }\n    }\n\n    var underlayOpacity = 0;\n    var underlayPadding = 0;\n\n    if (styleEnabled && options.includeUnderlays) {\n      underlayOpacity = ele.pstyle('underlay-opacity').value;\n\n      if (underlayOpacity !== 0) {\n        underlayPadding = ele.pstyle('underlay-padding').value;\n      }\n    }\n\n    var padding = Math.max(overlayPadding, underlayPadding);\n    var w = 0;\n    var wHalf = 0;\n\n    if (styleEnabled) {\n      w = ele.pstyle('width').pfValue;\n      wHalf = w / 2;\n    }\n\n    if (isNode && options.includeNodes) {\n      var pos = ele.position();\n      x = pos.x;\n      y = pos.y;\n\n      var _w = ele.outerWidth();\n\n      var halfW = _w / 2;\n      var h = ele.outerHeight();\n      var halfH = h / 2; // handle node dimensions\n      /////////////////////////\n\n      ex1 = x - halfW;\n      ex2 = x + halfW;\n      ey1 = y - halfH;\n      ey2 = y + halfH;\n      updateBounds(bounds, ex1, ey1, ex2, ey2);\n    } else if (isEdge && options.includeEdges) {\n      if (styleEnabled && !headless) {\n        var curveStyle = ele.pstyle('curve-style').strValue; // handle edge dimensions (rough box estimate)\n        //////////////////////////////////////////////\n\n        ex1 = Math.min(rstyle.srcX, rstyle.midX, rstyle.tgtX);\n        ex2 = Math.max(rstyle.srcX, rstyle.midX, rstyle.tgtX);\n        ey1 = Math.min(rstyle.srcY, rstyle.midY, rstyle.tgtY);\n        ey2 = Math.max(rstyle.srcY, rstyle.midY, rstyle.tgtY); // take into account edge width\n\n        ex1 -= wHalf;\n        ex2 += wHalf;\n        ey1 -= wHalf;\n        ey2 += wHalf;\n        updateBounds(bounds, ex1, ey1, ex2, ey2); // precise edges\n        ////////////////\n\n        if (curveStyle === 'haystack') {\n          var hpts = rstyle.haystackPts;\n\n          if (hpts && hpts.length === 2) {\n            ex1 = hpts[0].x;\n            ey1 = hpts[0].y;\n            ex2 = hpts[1].x;\n            ey2 = hpts[1].y;\n\n            if (ex1 > ex2) {\n              var temp = ex1;\n              ex1 = ex2;\n              ex2 = temp;\n            }\n\n            if (ey1 > ey2) {\n              var _temp = ey1;\n              ey1 = ey2;\n              ey2 = _temp;\n            }\n\n            updateBounds(bounds, ex1 - wHalf, ey1 - wHalf, ex2 + wHalf, ey2 + wHalf);\n          }\n        } else if (curveStyle === 'bezier' || curveStyle === 'unbundled-bezier' || curveStyle === 'segments' || curveStyle === 'taxi') {\n          var pts;\n\n          switch (curveStyle) {\n            case 'bezier':\n            case 'unbundled-bezier':\n              pts = rstyle.bezierPts;\n              break;\n\n            case 'segments':\n            case 'taxi':\n              pts = rstyle.linePts;\n              break;\n          }\n\n          if (pts != null) {\n            for (var j = 0; j < pts.length; j++) {\n              var pt = pts[j];\n              ex1 = pt.x - wHalf;\n              ex2 = pt.x + wHalf;\n              ey1 = pt.y - wHalf;\n              ey2 = pt.y + wHalf;\n              updateBounds(bounds, ex1, ey1, ex2, ey2);\n            }\n          }\n        } // bezier-like or segment-like edge\n\n      } else {\n        // headless or style disabled\n        // fallback on source and target positions\n        //////////////////////////////////////////\n        var n1 = ele.source();\n        var n1pos = n1.position();\n        var n2 = ele.target();\n        var n2pos = n2.position();\n        ex1 = n1pos.x;\n        ex2 = n2pos.x;\n        ey1 = n1pos.y;\n        ey2 = n2pos.y;\n\n        if (ex1 > ex2) {\n          var _temp2 = ex1;\n          ex1 = ex2;\n          ex2 = _temp2;\n        }\n\n        if (ey1 > ey2) {\n          var _temp3 = ey1;\n          ey1 = ey2;\n          ey2 = _temp3;\n        } // take into account edge width\n\n\n        ex1 -= wHalf;\n        ex2 += wHalf;\n        ey1 -= wHalf;\n        ey2 += wHalf;\n        updateBounds(bounds, ex1, ey1, ex2, ey2);\n      } // headless or style disabled\n\n    } // edges\n    // handle edge arrow size\n    /////////////////////////\n\n\n    if (styleEnabled && options.includeEdges && isEdge) {\n      updateBoundsFromArrow(bounds, ele, 'mid-source');\n      updateBoundsFromArrow(bounds, ele, 'mid-target');\n      updateBoundsFromArrow(bounds, ele, 'source');\n      updateBoundsFromArrow(bounds, ele, 'target');\n    } // ghost\n    ////////\n\n\n    if (styleEnabled) {\n      var ghost = ele.pstyle('ghost').value === 'yes';\n\n      if (ghost) {\n        var gx = ele.pstyle('ghost-offset-x').pfValue;\n        var gy = ele.pstyle('ghost-offset-y').pfValue;\n        updateBounds(bounds, bounds.x1 + gx, bounds.y1 + gy, bounds.x2 + gx, bounds.y2 + gy);\n      }\n    } // always store the body bounds separately from the labels\n\n\n    var bbBody = _p.bodyBounds = _p.bodyBounds || {};\n    assignBoundingBox(bbBody, bounds);\n    expandBoundingBoxSides(bbBody, manualExpansion);\n    expandBoundingBox(bbBody, 1); // expand to work around browser dimension inaccuracies\n    // overlay\n    //////////\n\n    if (styleEnabled) {\n      ex1 = bounds.x1;\n      ex2 = bounds.x2;\n      ey1 = bounds.y1;\n      ey2 = bounds.y2;\n      updateBounds(bounds, ex1 - padding, ey1 - padding, ex2 + padding, ey2 + padding);\n    } // always store the body bounds separately from the labels\n\n\n    var bbOverlay = _p.overlayBounds = _p.overlayBounds || {};\n    assignBoundingBox(bbOverlay, bounds);\n    expandBoundingBoxSides(bbOverlay, manualExpansion);\n    expandBoundingBox(bbOverlay, 1); // expand to work around browser dimension inaccuracies\n    // handle label dimensions\n    //////////////////////////\n\n    var bbLabels = _p.labelBounds = _p.labelBounds || {};\n\n    if (bbLabels.all != null) {\n      clearBoundingBox(bbLabels.all);\n    } else {\n      bbLabels.all = makeBoundingBox();\n    }\n\n    if (styleEnabled && options.includeLabels) {\n      if (options.includeMainLabels) {\n        updateBoundsFromLabel(bounds, ele, null);\n      }\n\n      if (isEdge) {\n        if (options.includeSourceLabels) {\n          updateBoundsFromLabel(bounds, ele, 'source');\n        }\n\n        if (options.includeTargetLabels) {\n          updateBoundsFromLabel(bounds, ele, 'target');\n        }\n      }\n    } // style enabled for labels\n\n  } // if displayed\n\n\n  bounds.x1 = noninf(bounds.x1);\n  bounds.y1 = noninf(bounds.y1);\n  bounds.x2 = noninf(bounds.x2);\n  bounds.y2 = noninf(bounds.y2);\n  bounds.w = noninf(bounds.x2 - bounds.x1);\n  bounds.h = noninf(bounds.y2 - bounds.y1);\n\n  if (bounds.w > 0 && bounds.h > 0 && displayed) {\n    expandBoundingBoxSides(bounds, manualExpansion); // expand bounds by 1 because antialiasing can increase the visual/effective size by 1 on all sides\n\n    expandBoundingBox(bounds, 1);\n  }\n\n  return bounds;\n};\n\nvar getKey = function getKey(opts) {\n  var i = 0;\n\n  var tf = function tf(val) {\n    return (val ? 1 : 0) << i++;\n  };\n\n  var key = 0;\n  key += tf(opts.incudeNodes);\n  key += tf(opts.includeEdges);\n  key += tf(opts.includeLabels);\n  key += tf(opts.includeMainLabels);\n  key += tf(opts.includeSourceLabels);\n  key += tf(opts.includeTargetLabels);\n  key += tf(opts.includeOverlays);\n  return key;\n};\n\nvar getBoundingBoxPosKey = function getBoundingBoxPosKey(ele) {\n  if (ele.isEdge()) {\n    var p1 = ele.source().position();\n    var p2 = ele.target().position();\n\n    var r = function r(x) {\n      return Math.round(x);\n    };\n\n    return hashIntsArray([r(p1.x), r(p1.y), r(p2.x), r(p2.y)]);\n  } else {\n    return 0;\n  }\n};\n\nvar cachedBoundingBoxImpl = function cachedBoundingBoxImpl(ele, opts) {\n  var _p = ele._private;\n  var bb;\n  var isEdge = ele.isEdge();\n  var key = opts == null ? defBbOptsKey : getKey(opts);\n  var usingDefOpts = key === defBbOptsKey;\n  var currPosKey = getBoundingBoxPosKey(ele);\n  var isPosKeySame = _p.bbCachePosKey === currPosKey;\n  var useCache = opts.useCache && isPosKeySame;\n\n  var isDirty = function isDirty(ele) {\n    return ele._private.bbCache == null || ele._private.styleDirty;\n  };\n\n  var needRecalc = !useCache || isDirty(ele) || isEdge && isDirty(ele.source()) || isDirty(ele.target());\n\n  if (needRecalc) {\n    if (!isPosKeySame) {\n      ele.recalculateRenderedStyle(useCache);\n    }\n\n    bb = boundingBoxImpl(ele, defBbOpts);\n    _p.bbCache = bb;\n    _p.bbCachePosKey = currPosKey;\n  } else {\n    bb = _p.bbCache;\n  } // not using def opts => need to build up bb from combination of sub bbs\n\n\n  if (!usingDefOpts) {\n    var isNode = ele.isNode();\n    bb = makeBoundingBox();\n\n    if (opts.includeNodes && isNode || opts.includeEdges && !isNode) {\n      if (opts.includeOverlays) {\n        updateBoundsFromBox(bb, _p.overlayBounds);\n      } else {\n        updateBoundsFromBox(bb, _p.bodyBounds);\n      }\n    }\n\n    if (opts.includeLabels) {\n      if (opts.includeMainLabels && (!isEdge || opts.includeSourceLabels && opts.includeTargetLabels)) {\n        updateBoundsFromBox(bb, _p.labelBounds.all);\n      } else {\n        if (opts.includeMainLabels) {\n          updateBoundsFromBox(bb, _p.labelBounds.mainRot);\n        }\n\n        if (opts.includeSourceLabels) {\n          updateBoundsFromBox(bb, _p.labelBounds.sourceRot);\n        }\n\n        if (opts.includeTargetLabels) {\n          updateBoundsFromBox(bb, _p.labelBounds.targetRot);\n        }\n      }\n    }\n\n    bb.w = bb.x2 - bb.x1;\n    bb.h = bb.y2 - bb.y1;\n  }\n\n  return bb;\n};\n\nvar defBbOpts = {\n  includeNodes: true,\n  includeEdges: true,\n  includeLabels: true,\n  includeMainLabels: true,\n  includeSourceLabels: true,\n  includeTargetLabels: true,\n  includeOverlays: true,\n  includeUnderlays: true,\n  useCache: true\n};\nvar defBbOptsKey = getKey(defBbOpts);\nvar filledBbOpts = defaults$g(defBbOpts);\n\nelesfn$b.boundingBox = function (options) {\n  var bounds; // the main usecase is ele.boundingBox() for a single element with no/def options\n  // specified s.t. the cache is used, so check for this case to make it faster by\n  // avoiding the overhead of the rest of the function\n\n  if (this.length === 1 && this[0]._private.bbCache != null && !this[0]._private.styleDirty && (options === undefined || options.useCache === undefined || options.useCache === true)) {\n    if (options === undefined) {\n      options = defBbOpts;\n    } else {\n      options = filledBbOpts(options);\n    }\n\n    bounds = cachedBoundingBoxImpl(this[0], options);\n  } else {\n    bounds = makeBoundingBox();\n    options = options || defBbOpts;\n    var opts = filledBbOpts(options);\n    var eles = this;\n    var cy = eles.cy();\n    var styleEnabled = cy.styleEnabled();\n\n    if (styleEnabled) {\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        var _p = ele._private;\n        var currPosKey = getBoundingBoxPosKey(ele);\n        var isPosKeySame = _p.bbCachePosKey === currPosKey;\n        var useCache = opts.useCache && isPosKeySame && !_p.styleDirty;\n        ele.recalculateRenderedStyle(useCache);\n      }\n    }\n\n    this.updateCompoundBounds(!options.useCache);\n\n    for (var _i = 0; _i < eles.length; _i++) {\n      var _ele = eles[_i];\n      updateBoundsFromBox(bounds, cachedBoundingBoxImpl(_ele, opts));\n    }\n  }\n\n  bounds.x1 = noninf(bounds.x1);\n  bounds.y1 = noninf(bounds.y1);\n  bounds.x2 = noninf(bounds.x2);\n  bounds.y2 = noninf(bounds.y2);\n  bounds.w = noninf(bounds.x2 - bounds.x1);\n  bounds.h = noninf(bounds.y2 - bounds.y1);\n  return bounds;\n};\n\nelesfn$b.dirtyBoundingBoxCache = function () {\n  for (var i = 0; i < this.length; i++) {\n    var _p = this[i]._private;\n    _p.bbCache = null;\n    _p.bbCachePosKey = null;\n    _p.bodyBounds = null;\n    _p.overlayBounds = null;\n    _p.labelBounds.all = null;\n    _p.labelBounds.source = null;\n    _p.labelBounds.target = null;\n    _p.labelBounds.main = null;\n    _p.labelBounds.sourceRot = null;\n    _p.labelBounds.targetRot = null;\n    _p.labelBounds.mainRot = null;\n    _p.arrowBounds.source = null;\n    _p.arrowBounds.target = null;\n    _p.arrowBounds['mid-source'] = null;\n    _p.arrowBounds['mid-target'] = null;\n  }\n\n  this.emitAndNotify('bounds');\n  return this;\n}; // private helper to get bounding box for custom node positions\n// - good for perf in certain cases but currently requires dirtying the rendered style\n// - would be better to not modify the nodes but the nodes are read directly everywhere in the renderer...\n// - try to use for only things like discrete layouts where the node position would change anyway\n\n\nelesfn$b.boundingBoxAt = function (fn) {\n  var nodes = this.nodes();\n  var cy = this.cy();\n  var hasCompoundNodes = cy.hasCompoundNodes();\n  var parents = cy.collection();\n\n  if (hasCompoundNodes) {\n    parents = nodes.filter(function (node) {\n      return node.isParent();\n    });\n    nodes = nodes.not(parents);\n  }\n\n  if (plainObject(fn)) {\n    var obj = fn;\n\n    fn = function fn() {\n      return obj;\n    };\n  }\n\n  var storeOldPos = function storeOldPos(node, i) {\n    return node._private.bbAtOldPos = fn(node, i);\n  };\n\n  var getOldPos = function getOldPos(node) {\n    return node._private.bbAtOldPos;\n  };\n\n  cy.startBatch();\n  nodes.forEach(storeOldPos).silentPositions(fn);\n\n  if (hasCompoundNodes) {\n    parents.dirtyCompoundBoundsCache();\n    parents.dirtyBoundingBoxCache();\n    parents.updateCompoundBounds(true); // force update b/c we're inside a batch cycle\n  }\n\n  var bb = copyBoundingBox(this.boundingBox({\n    useCache: false\n  }));\n  nodes.silentPositions(getOldPos);\n\n  if (hasCompoundNodes) {\n    parents.dirtyCompoundBoundsCache();\n    parents.dirtyBoundingBoxCache();\n    parents.updateCompoundBounds(true); // force update b/c we're inside a batch cycle\n  }\n\n  cy.endBatch();\n  return bb;\n};\n\nfn$3.boundingbox = fn$3.bb = fn$3.boundingBox;\nfn$3.renderedBoundingbox = fn$3.renderedBoundingBox;\nvar bounds = elesfn$b;\n\nvar fn$2, elesfn$a;\nfn$2 = elesfn$a = {};\n\nvar defineDimFns = function defineDimFns(opts) {\n  opts.uppercaseName = capitalize(opts.name);\n  opts.autoName = 'auto' + opts.uppercaseName;\n  opts.labelName = 'label' + opts.uppercaseName;\n  opts.outerName = 'outer' + opts.uppercaseName;\n  opts.uppercaseOuterName = capitalize(opts.outerName);\n\n  fn$2[opts.name] = function dimImpl() {\n    var ele = this[0];\n    var _p = ele._private;\n    var cy = _p.cy;\n    var styleEnabled = cy._private.styleEnabled;\n\n    if (ele) {\n      if (styleEnabled) {\n        if (ele.isParent()) {\n          ele.updateCompoundBounds();\n          return _p[opts.autoName] || 0;\n        }\n\n        var d = ele.pstyle(opts.name);\n\n        switch (d.strValue) {\n          case 'label':\n            ele.recalculateRenderedStyle();\n            return _p.rstyle[opts.labelName] || 0;\n\n          default:\n            return d.pfValue;\n        }\n      } else {\n        return 1;\n      }\n    }\n  };\n\n  fn$2['outer' + opts.uppercaseName] = function outerDimImpl() {\n    var ele = this[0];\n    var _p = ele._private;\n    var cy = _p.cy;\n    var styleEnabled = cy._private.styleEnabled;\n\n    if (ele) {\n      if (styleEnabled) {\n        var dim = ele[opts.name]();\n        var border = ele.pstyle('border-width').pfValue; // n.b. 1/2 each side\n\n        var padding = 2 * ele.padding();\n        return dim + border + padding;\n      } else {\n        return 1;\n      }\n    }\n  };\n\n  fn$2['rendered' + opts.uppercaseName] = function renderedDimImpl() {\n    var ele = this[0];\n\n    if (ele) {\n      var d = ele[opts.name]();\n      return d * this.cy().zoom();\n    }\n  };\n\n  fn$2['rendered' + opts.uppercaseOuterName] = function renderedOuterDimImpl() {\n    var ele = this[0];\n\n    if (ele) {\n      var od = ele[opts.outerName]();\n      return od * this.cy().zoom();\n    }\n  };\n};\n\ndefineDimFns({\n  name: 'width'\n});\ndefineDimFns({\n  name: 'height'\n});\n\nelesfn$a.padding = function () {\n  var ele = this[0];\n  var _p = ele._private;\n\n  if (ele.isParent()) {\n    ele.updateCompoundBounds();\n\n    if (_p.autoPadding !== undefined) {\n      return _p.autoPadding;\n    } else {\n      return ele.pstyle('padding').pfValue;\n    }\n  } else {\n    return ele.pstyle('padding').pfValue;\n  }\n};\n\nelesfn$a.paddedHeight = function () {\n  var ele = this[0];\n  return ele.height() + 2 * ele.padding();\n};\n\nelesfn$a.paddedWidth = function () {\n  var ele = this[0];\n  return ele.width() + 2 * ele.padding();\n};\n\nvar widthHeight = elesfn$a;\n\nvar ifEdge = function ifEdge(ele, getValue) {\n  if (ele.isEdge()) {\n    return getValue(ele);\n  }\n};\n\nvar ifEdgeRenderedPosition = function ifEdgeRenderedPosition(ele, getPoint) {\n  if (ele.isEdge()) {\n    var cy = ele.cy();\n    return modelToRenderedPosition(getPoint(ele), cy.zoom(), cy.pan());\n  }\n};\n\nvar ifEdgeRenderedPositions = function ifEdgeRenderedPositions(ele, getPoints) {\n  if (ele.isEdge()) {\n    var cy = ele.cy();\n    var pan = cy.pan();\n    var zoom = cy.zoom();\n    return getPoints(ele).map(function (p) {\n      return modelToRenderedPosition(p, zoom, pan);\n    });\n  }\n};\n\nvar controlPoints = function controlPoints(ele) {\n  return ele.renderer().getControlPoints(ele);\n};\n\nvar segmentPoints = function segmentPoints(ele) {\n  return ele.renderer().getSegmentPoints(ele);\n};\n\nvar sourceEndpoint = function sourceEndpoint(ele) {\n  return ele.renderer().getSourceEndpoint(ele);\n};\n\nvar targetEndpoint = function targetEndpoint(ele) {\n  return ele.renderer().getTargetEndpoint(ele);\n};\n\nvar midpoint = function midpoint(ele) {\n  return ele.renderer().getEdgeMidpoint(ele);\n};\n\nvar pts = {\n  controlPoints: {\n    get: controlPoints,\n    mult: true\n  },\n  segmentPoints: {\n    get: segmentPoints,\n    mult: true\n  },\n  sourceEndpoint: {\n    get: sourceEndpoint\n  },\n  targetEndpoint: {\n    get: targetEndpoint\n  },\n  midpoint: {\n    get: midpoint\n  }\n};\n\nvar renderedName = function renderedName(name) {\n  return 'rendered' + name[0].toUpperCase() + name.substr(1);\n};\n\nvar edgePoints = Object.keys(pts).reduce(function (obj, name) {\n  var spec = pts[name];\n  var rName = renderedName(name);\n\n  obj[name] = function () {\n    return ifEdge(this, spec.get);\n  };\n\n  if (spec.mult) {\n    obj[rName] = function () {\n      return ifEdgeRenderedPositions(this, spec.get);\n    };\n  } else {\n    obj[rName] = function () {\n      return ifEdgeRenderedPosition(this, spec.get);\n    };\n  }\n\n  return obj;\n}, {});\n\nvar dimensions = extend({}, position, bounds, widthHeight, edgePoints);\n\n/*!\nEvent object based on jQuery events, MIT license\n\nhttps://jquery.org/license/\nhttps://tldrlegal.com/license/mit-license\nhttps://github.com/jquery/jquery/blob/master/src/event.js\n*/\nvar Event = function Event(src, props) {\n  this.recycle(src, props);\n};\n\nfunction returnFalse() {\n  return false;\n}\n\nfunction returnTrue() {\n  return true;\n} // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\n\nEvent.prototype = {\n  instanceString: function instanceString() {\n    return 'event';\n  },\n  recycle: function recycle(src, props) {\n    this.isImmediatePropagationStopped = this.isPropagationStopped = this.isDefaultPrevented = returnFalse;\n\n    if (src != null && src.preventDefault) {\n      // Browser Event object\n      this.type = src.type; // Events bubbling up the document may have been marked as prevented\n      // by a handler lower down the tree; reflect the correct value.\n\n      this.isDefaultPrevented = src.defaultPrevented ? returnTrue : returnFalse;\n    } else if (src != null && src.type) {\n      // Plain object containing all event details\n      props = src;\n    } else {\n      // Event string\n      this.type = src;\n    } // Put explicitly provided properties onto the event object\n\n\n    if (props != null) {\n      // more efficient to manually copy fields we use\n      this.originalEvent = props.originalEvent;\n      this.type = props.type != null ? props.type : this.type;\n      this.cy = props.cy;\n      this.target = props.target;\n      this.position = props.position;\n      this.renderedPosition = props.renderedPosition;\n      this.namespace = props.namespace;\n      this.layout = props.layout;\n    }\n\n    if (this.cy != null && this.position != null && this.renderedPosition == null) {\n      // create a rendered position based on the passed position\n      var pos = this.position;\n      var zoom = this.cy.zoom();\n      var pan = this.cy.pan();\n      this.renderedPosition = {\n        x: pos.x * zoom + pan.x,\n        y: pos.y * zoom + pan.y\n      };\n    } // Create a timestamp if incoming event doesn't have one\n\n\n    this.timeStamp = src && src.timeStamp || Date.now();\n  },\n  preventDefault: function preventDefault() {\n    this.isDefaultPrevented = returnTrue;\n    var e = this.originalEvent;\n\n    if (!e) {\n      return;\n    } // if preventDefault exists run it on the original event\n\n\n    if (e.preventDefault) {\n      e.preventDefault();\n    }\n  },\n  stopPropagation: function stopPropagation() {\n    this.isPropagationStopped = returnTrue;\n    var e = this.originalEvent;\n\n    if (!e) {\n      return;\n    } // if stopPropagation exists run it on the original event\n\n\n    if (e.stopPropagation) {\n      e.stopPropagation();\n    }\n  },\n  stopImmediatePropagation: function stopImmediatePropagation() {\n    this.isImmediatePropagationStopped = returnTrue;\n    this.stopPropagation();\n  },\n  isDefaultPrevented: returnFalse,\n  isPropagationStopped: returnFalse,\n  isImmediatePropagationStopped: returnFalse\n};\n\nvar eventRegex = /^([^.]+)(\\.(?:[^.]+))?$/; // regex for matching event strings (e.g. \"click.namespace\")\n\nvar universalNamespace = '.*'; // matches as if no namespace specified and prevents users from unbinding accidentally\n\nvar defaults$8 = {\n  qualifierCompare: function qualifierCompare(q1, q2) {\n    return q1 === q2;\n  },\n  eventMatches: function\n    /*context, listener, eventObj*/\n  eventMatches() {\n    return true;\n  },\n  addEventFields: function\n    /*context, evt*/\n  addEventFields() {},\n  callbackContext: function callbackContext(context\n  /*, listener, eventObj*/\n  ) {\n    return context;\n  },\n  beforeEmit: function\n    /* context, listener, eventObj */\n  beforeEmit() {},\n  afterEmit: function\n    /* context, listener, eventObj */\n  afterEmit() {},\n  bubble: function\n    /*context*/\n  bubble() {\n    return false;\n  },\n  parent: function\n    /*context*/\n  parent() {\n    return null;\n  },\n  context: null\n};\nvar defaultsKeys = Object.keys(defaults$8);\nvar emptyOpts = {};\n\nfunction Emitter() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyOpts;\n  var context = arguments.length > 1 ? arguments[1] : undefined;\n\n  // micro-optimisation vs Object.assign() -- reduces Element instantiation time\n  for (var i = 0; i < defaultsKeys.length; i++) {\n    var key = defaultsKeys[i];\n    this[key] = opts[key] || defaults$8[key];\n  }\n\n  this.context = context || this.context;\n  this.listeners = [];\n  this.emitting = 0;\n}\n\nvar p = Emitter.prototype;\n\nvar forEachEvent = function forEachEvent(self, handler, events, qualifier, callback, conf, confOverrides) {\n  if (fn$6(qualifier)) {\n    callback = qualifier;\n    qualifier = null;\n  }\n\n  if (confOverrides) {\n    if (conf == null) {\n      conf = confOverrides;\n    } else {\n      conf = extend({}, conf, confOverrides);\n    }\n  }\n\n  var eventList = array(events) ? events : events.split(/\\s+/);\n\n  for (var i = 0; i < eventList.length; i++) {\n    var evt = eventList[i];\n\n    if (emptyString(evt)) {\n      continue;\n    }\n\n    var match = evt.match(eventRegex); // type[.namespace]\n\n    if (match) {\n      var type = match[1];\n      var namespace = match[2] ? match[2] : null;\n      var ret = handler(self, evt, type, namespace, qualifier, callback, conf);\n\n      if (ret === false) {\n        break;\n      } // allow exiting early\n\n    }\n  }\n};\n\nvar makeEventObj = function makeEventObj(self, obj) {\n  self.addEventFields(self.context, obj);\n  return new Event(obj.type, obj);\n};\n\nvar forEachEventObj = function forEachEventObj(self, handler, events) {\n  if (event(events)) {\n    handler(self, events);\n    return;\n  } else if (plainObject(events)) {\n    handler(self, makeEventObj(self, events));\n    return;\n  }\n\n  var eventList = array(events) ? events : events.split(/\\s+/);\n\n  for (var i = 0; i < eventList.length; i++) {\n    var evt = eventList[i];\n\n    if (emptyString(evt)) {\n      continue;\n    }\n\n    var match = evt.match(eventRegex); // type[.namespace]\n\n    if (match) {\n      var type = match[1];\n      var namespace = match[2] ? match[2] : null;\n      var eventObj = makeEventObj(self, {\n        type: type,\n        namespace: namespace,\n        target: self.context\n      });\n      handler(self, eventObj);\n    }\n  }\n};\n\np.on = p.addListener = function (events, qualifier, callback, conf, confOverrides) {\n  forEachEvent(this, function (self, event, type, namespace, qualifier, callback, conf) {\n    if (fn$6(callback)) {\n      self.listeners.push({\n        event: event,\n        // full event string\n        callback: callback,\n        // callback to run\n        type: type,\n        // the event type (e.g. 'click')\n        namespace: namespace,\n        // the event namespace (e.g. \".foo\")\n        qualifier: qualifier,\n        // a restriction on whether to match this emitter\n        conf: conf // additional configuration\n\n      });\n    }\n  }, events, qualifier, callback, conf, confOverrides);\n  return this;\n};\n\np.one = function (events, qualifier, callback, conf) {\n  return this.on(events, qualifier, callback, conf, {\n    one: true\n  });\n};\n\np.removeListener = p.off = function (events, qualifier, callback, conf) {\n  var _this = this;\n\n  if (this.emitting !== 0) {\n    this.listeners = copyArray(this.listeners);\n  }\n\n  var listeners = this.listeners;\n\n  var _loop = function _loop(i) {\n    var listener = listeners[i];\n    forEachEvent(_this, function (self, event, type, namespace, qualifier, callback\n    /*, conf*/\n    ) {\n      if ((listener.type === type || events === '*') && (!namespace && listener.namespace !== '.*' || listener.namespace === namespace) && (!qualifier || self.qualifierCompare(listener.qualifier, qualifier)) && (!callback || listener.callback === callback)) {\n        listeners.splice(i, 1);\n        return false;\n      }\n    }, events, qualifier, callback, conf);\n  };\n\n  for (var i = listeners.length - 1; i >= 0; i--) {\n    _loop(i);\n  }\n\n  return this;\n};\n\np.removeAllListeners = function () {\n  return this.removeListener('*');\n};\n\np.emit = p.trigger = function (events, extraParams, manualCallback) {\n  var listeners = this.listeners;\n  var numListenersBeforeEmit = listeners.length;\n  this.emitting++;\n\n  if (!array(extraParams)) {\n    extraParams = [extraParams];\n  }\n\n  forEachEventObj(this, function (self, eventObj) {\n    if (manualCallback != null) {\n      listeners = [{\n        event: eventObj.event,\n        type: eventObj.type,\n        namespace: eventObj.namespace,\n        callback: manualCallback\n      }];\n      numListenersBeforeEmit = listeners.length;\n    }\n\n    var _loop2 = function _loop2(i) {\n      var listener = listeners[i];\n\n      if (listener.type === eventObj.type && (!listener.namespace || listener.namespace === eventObj.namespace || listener.namespace === universalNamespace) && self.eventMatches(self.context, listener, eventObj)) {\n        var args = [eventObj];\n\n        if (extraParams != null) {\n          push(args, extraParams);\n        }\n\n        self.beforeEmit(self.context, listener, eventObj);\n\n        if (listener.conf && listener.conf.one) {\n          self.listeners = self.listeners.filter(function (l) {\n            return l !== listener;\n          });\n        }\n\n        var context = self.callbackContext(self.context, listener, eventObj);\n        var ret = listener.callback.apply(context, args);\n        self.afterEmit(self.context, listener, eventObj);\n\n        if (ret === false) {\n          eventObj.stopPropagation();\n          eventObj.preventDefault();\n        }\n      } // if listener matches\n\n    };\n\n    for (var i = 0; i < numListenersBeforeEmit; i++) {\n      _loop2(i);\n    } // for listener\n\n\n    if (self.bubble(self.context) && !eventObj.isPropagationStopped()) {\n      self.parent(self.context).emit(eventObj, extraParams);\n    }\n  }, events);\n  this.emitting--;\n  return this;\n};\n\nvar emitterOptions$1 = {\n  qualifierCompare: function qualifierCompare(selector1, selector2) {\n    if (selector1 == null || selector2 == null) {\n      return selector1 == null && selector2 == null;\n    } else {\n      return selector1.sameText(selector2);\n    }\n  },\n  eventMatches: function eventMatches(ele, listener, eventObj) {\n    var selector = listener.qualifier;\n\n    if (selector != null) {\n      return ele !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);\n    }\n\n    return true;\n  },\n  addEventFields: function addEventFields(ele, evt) {\n    evt.cy = ele.cy();\n    evt.target = ele;\n  },\n  callbackContext: function callbackContext(ele, listener, eventObj) {\n    return listener.qualifier != null ? eventObj.target : ele;\n  },\n  beforeEmit: function beforeEmit(context, listener\n  /*, eventObj*/\n  ) {\n    if (listener.conf && listener.conf.once) {\n      listener.conf.onceCollection.removeListener(listener.event, listener.qualifier, listener.callback);\n    }\n  },\n  bubble: function bubble() {\n    return true;\n  },\n  parent: function parent(ele) {\n    return ele.isChild() ? ele.parent() : ele.cy();\n  }\n};\n\nvar argSelector$1 = function argSelector(arg) {\n  if (string(arg)) {\n    return new Selector(arg);\n  } else {\n    return arg;\n  }\n};\n\nvar elesfn$9 = {\n  createEmitter: function createEmitter() {\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      var _p = ele._private;\n\n      if (!_p.emitter) {\n        _p.emitter = new Emitter(emitterOptions$1, ele);\n      }\n    }\n\n    return this;\n  },\n  emitter: function emitter() {\n    return this._private.emitter;\n  },\n  on: function on(events, selector, callback) {\n    var argSel = argSelector$1(selector);\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      ele.emitter().on(events, argSel, callback);\n    }\n\n    return this;\n  },\n  removeListener: function removeListener(events, selector, callback) {\n    var argSel = argSelector$1(selector);\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      ele.emitter().removeListener(events, argSel, callback);\n    }\n\n    return this;\n  },\n  removeAllListeners: function removeAllListeners() {\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      ele.emitter().removeAllListeners();\n    }\n\n    return this;\n  },\n  one: function one(events, selector, callback) {\n    var argSel = argSelector$1(selector);\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      ele.emitter().one(events, argSel, callback);\n    }\n\n    return this;\n  },\n  once: function once(events, selector, callback) {\n    var argSel = argSelector$1(selector);\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      ele.emitter().on(events, argSel, callback, {\n        once: true,\n        onceCollection: this\n      });\n    }\n  },\n  emit: function emit(events, extraParams) {\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      ele.emitter().emit(events, extraParams);\n    }\n\n    return this;\n  },\n  emitAndNotify: function emitAndNotify(event, extraParams) {\n    // for internal use only\n    if (this.length === 0) {\n      return;\n    } // empty collections don't need to notify anything\n    // notify renderer\n\n\n    this.cy().notify(event, this);\n    this.emit(event, extraParams);\n    return this;\n  }\n};\ndefine.eventAliasesOn(elesfn$9);\n\nvar elesfn$8 = {\n  nodes: function nodes(selector) {\n    return this.filter(function (ele) {\n      return ele.isNode();\n    }).filter(selector);\n  },\n  edges: function edges(selector) {\n    return this.filter(function (ele) {\n      return ele.isEdge();\n    }).filter(selector);\n  },\n  // internal helper to get nodes and edges as separate collections with single iteration over elements\n  byGroup: function byGroup() {\n    var nodes = this.spawn();\n    var edges = this.spawn();\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n\n      if (ele.isNode()) {\n        nodes.push(ele);\n      } else {\n        edges.push(ele);\n      }\n    }\n\n    return {\n      nodes: nodes,\n      edges: edges\n    };\n  },\n  filter: function filter(_filter, thisArg) {\n    if (_filter === undefined) {\n      // check this first b/c it's the most common/performant case\n      return this;\n    } else if (string(_filter) || elementOrCollection(_filter)) {\n      return new Selector(_filter).filter(this);\n    } else if (fn$6(_filter)) {\n      var filterEles = this.spawn();\n      var eles = this;\n\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        var include = thisArg ? _filter.apply(thisArg, [ele, i, eles]) : _filter(ele, i, eles);\n\n        if (include) {\n          filterEles.push(ele);\n        }\n      }\n\n      return filterEles;\n    }\n\n    return this.spawn(); // if not handled by above, give 'em an empty collection\n  },\n  not: function not(toRemove) {\n    if (!toRemove) {\n      return this;\n    } else {\n      if (string(toRemove)) {\n        toRemove = this.filter(toRemove);\n      }\n\n      var elements = this.spawn();\n\n      for (var i = 0; i < this.length; i++) {\n        var element = this[i];\n        var remove = toRemove.has(element);\n\n        if (!remove) {\n          elements.push(element);\n        }\n      }\n\n      return elements;\n    }\n  },\n  absoluteComplement: function absoluteComplement() {\n    var cy = this.cy();\n    return cy.mutableElements().not(this);\n  },\n  intersect: function intersect(other) {\n    // if a selector is specified, then filter by it instead\n    if (string(other)) {\n      var selector = other;\n      return this.filter(selector);\n    }\n\n    var elements = this.spawn();\n    var col1 = this;\n    var col2 = other;\n    var col1Smaller = this.length < other.length;\n    var colS = col1Smaller ? col1 : col2;\n    var colL = col1Smaller ? col2 : col1;\n\n    for (var i = 0; i < colS.length; i++) {\n      var ele = colS[i];\n\n      if (colL.has(ele)) {\n        elements.push(ele);\n      }\n    }\n\n    return elements;\n  },\n  xor: function xor(other) {\n    var cy = this._private.cy;\n\n    if (string(other)) {\n      other = cy.$(other);\n    }\n\n    var elements = this.spawn();\n    var col1 = this;\n    var col2 = other;\n\n    var add = function add(col, other) {\n      for (var i = 0; i < col.length; i++) {\n        var ele = col[i];\n        var id = ele._private.data.id;\n        var inOther = other.hasElementWithId(id);\n\n        if (!inOther) {\n          elements.push(ele);\n        }\n      }\n    };\n\n    add(col1, col2);\n    add(col2, col1);\n    return elements;\n  },\n  diff: function diff(other) {\n    var cy = this._private.cy;\n\n    if (string(other)) {\n      other = cy.$(other);\n    }\n\n    var left = this.spawn();\n    var right = this.spawn();\n    var both = this.spawn();\n    var col1 = this;\n    var col2 = other;\n\n    var add = function add(col, other, retEles) {\n      for (var i = 0; i < col.length; i++) {\n        var ele = col[i];\n        var id = ele._private.data.id;\n        var inOther = other.hasElementWithId(id);\n\n        if (inOther) {\n          both.merge(ele);\n        } else {\n          retEles.push(ele);\n        }\n      }\n    };\n\n    add(col1, col2, left);\n    add(col2, col1, right);\n    return {\n      left: left,\n      right: right,\n      both: both\n    };\n  },\n  add: function add(toAdd) {\n    var cy = this._private.cy;\n\n    if (!toAdd) {\n      return this;\n    }\n\n    if (string(toAdd)) {\n      var selector = toAdd;\n      toAdd = cy.mutableElements().filter(selector);\n    }\n\n    var elements = this.spawnSelf();\n\n    for (var i = 0; i < toAdd.length; i++) {\n      var ele = toAdd[i];\n      var add = !this.has(ele);\n\n      if (add) {\n        elements.push(ele);\n      }\n    }\n\n    return elements;\n  },\n  // in place merge on calling collection\n  merge: function merge(toAdd) {\n    var _p = this._private;\n    var cy = _p.cy;\n\n    if (!toAdd) {\n      return this;\n    }\n\n    if (toAdd && string(toAdd)) {\n      var selector = toAdd;\n      toAdd = cy.mutableElements().filter(selector);\n    }\n\n    var map = _p.map;\n\n    for (var i = 0; i < toAdd.length; i++) {\n      var toAddEle = toAdd[i];\n      var id = toAddEle._private.data.id;\n      var add = !map.has(id);\n\n      if (add) {\n        var index = this.length++;\n        this[index] = toAddEle;\n        map.set(id, {\n          ele: toAddEle,\n          index: index\n        });\n      }\n    }\n\n    return this; // chaining\n  },\n  unmergeAt: function unmergeAt(i) {\n    var ele = this[i];\n    var id = ele.id();\n    var _p = this._private;\n    var map = _p.map; // remove ele\n\n    this[i] = undefined;\n    map[\"delete\"](id);\n    var unmergedLastEle = i === this.length - 1; // replace empty spot with last ele in collection\n\n    if (this.length > 1 && !unmergedLastEle) {\n      var lastEleI = this.length - 1;\n      var lastEle = this[lastEleI];\n      var lastEleId = lastEle._private.data.id;\n      this[lastEleI] = undefined;\n      this[i] = lastEle;\n      map.set(lastEleId, {\n        ele: lastEle,\n        index: i\n      });\n    } // the collection is now 1 ele smaller\n\n\n    this.length--;\n    return this;\n  },\n  // remove single ele in place in calling collection\n  unmergeOne: function unmergeOne(ele) {\n    ele = ele[0];\n    var _p = this._private;\n    var id = ele._private.data.id;\n    var map = _p.map;\n    var entry = map.get(id);\n\n    if (!entry) {\n      return this; // no need to remove\n    }\n\n    var i = entry.index;\n    this.unmergeAt(i);\n    return this;\n  },\n  // remove eles in place on calling collection\n  unmerge: function unmerge(toRemove) {\n    var cy = this._private.cy;\n\n    if (!toRemove) {\n      return this;\n    }\n\n    if (toRemove && string(toRemove)) {\n      var selector = toRemove;\n      toRemove = cy.mutableElements().filter(selector);\n    }\n\n    for (var i = 0; i < toRemove.length; i++) {\n      this.unmergeOne(toRemove[i]);\n    }\n\n    return this; // chaining\n  },\n  unmergeBy: function unmergeBy(toRmFn) {\n    for (var i = this.length - 1; i >= 0; i--) {\n      var ele = this[i];\n\n      if (toRmFn(ele)) {\n        this.unmergeAt(i);\n      }\n    }\n\n    return this;\n  },\n  map: function map(mapFn, thisArg) {\n    var arr = [];\n    var eles = this;\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      var ret = thisArg ? mapFn.apply(thisArg, [ele, i, eles]) : mapFn(ele, i, eles);\n      arr.push(ret);\n    }\n\n    return arr;\n  },\n  reduce: function reduce(fn, initialValue) {\n    var val = initialValue;\n    var eles = this;\n\n    for (var i = 0; i < eles.length; i++) {\n      val = fn(val, eles[i], i, eles);\n    }\n\n    return val;\n  },\n  max: function max(valFn, thisArg) {\n    var max = -Infinity;\n    var maxEle;\n    var eles = this;\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);\n\n      if (val > max) {\n        max = val;\n        maxEle = ele;\n      }\n    }\n\n    return {\n      value: max,\n      ele: maxEle\n    };\n  },\n  min: function min(valFn, thisArg) {\n    var min = Infinity;\n    var minEle;\n    var eles = this;\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);\n\n      if (val < min) {\n        min = val;\n        minEle = ele;\n      }\n    }\n\n    return {\n      value: min,\n      ele: minEle\n    };\n  }\n}; // aliases\n\nvar fn$1 = elesfn$8;\nfn$1['u'] = fn$1['|'] = fn$1['+'] = fn$1.union = fn$1.or = fn$1.add;\nfn$1['\\\\'] = fn$1['!'] = fn$1['-'] = fn$1.difference = fn$1.relativeComplement = fn$1.subtract = fn$1.not;\nfn$1['n'] = fn$1['&'] = fn$1['.'] = fn$1.and = fn$1.intersection = fn$1.intersect;\nfn$1['^'] = fn$1['(+)'] = fn$1['(-)'] = fn$1.symmetricDifference = fn$1.symdiff = fn$1.xor;\nfn$1.fnFilter = fn$1.filterFn = fn$1.stdFilter = fn$1.filter;\nfn$1.complement = fn$1.abscomp = fn$1.absoluteComplement;\n\nvar elesfn$7 = {\n  isNode: function isNode() {\n    return this.group() === 'nodes';\n  },\n  isEdge: function isEdge() {\n    return this.group() === 'edges';\n  },\n  isLoop: function isLoop() {\n    return this.isEdge() && this.source()[0] === this.target()[0];\n  },\n  isSimple: function isSimple() {\n    return this.isEdge() && this.source()[0] !== this.target()[0];\n  },\n  group: function group() {\n    var ele = this[0];\n\n    if (ele) {\n      return ele._private.group;\n    }\n  }\n};\n\n/**\n *  Elements are drawn in a specific order based on compound depth (low to high), the element type (nodes above edges),\n *  and z-index (low to high).  These styles affect how this applies:\n *\n *  z-compound-depth: May be `bottom | orphan | auto | top`.  The first drawn is `bottom`, then `orphan` which is the\n *      same depth as the root of the compound graph, followed by the default value `auto` which draws in order from\n *      root to leaves of the compound graph.  The last drawn is `top`.\n *  z-index-compare: May be `auto | manual`.  The default value is `auto` which always draws edges under nodes.\n *      `manual` ignores this convention and draws based on the `z-index` value setting.\n *  z-index: An integer value that affects the relative draw order of elements.  In general, an element with a higher\n *      `z-index` will be drawn on top of an element with a lower `z-index`.\n */\n\nvar zIndexSort = function zIndexSort(a, b) {\n  var cy = a.cy();\n  var hasCompoundNodes = cy.hasCompoundNodes();\n\n  function getDepth(ele) {\n    var style = ele.pstyle('z-compound-depth');\n\n    if (style.value === 'auto') {\n      return hasCompoundNodes ? ele.zDepth() : 0;\n    } else if (style.value === 'bottom') {\n      return -1;\n    } else if (style.value === 'top') {\n      return MAX_INT$1;\n    } // 'orphan'\n\n\n    return 0;\n  }\n\n  var depthDiff = getDepth(a) - getDepth(b);\n\n  if (depthDiff !== 0) {\n    return depthDiff;\n  }\n\n  function getEleDepth(ele) {\n    var style = ele.pstyle('z-index-compare');\n\n    if (style.value === 'auto') {\n      return ele.isNode() ? 1 : 0;\n    } // 'manual'\n\n\n    return 0;\n  }\n\n  var eleDiff = getEleDepth(a) - getEleDepth(b);\n\n  if (eleDiff !== 0) {\n    return eleDiff;\n  }\n\n  var zDiff = a.pstyle('z-index').value - b.pstyle('z-index').value;\n\n  if (zDiff !== 0) {\n    return zDiff;\n  } // compare indices in the core (order added to graph w/ last on top)\n\n\n  return a.poolIndex() - b.poolIndex();\n};\n\nvar elesfn$6 = {\n  forEach: function forEach(fn, thisArg) {\n    if (fn$6(fn)) {\n      var N = this.length;\n\n      for (var i = 0; i < N; i++) {\n        var ele = this[i];\n        var ret = thisArg ? fn.apply(thisArg, [ele, i, this]) : fn(ele, i, this);\n\n        if (ret === false) {\n          break;\n        } // exit each early on return false\n\n      }\n    }\n\n    return this;\n  },\n  toArray: function toArray() {\n    var array = [];\n\n    for (var i = 0; i < this.length; i++) {\n      array.push(this[i]);\n    }\n\n    return array;\n  },\n  slice: function slice(start, end) {\n    var array = [];\n    var thisSize = this.length;\n\n    if (end == null) {\n      end = thisSize;\n    }\n\n    if (start == null) {\n      start = 0;\n    }\n\n    if (start < 0) {\n      start = thisSize + start;\n    }\n\n    if (end < 0) {\n      end = thisSize + end;\n    }\n\n    for (var i = start; i >= 0 && i < end && i < thisSize; i++) {\n      array.push(this[i]);\n    }\n\n    return this.spawn(array);\n  },\n  size: function size() {\n    return this.length;\n  },\n  eq: function eq(i) {\n    return this[i] || this.spawn();\n  },\n  first: function first() {\n    return this[0] || this.spawn();\n  },\n  last: function last() {\n    return this[this.length - 1] || this.spawn();\n  },\n  empty: function empty() {\n    return this.length === 0;\n  },\n  nonempty: function nonempty() {\n    return !this.empty();\n  },\n  sort: function sort(sortFn) {\n    if (!fn$6(sortFn)) {\n      return this;\n    }\n\n    var sorted = this.toArray().sort(sortFn);\n    return this.spawn(sorted);\n  },\n  sortByZIndex: function sortByZIndex() {\n    return this.sort(zIndexSort);\n  },\n  zDepth: function zDepth() {\n    var ele = this[0];\n\n    if (!ele) {\n      return undefined;\n    } // let cy = ele.cy();\n\n\n    var _p = ele._private;\n    var group = _p.group;\n\n    if (group === 'nodes') {\n      var depth = _p.data.parent ? ele.parents().size() : 0;\n\n      if (!ele.isParent()) {\n        return MAX_INT$1 - 1; // childless nodes always on top\n      }\n\n      return depth;\n    } else {\n      var src = _p.source;\n      var tgt = _p.target;\n      var srcDepth = src.zDepth();\n      var tgtDepth = tgt.zDepth();\n      return Math.max(srcDepth, tgtDepth, 0); // depth of deepest parent\n    }\n  }\n};\nelesfn$6.each = elesfn$6.forEach;\n\nvar defineSymbolIterator = function defineSymbolIterator() {\n  var typeofUndef = \"undefined\" ;\n  var isIteratorSupported = (typeof Symbol === \"undefined\" ? \"undefined\" : _typeof(Symbol)) != typeofUndef && _typeof(Symbol.iterator) != typeofUndef; // eslint-disable-line no-undef\n\n  if (isIteratorSupported) {\n    elesfn$6[Symbol.iterator] = function () {\n      var _this = this;\n\n      // eslint-disable-line no-undef\n      var entry = {\n        value: undefined,\n        done: false\n      };\n      var i = 0;\n      var length = this.length;\n      return _defineProperty({\n        next: function next() {\n          if (i < length) {\n            entry.value = _this[i++];\n          } else {\n            entry.value = undefined;\n            entry.done = true;\n          }\n\n          return entry;\n        }\n      }, Symbol.iterator, function () {\n        // eslint-disable-line no-undef\n        return this;\n      });\n    };\n  }\n};\n\ndefineSymbolIterator();\n\nvar getLayoutDimensionOptions = defaults$g({\n  nodeDimensionsIncludeLabels: false\n});\nvar elesfn$5 = {\n  // Calculates and returns node dimensions { x, y } based on options given\n  layoutDimensions: function layoutDimensions(options) {\n    options = getLayoutDimensionOptions(options);\n    var dims;\n\n    if (!this.takesUpSpace()) {\n      dims = {\n        w: 0,\n        h: 0\n      };\n    } else if (options.nodeDimensionsIncludeLabels) {\n      var bbDim = this.boundingBox();\n      dims = {\n        w: bbDim.w,\n        h: bbDim.h\n      };\n    } else {\n      dims = {\n        w: this.outerWidth(),\n        h: this.outerHeight()\n      };\n    } // sanitise the dimensions for external layouts (avoid division by zero)\n\n\n    if (dims.w === 0 || dims.h === 0) {\n      dims.w = dims.h = 1;\n    }\n\n    return dims;\n  },\n  // using standard layout options, apply position function (w/ or w/o animation)\n  layoutPositions: function layoutPositions(layout, options, fn) {\n    var nodes = this.nodes().filter(function (n) {\n      return !n.isParent();\n    });\n    var cy = this.cy();\n    var layoutEles = options.eles; // nodes & edges\n\n    var getMemoizeKey = function getMemoizeKey(node) {\n      return node.id();\n    };\n\n    var fnMem = memoize(fn, getMemoizeKey); // memoized version of position function\n\n    layout.emit({\n      type: 'layoutstart',\n      layout: layout\n    });\n    layout.animations = [];\n\n    var calculateSpacing = function calculateSpacing(spacing, nodesBb, pos) {\n      var center = {\n        x: nodesBb.x1 + nodesBb.w / 2,\n        y: nodesBb.y1 + nodesBb.h / 2\n      };\n      var spacingVector = {\n        // scale from center of bounding box (not necessarily 0,0)\n        x: (pos.x - center.x) * spacing,\n        y: (pos.y - center.y) * spacing\n      };\n      return {\n        x: center.x + spacingVector.x,\n        y: center.y + spacingVector.y\n      };\n    };\n\n    var useSpacingFactor = options.spacingFactor && options.spacingFactor !== 1;\n\n    var spacingBb = function spacingBb() {\n      if (!useSpacingFactor) {\n        return null;\n      }\n\n      var bb = makeBoundingBox();\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var pos = fnMem(node, i);\n        expandBoundingBoxByPoint(bb, pos.x, pos.y);\n      }\n\n      return bb;\n    };\n\n    var bb = spacingBb();\n    var getFinalPos = memoize(function (node, i) {\n      var newPos = fnMem(node, i);\n\n      if (useSpacingFactor) {\n        var spacing = Math.abs(options.spacingFactor);\n        newPos = calculateSpacing(spacing, bb, newPos);\n      }\n\n      if (options.transform != null) {\n        newPos = options.transform(node, newPos);\n      }\n\n      return newPos;\n    }, getMemoizeKey);\n\n    if (options.animate) {\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var newPos = getFinalPos(node, i);\n        var animateNode = options.animateFilter == null || options.animateFilter(node, i);\n\n        if (animateNode) {\n          var ani = node.animation({\n            position: newPos,\n            duration: options.animationDuration,\n            easing: options.animationEasing\n          });\n          layout.animations.push(ani);\n        } else {\n          node.position(newPos);\n        }\n      }\n\n      if (options.fit) {\n        var fitAni = cy.animation({\n          fit: {\n            boundingBox: layoutEles.boundingBoxAt(getFinalPos),\n            padding: options.padding\n          },\n          duration: options.animationDuration,\n          easing: options.animationEasing\n        });\n        layout.animations.push(fitAni);\n      } else if (options.zoom !== undefined && options.pan !== undefined) {\n        var zoomPanAni = cy.animation({\n          zoom: options.zoom,\n          pan: options.pan,\n          duration: options.animationDuration,\n          easing: options.animationEasing\n        });\n        layout.animations.push(zoomPanAni);\n      }\n\n      layout.animations.forEach(function (ani) {\n        return ani.play();\n      });\n      layout.one('layoutready', options.ready);\n      layout.emit({\n        type: 'layoutready',\n        layout: layout\n      });\n      Promise$1.all(layout.animations.map(function (ani) {\n        return ani.promise();\n      })).then(function () {\n        layout.one('layoutstop', options.stop);\n        layout.emit({\n          type: 'layoutstop',\n          layout: layout\n        });\n      });\n    } else {\n      nodes.positions(getFinalPos);\n\n      if (options.fit) {\n        cy.fit(options.eles, options.padding);\n      }\n\n      if (options.zoom != null) {\n        cy.zoom(options.zoom);\n      }\n\n      if (options.pan) {\n        cy.pan(options.pan);\n      }\n\n      layout.one('layoutready', options.ready);\n      layout.emit({\n        type: 'layoutready',\n        layout: layout\n      });\n      layout.one('layoutstop', options.stop);\n      layout.emit({\n        type: 'layoutstop',\n        layout: layout\n      });\n    }\n\n    return this; // chaining\n  },\n  layout: function layout(options) {\n    var cy = this.cy();\n    return cy.makeLayout(extend({}, options, {\n      eles: this\n    }));\n  }\n}; // aliases:\n\nelesfn$5.createLayout = elesfn$5.makeLayout = elesfn$5.layout;\n\nfunction styleCache(key, fn, ele) {\n  var _p = ele._private;\n  var cache = _p.styleCache = _p.styleCache || [];\n  var val;\n\n  if ((val = cache[key]) != null) {\n    return val;\n  } else {\n    val = cache[key] = fn(ele);\n    return val;\n  }\n}\n\nfunction cacheStyleFunction(key, fn) {\n  key = hashString(key);\n  return function cachedStyleFunction(ele) {\n    return styleCache(key, fn, ele);\n  };\n}\n\nfunction cachePrototypeStyleFunction(key, fn) {\n  key = hashString(key);\n\n  var selfFn = function selfFn(ele) {\n    return fn.call(ele);\n  };\n\n  return function cachedPrototypeStyleFunction() {\n    var ele = this[0];\n\n    if (ele) {\n      return styleCache(key, selfFn, ele);\n    }\n  };\n}\n\nvar elesfn$4 = {\n  recalculateRenderedStyle: function recalculateRenderedStyle(useCache) {\n    var cy = this.cy();\n    var renderer = cy.renderer();\n    var styleEnabled = cy.styleEnabled();\n\n    if (renderer && styleEnabled) {\n      renderer.recalculateRenderedStyle(this, useCache);\n    }\n\n    return this;\n  },\n  dirtyStyleCache: function dirtyStyleCache() {\n    var cy = this.cy();\n\n    var dirty = function dirty(ele) {\n      return ele._private.styleCache = null;\n    };\n\n    if (cy.hasCompoundNodes()) {\n      var eles;\n      eles = this.spawnSelf().merge(this.descendants()).merge(this.parents());\n      eles.merge(eles.connectedEdges());\n      eles.forEach(dirty);\n    } else {\n      this.forEach(function (ele) {\n        dirty(ele);\n        ele.connectedEdges().forEach(dirty);\n      });\n    }\n\n    return this;\n  },\n  // fully updates (recalculates) the style for the elements\n  updateStyle: function updateStyle(notifyRenderer) {\n    var cy = this._private.cy;\n\n    if (!cy.styleEnabled()) {\n      return this;\n    }\n\n    if (cy.batching()) {\n      var bEles = cy._private.batchStyleEles;\n      bEles.merge(this);\n      return this; // chaining and exit early when batching\n    }\n\n    var hasCompounds = cy.hasCompoundNodes();\n    var updatedEles = this;\n    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;\n\n    if (hasCompounds) {\n      // then add everything up and down for compound selector checks\n      updatedEles = this.spawnSelf().merge(this.descendants()).merge(this.parents());\n    } // let changedEles = style.apply( updatedEles );\n\n\n    var changedEles = updatedEles;\n\n    if (notifyRenderer) {\n      changedEles.emitAndNotify('style'); // let renderer know we changed style\n    } else {\n      changedEles.emit('style'); // just fire the event\n    }\n\n    updatedEles.forEach(function (ele) {\n      return ele._private.styleDirty = true;\n    });\n    return this; // chaining\n  },\n  // private: clears dirty flag and recalculates style\n  cleanStyle: function cleanStyle() {\n    var cy = this.cy();\n\n    if (!cy.styleEnabled()) {\n      return;\n    }\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n\n      if (ele._private.styleDirty) {\n        // n.b. this flag should be set before apply() to avoid potential infinite recursion\n        ele._private.styleDirty = false;\n        cy.style().apply(ele);\n      }\n    }\n  },\n  // get the internal parsed style object for the specified property\n  parsedStyle: function parsedStyle(property) {\n    var includeNonDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var ele = this[0];\n    var cy = ele.cy();\n\n    if (!cy.styleEnabled()) {\n      return;\n    }\n\n    if (ele) {\n      this.cleanStyle();\n      var overriddenStyle = ele._private.style[property];\n\n      if (overriddenStyle != null) {\n        return overriddenStyle;\n      } else if (includeNonDefault) {\n        return cy.style().getDefaultProperty(property);\n      } else {\n        return null;\n      }\n    }\n  },\n  numericStyle: function numericStyle(property) {\n    var ele = this[0];\n\n    if (!ele.cy().styleEnabled()) {\n      return;\n    }\n\n    if (ele) {\n      var pstyle = ele.pstyle(property);\n      return pstyle.pfValue !== undefined ? pstyle.pfValue : pstyle.value;\n    }\n  },\n  numericStyleUnits: function numericStyleUnits(property) {\n    var ele = this[0];\n\n    if (!ele.cy().styleEnabled()) {\n      return;\n    }\n\n    if (ele) {\n      return ele.pstyle(property).units;\n    }\n  },\n  // get the specified css property as a rendered value (i.e. on-screen value)\n  // or get the whole rendered style if no property specified (NB doesn't allow setting)\n  renderedStyle: function renderedStyle(property) {\n    var cy = this.cy();\n\n    if (!cy.styleEnabled()) {\n      return this;\n    }\n\n    var ele = this[0];\n\n    if (ele) {\n      return cy.style().getRenderedStyle(ele, property);\n    }\n  },\n  // read the calculated css style of the element or override the style (via a bypass)\n  style: function style(name, value) {\n    var cy = this.cy();\n\n    if (!cy.styleEnabled()) {\n      return this;\n    }\n\n    var updateTransitions = false;\n    var style = cy.style();\n\n    if (plainObject(name)) {\n      // then extend the bypass\n      var props = name;\n      style.applyBypass(this, props, updateTransitions);\n      this.emitAndNotify('style'); // let the renderer know we've updated style\n    } else if (string(name)) {\n      if (value === undefined) {\n        // then get the property from the style\n        var ele = this[0];\n\n        if (ele) {\n          return style.getStylePropertyValue(ele, name);\n        } else {\n          // empty collection => can't get any value\n          return;\n        }\n      } else {\n        // then set the bypass with the property value\n        style.applyBypass(this, name, value, updateTransitions);\n        this.emitAndNotify('style'); // let the renderer know we've updated style\n      }\n    } else if (name === undefined) {\n      var _ele = this[0];\n\n      if (_ele) {\n        return style.getRawStyle(_ele);\n      } else {\n        // empty collection => can't get any value\n        return;\n      }\n    }\n\n    return this; // chaining\n  },\n  removeStyle: function removeStyle(names) {\n    var cy = this.cy();\n\n    if (!cy.styleEnabled()) {\n      return this;\n    }\n\n    var updateTransitions = false;\n    var style = cy.style();\n    var eles = this;\n\n    if (names === undefined) {\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        style.removeAllBypasses(ele, updateTransitions);\n      }\n    } else {\n      names = names.split(/\\s+/);\n\n      for (var _i = 0; _i < eles.length; _i++) {\n        var _ele2 = eles[_i];\n        style.removeBypasses(_ele2, names, updateTransitions);\n      }\n    }\n\n    this.emitAndNotify('style'); // let the renderer know we've updated style\n\n    return this; // chaining\n  },\n  show: function show() {\n    this.css('display', 'element');\n    return this; // chaining\n  },\n  hide: function hide() {\n    this.css('display', 'none');\n    return this; // chaining\n  },\n  effectiveOpacity: function effectiveOpacity() {\n    var cy = this.cy();\n\n    if (!cy.styleEnabled()) {\n      return 1;\n    }\n\n    var hasCompoundNodes = cy.hasCompoundNodes();\n    var ele = this[0];\n\n    if (ele) {\n      var _p = ele._private;\n      var parentOpacity = ele.pstyle('opacity').value;\n\n      if (!hasCompoundNodes) {\n        return parentOpacity;\n      }\n\n      var parents = !_p.data.parent ? null : ele.parents();\n\n      if (parents) {\n        for (var i = 0; i < parents.length; i++) {\n          var parent = parents[i];\n          var opacity = parent.pstyle('opacity').value;\n          parentOpacity = opacity * parentOpacity;\n        }\n      }\n\n      return parentOpacity;\n    }\n  },\n  transparent: function transparent() {\n    var cy = this.cy();\n\n    if (!cy.styleEnabled()) {\n      return false;\n    }\n\n    var ele = this[0];\n    var hasCompoundNodes = ele.cy().hasCompoundNodes();\n\n    if (ele) {\n      if (!hasCompoundNodes) {\n        return ele.pstyle('opacity').value === 0;\n      } else {\n        return ele.effectiveOpacity() === 0;\n      }\n    }\n  },\n  backgrounding: function backgrounding() {\n    var cy = this.cy();\n\n    if (!cy.styleEnabled()) {\n      return false;\n    }\n\n    var ele = this[0];\n    return ele._private.backgrounding ? true : false;\n  }\n};\n\nfunction checkCompound(ele, parentOk) {\n  var _p = ele._private;\n  var parents = _p.data.parent ? ele.parents() : null;\n\n  if (parents) {\n    for (var i = 0; i < parents.length; i++) {\n      var parent = parents[i];\n\n      if (!parentOk(parent)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction defineDerivedStateFunction(specs) {\n  var ok = specs.ok;\n  var edgeOkViaNode = specs.edgeOkViaNode || specs.ok;\n  var parentOk = specs.parentOk || specs.ok;\n  return function () {\n    var cy = this.cy();\n\n    if (!cy.styleEnabled()) {\n      return true;\n    }\n\n    var ele = this[0];\n    var hasCompoundNodes = cy.hasCompoundNodes();\n\n    if (ele) {\n      var _p = ele._private;\n\n      if (!ok(ele)) {\n        return false;\n      }\n\n      if (ele.isNode()) {\n        return !hasCompoundNodes || checkCompound(ele, parentOk);\n      } else {\n        var src = _p.source;\n        var tgt = _p.target;\n        return edgeOkViaNode(src) && (!hasCompoundNodes || checkCompound(src, edgeOkViaNode)) && (src === tgt || edgeOkViaNode(tgt) && (!hasCompoundNodes || checkCompound(tgt, edgeOkViaNode)));\n      }\n    }\n  };\n}\n\nvar eleTakesUpSpace = cacheStyleFunction('eleTakesUpSpace', function (ele) {\n  return ele.pstyle('display').value === 'element' && ele.width() !== 0 && (ele.isNode() ? ele.height() !== 0 : true);\n});\nelesfn$4.takesUpSpace = cachePrototypeStyleFunction('takesUpSpace', defineDerivedStateFunction({\n  ok: eleTakesUpSpace\n}));\nvar eleInteractive = cacheStyleFunction('eleInteractive', function (ele) {\n  return ele.pstyle('events').value === 'yes' && ele.pstyle('visibility').value === 'visible' && eleTakesUpSpace(ele);\n});\nvar parentInteractive = cacheStyleFunction('parentInteractive', function (parent) {\n  return parent.pstyle('visibility').value === 'visible' && eleTakesUpSpace(parent);\n});\nelesfn$4.interactive = cachePrototypeStyleFunction('interactive', defineDerivedStateFunction({\n  ok: eleInteractive,\n  parentOk: parentInteractive,\n  edgeOkViaNode: eleTakesUpSpace\n}));\n\nelesfn$4.noninteractive = function () {\n  var ele = this[0];\n\n  if (ele) {\n    return !ele.interactive();\n  }\n};\n\nvar eleVisible = cacheStyleFunction('eleVisible', function (ele) {\n  return ele.pstyle('visibility').value === 'visible' && ele.pstyle('opacity').pfValue !== 0 && eleTakesUpSpace(ele);\n});\nvar edgeVisibleViaNode = eleTakesUpSpace;\nelesfn$4.visible = cachePrototypeStyleFunction('visible', defineDerivedStateFunction({\n  ok: eleVisible,\n  edgeOkViaNode: edgeVisibleViaNode\n}));\n\nelesfn$4.hidden = function () {\n  var ele = this[0];\n\n  if (ele) {\n    return !ele.visible();\n  }\n};\n\nelesfn$4.isBundledBezier = cachePrototypeStyleFunction('isBundledBezier', function () {\n  if (!this.cy().styleEnabled()) {\n    return false;\n  }\n\n  return !this.removed() && this.pstyle('curve-style').value === 'bezier' && this.takesUpSpace();\n});\nelesfn$4.bypass = elesfn$4.css = elesfn$4.style;\nelesfn$4.renderedCss = elesfn$4.renderedStyle;\nelesfn$4.removeBypass = elesfn$4.removeCss = elesfn$4.removeStyle;\nelesfn$4.pstyle = elesfn$4.parsedStyle;\n\nvar elesfn$3 = {};\n\nfunction defineSwitchFunction(params) {\n  return function () {\n    var args = arguments;\n    var changedEles = []; // e.g. cy.nodes().select( data, handler )\n\n    if (args.length === 2) {\n      var data = args[0];\n      var handler = args[1];\n      this.on(params.event, data, handler);\n    } // e.g. cy.nodes().select( handler )\n    else if (args.length === 1 && fn$6(args[0])) {\n      var _handler = args[0];\n      this.on(params.event, _handler);\n    } // e.g. cy.nodes().select()\n    // e.g. (private) cy.nodes().select(['tapselect'])\n    else if (args.length === 0 || args.length === 1 && array(args[0])) {\n      var addlEvents = args.length === 1 ? args[0] : null;\n\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        var able = !params.ableField || ele._private[params.ableField];\n        var changed = ele._private[params.field] != params.value;\n\n        if (params.overrideAble) {\n          var overrideAble = params.overrideAble(ele);\n\n          if (overrideAble !== undefined) {\n            able = overrideAble;\n\n            if (!overrideAble) {\n              return this;\n            } // to save cycles assume not able for all on override\n\n          }\n        }\n\n        if (able) {\n          ele._private[params.field] = params.value;\n\n          if (changed) {\n            changedEles.push(ele);\n          }\n        }\n      }\n\n      var changedColl = this.spawn(changedEles);\n      changedColl.updateStyle(); // change of state => possible change of style\n\n      changedColl.emit(params.event);\n\n      if (addlEvents) {\n        changedColl.emit(addlEvents);\n      }\n    }\n\n    return this;\n  };\n}\n\nfunction defineSwitchSet(params) {\n  elesfn$3[params.field] = function () {\n    var ele = this[0];\n\n    if (ele) {\n      if (params.overrideField) {\n        var val = params.overrideField(ele);\n\n        if (val !== undefined) {\n          return val;\n        }\n      }\n\n      return ele._private[params.field];\n    }\n  };\n\n  elesfn$3[params.on] = defineSwitchFunction({\n    event: params.on,\n    field: params.field,\n    ableField: params.ableField,\n    overrideAble: params.overrideAble,\n    value: true\n  });\n  elesfn$3[params.off] = defineSwitchFunction({\n    event: params.off,\n    field: params.field,\n    ableField: params.ableField,\n    overrideAble: params.overrideAble,\n    value: false\n  });\n}\n\ndefineSwitchSet({\n  field: 'locked',\n  overrideField: function overrideField(ele) {\n    return ele.cy().autolock() ? true : undefined;\n  },\n  on: 'lock',\n  off: 'unlock'\n});\ndefineSwitchSet({\n  field: 'grabbable',\n  overrideField: function overrideField(ele) {\n    return ele.cy().autoungrabify() || ele.pannable() ? false : undefined;\n  },\n  on: 'grabify',\n  off: 'ungrabify'\n});\ndefineSwitchSet({\n  field: 'selected',\n  ableField: 'selectable',\n  overrideAble: function overrideAble(ele) {\n    return ele.cy().autounselectify() ? false : undefined;\n  },\n  on: 'select',\n  off: 'unselect'\n});\ndefineSwitchSet({\n  field: 'selectable',\n  overrideField: function overrideField(ele) {\n    return ele.cy().autounselectify() ? false : undefined;\n  },\n  on: 'selectify',\n  off: 'unselectify'\n});\nelesfn$3.deselect = elesfn$3.unselect;\n\nelesfn$3.grabbed = function () {\n  var ele = this[0];\n\n  if (ele) {\n    return ele._private.grabbed;\n  }\n};\n\ndefineSwitchSet({\n  field: 'active',\n  on: 'activate',\n  off: 'unactivate'\n});\ndefineSwitchSet({\n  field: 'pannable',\n  on: 'panify',\n  off: 'unpanify'\n});\n\nelesfn$3.inactive = function () {\n  var ele = this[0];\n\n  if (ele) {\n    return !ele._private.active;\n  }\n};\n\nvar elesfn$2 = {}; // DAG functions\n////////////////\n\nvar defineDagExtremity = function defineDagExtremity(params) {\n  return function dagExtremityImpl(selector) {\n    var eles = this;\n    var ret = [];\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n\n      if (!ele.isNode()) {\n        continue;\n      }\n\n      var disqualified = false;\n      var edges = ele.connectedEdges();\n\n      for (var j = 0; j < edges.length; j++) {\n        var edge = edges[j];\n        var src = edge.source();\n        var tgt = edge.target();\n\n        if (params.noIncomingEdges && tgt === ele && src !== ele || params.noOutgoingEdges && src === ele && tgt !== ele) {\n          disqualified = true;\n          break;\n        }\n      }\n\n      if (!disqualified) {\n        ret.push(ele);\n      }\n    }\n\n    return this.spawn(ret, true).filter(selector);\n  };\n};\n\nvar defineDagOneHop = function defineDagOneHop(params) {\n  return function (selector) {\n    var eles = this;\n    var oEles = [];\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n\n      if (!ele.isNode()) {\n        continue;\n      }\n\n      var edges = ele.connectedEdges();\n\n      for (var j = 0; j < edges.length; j++) {\n        var edge = edges[j];\n        var src = edge.source();\n        var tgt = edge.target();\n\n        if (params.outgoing && src === ele) {\n          oEles.push(edge);\n          oEles.push(tgt);\n        } else if (params.incoming && tgt === ele) {\n          oEles.push(edge);\n          oEles.push(src);\n        }\n      }\n    }\n\n    return this.spawn(oEles, true).filter(selector);\n  };\n};\n\nvar defineDagAllHops = function defineDagAllHops(params) {\n  return function (selector) {\n    var eles = this;\n    var sEles = [];\n    var sElesIds = {};\n\n    for (;;) {\n      var next = params.outgoing ? eles.outgoers() : eles.incomers();\n\n      if (next.length === 0) {\n        break;\n      } // done if none left\n\n\n      var newNext = false;\n\n      for (var i = 0; i < next.length; i++) {\n        var n = next[i];\n        var nid = n.id();\n\n        if (!sElesIds[nid]) {\n          sElesIds[nid] = true;\n          sEles.push(n);\n          newNext = true;\n        }\n      }\n\n      if (!newNext) {\n        break;\n      } // done if touched all outgoers already\n\n\n      eles = next;\n    }\n\n    return this.spawn(sEles, true).filter(selector);\n  };\n};\n\nelesfn$2.clearTraversalCache = function () {\n  for (var i = 0; i < this.length; i++) {\n    this[i]._private.traversalCache = null;\n  }\n};\n\nextend(elesfn$2, {\n  // get the root nodes in the DAG\n  roots: defineDagExtremity({\n    noIncomingEdges: true\n  }),\n  // get the leaf nodes in the DAG\n  leaves: defineDagExtremity({\n    noOutgoingEdges: true\n  }),\n  // normally called children in graph theory\n  // these nodes =edges=> outgoing nodes\n  outgoers: cache(defineDagOneHop({\n    outgoing: true\n  }), 'outgoers'),\n  // aka DAG descendants\n  successors: defineDagAllHops({\n    outgoing: true\n  }),\n  // normally called parents in graph theory\n  // these nodes <=edges= incoming nodes\n  incomers: cache(defineDagOneHop({\n    incoming: true\n  }), 'incomers'),\n  // aka DAG ancestors\n  predecessors: defineDagAllHops({\n    incoming: true\n  })\n}); // Neighbourhood functions\n//////////////////////////\n\nextend(elesfn$2, {\n  neighborhood: cache(function (selector) {\n    var elements = [];\n    var nodes = this.nodes();\n\n    for (var i = 0; i < nodes.length; i++) {\n      // for all nodes\n      var node = nodes[i];\n      var connectedEdges = node.connectedEdges(); // for each connected edge, add the edge and the other node\n\n      for (var j = 0; j < connectedEdges.length; j++) {\n        var edge = connectedEdges[j];\n        var src = edge.source();\n        var tgt = edge.target();\n        var otherNode = node === src ? tgt : src; // need check in case of loop\n\n        if (otherNode.length > 0) {\n          elements.push(otherNode[0]); // add node 1 hop away\n        } // add connected edge\n\n\n        elements.push(edge[0]);\n      }\n    }\n\n    return this.spawn(elements, true).filter(selector);\n  }, 'neighborhood'),\n  closedNeighborhood: function closedNeighborhood(selector) {\n    return this.neighborhood().add(this).filter(selector);\n  },\n  openNeighborhood: function openNeighborhood(selector) {\n    return this.neighborhood(selector);\n  }\n}); // aliases\n\nelesfn$2.neighbourhood = elesfn$2.neighborhood;\nelesfn$2.closedNeighbourhood = elesfn$2.closedNeighborhood;\nelesfn$2.openNeighbourhood = elesfn$2.openNeighborhood; // Edge functions\n/////////////////\n\nextend(elesfn$2, {\n  source: cache(function sourceImpl(selector) {\n    var ele = this[0];\n    var src;\n\n    if (ele) {\n      src = ele._private.source || ele.cy().collection();\n    }\n\n    return src && selector ? src.filter(selector) : src;\n  }, 'source'),\n  target: cache(function targetImpl(selector) {\n    var ele = this[0];\n    var tgt;\n\n    if (ele) {\n      tgt = ele._private.target || ele.cy().collection();\n    }\n\n    return tgt && selector ? tgt.filter(selector) : tgt;\n  }, 'target'),\n  sources: defineSourceFunction({\n    attr: 'source'\n  }),\n  targets: defineSourceFunction({\n    attr: 'target'\n  })\n});\n\nfunction defineSourceFunction(params) {\n  return function sourceImpl(selector) {\n    var sources = [];\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      var src = ele._private[params.attr];\n\n      if (src) {\n        sources.push(src);\n      }\n    }\n\n    return this.spawn(sources, true).filter(selector);\n  };\n}\n\nextend(elesfn$2, {\n  edgesWith: cache(defineEdgesWithFunction(), 'edgesWith'),\n  edgesTo: cache(defineEdgesWithFunction({\n    thisIsSrc: true\n  }), 'edgesTo')\n});\n\nfunction defineEdgesWithFunction(params) {\n  return function edgesWithImpl(otherNodes) {\n    var elements = [];\n    var cy = this._private.cy;\n    var p = params || {}; // get elements if a selector is specified\n\n    if (string(otherNodes)) {\n      otherNodes = cy.$(otherNodes);\n    }\n\n    for (var h = 0; h < otherNodes.length; h++) {\n      var edges = otherNodes[h]._private.edges;\n\n      for (var i = 0; i < edges.length; i++) {\n        var edge = edges[i];\n        var edgeData = edge._private.data;\n        var thisToOther = this.hasElementWithId(edgeData.source) && otherNodes.hasElementWithId(edgeData.target);\n        var otherToThis = otherNodes.hasElementWithId(edgeData.source) && this.hasElementWithId(edgeData.target);\n        var edgeConnectsThisAndOther = thisToOther || otherToThis;\n\n        if (!edgeConnectsThisAndOther) {\n          continue;\n        }\n\n        if (p.thisIsSrc || p.thisIsTgt) {\n          if (p.thisIsSrc && !thisToOther) {\n            continue;\n          }\n\n          if (p.thisIsTgt && !otherToThis) {\n            continue;\n          }\n        }\n\n        elements.push(edge);\n      }\n    }\n\n    return this.spawn(elements, true);\n  };\n}\n\nextend(elesfn$2, {\n  connectedEdges: cache(function (selector) {\n    var retEles = [];\n    var eles = this;\n\n    for (var i = 0; i < eles.length; i++) {\n      var node = eles[i];\n\n      if (!node.isNode()) {\n        continue;\n      }\n\n      var edges = node._private.edges;\n\n      for (var j = 0; j < edges.length; j++) {\n        var edge = edges[j];\n        retEles.push(edge);\n      }\n    }\n\n    return this.spawn(retEles, true).filter(selector);\n  }, 'connectedEdges'),\n  connectedNodes: cache(function (selector) {\n    var retEles = [];\n    var eles = this;\n\n    for (var i = 0; i < eles.length; i++) {\n      var edge = eles[i];\n\n      if (!edge.isEdge()) {\n        continue;\n      }\n\n      retEles.push(edge.source()[0]);\n      retEles.push(edge.target()[0]);\n    }\n\n    return this.spawn(retEles, true).filter(selector);\n  }, 'connectedNodes'),\n  parallelEdges: cache(defineParallelEdgesFunction(), 'parallelEdges'),\n  codirectedEdges: cache(defineParallelEdgesFunction({\n    codirected: true\n  }), 'codirectedEdges')\n});\n\nfunction defineParallelEdgesFunction(params) {\n  var defaults = {\n    codirected: false\n  };\n  params = extend({}, defaults, params);\n  return function parallelEdgesImpl(selector) {\n    // micro-optimised for renderer\n    var elements = [];\n    var edges = this.edges();\n    var p = params; // look at all the edges in the collection\n\n    for (var i = 0; i < edges.length; i++) {\n      var edge1 = edges[i];\n      var edge1_p = edge1._private;\n      var src1 = edge1_p.source;\n      var srcid1 = src1._private.data.id;\n      var tgtid1 = edge1_p.data.target;\n      var srcEdges1 = src1._private.edges; // look at edges connected to the src node of this edge\n\n      for (var j = 0; j < srcEdges1.length; j++) {\n        var edge2 = srcEdges1[j];\n        var edge2data = edge2._private.data;\n        var tgtid2 = edge2data.target;\n        var srcid2 = edge2data.source;\n        var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;\n        var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;\n\n        if (p.codirected && codirected || !p.codirected && (codirected || oppdirected)) {\n          elements.push(edge2);\n        }\n      }\n    }\n\n    return this.spawn(elements, true).filter(selector);\n  };\n} // Misc functions\n/////////////////\n\n\nextend(elesfn$2, {\n  components: function components(root) {\n    var self = this;\n    var cy = self.cy();\n    var visited = cy.collection();\n    var unvisited = root == null ? self.nodes() : root.nodes();\n    var components = [];\n\n    if (root != null && unvisited.empty()) {\n      // root may contain only edges\n      unvisited = root.sources(); // doesn't matter which node to use (undirected), so just use the source sides\n    }\n\n    var visitInComponent = function visitInComponent(node, component) {\n      visited.merge(node);\n      unvisited.unmerge(node);\n      component.merge(node);\n    };\n\n    if (unvisited.empty()) {\n      return self.spawn();\n    }\n\n    var _loop = function _loop() {\n      // each iteration yields a component\n      var cmpt = cy.collection();\n      components.push(cmpt);\n      var root = unvisited[0];\n      visitInComponent(root, cmpt);\n      self.bfs({\n        directed: false,\n        roots: root,\n        visit: function visit(v) {\n          return visitInComponent(v, cmpt);\n        }\n      });\n      cmpt.forEach(function (node) {\n        node.connectedEdges().forEach(function (e) {\n          // connectedEdges() usually cached\n          if (self.has(e) && cmpt.has(e.source()) && cmpt.has(e.target())) {\n            // has() is cheap\n            cmpt.merge(e); // forEach() only considers nodes -- sets N at call time\n          }\n        });\n      });\n    };\n\n    do {\n      _loop();\n    } while (unvisited.length > 0);\n\n    return components;\n  },\n  component: function component() {\n    var ele = this[0];\n    return ele.cy().mutableElements().components(ele)[0];\n  }\n});\nelesfn$2.componentsOf = elesfn$2.components;\n\nvar Collection = function Collection(cy, elements) {\n  var unique = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var removed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  if (cy === undefined) {\n    error('A collection must have a reference to the core');\n    return;\n  }\n\n  var map = new Map$1();\n  var createdElements = false;\n\n  if (!elements) {\n    elements = [];\n  } else if (elements.length > 0 && plainObject(elements[0]) && !element(elements[0])) {\n    createdElements = true; // make elements from json and restore all at once later\n\n    var eles = [];\n    var elesIds = new Set$1();\n\n    for (var i = 0, l = elements.length; i < l; i++) {\n      var json = elements[i];\n\n      if (json.data == null) {\n        json.data = {};\n      }\n\n      var _data = json.data; // make sure newly created elements have valid ids\n\n      if (_data.id == null) {\n        _data.id = uuid();\n      } else if (cy.hasElementWithId(_data.id) || elesIds.has(_data.id)) {\n        continue; // can't create element if prior id already exists\n      }\n\n      var ele = new Element(cy, json, false);\n      eles.push(ele);\n      elesIds.add(_data.id);\n    }\n\n    elements = eles;\n  }\n\n  this.length = 0;\n\n  for (var _i = 0, _l = elements.length; _i < _l; _i++) {\n    var element$1 = elements[_i][0]; // [0] in case elements is an array of collections, rather than array of elements\n\n    if (element$1 == null) {\n      continue;\n    }\n\n    var id = element$1._private.data.id;\n\n    if (!unique || !map.has(id)) {\n      if (unique) {\n        map.set(id, {\n          index: this.length,\n          ele: element$1\n        });\n      }\n\n      this[this.length] = element$1;\n      this.length++;\n    }\n  }\n\n  this._private = {\n    eles: this,\n    cy: cy,\n\n    get map() {\n      if (this.lazyMap == null) {\n        this.rebuildMap();\n      }\n\n      return this.lazyMap;\n    },\n\n    set map(m) {\n      this.lazyMap = m;\n    },\n\n    rebuildMap: function rebuildMap() {\n      var m = this.lazyMap = new Map$1();\n      var eles = this.eles;\n\n      for (var _i2 = 0; _i2 < eles.length; _i2++) {\n        var _ele = eles[_i2];\n        m.set(_ele.id(), {\n          index: _i2,\n          ele: _ele\n        });\n      }\n    }\n  };\n\n  if (unique) {\n    this._private.map = map;\n  } // restore the elements if we created them from json\n\n\n  if (createdElements && !removed) {\n    this.restore();\n  }\n}; // Functions\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// keep the prototypes in sync (an element has the same functions as a collection)\n// and use elefn and elesfn as shorthands to the prototypes\n\n\nvar elesfn$1 = Element.prototype = Collection.prototype = Object.create(Array.prototype);\n\nelesfn$1.instanceString = function () {\n  return 'collection';\n};\n\nelesfn$1.spawn = function (eles, unique) {\n  return new Collection(this.cy(), eles, unique);\n};\n\nelesfn$1.spawnSelf = function () {\n  return this.spawn(this);\n};\n\nelesfn$1.cy = function () {\n  return this._private.cy;\n};\n\nelesfn$1.renderer = function () {\n  return this._private.cy.renderer();\n};\n\nelesfn$1.element = function () {\n  return this[0];\n};\n\nelesfn$1.collection = function () {\n  if (collection(this)) {\n    return this;\n  } else {\n    // an element\n    return new Collection(this._private.cy, [this]);\n  }\n};\n\nelesfn$1.unique = function () {\n  return new Collection(this._private.cy, this, true);\n};\n\nelesfn$1.hasElementWithId = function (id) {\n  id = '' + id; // id must be string\n\n  return this._private.map.has(id);\n};\n\nelesfn$1.getElementById = function (id) {\n  id = '' + id; // id must be string\n\n  var cy = this._private.cy;\n\n  var entry = this._private.map.get(id);\n\n  return entry ? entry.ele : new Collection(cy); // get ele or empty collection\n};\n\nelesfn$1.$id = elesfn$1.getElementById;\n\nelesfn$1.poolIndex = function () {\n  var cy = this._private.cy;\n  var eles = cy._private.elements;\n  var id = this[0]._private.data.id;\n  return eles._private.map.get(id).index;\n};\n\nelesfn$1.indexOf = function (ele) {\n  var id = ele[0]._private.data.id;\n  return this._private.map.get(id).index;\n};\n\nelesfn$1.indexOfId = function (id) {\n  id = '' + id; // id must be string\n\n  return this._private.map.get(id).index;\n};\n\nelesfn$1.json = function (obj) {\n  var ele = this.element();\n  var cy = this.cy();\n\n  if (ele == null && obj) {\n    return this;\n  } // can't set to no eles\n\n\n  if (ele == null) {\n    return undefined;\n  } // can't get from no eles\n\n\n  var p = ele._private;\n\n  if (plainObject(obj)) {\n    // set\n    cy.startBatch();\n\n    if (obj.data) {\n      ele.data(obj.data);\n      var _data2 = p.data;\n\n      if (ele.isEdge()) {\n        // source and target are immutable via data()\n        var move = false;\n        var spec = {};\n        var src = obj.data.source;\n        var tgt = obj.data.target;\n\n        if (src != null && src != _data2.source) {\n          spec.source = '' + src; // id must be string\n\n          move = true;\n        }\n\n        if (tgt != null && tgt != _data2.target) {\n          spec.target = '' + tgt; // id must be string\n\n          move = true;\n        }\n\n        if (move) {\n          ele = ele.move(spec);\n        }\n      } else {\n        // parent is immutable via data()\n        var newParentValSpecd = ('parent' in obj.data);\n        var parent = obj.data.parent;\n\n        if (newParentValSpecd && (parent != null || _data2.parent != null) && parent != _data2.parent) {\n          if (parent === undefined) {\n            // can't set undefined imperatively, so use null\n            parent = null;\n          }\n\n          if (parent != null) {\n            parent = '' + parent; // id must be string\n          }\n\n          ele = ele.move({\n            parent: parent\n          });\n        }\n      }\n    }\n\n    if (obj.position) {\n      ele.position(obj.position);\n    } // ignore group -- immutable\n\n\n    var checkSwitch = function checkSwitch(k, trueFnName, falseFnName) {\n      var obj_k = obj[k];\n\n      if (obj_k != null && obj_k !== p[k]) {\n        if (obj_k) {\n          ele[trueFnName]();\n        } else {\n          ele[falseFnName]();\n        }\n      }\n    };\n\n    checkSwitch('removed', 'remove', 'restore');\n    checkSwitch('selected', 'select', 'unselect');\n    checkSwitch('selectable', 'selectify', 'unselectify');\n    checkSwitch('locked', 'lock', 'unlock');\n    checkSwitch('grabbable', 'grabify', 'ungrabify');\n    checkSwitch('pannable', 'panify', 'unpanify');\n\n    if (obj.classes != null) {\n      ele.classes(obj.classes);\n    }\n\n    cy.endBatch();\n    return this;\n  } else if (obj === undefined) {\n    // get\n    var json = {\n      data: copy(p.data),\n      position: copy(p.position),\n      group: p.group,\n      removed: p.removed,\n      selected: p.selected,\n      selectable: p.selectable,\n      locked: p.locked,\n      grabbable: p.grabbable,\n      pannable: p.pannable,\n      classes: null\n    };\n    json.classes = '';\n    var i = 0;\n    p.classes.forEach(function (cls) {\n      return json.classes += i++ === 0 ? cls : ' ' + cls;\n    });\n    return json;\n  }\n};\n\nelesfn$1.jsons = function () {\n  var jsons = [];\n\n  for (var i = 0; i < this.length; i++) {\n    var ele = this[i];\n    var json = ele.json();\n    jsons.push(json);\n  }\n\n  return jsons;\n};\n\nelesfn$1.clone = function () {\n  var cy = this.cy();\n  var elesArr = [];\n\n  for (var i = 0; i < this.length; i++) {\n    var ele = this[i];\n    var json = ele.json();\n    var clone = new Element(cy, json, false); // NB no restore\n\n    elesArr.push(clone);\n  }\n\n  return new Collection(cy, elesArr);\n};\n\nelesfn$1.copy = elesfn$1.clone;\n\nelesfn$1.restore = function () {\n  var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var addToPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var self = this;\n  var cy = self.cy();\n  var cy_p = cy._private; // create arrays of nodes and edges, since we need to\n  // restore the nodes first\n\n  var nodes = [];\n  var edges = [];\n  var elements;\n\n  for (var _i3 = 0, l = self.length; _i3 < l; _i3++) {\n    var ele = self[_i3];\n\n    if (addToPool && !ele.removed()) {\n      // don't need to handle this ele\n      continue;\n    } // keep nodes first in the array and edges after\n\n\n    if (ele.isNode()) {\n      // put to front of array if node\n      nodes.push(ele);\n    } else {\n      // put to end of array if edge\n      edges.push(ele);\n    }\n  }\n\n  elements = nodes.concat(edges);\n  var i;\n\n  var removeFromElements = function removeFromElements() {\n    elements.splice(i, 1);\n    i--;\n  }; // now, restore each element\n\n\n  for (i = 0; i < elements.length; i++) {\n    var _ele2 = elements[i];\n    var _private = _ele2._private;\n    var _data3 = _private.data; // the traversal cache should start fresh when ele is added\n\n    _ele2.clearTraversalCache(); // set id and validate\n\n\n    if (!addToPool && !_private.removed) ; else if (_data3.id === undefined) {\n      _data3.id = uuid();\n    } else if (number$1(_data3.id)) {\n      _data3.id = '' + _data3.id; // now it's a string\n    } else if (emptyString(_data3.id) || !string(_data3.id)) {\n      error('Can not create element with invalid string ID `' + _data3.id + '`'); // can't create element if it has empty string as id or non-string id\n\n      removeFromElements();\n      continue;\n    } else if (cy.hasElementWithId(_data3.id)) {\n      error('Can not create second element with ID `' + _data3.id + '`'); // can't create element if one already has that id\n\n      removeFromElements();\n      continue;\n    }\n\n    var id = _data3.id; // id is finalised, now let's keep a ref\n\n    if (_ele2.isNode()) {\n      // extra checks for nodes\n      var pos = _private.position; // make sure the nodes have a defined position\n\n      if (pos.x == null) {\n        pos.x = 0;\n      }\n\n      if (pos.y == null) {\n        pos.y = 0;\n      }\n    }\n\n    if (_ele2.isEdge()) {\n      // extra checks for edges\n      var edge = _ele2;\n      var fields = ['source', 'target'];\n      var fieldsLength = fields.length;\n      var badSourceOrTarget = false;\n\n      for (var j = 0; j < fieldsLength; j++) {\n        var field = fields[j];\n        var val = _data3[field];\n\n        if (number$1(val)) {\n          val = _data3[field] = '' + _data3[field]; // now string\n        }\n\n        if (val == null || val === '') {\n          // can't create if source or target is not defined properly\n          error('Can not create edge `' + id + '` with unspecified ' + field);\n          badSourceOrTarget = true;\n        } else if (!cy.hasElementWithId(val)) {\n          // can't create edge if one of its nodes doesn't exist\n          error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');\n          badSourceOrTarget = true;\n        }\n      }\n\n      if (badSourceOrTarget) {\n        removeFromElements();\n        continue;\n      } // can't create this\n\n\n      var src = cy.getElementById(_data3.source);\n      var tgt = cy.getElementById(_data3.target); // only one edge in node if loop\n\n      if (src.same(tgt)) {\n        src._private.edges.push(edge);\n      } else {\n        src._private.edges.push(edge);\n\n        tgt._private.edges.push(edge);\n      }\n\n      edge._private.source = src;\n      edge._private.target = tgt;\n    } // if is edge\n    // create mock ids / indexes maps for element so it can be used like collections\n\n\n    _private.map = new Map$1();\n\n    _private.map.set(id, {\n      ele: _ele2,\n      index: 0\n    });\n\n    _private.removed = false;\n\n    if (addToPool) {\n      cy.addToPool(_ele2);\n    }\n  } // for each element\n  // do compound node sanity checks\n\n\n  for (var _i4 = 0; _i4 < nodes.length; _i4++) {\n    // each node\n    var node = nodes[_i4];\n    var _data4 = node._private.data;\n\n    if (number$1(_data4.parent)) {\n      // then automake string\n      _data4.parent = '' + _data4.parent;\n    }\n\n    var parentId = _data4.parent;\n    var specifiedParent = parentId != null;\n\n    if (specifiedParent || node._private.parent) {\n      var parent = node._private.parent ? cy.collection().merge(node._private.parent) : cy.getElementById(parentId);\n\n      if (parent.empty()) {\n        // non-existant parent; just remove it\n        _data4.parent = undefined;\n      } else if (parent[0].removed()) {\n        warn('Node added with missing parent, reference to parent removed');\n        _data4.parent = undefined;\n        node._private.parent = null;\n      } else {\n        var selfAsParent = false;\n        var ancestor = parent;\n\n        while (!ancestor.empty()) {\n          if (node.same(ancestor)) {\n            // mark self as parent and remove from data\n            selfAsParent = true;\n            _data4.parent = undefined; // remove parent reference\n            // exit or we loop forever\n\n            break;\n          }\n\n          ancestor = ancestor.parent();\n        }\n\n        if (!selfAsParent) {\n          // connect with children\n          parent[0]._private.children.push(node);\n\n          node._private.parent = parent[0]; // let the core know we have a compound graph\n\n          cy_p.hasCompoundNodes = true;\n        }\n      } // else\n\n    } // if specified parent\n\n  } // for each node\n\n\n  if (elements.length > 0) {\n    var restored = elements.length === self.length ? self : new Collection(cy, elements);\n\n    for (var _i5 = 0; _i5 < restored.length; _i5++) {\n      var _ele3 = restored[_i5];\n\n      if (_ele3.isNode()) {\n        continue;\n      } // adding an edge invalidates the traversal caches for the parallel edges\n\n\n      _ele3.parallelEdges().clearTraversalCache(); // adding an edge invalidates the traversal cache for the connected nodes\n\n\n      _ele3.source().clearTraversalCache();\n\n      _ele3.target().clearTraversalCache();\n    }\n\n    var toUpdateStyle;\n\n    if (cy_p.hasCompoundNodes) {\n      toUpdateStyle = cy.collection().merge(restored).merge(restored.connectedNodes()).merge(restored.parent());\n    } else {\n      toUpdateStyle = restored;\n    }\n\n    toUpdateStyle.dirtyCompoundBoundsCache().dirtyBoundingBoxCache().updateStyle(notifyRenderer);\n\n    if (notifyRenderer) {\n      restored.emitAndNotify('add');\n    } else if (addToPool) {\n      restored.emit('add');\n    }\n  }\n\n  return self; // chainability\n};\n\nelesfn$1.removed = function () {\n  var ele = this[0];\n  return ele && ele._private.removed;\n};\n\nelesfn$1.inside = function () {\n  var ele = this[0];\n  return ele && !ele._private.removed;\n};\n\nelesfn$1.remove = function () {\n  var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var removeFromPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var self = this;\n  var elesToRemove = [];\n  var elesToRemoveIds = {};\n  var cy = self._private.cy; // add connected edges\n\n  function addConnectedEdges(node) {\n    var edges = node._private.edges;\n\n    for (var i = 0; i < edges.length; i++) {\n      add(edges[i]);\n    }\n  } // add descendant nodes\n\n\n  function addChildren(node) {\n    var children = node._private.children;\n\n    for (var i = 0; i < children.length; i++) {\n      add(children[i]);\n    }\n  }\n\n  function add(ele) {\n    var alreadyAdded = elesToRemoveIds[ele.id()];\n\n    if (removeFromPool && ele.removed() || alreadyAdded) {\n      return;\n    } else {\n      elesToRemoveIds[ele.id()] = true;\n    }\n\n    if (ele.isNode()) {\n      elesToRemove.push(ele); // nodes are removed last\n\n      addConnectedEdges(ele);\n      addChildren(ele);\n    } else {\n      elesToRemove.unshift(ele); // edges are removed first\n    }\n  } // make the list of elements to remove\n  // (may be removing more than specified due to connected edges etc)\n\n\n  for (var i = 0, l = self.length; i < l; i++) {\n    var ele = self[i];\n    add(ele);\n  }\n\n  function removeEdgeRef(node, edge) {\n    var connectedEdges = node._private.edges;\n    removeFromArray(connectedEdges, edge); // removing an edges invalidates the traversal cache for its nodes\n\n    node.clearTraversalCache();\n  }\n\n  function removeParallelRef(pllEdge) {\n    // removing an edge invalidates the traversal caches for the parallel edges\n    pllEdge.clearTraversalCache();\n  }\n\n  var alteredParents = [];\n  alteredParents.ids = {};\n\n  function removeChildRef(parent, ele) {\n    ele = ele[0];\n    parent = parent[0];\n    var children = parent._private.children;\n    var pid = parent.id();\n    removeFromArray(children, ele); // remove parent => child ref\n\n    ele._private.parent = null; // remove child => parent ref\n\n    if (!alteredParents.ids[pid]) {\n      alteredParents.ids[pid] = true;\n      alteredParents.push(parent);\n    }\n  }\n\n  self.dirtyCompoundBoundsCache();\n\n  if (removeFromPool) {\n    cy.removeFromPool(elesToRemove); // remove from core pool\n  }\n\n  for (var _i6 = 0; _i6 < elesToRemove.length; _i6++) {\n    var _ele4 = elesToRemove[_i6];\n\n    if (_ele4.isEdge()) {\n      // remove references to this edge in its connected nodes\n      var src = _ele4.source()[0];\n\n      var tgt = _ele4.target()[0];\n\n      removeEdgeRef(src, _ele4);\n      removeEdgeRef(tgt, _ele4);\n\n      var pllEdges = _ele4.parallelEdges();\n\n      for (var j = 0; j < pllEdges.length; j++) {\n        var pllEdge = pllEdges[j];\n        removeParallelRef(pllEdge);\n\n        if (pllEdge.isBundledBezier()) {\n          pllEdge.dirtyBoundingBoxCache();\n        }\n      }\n    } else {\n      // remove reference to parent\n      var parent = _ele4.parent();\n\n      if (parent.length !== 0) {\n        removeChildRef(parent, _ele4);\n      }\n    }\n\n    if (removeFromPool) {\n      // mark as removed\n      _ele4._private.removed = true;\n    }\n  } // check to see if we have a compound graph or not\n\n\n  var elesStillInside = cy._private.elements;\n  cy._private.hasCompoundNodes = false;\n\n  for (var _i7 = 0; _i7 < elesStillInside.length; _i7++) {\n    var _ele5 = elesStillInside[_i7];\n\n    if (_ele5.isParent()) {\n      cy._private.hasCompoundNodes = true;\n      break;\n    }\n  }\n\n  var removedElements = new Collection(this.cy(), elesToRemove);\n\n  if (removedElements.size() > 0) {\n    // must manually notify since trigger won't do this automatically once removed\n    if (notifyRenderer) {\n      removedElements.emitAndNotify('remove');\n    } else if (removeFromPool) {\n      removedElements.emit('remove');\n    }\n  } // the parents who were modified by the removal need their style updated\n\n\n  for (var _i8 = 0; _i8 < alteredParents.length; _i8++) {\n    var _ele6 = alteredParents[_i8];\n\n    if (!removeFromPool || !_ele6.removed()) {\n      _ele6.updateStyle();\n    }\n  }\n\n  return removedElements;\n};\n\nelesfn$1.move = function (struct) {\n  var cy = this._private.cy;\n  var eles = this; // just clean up refs, caches, etc. in the same way as when removing and then restoring\n  // (our calls to remove/restore do not remove from the graph or make events)\n\n  var notifyRenderer = false;\n  var modifyPool = false;\n\n  var toString = function toString(id) {\n    return id == null ? id : '' + id;\n  }; // id must be string\n\n\n  if (struct.source !== undefined || struct.target !== undefined) {\n    var srcId = toString(struct.source);\n    var tgtId = toString(struct.target);\n    var srcExists = srcId != null && cy.hasElementWithId(srcId);\n    var tgtExists = tgtId != null && cy.hasElementWithId(tgtId);\n\n    if (srcExists || tgtExists) {\n      cy.batch(function () {\n        // avoid duplicate style updates\n        eles.remove(notifyRenderer, modifyPool); // clean up refs etc.\n\n        eles.emitAndNotify('moveout');\n\n        for (var i = 0; i < eles.length; i++) {\n          var ele = eles[i];\n          var _data5 = ele._private.data;\n\n          if (ele.isEdge()) {\n            if (srcExists) {\n              _data5.source = srcId;\n            }\n\n            if (tgtExists) {\n              _data5.target = tgtId;\n            }\n          }\n        }\n\n        eles.restore(notifyRenderer, modifyPool); // make new refs, style, etc.\n      });\n      eles.emitAndNotify('move');\n    }\n  } else if (struct.parent !== undefined) {\n    // move node to new parent\n    var parentId = toString(struct.parent);\n    var parentExists = parentId === null || cy.hasElementWithId(parentId);\n\n    if (parentExists) {\n      var pidToAssign = parentId === null ? undefined : parentId;\n      cy.batch(function () {\n        // avoid duplicate style updates\n        var updated = eles.remove(notifyRenderer, modifyPool); // clean up refs etc.\n\n        updated.emitAndNotify('moveout');\n\n        for (var i = 0; i < eles.length; i++) {\n          var ele = eles[i];\n          var _data6 = ele._private.data;\n\n          if (ele.isNode()) {\n            _data6.parent = pidToAssign;\n          }\n        }\n\n        updated.restore(notifyRenderer, modifyPool); // make new refs, style, etc.\n      });\n      eles.emitAndNotify('move');\n    }\n  }\n\n  return this;\n};\n\n[elesfn$j, elesfn$i, elesfn$h, elesfn$g, elesfn$f, data, elesfn$d, dimensions, elesfn$9, elesfn$8, elesfn$7, elesfn$6, elesfn$5, elesfn$4, elesfn$3, elesfn$2].forEach(function (props) {\n  extend(elesfn$1, props);\n});\n\nvar corefn$9 = {\n  add: function add(opts) {\n    var elements;\n    var cy = this; // add the elements\n\n    if (elementOrCollection(opts)) {\n      var eles = opts;\n\n      if (eles._private.cy === cy) {\n        // same instance => just restore\n        elements = eles.restore();\n      } else {\n        // otherwise, copy from json\n        var jsons = [];\n\n        for (var i = 0; i < eles.length; i++) {\n          var ele = eles[i];\n          jsons.push(ele.json());\n        }\n\n        elements = new Collection(cy, jsons);\n      }\n    } // specify an array of options\n    else if (array(opts)) {\n      var _jsons = opts;\n      elements = new Collection(cy, _jsons);\n    } // specify via opts.nodes and opts.edges\n    else if (plainObject(opts) && (array(opts.nodes) || array(opts.edges))) {\n      var elesByGroup = opts;\n      var _jsons2 = [];\n      var grs = ['nodes', 'edges'];\n\n      for (var _i = 0, il = grs.length; _i < il; _i++) {\n        var group = grs[_i];\n        var elesArray = elesByGroup[group];\n\n        if (array(elesArray)) {\n          for (var j = 0, jl = elesArray.length; j < jl; j++) {\n            var json = extend({\n              group: group\n            }, elesArray[j]);\n\n            _jsons2.push(json);\n          }\n        }\n      }\n\n      elements = new Collection(cy, _jsons2);\n    } // specify options for one element\n    else {\n      var _json = opts;\n      elements = new Element(cy, _json).collection();\n    }\n\n    return elements;\n  },\n  remove: function remove(collection) {\n    if (elementOrCollection(collection)) ; else if (string(collection)) {\n      var selector = collection;\n      collection = this.$(selector);\n    }\n\n    return collection.remove();\n  }\n};\n\n/* global Float32Array */\n\n/*! Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */\nfunction generateCubicBezier(mX1, mY1, mX2, mY2) {\n  var NEWTON_ITERATIONS = 4,\n      NEWTON_MIN_SLOPE = 0.001,\n      SUBDIVISION_PRECISION = 0.0000001,\n      SUBDIVISION_MAX_ITERATIONS = 10,\n      kSplineTableSize = 11,\n      kSampleStepSize = 1.0 / (kSplineTableSize - 1.0),\n      float32ArraySupported = typeof Float32Array !== 'undefined';\n  /* Must contain four arguments. */\n\n  if (arguments.length !== 4) {\n    return false;\n  }\n  /* Arguments must be numbers. */\n\n\n  for (var i = 0; i < 4; ++i) {\n    if (typeof arguments[i] !== \"number\" || isNaN(arguments[i]) || !isFinite(arguments[i])) {\n      return false;\n    }\n  }\n  /* X values must be in the [0, 1] range. */\n\n\n  mX1 = Math.min(mX1, 1);\n  mX2 = Math.min(mX2, 1);\n  mX1 = Math.max(mX1, 0);\n  mX2 = Math.max(mX2, 0);\n  var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n\n  function A(aA1, aA2) {\n    return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n  }\n\n  function B(aA1, aA2) {\n    return 3.0 * aA2 - 6.0 * aA1;\n  }\n\n  function C(aA1) {\n    return 3.0 * aA1;\n  }\n\n  function calcBezier(aT, aA1, aA2) {\n    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n  }\n\n  function getSlope(aT, aA1, aA2) {\n    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n  }\n\n  function newtonRaphsonIterate(aX, aGuessT) {\n    for (var _i = 0; _i < NEWTON_ITERATIONS; ++_i) {\n      var currentSlope = getSlope(aGuessT, mX1, mX2);\n\n      if (currentSlope === 0.0) {\n        return aGuessT;\n      }\n\n      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n      aGuessT -= currentX / currentSlope;\n    }\n\n    return aGuessT;\n  }\n\n  function calcSampleValues() {\n    for (var _i2 = 0; _i2 < kSplineTableSize; ++_i2) {\n      mSampleValues[_i2] = calcBezier(_i2 * kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  function binarySubdivide(aX, aA, aB) {\n    var currentX,\n        currentT,\n        i = 0;\n\n    do {\n      currentT = aA + (aB - aA) / 2.0;\n      currentX = calcBezier(currentT, mX1, mX2) - aX;\n\n      if (currentX > 0.0) {\n        aB = currentT;\n      } else {\n        aA = currentT;\n      }\n    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n\n    return currentT;\n  }\n\n  function getTForX(aX) {\n    var intervalStart = 0.0,\n        currentSample = 1,\n        lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n\n    --currentSample;\n    var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]),\n        guessForT = intervalStart + dist * kSampleStepSize,\n        initialSlope = getSlope(guessForT, mX1, mX2);\n\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);\n    }\n  }\n\n  var _precomputed = false;\n\n  function precompute() {\n    _precomputed = true;\n\n    if (mX1 !== mY1 || mX2 !== mY2) {\n      calcSampleValues();\n    }\n  }\n\n  var f = function f(aX) {\n    if (!_precomputed) {\n      precompute();\n    }\n\n    if (mX1 === mY1 && mX2 === mY2) {\n      return aX;\n    }\n\n    if (aX === 0) {\n      return 0;\n    }\n\n    if (aX === 1) {\n      return 1;\n    }\n\n    return calcBezier(getTForX(aX), mY1, mY2);\n  };\n\n  f.getControlPoints = function () {\n    return [{\n      x: mX1,\n      y: mY1\n    }, {\n      x: mX2,\n      y: mY2\n    }];\n  };\n\n  var str = \"generateBezier(\" + [mX1, mY1, mX2, mY2] + \")\";\n\n  f.toString = function () {\n    return str;\n  };\n\n  return f;\n}\n\n/*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */\n\n/* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass\n   then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */\nvar generateSpringRK4 = function () {\n  function springAccelerationForState(state) {\n    return -state.tension * state.x - state.friction * state.v;\n  }\n\n  function springEvaluateStateWithDerivative(initialState, dt, derivative) {\n    var state = {\n      x: initialState.x + derivative.dx * dt,\n      v: initialState.v + derivative.dv * dt,\n      tension: initialState.tension,\n      friction: initialState.friction\n    };\n    return {\n      dx: state.v,\n      dv: springAccelerationForState(state)\n    };\n  }\n\n  function springIntegrateState(state, dt) {\n    var a = {\n      dx: state.v,\n      dv: springAccelerationForState(state)\n    },\n        b = springEvaluateStateWithDerivative(state, dt * 0.5, a),\n        c = springEvaluateStateWithDerivative(state, dt * 0.5, b),\n        d = springEvaluateStateWithDerivative(state, dt, c),\n        dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),\n        dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);\n    state.x = state.x + dxdt * dt;\n    state.v = state.v + dvdt * dt;\n    return state;\n  }\n\n  return function springRK4Factory(tension, friction, duration) {\n    var initState = {\n      x: -1,\n      v: 0,\n      tension: null,\n      friction: null\n    },\n        path = [0],\n        time_lapsed = 0,\n        tolerance = 1 / 10000,\n        DT = 16 / 1000,\n        have_duration,\n        dt,\n        last_state;\n    tension = parseFloat(tension) || 500;\n    friction = parseFloat(friction) || 20;\n    duration = duration || null;\n    initState.tension = tension;\n    initState.friction = friction;\n    have_duration = duration !== null;\n    /* Calculate the actual time it takes for this animation to complete with the provided conditions. */\n\n    if (have_duration) {\n      /* Run the simulation without a duration. */\n      time_lapsed = springRK4Factory(tension, friction);\n      /* Compute the adjusted time delta. */\n\n      dt = time_lapsed / duration * DT;\n    } else {\n      dt = DT;\n    }\n\n    for (;;) {\n      /* Next/step function .*/\n      last_state = springIntegrateState(last_state || initState, dt);\n      /* Store the position. */\n\n      path.push(1 + last_state.x);\n      time_lapsed += 16;\n      /* If the change threshold is reached, break. */\n\n      if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {\n        break;\n      }\n    }\n    /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the\n       computed path and returns a snapshot of the position according to a given percentComplete. */\n\n\n    return !have_duration ? time_lapsed : function (percentComplete) {\n      return path[percentComplete * (path.length - 1) | 0];\n    };\n  };\n}();\n\nvar cubicBezier = function cubicBezier(t1, p1, t2, p2) {\n  var bezier = generateCubicBezier(t1, p1, t2, p2);\n  return function (start, end, percent) {\n    return start + (end - start) * bezier(percent);\n  };\n};\n\nvar easings = {\n  'linear': function linear(start, end, percent) {\n    return start + (end - start) * percent;\n  },\n  // default easings\n  'ease': cubicBezier(0.25, 0.1, 0.25, 1),\n  'ease-in': cubicBezier(0.42, 0, 1, 1),\n  'ease-out': cubicBezier(0, 0, 0.58, 1),\n  'ease-in-out': cubicBezier(0.42, 0, 0.58, 1),\n  // sine\n  'ease-in-sine': cubicBezier(0.47, 0, 0.745, 0.715),\n  'ease-out-sine': cubicBezier(0.39, 0.575, 0.565, 1),\n  'ease-in-out-sine': cubicBezier(0.445, 0.05, 0.55, 0.95),\n  // quad\n  'ease-in-quad': cubicBezier(0.55, 0.085, 0.68, 0.53),\n  'ease-out-quad': cubicBezier(0.25, 0.46, 0.45, 0.94),\n  'ease-in-out-quad': cubicBezier(0.455, 0.03, 0.515, 0.955),\n  // cubic\n  'ease-in-cubic': cubicBezier(0.55, 0.055, 0.675, 0.19),\n  'ease-out-cubic': cubicBezier(0.215, 0.61, 0.355, 1),\n  'ease-in-out-cubic': cubicBezier(0.645, 0.045, 0.355, 1),\n  // quart\n  'ease-in-quart': cubicBezier(0.895, 0.03, 0.685, 0.22),\n  'ease-out-quart': cubicBezier(0.165, 0.84, 0.44, 1),\n  'ease-in-out-quart': cubicBezier(0.77, 0, 0.175, 1),\n  // quint\n  'ease-in-quint': cubicBezier(0.755, 0.05, 0.855, 0.06),\n  'ease-out-quint': cubicBezier(0.23, 1, 0.32, 1),\n  'ease-in-out-quint': cubicBezier(0.86, 0, 0.07, 1),\n  // expo\n  'ease-in-expo': cubicBezier(0.95, 0.05, 0.795, 0.035),\n  'ease-out-expo': cubicBezier(0.19, 1, 0.22, 1),\n  'ease-in-out-expo': cubicBezier(1, 0, 0, 1),\n  // circ\n  'ease-in-circ': cubicBezier(0.6, 0.04, 0.98, 0.335),\n  'ease-out-circ': cubicBezier(0.075, 0.82, 0.165, 1),\n  'ease-in-out-circ': cubicBezier(0.785, 0.135, 0.15, 0.86),\n  // user param easings...\n  'spring': function spring(tension, friction, duration) {\n    if (duration === 0) {\n      // can't get a spring w/ duration 0\n      return easings.linear; // duration 0 => jump to end so impl doesn't matter\n    }\n\n    var spring = generateSpringRK4(tension, friction, duration);\n    return function (start, end, percent) {\n      return start + (end - start) * spring(percent);\n    };\n  },\n  'cubic-bezier': cubicBezier\n};\n\nfunction getEasedValue(type, start, end, percent, easingFn) {\n  if (percent === 1) {\n    return end;\n  }\n\n  if (start === end) {\n    return end;\n  }\n\n  var val = easingFn(start, end, percent);\n\n  if (type == null) {\n    return val;\n  }\n\n  if (type.roundValue || type.color) {\n    val = Math.round(val);\n  }\n\n  if (type.min !== undefined) {\n    val = Math.max(val, type.min);\n  }\n\n  if (type.max !== undefined) {\n    val = Math.min(val, type.max);\n  }\n\n  return val;\n}\n\nfunction getValue(prop, spec) {\n  if (prop.pfValue != null || prop.value != null) {\n    if (prop.pfValue != null && (spec == null || spec.type.units !== '%')) {\n      return prop.pfValue;\n    } else {\n      return prop.value;\n    }\n  } else {\n    return prop;\n  }\n}\n\nfunction ease(startProp, endProp, percent, easingFn, propSpec) {\n  var type = propSpec != null ? propSpec.type : null;\n\n  if (percent < 0) {\n    percent = 0;\n  } else if (percent > 1) {\n    percent = 1;\n  }\n\n  var start = getValue(startProp, propSpec);\n  var end = getValue(endProp, propSpec);\n\n  if (number$1(start) && number$1(end)) {\n    return getEasedValue(type, start, end, percent, easingFn);\n  } else if (array(start) && array(end)) {\n    var easedArr = [];\n\n    for (var i = 0; i < end.length; i++) {\n      var si = start[i];\n      var ei = end[i];\n\n      if (si != null && ei != null) {\n        var val = getEasedValue(type, si, ei, percent, easingFn);\n        easedArr.push(val);\n      } else {\n        easedArr.push(ei);\n      }\n    }\n\n    return easedArr;\n  }\n\n  return undefined;\n}\n\nfunction step$1(self, ani, now, isCore) {\n  var isEles = !isCore;\n  var _p = self._private;\n  var ani_p = ani._private;\n  var pEasing = ani_p.easing;\n  var startTime = ani_p.startTime;\n  var cy = isCore ? self : self.cy();\n  var style = cy.style();\n\n  if (!ani_p.easingImpl) {\n    if (pEasing == null) {\n      // use default\n      ani_p.easingImpl = easings['linear'];\n    } else {\n      // then define w/ name\n      var easingVals;\n\n      if (string(pEasing)) {\n        var easingProp = style.parse('transition-timing-function', pEasing);\n        easingVals = easingProp.value;\n      } else {\n        // then assume preparsed array\n        easingVals = pEasing;\n      }\n\n      var name, args;\n\n      if (string(easingVals)) {\n        name = easingVals;\n        args = [];\n      } else {\n        name = easingVals[1];\n        args = easingVals.slice(2).map(function (n) {\n          return +n;\n        });\n      }\n\n      if (args.length > 0) {\n        // create with args\n        if (name === 'spring') {\n          args.push(ani_p.duration); // need duration to generate spring\n        }\n\n        ani_p.easingImpl = easings[name].apply(null, args);\n      } else {\n        // static impl by name\n        ani_p.easingImpl = easings[name];\n      }\n    }\n  }\n\n  var easing = ani_p.easingImpl;\n  var percent;\n\n  if (ani_p.duration === 0) {\n    percent = 1;\n  } else {\n    percent = (now - startTime) / ani_p.duration;\n  }\n\n  if (ani_p.applying) {\n    percent = ani_p.progress;\n  }\n\n  if (percent < 0) {\n    percent = 0;\n  } else if (percent > 1) {\n    percent = 1;\n  }\n\n  if (ani_p.delay == null) {\n    // then update\n    var startPos = ani_p.startPosition;\n    var endPos = ani_p.position;\n\n    if (endPos && isEles && !self.locked()) {\n      var newPos = {};\n\n      if (valid(startPos.x, endPos.x)) {\n        newPos.x = ease(startPos.x, endPos.x, percent, easing);\n      }\n\n      if (valid(startPos.y, endPos.y)) {\n        newPos.y = ease(startPos.y, endPos.y, percent, easing);\n      }\n\n      self.position(newPos);\n    }\n\n    var startPan = ani_p.startPan;\n    var endPan = ani_p.pan;\n    var pan = _p.pan;\n    var animatingPan = endPan != null && isCore;\n\n    if (animatingPan) {\n      if (valid(startPan.x, endPan.x)) {\n        pan.x = ease(startPan.x, endPan.x, percent, easing);\n      }\n\n      if (valid(startPan.y, endPan.y)) {\n        pan.y = ease(startPan.y, endPan.y, percent, easing);\n      }\n\n      self.emit('pan');\n    }\n\n    var startZoom = ani_p.startZoom;\n    var endZoom = ani_p.zoom;\n    var animatingZoom = endZoom != null && isCore;\n\n    if (animatingZoom) {\n      if (valid(startZoom, endZoom)) {\n        _p.zoom = bound(_p.minZoom, ease(startZoom, endZoom, percent, easing), _p.maxZoom);\n      }\n\n      self.emit('zoom');\n    }\n\n    if (animatingPan || animatingZoom) {\n      self.emit('viewport');\n    }\n\n    var props = ani_p.style;\n\n    if (props && props.length > 0 && isEles) {\n      for (var i = 0; i < props.length; i++) {\n        var prop = props[i];\n        var _name = prop.name;\n        var end = prop;\n        var start = ani_p.startStyle[_name];\n        var propSpec = style.properties[start.name];\n        var easedVal = ease(start, end, percent, easing, propSpec);\n        style.overrideBypass(self, _name, easedVal);\n      } // for props\n\n\n      self.emit('style');\n    } // if\n\n  }\n\n  ani_p.progress = percent;\n  return percent;\n}\n\nfunction valid(start, end) {\n  if (start == null || end == null) {\n    return false;\n  }\n\n  if (number$1(start) && number$1(end)) {\n    return true;\n  } else if (start && end) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction startAnimation(self, ani, now, isCore) {\n  var ani_p = ani._private;\n  ani_p.started = true;\n  ani_p.startTime = now - ani_p.progress * ani_p.duration;\n}\n\nfunction stepAll(now, cy) {\n  var eles = cy._private.aniEles;\n  var doneEles = [];\n\n  function stepOne(ele, isCore) {\n    var _p = ele._private;\n    var current = _p.animation.current;\n    var queue = _p.animation.queue;\n    var ranAnis = false; // if nothing currently animating, get something from the queue\n\n    if (current.length === 0) {\n      var next = queue.shift();\n\n      if (next) {\n        current.push(next);\n      }\n    }\n\n    var callbacks = function callbacks(_callbacks) {\n      for (var j = _callbacks.length - 1; j >= 0; j--) {\n        var cb = _callbacks[j];\n        cb();\n      }\n\n      _callbacks.splice(0, _callbacks.length);\n    }; // step and remove if done\n\n\n    for (var i = current.length - 1; i >= 0; i--) {\n      var ani = current[i];\n      var ani_p = ani._private;\n\n      if (ani_p.stopped) {\n        current.splice(i, 1);\n        ani_p.hooked = false;\n        ani_p.playing = false;\n        ani_p.started = false;\n        callbacks(ani_p.frames);\n        continue;\n      }\n\n      if (!ani_p.playing && !ani_p.applying) {\n        continue;\n      } // an apply() while playing shouldn't do anything\n\n\n      if (ani_p.playing && ani_p.applying) {\n        ani_p.applying = false;\n      }\n\n      if (!ani_p.started) {\n        startAnimation(ele, ani, now);\n      }\n\n      step$1(ele, ani, now, isCore);\n\n      if (ani_p.applying) {\n        ani_p.applying = false;\n      }\n\n      callbacks(ani_p.frames);\n\n      if (ani_p.step != null) {\n        ani_p.step(now);\n      }\n\n      if (ani.completed()) {\n        current.splice(i, 1);\n        ani_p.hooked = false;\n        ani_p.playing = false;\n        ani_p.started = false;\n        callbacks(ani_p.completes);\n      }\n\n      ranAnis = true;\n    }\n\n    if (!isCore && current.length === 0 && queue.length === 0) {\n      doneEles.push(ele);\n    }\n\n    return ranAnis;\n  } // stepElement\n  // handle all eles\n\n\n  var ranEleAni = false;\n\n  for (var e = 0; e < eles.length; e++) {\n    var ele = eles[e];\n    var handledThisEle = stepOne(ele);\n    ranEleAni = ranEleAni || handledThisEle;\n  } // each element\n\n\n  var ranCoreAni = stepOne(cy, true); // notify renderer\n\n  if (ranEleAni || ranCoreAni) {\n    if (eles.length > 0) {\n      cy.notify('draw', eles);\n    } else {\n      cy.notify('draw');\n    }\n  } // remove elements from list of currently animating if its queues are empty\n\n\n  eles.unmerge(doneEles);\n  cy.emit('step');\n} // stepAll\n\nvar corefn$8 = {\n  // pull in animation functions\n  animate: define.animate(),\n  animation: define.animation(),\n  animated: define.animated(),\n  clearQueue: define.clearQueue(),\n  delay: define.delay(),\n  delayAnimation: define.delayAnimation(),\n  stop: define.stop(),\n  addToAnimationPool: function addToAnimationPool(eles) {\n    var cy = this;\n\n    if (!cy.styleEnabled()) {\n      return;\n    } // save cycles when no style used\n\n\n    cy._private.aniEles.merge(eles);\n  },\n  stopAnimationLoop: function stopAnimationLoop() {\n    this._private.animationsRunning = false;\n  },\n  startAnimationLoop: function startAnimationLoop() {\n    var cy = this;\n    cy._private.animationsRunning = true;\n\n    if (!cy.styleEnabled()) {\n      return;\n    } // save cycles when no style used\n    // NB the animation loop will exec in headless environments if style enabled\n    // and explicit cy.destroy() is necessary to stop the loop\n\n\n    function headlessStep() {\n      if (!cy._private.animationsRunning) {\n        return;\n      }\n\n      requestAnimationFrame(function animationStep(now) {\n        stepAll(now, cy);\n        headlessStep();\n      });\n    }\n\n    var renderer = cy.renderer();\n\n    if (renderer && renderer.beforeRender) {\n      // let the renderer schedule animations\n      renderer.beforeRender(function rendererAnimationStep(willDraw, now) {\n        stepAll(now, cy);\n      }, renderer.beforeRenderPriorities.animations);\n    } else {\n      // manage the animation loop ourselves\n      headlessStep(); // first call\n    }\n  }\n};\n\nvar emitterOptions = {\n  qualifierCompare: function qualifierCompare(selector1, selector2) {\n    if (selector1 == null || selector2 == null) {\n      return selector1 == null && selector2 == null;\n    } else {\n      return selector1.sameText(selector2);\n    }\n  },\n  eventMatches: function eventMatches(cy, listener, eventObj) {\n    var selector = listener.qualifier;\n\n    if (selector != null) {\n      return cy !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);\n    }\n\n    return true;\n  },\n  addEventFields: function addEventFields(cy, evt) {\n    evt.cy = cy;\n    evt.target = cy;\n  },\n  callbackContext: function callbackContext(cy, listener, eventObj) {\n    return listener.qualifier != null ? eventObj.target : cy;\n  }\n};\n\nvar argSelector = function argSelector(arg) {\n  if (string(arg)) {\n    return new Selector(arg);\n  } else {\n    return arg;\n  }\n};\n\nvar elesfn = {\n  createEmitter: function createEmitter() {\n    var _p = this._private;\n\n    if (!_p.emitter) {\n      _p.emitter = new Emitter(emitterOptions, this);\n    }\n\n    return this;\n  },\n  emitter: function emitter() {\n    return this._private.emitter;\n  },\n  on: function on(events, selector, callback) {\n    this.emitter().on(events, argSelector(selector), callback);\n    return this;\n  },\n  removeListener: function removeListener(events, selector, callback) {\n    this.emitter().removeListener(events, argSelector(selector), callback);\n    return this;\n  },\n  removeAllListeners: function removeAllListeners() {\n    this.emitter().removeAllListeners();\n    return this;\n  },\n  one: function one(events, selector, callback) {\n    this.emitter().one(events, argSelector(selector), callback);\n    return this;\n  },\n  once: function once(events, selector, callback) {\n    this.emitter().one(events, argSelector(selector), callback);\n    return this;\n  },\n  emit: function emit(events, extraParams) {\n    this.emitter().emit(events, extraParams);\n    return this;\n  },\n  emitAndNotify: function emitAndNotify(event, eles) {\n    this.emit(event);\n    this.notify(event, eles);\n    return this;\n  }\n};\ndefine.eventAliasesOn(elesfn);\n\nvar corefn$7 = {\n  png: function png(options) {\n    var renderer = this._private.renderer;\n    options = options || {};\n    return renderer.png(options);\n  },\n  jpg: function jpg(options) {\n    var renderer = this._private.renderer;\n    options = options || {};\n    options.bg = options.bg || '#fff';\n    return renderer.jpg(options);\n  }\n};\ncorefn$7.jpeg = corefn$7.jpg;\n\nvar corefn$6 = {\n  layout: function layout(options) {\n    var cy = this;\n\n    if (options == null) {\n      error('Layout options must be specified to make a layout');\n      return;\n    }\n\n    if (options.name == null) {\n      error('A `name` must be specified to make a layout');\n      return;\n    }\n\n    var name = options.name;\n    var Layout = cy.extension('layout', name);\n\n    if (Layout == null) {\n      error('No such layout `' + name + '` found.  Did you forget to import it and `cytoscape.use()` it?');\n      return;\n    }\n\n    var eles;\n\n    if (string(options.eles)) {\n      eles = cy.$(options.eles);\n    } else {\n      eles = options.eles != null ? options.eles : cy.$();\n    }\n\n    var layout = new Layout(extend({}, options, {\n      cy: cy,\n      eles: eles\n    }));\n    return layout;\n  }\n};\ncorefn$6.createLayout = corefn$6.makeLayout = corefn$6.layout;\n\nvar corefn$5 = {\n  notify: function notify(eventName, eventEles) {\n    var _p = this._private;\n\n    if (this.batching()) {\n      _p.batchNotifications = _p.batchNotifications || {};\n      var eles = _p.batchNotifications[eventName] = _p.batchNotifications[eventName] || this.collection();\n\n      if (eventEles != null) {\n        eles.merge(eventEles);\n      }\n\n      return; // notifications are disabled during batching\n    }\n\n    if (!_p.notificationsEnabled) {\n      return;\n    } // exit on disabled\n\n\n    var renderer = this.renderer(); // exit if destroy() called on core or renderer in between frames #1499 #1528\n\n    if (this.destroyed() || !renderer) {\n      return;\n    }\n\n    renderer.notify(eventName, eventEles);\n  },\n  notifications: function notifications(bool) {\n    var p = this._private;\n\n    if (bool === undefined) {\n      return p.notificationsEnabled;\n    } else {\n      p.notificationsEnabled = bool ? true : false;\n    }\n\n    return this;\n  },\n  noNotifications: function noNotifications(callback) {\n    this.notifications(false);\n    callback();\n    this.notifications(true);\n  },\n  batching: function batching() {\n    return this._private.batchCount > 0;\n  },\n  startBatch: function startBatch() {\n    var _p = this._private;\n\n    if (_p.batchCount == null) {\n      _p.batchCount = 0;\n    }\n\n    if (_p.batchCount === 0) {\n      _p.batchStyleEles = this.collection();\n      _p.batchNotifications = {};\n    }\n\n    _p.batchCount++;\n    return this;\n  },\n  endBatch: function endBatch() {\n    var _p = this._private;\n\n    if (_p.batchCount === 0) {\n      return this;\n    }\n\n    _p.batchCount--;\n\n    if (_p.batchCount === 0) {\n      // update style for dirty eles\n      _p.batchStyleEles.updateStyle();\n\n      var renderer = this.renderer(); // notify the renderer of queued eles and event types\n\n      Object.keys(_p.batchNotifications).forEach(function (eventName) {\n        var eles = _p.batchNotifications[eventName];\n\n        if (eles.empty()) {\n          renderer.notify(eventName);\n        } else {\n          renderer.notify(eventName, eles);\n        }\n      });\n    }\n\n    return this;\n  },\n  batch: function batch(callback) {\n    this.startBatch();\n    callback();\n    this.endBatch();\n    return this;\n  },\n  // for backwards compatibility\n  batchData: function batchData(map) {\n    var cy = this;\n    return this.batch(function () {\n      var ids = Object.keys(map);\n\n      for (var i = 0; i < ids.length; i++) {\n        var id = ids[i];\n        var data = map[id];\n        var ele = cy.getElementById(id);\n        ele.data(data);\n      }\n    });\n  }\n};\n\nvar rendererDefaults = defaults$g({\n  hideEdgesOnViewport: false,\n  textureOnViewport: false,\n  motionBlur: false,\n  motionBlurOpacity: 0.05,\n  pixelRatio: undefined,\n  desktopTapThreshold: 4,\n  touchTapThreshold: 8,\n  wheelSensitivity: 1,\n  debug: false,\n  showFps: false\n});\nvar corefn$4 = {\n  renderTo: function renderTo(context, zoom, pan, pxRatio) {\n    var r = this._private.renderer;\n    r.renderTo(context, zoom, pan, pxRatio);\n    return this;\n  },\n  renderer: function renderer() {\n    return this._private.renderer;\n  },\n  forceRender: function forceRender() {\n    this.notify('draw');\n    return this;\n  },\n  resize: function resize() {\n    this.invalidateSize();\n    this.emitAndNotify('resize');\n    return this;\n  },\n  initRenderer: function initRenderer(options) {\n    var cy = this;\n    var RendererProto = cy.extension('renderer', options.name);\n\n    if (RendererProto == null) {\n      error(\"Can not initialise: No such renderer `\".concat(options.name, \"` found. Did you forget to import it and `cytoscape.use()` it?\"));\n      return;\n    }\n\n    if (options.wheelSensitivity !== undefined) {\n      warn(\"You have set a custom wheel sensitivity.  This will make your app zoom unnaturally when using mainstream mice.  You should change this value from the default only if you can guarantee that all your users will use the same hardware and OS configuration as your current machine.\");\n    }\n\n    var rOpts = rendererDefaults(options);\n    rOpts.cy = cy;\n    cy._private.renderer = new RendererProto(rOpts);\n    this.notify('init');\n  },\n  destroyRenderer: function destroyRenderer() {\n    var cy = this;\n    cy.notify('destroy'); // destroy the renderer\n\n    var domEle = cy.container();\n\n    if (domEle) {\n      domEle._cyreg = null;\n\n      while (domEle.childNodes.length > 0) {\n        domEle.removeChild(domEle.childNodes[0]);\n      }\n    }\n\n    cy._private.renderer = null; // to be extra safe, remove the ref\n\n    cy.mutableElements().forEach(function (ele) {\n      var _p = ele._private;\n      _p.rscratch = {};\n      _p.rstyle = {};\n      _p.animation.current = [];\n      _p.animation.queue = [];\n    });\n  },\n  onRender: function onRender(fn) {\n    return this.on('render', fn);\n  },\n  offRender: function offRender(fn) {\n    return this.off('render', fn);\n  }\n};\ncorefn$4.invalidateDimensions = corefn$4.resize;\n\nvar corefn$3 = {\n  // get a collection\n  // - empty collection on no args\n  // - collection of elements in the graph on selector arg\n  // - guarantee a returned collection when elements or collection specified\n  collection: function collection(eles, opts) {\n    if (string(eles)) {\n      return this.$(eles);\n    } else if (elementOrCollection(eles)) {\n      return eles.collection();\n    } else if (array(eles)) {\n      if (!opts) {\n        opts = {};\n      }\n\n      return new Collection(this, eles, opts.unique, opts.removed);\n    }\n\n    return new Collection(this);\n  },\n  nodes: function nodes(selector) {\n    var nodes = this.$(function (ele) {\n      return ele.isNode();\n    });\n\n    if (selector) {\n      return nodes.filter(selector);\n    }\n\n    return nodes;\n  },\n  edges: function edges(selector) {\n    var edges = this.$(function (ele) {\n      return ele.isEdge();\n    });\n\n    if (selector) {\n      return edges.filter(selector);\n    }\n\n    return edges;\n  },\n  // search the graph like jQuery\n  $: function $(selector) {\n    var eles = this._private.elements;\n\n    if (selector) {\n      return eles.filter(selector);\n    } else {\n      return eles.spawnSelf();\n    }\n  },\n  mutableElements: function mutableElements() {\n    return this._private.elements;\n  }\n}; // aliases\n\ncorefn$3.elements = corefn$3.filter = corefn$3.$;\n\nvar styfn$8 = {}; // keys for style blocks, e.g. ttfftt\n\nvar TRUE = 't';\nvar FALSE = 'f'; // (potentially expensive calculation)\n// apply the style to the element based on\n// - its bypass\n// - what selectors match it\n\nstyfn$8.apply = function (eles) {\n  var self = this;\n  var _p = self._private;\n  var cy = _p.cy;\n  var updatedEles = cy.collection();\n\n  for (var ie = 0; ie < eles.length; ie++) {\n    var ele = eles[ie];\n    var cxtMeta = self.getContextMeta(ele);\n\n    if (cxtMeta.empty) {\n      continue;\n    }\n\n    var cxtStyle = self.getContextStyle(cxtMeta);\n    var app = self.applyContextStyle(cxtMeta, cxtStyle, ele);\n\n    if (ele._private.appliedInitStyle) {\n      self.updateTransitions(ele, app.diffProps);\n    } else {\n      ele._private.appliedInitStyle = true;\n    }\n\n    var hintsDiff = self.updateStyleHints(ele);\n\n    if (hintsDiff) {\n      updatedEles.push(ele);\n    }\n  } // for elements\n\n\n  return updatedEles;\n};\n\nstyfn$8.getPropertiesDiff = function (oldCxtKey, newCxtKey) {\n  var self = this;\n  var cache = self._private.propDiffs = self._private.propDiffs || {};\n  var dualCxtKey = oldCxtKey + '-' + newCxtKey;\n  var cachedVal = cache[dualCxtKey];\n\n  if (cachedVal) {\n    return cachedVal;\n  }\n\n  var diffProps = [];\n  var addedProp = {};\n\n  for (var i = 0; i < self.length; i++) {\n    var cxt = self[i];\n    var oldHasCxt = oldCxtKey[i] === TRUE;\n    var newHasCxt = newCxtKey[i] === TRUE;\n    var cxtHasDiffed = oldHasCxt !== newHasCxt;\n    var cxtHasMappedProps = cxt.mappedProperties.length > 0;\n\n    if (cxtHasDiffed || newHasCxt && cxtHasMappedProps) {\n      var props = void 0;\n\n      if (cxtHasDiffed && cxtHasMappedProps) {\n        props = cxt.properties; // suffices b/c mappedProperties is a subset of properties\n      } else if (cxtHasDiffed) {\n        props = cxt.properties; // need to check them all\n      } else if (cxtHasMappedProps) {\n        props = cxt.mappedProperties; // only need to check mapped\n      }\n\n      for (var j = 0; j < props.length; j++) {\n        var prop = props[j];\n        var name = prop.name; // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter\n        // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result\n        // is cached)\n\n        var laterCxtOverrides = false;\n\n        for (var k = i + 1; k < self.length; k++) {\n          var laterCxt = self[k];\n          var hasLaterCxt = newCxtKey[k] === TRUE;\n\n          if (!hasLaterCxt) {\n            continue;\n          } // can't override unless the context is active\n\n\n          laterCxtOverrides = laterCxt.properties[prop.name] != null;\n\n          if (laterCxtOverrides) {\n            break;\n          } // exit early as long as one later context overrides\n\n        }\n\n        if (!addedProp[name] && !laterCxtOverrides) {\n          addedProp[name] = true;\n          diffProps.push(name);\n        }\n      } // for props\n\n    } // if\n\n  } // for contexts\n\n\n  cache[dualCxtKey] = diffProps;\n  return diffProps;\n};\n\nstyfn$8.getContextMeta = function (ele) {\n  var self = this;\n  var cxtKey = '';\n  var diffProps;\n  var prevKey = ele._private.styleCxtKey || ''; // get the cxt key\n\n  for (var i = 0; i < self.length; i++) {\n    var context = self[i];\n    var contextSelectorMatches = context.selector && context.selector.matches(ele); // NB: context.selector may be null for 'core'\n\n    if (contextSelectorMatches) {\n      cxtKey += TRUE;\n    } else {\n      cxtKey += FALSE;\n    }\n  } // for context\n\n\n  diffProps = self.getPropertiesDiff(prevKey, cxtKey);\n  ele._private.styleCxtKey = cxtKey;\n  return {\n    key: cxtKey,\n    diffPropNames: diffProps,\n    empty: diffProps.length === 0\n  };\n}; // gets a computed ele style object based on matched contexts\n\n\nstyfn$8.getContextStyle = function (cxtMeta) {\n  var cxtKey = cxtMeta.key;\n  var self = this;\n  var cxtStyles = this._private.contextStyles = this._private.contextStyles || {}; // if already computed style, returned cached copy\n\n  if (cxtStyles[cxtKey]) {\n    return cxtStyles[cxtKey];\n  }\n\n  var style = {\n    _private: {\n      key: cxtKey\n    }\n  };\n\n  for (var i = 0; i < self.length; i++) {\n    var cxt = self[i];\n    var hasCxt = cxtKey[i] === TRUE;\n\n    if (!hasCxt) {\n      continue;\n    }\n\n    for (var j = 0; j < cxt.properties.length; j++) {\n      var prop = cxt.properties[j];\n      style[prop.name] = prop;\n    }\n  }\n\n  cxtStyles[cxtKey] = style;\n  return style;\n};\n\nstyfn$8.applyContextStyle = function (cxtMeta, cxtStyle, ele) {\n  var self = this;\n  var diffProps = cxtMeta.diffPropNames;\n  var retDiffProps = {};\n  var types = self.types;\n\n  for (var i = 0; i < diffProps.length; i++) {\n    var diffPropName = diffProps[i];\n    var cxtProp = cxtStyle[diffPropName];\n    var eleProp = ele.pstyle(diffPropName);\n\n    if (!cxtProp) {\n      // no context prop means delete\n      if (!eleProp) {\n        continue; // no existing prop means nothing needs to be removed\n        // nb affects initial application on mapped values like control-point-distances\n      } else if (eleProp.bypass) {\n        cxtProp = {\n          name: diffPropName,\n          deleteBypassed: true\n        };\n      } else {\n        cxtProp = {\n          name: diffPropName,\n          \"delete\": true\n        };\n      }\n    } // save cycles when the context prop doesn't need to be applied\n\n\n    if (eleProp === cxtProp) {\n      continue;\n    } // save cycles when a mapped context prop doesn't need to be applied\n\n\n    if (cxtProp.mapped === types.fn // context prop is function mapper\n    && eleProp != null // some props can be null even by default (e.g. a prop that overrides another one)\n    && eleProp.mapping != null // ele prop is a concrete value from from a mapper\n    && eleProp.mapping.value === cxtProp.value // the current prop on the ele is a flat prop value for the function mapper\n    ) {\n      // NB don't write to cxtProp, as it's shared among eles (stored in stylesheet)\n      var mapping = eleProp.mapping; // can write to mapping, as it's a per-ele copy\n\n      var fnValue = mapping.fnValue = cxtProp.value(ele); // temporarily cache the value in case of a miss\n\n      if (fnValue === mapping.prevFnValue) {\n        continue;\n      }\n    }\n\n    var retDiffProp = retDiffProps[diffPropName] = {\n      prev: eleProp\n    };\n    self.applyParsedProperty(ele, cxtProp);\n    retDiffProp.next = ele.pstyle(diffPropName);\n\n    if (retDiffProp.next && retDiffProp.next.bypass) {\n      retDiffProp.next = retDiffProp.next.bypassed;\n    }\n  }\n\n  return {\n    diffProps: retDiffProps\n  };\n};\n\nstyfn$8.updateStyleHints = function (ele) {\n  var _p = ele._private;\n  var self = this;\n  var propNames = self.propertyGroupNames;\n  var propGrKeys = self.propertyGroupKeys;\n\n  var propHash = function propHash(ele, propNames, seedKey) {\n    return self.getPropertiesHash(ele, propNames, seedKey);\n  };\n\n  var oldStyleKey = _p.styleKey;\n\n  if (ele.removed()) {\n    return false;\n  }\n\n  var isNode = _p.group === 'nodes'; // get the style key hashes per prop group\n  // but lazily -- only use non-default prop values to reduce the number of hashes\n  //\n\n  var overriddenStyles = ele._private.style;\n  propNames = Object.keys(overriddenStyles);\n\n  for (var i = 0; i < propGrKeys.length; i++) {\n    var grKey = propGrKeys[i];\n    _p.styleKeys[grKey] = [DEFAULT_HASH_SEED, DEFAULT_HASH_SEED_ALT];\n  }\n\n  var updateGrKey1 = function updateGrKey1(val, grKey) {\n    return _p.styleKeys[grKey][0] = hashInt(val, _p.styleKeys[grKey][0]);\n  };\n\n  var updateGrKey2 = function updateGrKey2(val, grKey) {\n    return _p.styleKeys[grKey][1] = hashIntAlt(val, _p.styleKeys[grKey][1]);\n  };\n\n  var updateGrKey = function updateGrKey(val, grKey) {\n    updateGrKey1(val, grKey);\n    updateGrKey2(val, grKey);\n  };\n\n  var updateGrKeyWStr = function updateGrKeyWStr(strVal, grKey) {\n    for (var j = 0; j < strVal.length; j++) {\n      var ch = strVal.charCodeAt(j);\n      updateGrKey1(ch, grKey);\n      updateGrKey2(ch, grKey);\n    }\n  }; // - hashing works on 32 bit ints b/c we use bitwise ops\n  // - small numbers get cut off (e.g. 0.123 is seen as 0 by the hashing function)\n  // - raise up small numbers so more significant digits are seen by hashing\n  // - make small numbers larger than a normal value to avoid collisions\n  // - works in practice and it's relatively cheap\n\n\n  var N = 2000000000;\n\n  var cleanNum = function cleanNum(val) {\n    return -128 < val && val < 128 && Math.floor(val) !== val ? N - (val * 1024 | 0) : val;\n  };\n\n  for (var _i = 0; _i < propNames.length; _i++) {\n    var name = propNames[_i];\n    var parsedProp = overriddenStyles[name];\n\n    if (parsedProp == null) {\n      continue;\n    }\n\n    var propInfo = this.properties[name];\n    var type = propInfo.type;\n    var _grKey = propInfo.groupKey;\n    var normalizedNumberVal = void 0;\n\n    if (propInfo.hashOverride != null) {\n      normalizedNumberVal = propInfo.hashOverride(ele, parsedProp);\n    } else if (parsedProp.pfValue != null) {\n      normalizedNumberVal = parsedProp.pfValue;\n    } // might not be a number if it allows enums\n\n\n    var numberVal = propInfo.enums == null ? parsedProp.value : null;\n    var haveNormNum = normalizedNumberVal != null;\n    var haveUnitedNum = numberVal != null;\n    var haveNum = haveNormNum || haveUnitedNum;\n    var units = parsedProp.units; // numbers are cheaper to hash than strings\n    // 1 hash op vs n hash ops (for length n string)\n\n    if (type.number && haveNum && !type.multiple) {\n      var v = haveNormNum ? normalizedNumberVal : numberVal;\n      updateGrKey(cleanNum(v), _grKey);\n\n      if (!haveNormNum && units != null) {\n        updateGrKeyWStr(units, _grKey);\n      }\n    } else {\n      updateGrKeyWStr(parsedProp.strValue, _grKey);\n    }\n  } // overall style key\n  //\n\n\n  var hash = [DEFAULT_HASH_SEED, DEFAULT_HASH_SEED_ALT];\n\n  for (var _i2 = 0; _i2 < propGrKeys.length; _i2++) {\n    var _grKey2 = propGrKeys[_i2];\n    var grHash = _p.styleKeys[_grKey2];\n    hash[0] = hashInt(grHash[0], hash[0]);\n    hash[1] = hashIntAlt(grHash[1], hash[1]);\n  }\n\n  _p.styleKey = combineHashes(hash[0], hash[1]); // label dims\n  //\n\n  var sk = _p.styleKeys;\n  _p.labelDimsKey = combineHashesArray(sk.labelDimensions);\n  var labelKeys = propHash(ele, ['label'], sk.labelDimensions);\n  _p.labelKey = combineHashesArray(labelKeys);\n  _p.labelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, labelKeys));\n\n  if (!isNode) {\n    var sourceLabelKeys = propHash(ele, ['source-label'], sk.labelDimensions);\n    _p.sourceLabelKey = combineHashesArray(sourceLabelKeys);\n    _p.sourceLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, sourceLabelKeys));\n    var targetLabelKeys = propHash(ele, ['target-label'], sk.labelDimensions);\n    _p.targetLabelKey = combineHashesArray(targetLabelKeys);\n    _p.targetLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, targetLabelKeys));\n  } // node\n  //\n\n\n  if (isNode) {\n    var _p$styleKeys = _p.styleKeys,\n        nodeBody = _p$styleKeys.nodeBody,\n        nodeBorder = _p$styleKeys.nodeBorder,\n        backgroundImage = _p$styleKeys.backgroundImage,\n        compound = _p$styleKeys.compound,\n        pie = _p$styleKeys.pie;\n    var nodeKeys = [nodeBody, nodeBorder, backgroundImage, compound, pie].filter(function (k) {\n      return k != null;\n    }).reduce(hashArrays, [DEFAULT_HASH_SEED, DEFAULT_HASH_SEED_ALT]);\n    _p.nodeKey = combineHashesArray(nodeKeys);\n    _p.hasPie = pie != null && pie[0] !== DEFAULT_HASH_SEED && pie[1] !== DEFAULT_HASH_SEED_ALT;\n  }\n\n  return oldStyleKey !== _p.styleKey;\n};\n\nstyfn$8.clearStyleHints = function (ele) {\n  var _p = ele._private;\n  _p.styleCxtKey = '';\n  _p.styleKeys = {};\n  _p.styleKey = null;\n  _p.labelKey = null;\n  _p.labelStyleKey = null;\n  _p.sourceLabelKey = null;\n  _p.sourceLabelStyleKey = null;\n  _p.targetLabelKey = null;\n  _p.targetLabelStyleKey = null;\n  _p.nodeKey = null;\n  _p.hasPie = null;\n}; // apply a property to the style (for internal use)\n// returns whether application was successful\n//\n// now, this function flattens the property, and here's how:\n//\n// for parsedProp:{ bypass: true, deleteBypass: true }\n// no property is generated, instead the bypass property in the\n// element's style is replaced by what's pointed to by the `bypassed`\n// field in the bypass property (i.e. restoring the property the\n// bypass was overriding)\n//\n// for parsedProp:{ mapped: truthy }\n// the generated flattenedProp:{ mapping: prop }\n//\n// for parsedProp:{ bypass: true }\n// the generated flattenedProp:{ bypassed: parsedProp }\n\n\nstyfn$8.applyParsedProperty = function (ele, parsedProp) {\n  var self = this;\n  var prop = parsedProp;\n  var style = ele._private.style;\n  var flatProp;\n  var types = self.types;\n  var type = self.properties[prop.name].type;\n  var propIsBypass = prop.bypass;\n  var origProp = style[prop.name];\n  var origPropIsBypass = origProp && origProp.bypass;\n  var _p = ele._private;\n  var flatPropMapping = 'mapping';\n\n  var getVal = function getVal(p) {\n    if (p == null) {\n      return null;\n    } else if (p.pfValue != null) {\n      return p.pfValue;\n    } else {\n      return p.value;\n    }\n  };\n\n  var checkTriggers = function checkTriggers() {\n    var fromVal = getVal(origProp);\n    var toVal = getVal(prop);\n    self.checkTriggers(ele, prop.name, fromVal, toVal);\n  };\n\n  if (prop && prop.name.substr(0, 3) === 'pie') {\n    warn('The pie style properties are deprecated.  Create charts using background images instead.');\n  } // edge sanity checks to prevent the client from making serious mistakes\n\n\n  if (parsedProp.name === 'curve-style' && ele.isEdge() && ( // loops must be bundled beziers\n  parsedProp.value !== 'bezier' && ele.isLoop() || // edges connected to compound nodes can not be haystacks\n  parsedProp.value === 'haystack' && (ele.source().isParent() || ele.target().isParent()))) {\n    prop = parsedProp = this.parse(parsedProp.name, 'bezier', propIsBypass);\n  }\n\n  if (prop[\"delete\"]) {\n    // delete the property and use the default value on falsey value\n    style[prop.name] = undefined;\n    checkTriggers();\n    return true;\n  }\n\n  if (prop.deleteBypassed) {\n    // delete the property that the\n    if (!origProp) {\n      checkTriggers();\n      return true; // can't delete if no prop\n    } else if (origProp.bypass) {\n      // delete bypassed\n      origProp.bypassed = undefined;\n      checkTriggers();\n      return true;\n    } else {\n      return false; // we're unsuccessful deleting the bypassed\n    }\n  } // check if we need to delete the current bypass\n\n\n  if (prop.deleteBypass) {\n    // then this property is just here to indicate we need to delete\n    if (!origProp) {\n      checkTriggers();\n      return true; // property is already not defined\n    } else if (origProp.bypass) {\n      // then replace the bypass property with the original\n      // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)\n      style[prop.name] = origProp.bypassed;\n      checkTriggers();\n      return true;\n    } else {\n      return false; // we're unsuccessful deleting the bypass\n    }\n  }\n\n  var printMappingErr = function printMappingErr() {\n    warn('Do not assign mappings to elements without corresponding data (i.e. ele `' + ele.id() + '` has no mapping for property `' + prop.name + '` with data field `' + prop.field + '`); try a `[' + prop.field + ']` selector to limit scope to elements with `' + prop.field + '` defined');\n  }; // put the property in the style objects\n\n\n  switch (prop.mapped) {\n    // flatten the property if mapped\n    case types.mapData:\n      {\n        // flatten the field (e.g. data.foo.bar)\n        var fields = prop.field.split('.');\n        var fieldVal = _p.data;\n\n        for (var i = 0; i < fields.length && fieldVal; i++) {\n          var field = fields[i];\n          fieldVal = fieldVal[field];\n        }\n\n        if (fieldVal == null) {\n          printMappingErr();\n          return false;\n        }\n\n        var percent;\n\n        if (!number$1(fieldVal)) {\n          // then don't apply and fall back on the existing style\n          warn('Do not use continuous mappers without specifying numeric data (i.e. `' + prop.field + ': ' + fieldVal + '` for `' + ele.id() + '` is non-numeric)');\n          return false;\n        } else {\n          var fieldWidth = prop.fieldMax - prop.fieldMin;\n\n          if (fieldWidth === 0) {\n            // safety check -- not strictly necessary as no props of zero range should be passed here\n            percent = 0;\n          } else {\n            percent = (fieldVal - prop.fieldMin) / fieldWidth;\n          }\n        } // make sure to bound percent value\n\n\n        if (percent < 0) {\n          percent = 0;\n        } else if (percent > 1) {\n          percent = 1;\n        }\n\n        if (type.color) {\n          var r1 = prop.valueMin[0];\n          var r2 = prop.valueMax[0];\n          var g1 = prop.valueMin[1];\n          var g2 = prop.valueMax[1];\n          var b1 = prop.valueMin[2];\n          var b2 = prop.valueMax[2];\n          var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];\n          var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];\n          var clr = [Math.round(r1 + (r2 - r1) * percent), Math.round(g1 + (g2 - g1) * percent), Math.round(b1 + (b2 - b1) * percent), Math.round(a1 + (a2 - a1) * percent)];\n          flatProp = {\n            // colours are simple, so just create the flat property instead of expensive string parsing\n            bypass: prop.bypass,\n            // we're a bypass if the mapping property is a bypass\n            name: prop.name,\n            value: clr,\n            strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'\n          };\n        } else if (type.number) {\n          var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;\n          flatProp = this.parse(prop.name, calcValue, prop.bypass, flatPropMapping);\n        } else {\n          return false; // can only map to colours and numbers\n        }\n\n        if (!flatProp) {\n          // if we can't flatten the property, then don't apply the property and fall back on the existing style\n          printMappingErr();\n          return false;\n        }\n\n        flatProp.mapping = prop; // keep a reference to the mapping\n\n        prop = flatProp; // the flattened (mapped) property is the one we want\n\n        break;\n      }\n    // direct mapping\n\n    case types.data:\n      {\n        // flatten the field (e.g. data.foo.bar)\n        var _fields = prop.field.split('.');\n\n        var _fieldVal = _p.data;\n\n        for (var _i3 = 0; _i3 < _fields.length && _fieldVal; _i3++) {\n          var _field = _fields[_i3];\n          _fieldVal = _fieldVal[_field];\n        }\n\n        if (_fieldVal != null) {\n          flatProp = this.parse(prop.name, _fieldVal, prop.bypass, flatPropMapping);\n        }\n\n        if (!flatProp) {\n          // if we can't flatten the property, then don't apply and fall back on the existing style\n          printMappingErr();\n          return false;\n        }\n\n        flatProp.mapping = prop; // keep a reference to the mapping\n\n        prop = flatProp; // the flattened (mapped) property is the one we want\n\n        break;\n      }\n\n    case types.fn:\n      {\n        var fn = prop.value;\n        var fnRetVal = prop.fnValue != null ? prop.fnValue : fn(ele); // check for cached value before calling function\n\n        prop.prevFnValue = fnRetVal;\n\n        if (fnRetVal == null) {\n          warn('Custom function mappers may not return null (i.e. `' + prop.name + '` for ele `' + ele.id() + '` is null)');\n          return false;\n        }\n\n        flatProp = this.parse(prop.name, fnRetVal, prop.bypass, flatPropMapping);\n\n        if (!flatProp) {\n          warn('Custom function mappers may not return invalid values for the property type (i.e. `' + prop.name + '` for ele `' + ele.id() + '` is invalid)');\n          return false;\n        }\n\n        flatProp.mapping = copy(prop); // keep a reference to the mapping\n\n        prop = flatProp; // the flattened (mapped) property is the one we want\n\n        break;\n      }\n\n    case undefined:\n      break;\n    // just set the property\n\n    default:\n      return false;\n    // not a valid mapping\n  } // if the property is a bypass property, then link the resultant property to the original one\n\n\n  if (propIsBypass) {\n    if (origPropIsBypass) {\n      // then this bypass overrides the existing one\n      prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass\n    } else {\n      // then link the orig prop to the new bypass\n      prop.bypassed = origProp;\n    }\n\n    style[prop.name] = prop; // and set\n  } else {\n    // prop is not bypass\n    if (origPropIsBypass) {\n      // then keep the orig prop (since it's a bypass) and link to the new prop\n      origProp.bypassed = prop;\n    } else {\n      // then just replace the old prop with the new one\n      style[prop.name] = prop;\n    }\n  }\n\n  checkTriggers();\n  return true;\n};\n\nstyfn$8.cleanElements = function (eles, keepBypasses) {\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n    this.clearStyleHints(ele);\n    ele.dirtyCompoundBoundsCache();\n    ele.dirtyBoundingBoxCache();\n\n    if (!keepBypasses) {\n      ele._private.style = {};\n    } else {\n      var style = ele._private.style;\n      var propNames = Object.keys(style);\n\n      for (var j = 0; j < propNames.length; j++) {\n        var propName = propNames[j];\n        var eleProp = style[propName];\n\n        if (eleProp != null) {\n          if (eleProp.bypass) {\n            eleProp.bypassed = null;\n          } else {\n            style[propName] = null;\n          }\n        }\n      }\n    }\n  }\n}; // updates the visual style for all elements (useful for manual style modification after init)\n\n\nstyfn$8.update = function () {\n  var cy = this._private.cy;\n  var eles = cy.mutableElements();\n  eles.updateStyle();\n}; // diffProps : { name => { prev, next } }\n\n\nstyfn$8.updateTransitions = function (ele, diffProps) {\n  var self = this;\n  var _p = ele._private;\n  var props = ele.pstyle('transition-property').value;\n  var duration = ele.pstyle('transition-duration').pfValue;\n  var delay = ele.pstyle('transition-delay').pfValue;\n\n  if (props.length > 0 && duration > 0) {\n    var style = {}; // build up the style to animate towards\n\n    var anyPrev = false;\n\n    for (var i = 0; i < props.length; i++) {\n      var prop = props[i];\n      var styProp = ele.pstyle(prop);\n      var diffProp = diffProps[prop];\n\n      if (!diffProp) {\n        continue;\n      }\n\n      var prevProp = diffProp.prev;\n      var fromProp = prevProp;\n      var toProp = diffProp.next != null ? diffProp.next : styProp;\n      var diff = false;\n      var initVal = void 0;\n      var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)\n\n      if (!fromProp) {\n        continue;\n      } // consider px values\n\n\n      if (number$1(fromProp.pfValue) && number$1(toProp.pfValue)) {\n        diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy\n\n        initVal = fromProp.pfValue + initDt * diff; // consider numerical values\n      } else if (number$1(fromProp.value) && number$1(toProp.value)) {\n        diff = toProp.value - fromProp.value; // nonzero is truthy\n\n        initVal = fromProp.value + initDt * diff; // consider colour values\n      } else if (array(fromProp.value) && array(toProp.value)) {\n        diff = fromProp.value[0] !== toProp.value[0] || fromProp.value[1] !== toProp.value[1] || fromProp.value[2] !== toProp.value[2];\n        initVal = fromProp.strValue;\n      } // the previous value is good for an animation only if it's different\n\n\n      if (diff) {\n        style[prop] = toProp.strValue; // to val\n\n        this.applyBypass(ele, prop, initVal); // from val\n\n        anyPrev = true;\n      }\n    } // end if props allow ani\n    // can't transition if there's nothing previous to transition from\n\n\n    if (!anyPrev) {\n      return;\n    }\n\n    _p.transitioning = true;\n    new Promise$1(function (resolve) {\n      if (delay > 0) {\n        ele.delayAnimation(delay).play().promise().then(resolve);\n      } else {\n        resolve();\n      }\n    }).then(function () {\n      return ele.animation({\n        style: style,\n        duration: duration,\n        easing: ele.pstyle('transition-timing-function').value,\n        queue: false\n      }).play().promise();\n    }).then(function () {\n      // if( !isBypass ){\n      self.removeBypasses(ele, props);\n      ele.emitAndNotify('style'); // }\n\n      _p.transitioning = false;\n    });\n  } else if (_p.transitioning) {\n    this.removeBypasses(ele, props);\n    ele.emitAndNotify('style');\n    _p.transitioning = false;\n  }\n};\n\nstyfn$8.checkTrigger = function (ele, name, fromValue, toValue, getTrigger, onTrigger) {\n  var prop = this.properties[name];\n  var triggerCheck = getTrigger(prop);\n\n  if (triggerCheck != null && triggerCheck(fromValue, toValue)) {\n    onTrigger(prop);\n  }\n};\n\nstyfn$8.checkZOrderTrigger = function (ele, name, fromValue, toValue) {\n  var _this = this;\n\n  this.checkTrigger(ele, name, fromValue, toValue, function (prop) {\n    return prop.triggersZOrder;\n  }, function () {\n    _this._private.cy.notify('zorder', ele);\n  });\n};\n\nstyfn$8.checkBoundsTrigger = function (ele, name, fromValue, toValue) {\n  this.checkTrigger(ele, name, fromValue, toValue, function (prop) {\n    return prop.triggersBounds;\n  }, function (prop) {\n    ele.dirtyCompoundBoundsCache();\n    ele.dirtyBoundingBoxCache(); // if the prop change makes the bb of pll bezier edges invalid,\n    // then dirty the pll edge bb cache as well\n\n    if ( // only for beziers -- so performance of other edges isn't affected\n    prop.triggersBoundsOfParallelBeziers && (name === 'curve-style' && (fromValue === 'bezier' || toValue === 'bezier') || name === 'display' && (fromValue === 'none' || toValue === 'none'))) {\n      ele.parallelEdges().forEach(function (pllEdge) {\n        if (pllEdge.isBundledBezier()) {\n          pllEdge.dirtyBoundingBoxCache();\n        }\n      });\n    }\n  });\n};\n\nstyfn$8.checkTriggers = function (ele, name, fromValue, toValue) {\n  ele.dirtyStyleCache();\n  this.checkZOrderTrigger(ele, name, fromValue, toValue);\n  this.checkBoundsTrigger(ele, name, fromValue, toValue);\n};\n\nvar styfn$7 = {}; // bypasses are applied to an existing style on an element, and just tacked on temporarily\n// returns true iff application was successful for at least 1 specified property\n\nstyfn$7.applyBypass = function (eles, name, value, updateTransitions) {\n  var self = this;\n  var props = [];\n  var isBypass = true; // put all the properties (can specify one or many) in an array after parsing them\n\n  if (name === '*' || name === '**') {\n    // apply to all property names\n    if (value !== undefined) {\n      for (var i = 0; i < self.properties.length; i++) {\n        var prop = self.properties[i];\n        var _name = prop.name;\n        var parsedProp = this.parse(_name, value, true);\n\n        if (parsedProp) {\n          props.push(parsedProp);\n        }\n      }\n    }\n  } else if (string(name)) {\n    // then parse the single property\n    var _parsedProp = this.parse(name, value, true);\n\n    if (_parsedProp) {\n      props.push(_parsedProp);\n    }\n  } else if (plainObject(name)) {\n    // then parse each property\n    var specifiedProps = name;\n    updateTransitions = value;\n    var names = Object.keys(specifiedProps);\n\n    for (var _i = 0; _i < names.length; _i++) {\n      var _name2 = names[_i];\n      var _value = specifiedProps[_name2];\n\n      if (_value === undefined) {\n        // try camel case name too\n        _value = specifiedProps[dash2camel(_name2)];\n      }\n\n      if (_value !== undefined) {\n        var _parsedProp2 = this.parse(_name2, _value, true);\n\n        if (_parsedProp2) {\n          props.push(_parsedProp2);\n        }\n      }\n    }\n  } else {\n    // can't do anything without well defined properties\n    return false;\n  } // we've failed if there are no valid properties\n\n\n  if (props.length === 0) {\n    return false;\n  } // now, apply the bypass properties on the elements\n\n\n  var ret = false; // return true if at least one succesful bypass applied\n\n  for (var _i2 = 0; _i2 < eles.length; _i2++) {\n    // for each ele\n    var ele = eles[_i2];\n    var diffProps = {};\n    var diffProp = void 0;\n\n    for (var j = 0; j < props.length; j++) {\n      // for each prop\n      var _prop = props[j];\n\n      if (updateTransitions) {\n        var prevProp = ele.pstyle(_prop.name);\n        diffProp = diffProps[_prop.name] = {\n          prev: prevProp\n        };\n      }\n\n      ret = this.applyParsedProperty(ele, copy(_prop)) || ret;\n\n      if (updateTransitions) {\n        diffProp.next = ele.pstyle(_prop.name);\n      }\n    } // for props\n\n\n    if (ret) {\n      this.updateStyleHints(ele);\n    }\n\n    if (updateTransitions) {\n      this.updateTransitions(ele, diffProps, isBypass);\n    }\n  } // for eles\n\n\n  return ret;\n}; // only useful in specific cases like animation\n\n\nstyfn$7.overrideBypass = function (eles, name, value) {\n  name = camel2dash(name);\n\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n    var prop = ele._private.style[name];\n    var type = this.properties[name].type;\n    var isColor = type.color;\n    var isMulti = type.mutiple;\n    var oldValue = !prop ? null : prop.pfValue != null ? prop.pfValue : prop.value;\n\n    if (!prop || !prop.bypass) {\n      // need a bypass if one doesn't exist\n      this.applyBypass(ele, name, value);\n    } else {\n      prop.value = value;\n\n      if (prop.pfValue != null) {\n        prop.pfValue = value;\n      }\n\n      if (isColor) {\n        prop.strValue = 'rgb(' + value.join(',') + ')';\n      } else if (isMulti) {\n        prop.strValue = value.join(' ');\n      } else {\n        prop.strValue = '' + value;\n      }\n\n      this.updateStyleHints(ele);\n    }\n\n    this.checkTriggers(ele, name, oldValue, value);\n  }\n};\n\nstyfn$7.removeAllBypasses = function (eles, updateTransitions) {\n  return this.removeBypasses(eles, this.propertyNames, updateTransitions);\n};\n\nstyfn$7.removeBypasses = function (eles, props, updateTransitions) {\n  var isBypass = true;\n\n  for (var j = 0; j < eles.length; j++) {\n    var ele = eles[j];\n    var diffProps = {};\n\n    for (var i = 0; i < props.length; i++) {\n      var name = props[i];\n      var prop = this.properties[name];\n      var prevProp = ele.pstyle(prop.name);\n\n      if (!prevProp || !prevProp.bypass) {\n        // if a bypass doesn't exist for the prop, nothing needs to be removed\n        continue;\n      }\n\n      var value = ''; // empty => remove bypass\n\n      var parsedProp = this.parse(name, value, true);\n      var diffProp = diffProps[prop.name] = {\n        prev: prevProp\n      };\n      this.applyParsedProperty(ele, parsedProp);\n      diffProp.next = ele.pstyle(prop.name);\n    } // for props\n\n\n    this.updateStyleHints(ele);\n\n    if (updateTransitions) {\n      this.updateTransitions(ele, diffProps, isBypass);\n    }\n  } // for eles\n\n};\n\nvar styfn$6 = {}; // gets what an em size corresponds to in pixels relative to a dom element\n\nstyfn$6.getEmSizeInPixels = function () {\n  var px = this.containerCss('font-size');\n\n  if (px != null) {\n    return parseFloat(px);\n  } else {\n    return 1; // for headless\n  }\n}; // gets css property from the core container\n\n\nstyfn$6.containerCss = function (propName) {\n  var cy = this._private.cy;\n  var domElement = cy.container();\n  var containerWindow = cy.window();\n\n  if (containerWindow && domElement && containerWindow.getComputedStyle) {\n    return containerWindow.getComputedStyle(domElement).getPropertyValue(propName);\n  }\n};\n\nvar styfn$5 = {}; // gets the rendered style for an element\n\nstyfn$5.getRenderedStyle = function (ele, prop) {\n  if (prop) {\n    return this.getStylePropertyValue(ele, prop, true);\n  } else {\n    return this.getRawStyle(ele, true);\n  }\n}; // gets the raw style for an element\n\n\nstyfn$5.getRawStyle = function (ele, isRenderedVal) {\n  var self = this;\n  ele = ele[0]; // insure it's an element\n\n  if (ele) {\n    var rstyle = {};\n\n    for (var i = 0; i < self.properties.length; i++) {\n      var prop = self.properties[i];\n      var val = self.getStylePropertyValue(ele, prop.name, isRenderedVal);\n\n      if (val != null) {\n        rstyle[prop.name] = val;\n        rstyle[dash2camel(prop.name)] = val;\n      }\n    }\n\n    return rstyle;\n  }\n};\n\nstyfn$5.getIndexedStyle = function (ele, property, subproperty, index) {\n  var pstyle = ele.pstyle(property)[subproperty][index];\n  return pstyle != null ? pstyle : ele.cy().style().getDefaultProperty(property)[subproperty][0];\n};\n\nstyfn$5.getStylePropertyValue = function (ele, propName, isRenderedVal) {\n  var self = this;\n  ele = ele[0]; // insure it's an element\n\n  if (ele) {\n    var prop = self.properties[propName];\n\n    if (prop.alias) {\n      prop = prop.pointsTo;\n    }\n\n    var type = prop.type;\n    var styleProp = ele.pstyle(prop.name);\n\n    if (styleProp) {\n      var value = styleProp.value,\n          units = styleProp.units,\n          strValue = styleProp.strValue;\n\n      if (isRenderedVal && type.number && value != null && number$1(value)) {\n        var zoom = ele.cy().zoom();\n\n        var getRenderedValue = function getRenderedValue(val) {\n          return val * zoom;\n        };\n\n        var getValueStringWithUnits = function getValueStringWithUnits(val, units) {\n          return getRenderedValue(val) + units;\n        };\n\n        var isArrayValue = array(value);\n        var haveUnits = isArrayValue ? units.every(function (u) {\n          return u != null;\n        }) : units != null;\n\n        if (haveUnits) {\n          if (isArrayValue) {\n            return value.map(function (v, i) {\n              return getValueStringWithUnits(v, units[i]);\n            }).join(' ');\n          } else {\n            return getValueStringWithUnits(value, units);\n          }\n        } else {\n          if (isArrayValue) {\n            return value.map(function (v) {\n              return string(v) ? v : '' + getRenderedValue(v);\n            }).join(' ');\n          } else {\n            return '' + getRenderedValue(value);\n          }\n        }\n      } else if (strValue != null) {\n        return strValue;\n      }\n    }\n\n    return null;\n  }\n};\n\nstyfn$5.getAnimationStartStyle = function (ele, aniProps) {\n  var rstyle = {};\n\n  for (var i = 0; i < aniProps.length; i++) {\n    var aniProp = aniProps[i];\n    var name = aniProp.name;\n    var styleProp = ele.pstyle(name);\n\n    if (styleProp !== undefined) {\n      // then make a prop of it\n      if (plainObject(styleProp)) {\n        styleProp = this.parse(name, styleProp.strValue);\n      } else {\n        styleProp = this.parse(name, styleProp);\n      }\n    }\n\n    if (styleProp) {\n      rstyle[name] = styleProp;\n    }\n  }\n\n  return rstyle;\n};\n\nstyfn$5.getPropsList = function (propsObj) {\n  var self = this;\n  var rstyle = [];\n  var style = propsObj;\n  var props = self.properties;\n\n  if (style) {\n    var names = Object.keys(style);\n\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n      var val = style[name];\n      var prop = props[name] || props[camel2dash(name)];\n      var styleProp = this.parse(prop.name, val);\n\n      if (styleProp) {\n        rstyle.push(styleProp);\n      }\n    }\n  }\n\n  return rstyle;\n};\n\nstyfn$5.getNonDefaultPropertiesHash = function (ele, propNames, seed) {\n  var hash = seed.slice();\n  var name, val, strVal, chVal;\n  var i, j;\n\n  for (i = 0; i < propNames.length; i++) {\n    name = propNames[i];\n    val = ele.pstyle(name, false);\n\n    if (val == null) {\n      continue;\n    } else if (val.pfValue != null) {\n      hash[0] = hashInt(chVal, hash[0]);\n      hash[1] = hashIntAlt(chVal, hash[1]);\n    } else {\n      strVal = val.strValue;\n\n      for (j = 0; j < strVal.length; j++) {\n        chVal = strVal.charCodeAt(j);\n        hash[0] = hashInt(chVal, hash[0]);\n        hash[1] = hashIntAlt(chVal, hash[1]);\n      }\n    }\n  }\n\n  return hash;\n};\n\nstyfn$5.getPropertiesHash = styfn$5.getNonDefaultPropertiesHash;\n\nvar styfn$4 = {};\n\nstyfn$4.appendFromJson = function (json) {\n  var style = this;\n\n  for (var i = 0; i < json.length; i++) {\n    var context = json[i];\n    var selector = context.selector;\n    var props = context.style || context.css;\n    var names = Object.keys(props);\n    style.selector(selector); // apply selector\n\n    for (var j = 0; j < names.length; j++) {\n      var name = names[j];\n      var value = props[name];\n      style.css(name, value); // apply property\n    }\n  }\n\n  return style;\n}; // accessible cy.style() function\n\n\nstyfn$4.fromJson = function (json) {\n  var style = this;\n  style.resetToDefault();\n  style.appendFromJson(json);\n  return style;\n}; // get json from cy.style() api\n\n\nstyfn$4.json = function () {\n  var json = [];\n\n  for (var i = this.defaultLength; i < this.length; i++) {\n    var cxt = this[i];\n    var selector = cxt.selector;\n    var props = cxt.properties;\n    var css = {};\n\n    for (var j = 0; j < props.length; j++) {\n      var prop = props[j];\n      css[prop.name] = prop.strValue;\n    }\n\n    json.push({\n      selector: !selector ? 'core' : selector.toString(),\n      style: css\n    });\n  }\n\n  return json;\n};\n\nvar styfn$3 = {};\n\nstyfn$3.appendFromString = function (string) {\n  var self = this;\n  var style = this;\n  var remaining = '' + string;\n  var selAndBlockStr;\n  var blockRem;\n  var propAndValStr; // remove comments from the style string\n\n  remaining = remaining.replace(/[/][*](\\s|.)+?[*][/]/g, '');\n\n  function removeSelAndBlockFromRemaining() {\n    // remove the parsed selector and block from the remaining text to parse\n    if (remaining.length > selAndBlockStr.length) {\n      remaining = remaining.substr(selAndBlockStr.length);\n    } else {\n      remaining = '';\n    }\n  }\n\n  function removePropAndValFromRem() {\n    // remove the parsed property and value from the remaining block text to parse\n    if (blockRem.length > propAndValStr.length) {\n      blockRem = blockRem.substr(propAndValStr.length);\n    } else {\n      blockRem = '';\n    }\n  }\n\n  for (;;) {\n    var nothingLeftToParse = remaining.match(/^\\s*$/);\n\n    if (nothingLeftToParse) {\n      break;\n    }\n\n    var selAndBlock = remaining.match(/^\\s*((?:.|\\s)+?)\\s*\\{((?:.|\\s)+?)\\}/);\n\n    if (!selAndBlock) {\n      warn('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);\n      break;\n    }\n\n    selAndBlockStr = selAndBlock[0]; // parse the selector\n\n    var selectorStr = selAndBlock[1];\n\n    if (selectorStr !== 'core') {\n      var selector = new Selector(selectorStr);\n\n      if (selector.invalid) {\n        warn('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr); // skip this selector and block\n\n        removeSelAndBlockFromRemaining();\n        continue;\n      }\n    } // parse the block of properties and values\n\n\n    var blockStr = selAndBlock[2];\n    var invalidBlock = false;\n    blockRem = blockStr;\n    var props = [];\n\n    for (;;) {\n      var _nothingLeftToParse = blockRem.match(/^\\s*$/);\n\n      if (_nothingLeftToParse) {\n        break;\n      }\n\n      var propAndVal = blockRem.match(/^\\s*(.+?)\\s*:\\s*(.+?)(?:\\s*;|\\s*$)/);\n\n      if (!propAndVal) {\n        warn('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);\n        invalidBlock = true;\n        break;\n      }\n\n      propAndValStr = propAndVal[0];\n      var propStr = propAndVal[1];\n      var valStr = propAndVal[2];\n      var prop = self.properties[propStr];\n\n      if (!prop) {\n        warn('Skipping property: Invalid property name in: ' + propAndValStr); // skip this property in the block\n\n        removePropAndValFromRem();\n        continue;\n      }\n\n      var parsedProp = style.parse(propStr, valStr);\n\n      if (!parsedProp) {\n        warn('Skipping property: Invalid property definition in: ' + propAndValStr); // skip this property in the block\n\n        removePropAndValFromRem();\n        continue;\n      }\n\n      props.push({\n        name: propStr,\n        val: valStr\n      });\n      removePropAndValFromRem();\n    }\n\n    if (invalidBlock) {\n      removeSelAndBlockFromRemaining();\n      break;\n    } // put the parsed block in the style\n\n\n    style.selector(selectorStr);\n\n    for (var i = 0; i < props.length; i++) {\n      var _prop = props[i];\n      style.css(_prop.name, _prop.val);\n    }\n\n    removeSelAndBlockFromRemaining();\n  }\n\n  return style;\n};\n\nstyfn$3.fromString = function (string) {\n  var style = this;\n  style.resetToDefault();\n  style.appendFromString(string);\n  return style;\n};\n\nvar styfn$2 = {};\n\n(function () {\n  var number$1 = number;\n  var rgba = rgbaNoBackRefs;\n  var hsla = hslaNoBackRefs;\n  var hex3$1 = hex3;\n  var hex6$1 = hex6;\n\n  var data = function data(prefix) {\n    return '^' + prefix + '\\\\s*\\\\(\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\)$';\n  };\n\n  var mapData = function mapData(prefix) {\n    var mapArg = number$1 + '|\\\\w+|' + rgba + '|' + hsla + '|' + hex3$1 + '|' + hex6$1;\n    return '^' + prefix + '\\\\s*\\\\(([\\\\w\\\\.]+)\\\\s*\\\\,\\\\s*(' + number$1 + ')\\\\s*\\\\,\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + mapArg + ')\\\\s*\\\\,\\\\s*(' + mapArg + ')\\\\)$';\n  };\n\n  var urlRegexes = ['^url\\\\s*\\\\(\\\\s*[\\'\"]?(.+?)[\\'\"]?\\\\s*\\\\)$', '^(none)$', '^(.+)$']; // each visual style property has a type and needs to be validated according to it\n\n  styfn$2.types = {\n    time: {\n      number: true,\n      min: 0,\n      units: 's|ms',\n      implicitUnits: 'ms'\n    },\n    percent: {\n      number: true,\n      min: 0,\n      max: 100,\n      units: '%',\n      implicitUnits: '%'\n    },\n    percentages: {\n      number: true,\n      min: 0,\n      max: 100,\n      units: '%',\n      implicitUnits: '%',\n      multiple: true\n    },\n    zeroOneNumber: {\n      number: true,\n      min: 0,\n      max: 1,\n      unitless: true\n    },\n    zeroOneNumbers: {\n      number: true,\n      min: 0,\n      max: 1,\n      unitless: true,\n      multiple: true\n    },\n    nOneOneNumber: {\n      number: true,\n      min: -1,\n      max: 1,\n      unitless: true\n    },\n    nonNegativeInt: {\n      number: true,\n      min: 0,\n      integer: true,\n      unitless: true\n    },\n    position: {\n      enums: ['parent', 'origin']\n    },\n    nodeSize: {\n      number: true,\n      min: 0,\n      enums: ['label']\n    },\n    number: {\n      number: true,\n      unitless: true\n    },\n    numbers: {\n      number: true,\n      unitless: true,\n      multiple: true\n    },\n    positiveNumber: {\n      number: true,\n      unitless: true,\n      min: 0,\n      strictMin: true\n    },\n    size: {\n      number: true,\n      min: 0\n    },\n    bidirectionalSize: {\n      number: true\n    },\n    // allows negative\n    bidirectionalSizeMaybePercent: {\n      number: true,\n      allowPercent: true\n    },\n    // allows negative\n    bidirectionalSizes: {\n      number: true,\n      multiple: true\n    },\n    // allows negative\n    sizeMaybePercent: {\n      number: true,\n      min: 0,\n      allowPercent: true\n    },\n    axisDirection: {\n      enums: ['horizontal', 'leftward', 'rightward', 'vertical', 'upward', 'downward', 'auto']\n    },\n    paddingRelativeTo: {\n      enums: ['width', 'height', 'average', 'min', 'max']\n    },\n    bgWH: {\n      number: true,\n      min: 0,\n      allowPercent: true,\n      enums: ['auto'],\n      multiple: true\n    },\n    bgPos: {\n      number: true,\n      allowPercent: true,\n      multiple: true\n    },\n    bgRelativeTo: {\n      enums: ['inner', 'include-padding'],\n      multiple: true\n    },\n    bgRepeat: {\n      enums: ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'],\n      multiple: true\n    },\n    bgFit: {\n      enums: ['none', 'contain', 'cover'],\n      multiple: true\n    },\n    bgCrossOrigin: {\n      enums: ['anonymous', 'use-credentials', 'null'],\n      multiple: true\n    },\n    bgClip: {\n      enums: ['none', 'node'],\n      multiple: true\n    },\n    bgContainment: {\n      enums: ['inside', 'over'],\n      multiple: true\n    },\n    color: {\n      color: true\n    },\n    colors: {\n      color: true,\n      multiple: true\n    },\n    fill: {\n      enums: ['solid', 'linear-gradient', 'radial-gradient']\n    },\n    bool: {\n      enums: ['yes', 'no']\n    },\n    bools: {\n      enums: ['yes', 'no'],\n      multiple: true\n    },\n    lineStyle: {\n      enums: ['solid', 'dotted', 'dashed']\n    },\n    lineCap: {\n      enums: ['butt', 'round', 'square']\n    },\n    borderStyle: {\n      enums: ['solid', 'dotted', 'dashed', 'double']\n    },\n    curveStyle: {\n      enums: ['bezier', 'unbundled-bezier', 'haystack', 'segments', 'straight', 'straight-triangle', 'taxi']\n    },\n    fontFamily: {\n      regex: '^([\\\\w- \\\\\"]+(?:\\\\s*,\\\\s*[\\\\w- \\\\\"]+)*)$'\n    },\n    fontStyle: {\n      enums: ['italic', 'normal', 'oblique']\n    },\n    fontWeight: {\n      enums: ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900]\n    },\n    textDecoration: {\n      enums: ['none', 'underline', 'overline', 'line-through']\n    },\n    textTransform: {\n      enums: ['none', 'uppercase', 'lowercase']\n    },\n    textWrap: {\n      enums: ['none', 'wrap', 'ellipsis']\n    },\n    textOverflowWrap: {\n      enums: ['whitespace', 'anywhere']\n    },\n    textBackgroundShape: {\n      enums: ['rectangle', 'roundrectangle', 'round-rectangle']\n    },\n    nodeShape: {\n      enums: ['rectangle', 'roundrectangle', 'round-rectangle', 'cutrectangle', 'cut-rectangle', 'bottomroundrectangle', 'bottom-round-rectangle', 'barrel', 'ellipse', 'triangle', 'round-triangle', 'square', 'pentagon', 'round-pentagon', 'hexagon', 'round-hexagon', 'concavehexagon', 'concave-hexagon', 'heptagon', 'round-heptagon', 'octagon', 'round-octagon', 'tag', 'round-tag', 'star', 'diamond', 'round-diamond', 'vee', 'rhomboid', 'right-rhomboid', 'polygon']\n    },\n    overlayShape: {\n      enums: ['roundrectangle', 'round-rectangle', 'ellipse']\n    },\n    compoundIncludeLabels: {\n      enums: ['include', 'exclude']\n    },\n    arrowShape: {\n      enums: ['tee', 'triangle', 'triangle-tee', 'circle-triangle', 'triangle-cross', 'triangle-backcurve', 'vee', 'square', 'circle', 'diamond', 'chevron', 'none']\n    },\n    arrowFill: {\n      enums: ['filled', 'hollow']\n    },\n    display: {\n      enums: ['element', 'none']\n    },\n    visibility: {\n      enums: ['hidden', 'visible']\n    },\n    zCompoundDepth: {\n      enums: ['bottom', 'orphan', 'auto', 'top']\n    },\n    zIndexCompare: {\n      enums: ['auto', 'manual']\n    },\n    valign: {\n      enums: ['top', 'center', 'bottom']\n    },\n    halign: {\n      enums: ['left', 'center', 'right']\n    },\n    justification: {\n      enums: ['left', 'center', 'right', 'auto']\n    },\n    text: {\n      string: true\n    },\n    data: {\n      mapping: true,\n      regex: data('data')\n    },\n    layoutData: {\n      mapping: true,\n      regex: data('layoutData')\n    },\n    scratch: {\n      mapping: true,\n      regex: data('scratch')\n    },\n    mapData: {\n      mapping: true,\n      regex: mapData('mapData')\n    },\n    mapLayoutData: {\n      mapping: true,\n      regex: mapData('mapLayoutData')\n    },\n    mapScratch: {\n      mapping: true,\n      regex: mapData('mapScratch')\n    },\n    fn: {\n      mapping: true,\n      fn: true\n    },\n    url: {\n      regexes: urlRegexes,\n      singleRegexMatchValue: true\n    },\n    urls: {\n      regexes: urlRegexes,\n      singleRegexMatchValue: true,\n      multiple: true\n    },\n    propList: {\n      propList: true\n    },\n    angle: {\n      number: true,\n      units: 'deg|rad',\n      implicitUnits: 'rad'\n    },\n    textRotation: {\n      number: true,\n      units: 'deg|rad',\n      implicitUnits: 'rad',\n      enums: ['none', 'autorotate']\n    },\n    polygonPointList: {\n      number: true,\n      multiple: true,\n      evenMultiple: true,\n      min: -1,\n      max: 1,\n      unitless: true\n    },\n    edgeDistances: {\n      enums: ['intersection', 'node-position']\n    },\n    edgeEndpoint: {\n      number: true,\n      multiple: true,\n      units: '%|px|em|deg|rad',\n      implicitUnits: 'px',\n      enums: ['inside-to-node', 'outside-to-node', 'outside-to-node-or-label', 'outside-to-line', 'outside-to-line-or-label'],\n      singleEnum: true,\n      validate: function validate(valArr, unitsArr) {\n        switch (valArr.length) {\n          case 2:\n            // can be % or px only\n            return unitsArr[0] !== 'deg' && unitsArr[0] !== 'rad' && unitsArr[1] !== 'deg' && unitsArr[1] !== 'rad';\n\n          case 1:\n            // can be enum, deg, or rad only\n            return string(valArr[0]) || unitsArr[0] === 'deg' || unitsArr[0] === 'rad';\n\n          default:\n            return false;\n        }\n      }\n    },\n    easing: {\n      regexes: ['^(spring)\\\\s*\\\\(\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + number$1 + ')\\\\s*\\\\)$', '^(cubic-bezier)\\\\s*\\\\(\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + number$1 + ')\\\\s*\\\\)$'],\n      enums: ['linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out', 'ease-in-sine', 'ease-out-sine', 'ease-in-out-sine', 'ease-in-quad', 'ease-out-quad', 'ease-in-out-quad', 'ease-in-cubic', 'ease-out-cubic', 'ease-in-out-cubic', 'ease-in-quart', 'ease-out-quart', 'ease-in-out-quart', 'ease-in-quint', 'ease-out-quint', 'ease-in-out-quint', 'ease-in-expo', 'ease-out-expo', 'ease-in-out-expo', 'ease-in-circ', 'ease-out-circ', 'ease-in-out-circ']\n    },\n    gradientDirection: {\n      enums: ['to-bottom', 'to-top', 'to-left', 'to-right', 'to-bottom-right', 'to-bottom-left', 'to-top-right', 'to-top-left', 'to-right-bottom', 'to-left-bottom', 'to-right-top', 'to-left-top' // different order\n      ]\n    },\n    boundsExpansion: {\n      number: true,\n      multiple: true,\n      min: 0,\n      validate: function validate(valArr) {\n        var length = valArr.length;\n        return length === 1 || length === 2 || length === 4;\n      }\n    }\n  };\n  var diff = {\n    zeroNonZero: function zeroNonZero(val1, val2) {\n      if ((val1 == null || val2 == null) && val1 !== val2) {\n        return true; // null cases could represent any value\n      }\n\n      if (val1 == 0 && val2 != 0) {\n        return true;\n      } else if (val1 != 0 && val2 == 0) {\n        return true;\n      } else {\n        return false;\n      }\n    },\n    any: function any(val1, val2) {\n      return val1 != val2;\n    },\n    emptyNonEmpty: function emptyNonEmpty(str1, str2) {\n      var empty1 = emptyString(str1);\n      var empty2 = emptyString(str2);\n      return empty1 && !empty2 || !empty1 && empty2;\n    }\n  }; // define visual style properties\n  //\n  // - n.b. adding a new group of props may require updates to updateStyleHints()\n  // - adding new props to an existing group gets handled automatically\n\n  var t = styfn$2.types;\n  var mainLabel = [{\n    name: 'label',\n    type: t.text,\n    triggersBounds: diff.any,\n    triggersZOrder: diff.emptyNonEmpty\n  }, {\n    name: 'text-rotation',\n    type: t.textRotation,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-margin-x',\n    type: t.bidirectionalSize,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-margin-y',\n    type: t.bidirectionalSize,\n    triggersBounds: diff.any\n  }];\n  var sourceLabel = [{\n    name: 'source-label',\n    type: t.text,\n    triggersBounds: diff.any\n  }, {\n    name: 'source-text-rotation',\n    type: t.textRotation,\n    triggersBounds: diff.any\n  }, {\n    name: 'source-text-margin-x',\n    type: t.bidirectionalSize,\n    triggersBounds: diff.any\n  }, {\n    name: 'source-text-margin-y',\n    type: t.bidirectionalSize,\n    triggersBounds: diff.any\n  }, {\n    name: 'source-text-offset',\n    type: t.size,\n    triggersBounds: diff.any\n  }];\n  var targetLabel = [{\n    name: 'target-label',\n    type: t.text,\n    triggersBounds: diff.any\n  }, {\n    name: 'target-text-rotation',\n    type: t.textRotation,\n    triggersBounds: diff.any\n  }, {\n    name: 'target-text-margin-x',\n    type: t.bidirectionalSize,\n    triggersBounds: diff.any\n  }, {\n    name: 'target-text-margin-y',\n    type: t.bidirectionalSize,\n    triggersBounds: diff.any\n  }, {\n    name: 'target-text-offset',\n    type: t.size,\n    triggersBounds: diff.any\n  }];\n  var labelDimensions = [{\n    name: 'font-family',\n    type: t.fontFamily,\n    triggersBounds: diff.any\n  }, {\n    name: 'font-style',\n    type: t.fontStyle,\n    triggersBounds: diff.any\n  }, {\n    name: 'font-weight',\n    type: t.fontWeight,\n    triggersBounds: diff.any\n  }, {\n    name: 'font-size',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-transform',\n    type: t.textTransform,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-wrap',\n    type: t.textWrap,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-overflow-wrap',\n    type: t.textOverflowWrap,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-max-width',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-outline-width',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'line-height',\n    type: t.positiveNumber,\n    triggersBounds: diff.any\n  }];\n  var commonLabel = [{\n    name: 'text-valign',\n    type: t.valign,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-halign',\n    type: t.halign,\n    triggersBounds: diff.any\n  }, {\n    name: 'color',\n    type: t.color\n  }, {\n    name: 'text-outline-color',\n    type: t.color\n  }, {\n    name: 'text-outline-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'text-background-color',\n    type: t.color\n  }, {\n    name: 'text-background-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'text-background-padding',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-border-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'text-border-color',\n    type: t.color\n  }, {\n    name: 'text-border-width',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-border-style',\n    type: t.borderStyle,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-background-shape',\n    type: t.textBackgroundShape,\n    triggersBounds: diff.any\n  }, {\n    name: 'text-justification',\n    type: t.justification\n  }];\n  var behavior = [{\n    name: 'events',\n    type: t.bool\n  }, {\n    name: 'text-events',\n    type: t.bool\n  }];\n  var visibility = [{\n    name: 'display',\n    type: t.display,\n    triggersZOrder: diff.any,\n    triggersBounds: diff.any,\n    triggersBoundsOfParallelBeziers: true\n  }, {\n    name: 'visibility',\n    type: t.visibility,\n    triggersZOrder: diff.any\n  }, {\n    name: 'opacity',\n    type: t.zeroOneNumber,\n    triggersZOrder: diff.zeroNonZero\n  }, {\n    name: 'text-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'min-zoomed-font-size',\n    type: t.size\n  }, {\n    name: 'z-compound-depth',\n    type: t.zCompoundDepth,\n    triggersZOrder: diff.any\n  }, {\n    name: 'z-index-compare',\n    type: t.zIndexCompare,\n    triggersZOrder: diff.any\n  }, {\n    name: 'z-index',\n    type: t.nonNegativeInt,\n    triggersZOrder: diff.any\n  }];\n  var overlay = [{\n    name: 'overlay-padding',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'overlay-color',\n    type: t.color\n  }, {\n    name: 'overlay-opacity',\n    type: t.zeroOneNumber,\n    triggersBounds: diff.zeroNonZero\n  }, {\n    name: 'overlay-shape',\n    type: t.overlayShape,\n    triggersBounds: diff.any\n  }];\n  var underlay = [{\n    name: 'underlay-padding',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'underlay-color',\n    type: t.color\n  }, {\n    name: 'underlay-opacity',\n    type: t.zeroOneNumber,\n    triggersBounds: diff.zeroNonZero\n  }, {\n    name: 'underlay-shape',\n    type: t.overlayShape,\n    triggersBounds: diff.any\n  }];\n  var transition = [{\n    name: 'transition-property',\n    type: t.propList\n  }, {\n    name: 'transition-duration',\n    type: t.time\n  }, {\n    name: 'transition-delay',\n    type: t.time\n  }, {\n    name: 'transition-timing-function',\n    type: t.easing\n  }];\n\n  var nodeSizeHashOverride = function nodeSizeHashOverride(ele, parsedProp) {\n    if (parsedProp.value === 'label') {\n      return -ele.poolIndex(); // no hash key hits is using label size (hitrate for perf probably low anyway)\n    } else {\n      return parsedProp.pfValue;\n    }\n  };\n\n  var nodeBody = [{\n    name: 'height',\n    type: t.nodeSize,\n    triggersBounds: diff.any,\n    hashOverride: nodeSizeHashOverride\n  }, {\n    name: 'width',\n    type: t.nodeSize,\n    triggersBounds: diff.any,\n    hashOverride: nodeSizeHashOverride\n  }, {\n    name: 'shape',\n    type: t.nodeShape,\n    triggersBounds: diff.any\n  }, {\n    name: 'shape-polygon-points',\n    type: t.polygonPointList,\n    triggersBounds: diff.any\n  }, {\n    name: 'background-color',\n    type: t.color\n  }, {\n    name: 'background-fill',\n    type: t.fill\n  }, {\n    name: 'background-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'background-blacken',\n    type: t.nOneOneNumber\n  }, {\n    name: 'background-gradient-stop-colors',\n    type: t.colors\n  }, {\n    name: 'background-gradient-stop-positions',\n    type: t.percentages\n  }, {\n    name: 'background-gradient-direction',\n    type: t.gradientDirection\n  }, {\n    name: 'padding',\n    type: t.sizeMaybePercent,\n    triggersBounds: diff.any\n  }, {\n    name: 'padding-relative-to',\n    type: t.paddingRelativeTo,\n    triggersBounds: diff.any\n  }, {\n    name: 'bounds-expansion',\n    type: t.boundsExpansion,\n    triggersBounds: diff.any\n  }];\n  var nodeBorder = [{\n    name: 'border-color',\n    type: t.color\n  }, {\n    name: 'border-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'border-width',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'border-style',\n    type: t.borderStyle\n  }];\n  var backgroundImage = [{\n    name: 'background-image',\n    type: t.urls\n  }, {\n    name: 'background-image-crossorigin',\n    type: t.bgCrossOrigin\n  }, {\n    name: 'background-image-opacity',\n    type: t.zeroOneNumbers\n  }, {\n    name: 'background-image-containment',\n    type: t.bgContainment\n  }, {\n    name: 'background-image-smoothing',\n    type: t.bools\n  }, {\n    name: 'background-position-x',\n    type: t.bgPos\n  }, {\n    name: 'background-position-y',\n    type: t.bgPos\n  }, {\n    name: 'background-width-relative-to',\n    type: t.bgRelativeTo\n  }, {\n    name: 'background-height-relative-to',\n    type: t.bgRelativeTo\n  }, {\n    name: 'background-repeat',\n    type: t.bgRepeat\n  }, {\n    name: 'background-fit',\n    type: t.bgFit\n  }, {\n    name: 'background-clip',\n    type: t.bgClip\n  }, {\n    name: 'background-width',\n    type: t.bgWH\n  }, {\n    name: 'background-height',\n    type: t.bgWH\n  }, {\n    name: 'background-offset-x',\n    type: t.bgPos\n  }, {\n    name: 'background-offset-y',\n    type: t.bgPos\n  }];\n  var compound = [{\n    name: 'position',\n    type: t.position,\n    triggersBounds: diff.any\n  }, {\n    name: 'compound-sizing-wrt-labels',\n    type: t.compoundIncludeLabels,\n    triggersBounds: diff.any\n  }, {\n    name: 'min-width',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'min-width-bias-left',\n    type: t.sizeMaybePercent,\n    triggersBounds: diff.any\n  }, {\n    name: 'min-width-bias-right',\n    type: t.sizeMaybePercent,\n    triggersBounds: diff.any\n  }, {\n    name: 'min-height',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'min-height-bias-top',\n    type: t.sizeMaybePercent,\n    triggersBounds: diff.any\n  }, {\n    name: 'min-height-bias-bottom',\n    type: t.sizeMaybePercent,\n    triggersBounds: diff.any\n  }];\n  var edgeLine = [{\n    name: 'line-style',\n    type: t.lineStyle\n  }, {\n    name: 'line-color',\n    type: t.color\n  }, {\n    name: 'line-fill',\n    type: t.fill\n  }, {\n    name: 'line-cap',\n    type: t.lineCap\n  }, {\n    name: 'line-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'line-dash-pattern',\n    type: t.numbers\n  }, {\n    name: 'line-dash-offset',\n    type: t.number\n  }, {\n    name: 'line-gradient-stop-colors',\n    type: t.colors\n  }, {\n    name: 'line-gradient-stop-positions',\n    type: t.percentages\n  }, {\n    name: 'curve-style',\n    type: t.curveStyle,\n    triggersBounds: diff.any,\n    triggersBoundsOfParallelBeziers: true\n  }, {\n    name: 'haystack-radius',\n    type: t.zeroOneNumber,\n    triggersBounds: diff.any\n  }, {\n    name: 'source-endpoint',\n    type: t.edgeEndpoint,\n    triggersBounds: diff.any\n  }, {\n    name: 'target-endpoint',\n    type: t.edgeEndpoint,\n    triggersBounds: diff.any\n  }, {\n    name: 'control-point-step-size',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'control-point-distances',\n    type: t.bidirectionalSizes,\n    triggersBounds: diff.any\n  }, {\n    name: 'control-point-weights',\n    type: t.numbers,\n    triggersBounds: diff.any\n  }, {\n    name: 'segment-distances',\n    type: t.bidirectionalSizes,\n    triggersBounds: diff.any\n  }, {\n    name: 'segment-weights',\n    type: t.numbers,\n    triggersBounds: diff.any\n  }, {\n    name: 'taxi-turn',\n    type: t.bidirectionalSizeMaybePercent,\n    triggersBounds: diff.any\n  }, {\n    name: 'taxi-turn-min-distance',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'taxi-direction',\n    type: t.axisDirection,\n    triggersBounds: diff.any\n  }, {\n    name: 'edge-distances',\n    type: t.edgeDistances,\n    triggersBounds: diff.any\n  }, {\n    name: 'arrow-scale',\n    type: t.positiveNumber,\n    triggersBounds: diff.any\n  }, {\n    name: 'loop-direction',\n    type: t.angle,\n    triggersBounds: diff.any\n  }, {\n    name: 'loop-sweep',\n    type: t.angle,\n    triggersBounds: diff.any\n  }, {\n    name: 'source-distance-from-node',\n    type: t.size,\n    triggersBounds: diff.any\n  }, {\n    name: 'target-distance-from-node',\n    type: t.size,\n    triggersBounds: diff.any\n  }];\n  var ghost = [{\n    name: 'ghost',\n    type: t.bool,\n    triggersBounds: diff.any\n  }, {\n    name: 'ghost-offset-x',\n    type: t.bidirectionalSize,\n    triggersBounds: diff.any\n  }, {\n    name: 'ghost-offset-y',\n    type: t.bidirectionalSize,\n    triggersBounds: diff.any\n  }, {\n    name: 'ghost-opacity',\n    type: t.zeroOneNumber\n  }];\n  var core = [{\n    name: 'selection-box-color',\n    type: t.color\n  }, {\n    name: 'selection-box-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'selection-box-border-color',\n    type: t.color\n  }, {\n    name: 'selection-box-border-width',\n    type: t.size\n  }, {\n    name: 'active-bg-color',\n    type: t.color\n  }, {\n    name: 'active-bg-opacity',\n    type: t.zeroOneNumber\n  }, {\n    name: 'active-bg-size',\n    type: t.size\n  }, {\n    name: 'outside-texture-bg-color',\n    type: t.color\n  }, {\n    name: 'outside-texture-bg-opacity',\n    type: t.zeroOneNumber\n  }]; // pie backgrounds for nodes\n\n  var pie = [];\n  styfn$2.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)\n\n  pie.push({\n    name: 'pie-size',\n    type: t.sizeMaybePercent\n  });\n\n  for (var i = 1; i <= styfn$2.pieBackgroundN; i++) {\n    pie.push({\n      name: 'pie-' + i + '-background-color',\n      type: t.color\n    });\n    pie.push({\n      name: 'pie-' + i + '-background-size',\n      type: t.percent\n    });\n    pie.push({\n      name: 'pie-' + i + '-background-opacity',\n      type: t.zeroOneNumber\n    });\n  } // edge arrows\n\n\n  var edgeArrow = [];\n  var arrowPrefixes = styfn$2.arrowPrefixes = ['source', 'mid-source', 'target', 'mid-target'];\n  [{\n    name: 'arrow-shape',\n    type: t.arrowShape,\n    triggersBounds: diff.any\n  }, {\n    name: 'arrow-color',\n    type: t.color\n  }, {\n    name: 'arrow-fill',\n    type: t.arrowFill\n  }].forEach(function (prop) {\n    arrowPrefixes.forEach(function (prefix) {\n      var name = prefix + '-' + prop.name;\n      var type = prop.type,\n          triggersBounds = prop.triggersBounds;\n      edgeArrow.push({\n        name: name,\n        type: type,\n        triggersBounds: triggersBounds\n      });\n    });\n  }, {});\n  var props = styfn$2.properties = [].concat(behavior, transition, visibility, overlay, underlay, ghost, commonLabel, labelDimensions, mainLabel, sourceLabel, targetLabel, nodeBody, nodeBorder, backgroundImage, pie, compound, edgeLine, edgeArrow, core);\n  var propGroups = styfn$2.propertyGroups = {\n    // common to all eles\n    behavior: behavior,\n    transition: transition,\n    visibility: visibility,\n    overlay: overlay,\n    underlay: underlay,\n    ghost: ghost,\n    // labels\n    commonLabel: commonLabel,\n    labelDimensions: labelDimensions,\n    mainLabel: mainLabel,\n    sourceLabel: sourceLabel,\n    targetLabel: targetLabel,\n    // node props\n    nodeBody: nodeBody,\n    nodeBorder: nodeBorder,\n    backgroundImage: backgroundImage,\n    pie: pie,\n    compound: compound,\n    // edge props\n    edgeLine: edgeLine,\n    edgeArrow: edgeArrow,\n    core: core\n  };\n  var propGroupNames = styfn$2.propertyGroupNames = {};\n  var propGroupKeys = styfn$2.propertyGroupKeys = Object.keys(propGroups);\n  propGroupKeys.forEach(function (key) {\n    propGroupNames[key] = propGroups[key].map(function (prop) {\n      return prop.name;\n    });\n    propGroups[key].forEach(function (prop) {\n      return prop.groupKey = key;\n    });\n  }); // define aliases\n\n  var aliases = styfn$2.aliases = [{\n    name: 'content',\n    pointsTo: 'label'\n  }, {\n    name: 'control-point-distance',\n    pointsTo: 'control-point-distances'\n  }, {\n    name: 'control-point-weight',\n    pointsTo: 'control-point-weights'\n  }, {\n    name: 'edge-text-rotation',\n    pointsTo: 'text-rotation'\n  }, {\n    name: 'padding-left',\n    pointsTo: 'padding'\n  }, {\n    name: 'padding-right',\n    pointsTo: 'padding'\n  }, {\n    name: 'padding-top',\n    pointsTo: 'padding'\n  }, {\n    name: 'padding-bottom',\n    pointsTo: 'padding'\n  }]; // list of property names\n\n  styfn$2.propertyNames = props.map(function (p) {\n    return p.name;\n  }); // allow access of properties by name ( e.g. style.properties.height )\n\n  for (var _i = 0; _i < props.length; _i++) {\n    var prop = props[_i];\n    props[prop.name] = prop; // allow lookup by name\n  } // map aliases\n\n\n  for (var _i2 = 0; _i2 < aliases.length; _i2++) {\n    var alias = aliases[_i2];\n    var pointsToProp = props[alias.pointsTo];\n    var aliasProp = {\n      name: alias.name,\n      alias: true,\n      pointsTo: pointsToProp\n    }; // add alias prop for parsing\n\n    props.push(aliasProp);\n    props[alias.name] = aliasProp; // allow lookup by name\n  }\n})();\n\nstyfn$2.getDefaultProperty = function (name) {\n  return this.getDefaultProperties()[name];\n};\n\nstyfn$2.getDefaultProperties = function () {\n  var _p = this._private;\n\n  if (_p.defaultProperties != null) {\n    return _p.defaultProperties;\n  }\n\n  var rawProps = extend({\n    // core props\n    'selection-box-color': '#ddd',\n    'selection-box-opacity': 0.65,\n    'selection-box-border-color': '#aaa',\n    'selection-box-border-width': 1,\n    'active-bg-color': 'black',\n    'active-bg-opacity': 0.15,\n    'active-bg-size': 30,\n    'outside-texture-bg-color': '#000',\n    'outside-texture-bg-opacity': 0.125,\n    // common node/edge props\n    'events': 'yes',\n    'text-events': 'no',\n    'text-valign': 'top',\n    'text-halign': 'center',\n    'text-justification': 'auto',\n    'line-height': 1,\n    'color': '#000',\n    'text-outline-color': '#000',\n    'text-outline-width': 0,\n    'text-outline-opacity': 1,\n    'text-opacity': 1,\n    'text-decoration': 'none',\n    'text-transform': 'none',\n    'text-wrap': 'none',\n    'text-overflow-wrap': 'whitespace',\n    'text-max-width': 9999,\n    'text-background-color': '#000',\n    'text-background-opacity': 0,\n    'text-background-shape': 'rectangle',\n    'text-background-padding': 0,\n    'text-border-opacity': 0,\n    'text-border-width': 0,\n    'text-border-style': 'solid',\n    'text-border-color': '#000',\n    'font-family': 'Helvetica Neue, Helvetica, sans-serif',\n    'font-style': 'normal',\n    'font-weight': 'normal',\n    'font-size': 16,\n    'min-zoomed-font-size': 0,\n    'text-rotation': 'none',\n    'source-text-rotation': 'none',\n    'target-text-rotation': 'none',\n    'visibility': 'visible',\n    'display': 'element',\n    'opacity': 1,\n    'z-compound-depth': 'auto',\n    'z-index-compare': 'auto',\n    'z-index': 0,\n    'label': '',\n    'text-margin-x': 0,\n    'text-margin-y': 0,\n    'source-label': '',\n    'source-text-offset': 0,\n    'source-text-margin-x': 0,\n    'source-text-margin-y': 0,\n    'target-label': '',\n    'target-text-offset': 0,\n    'target-text-margin-x': 0,\n    'target-text-margin-y': 0,\n    'overlay-opacity': 0,\n    'overlay-color': '#000',\n    'overlay-padding': 10,\n    'overlay-shape': 'round-rectangle',\n    'underlay-opacity': 0,\n    'underlay-color': '#000',\n    'underlay-padding': 10,\n    'underlay-shape': 'round-rectangle',\n    'transition-property': 'none',\n    'transition-duration': 0,\n    'transition-delay': 0,\n    'transition-timing-function': 'linear',\n    // node props\n    'background-blacken': 0,\n    'background-color': '#999',\n    'background-fill': 'solid',\n    'background-opacity': 1,\n    'background-image': 'none',\n    'background-image-crossorigin': 'anonymous',\n    'background-image-opacity': 1,\n    'background-image-containment': 'inside',\n    'background-image-smoothing': 'yes',\n    'background-position-x': '50%',\n    'background-position-y': '50%',\n    'background-offset-x': 0,\n    'background-offset-y': 0,\n    'background-width-relative-to': 'include-padding',\n    'background-height-relative-to': 'include-padding',\n    'background-repeat': 'no-repeat',\n    'background-fit': 'none',\n    'background-clip': 'node',\n    'background-width': 'auto',\n    'background-height': 'auto',\n    'border-color': '#000',\n    'border-opacity': 1,\n    'border-width': 0,\n    'border-style': 'solid',\n    'height': 30,\n    'width': 30,\n    'shape': 'ellipse',\n    'shape-polygon-points': '-1, -1,   1, -1,   1, 1,   -1, 1',\n    'bounds-expansion': 0,\n    // node gradient\n    'background-gradient-direction': 'to-bottom',\n    'background-gradient-stop-colors': '#999',\n    'background-gradient-stop-positions': '0%',\n    // ghost props\n    'ghost': 'no',\n    'ghost-offset-y': 0,\n    'ghost-offset-x': 0,\n    'ghost-opacity': 0,\n    // compound props\n    'padding': 0,\n    'padding-relative-to': 'width',\n    'position': 'origin',\n    'compound-sizing-wrt-labels': 'include',\n    'min-width': 0,\n    'min-width-bias-left': 0,\n    'min-width-bias-right': 0,\n    'min-height': 0,\n    'min-height-bias-top': 0,\n    'min-height-bias-bottom': 0\n  }, {\n    // node pie bg\n    'pie-size': '100%'\n  }, [{\n    name: 'pie-{{i}}-background-color',\n    value: 'black'\n  }, {\n    name: 'pie-{{i}}-background-size',\n    value: '0%'\n  }, {\n    name: 'pie-{{i}}-background-opacity',\n    value: 1\n  }].reduce(function (css, prop) {\n    for (var i = 1; i <= styfn$2.pieBackgroundN; i++) {\n      var name = prop.name.replace('{{i}}', i);\n      var val = prop.value;\n      css[name] = val;\n    }\n\n    return css;\n  }, {}), {\n    // edge props\n    'line-style': 'solid',\n    'line-color': '#999',\n    'line-fill': 'solid',\n    'line-cap': 'butt',\n    'line-opacity': 1,\n    'line-gradient-stop-colors': '#999',\n    'line-gradient-stop-positions': '0%',\n    'control-point-step-size': 40,\n    'control-point-weights': 0.5,\n    'segment-weights': 0.5,\n    'segment-distances': 20,\n    'taxi-turn': '50%',\n    'taxi-turn-min-distance': 10,\n    'taxi-direction': 'auto',\n    'edge-distances': 'intersection',\n    'curve-style': 'haystack',\n    'haystack-radius': 0,\n    'arrow-scale': 1,\n    'loop-direction': '-45deg',\n    'loop-sweep': '-90deg',\n    'source-distance-from-node': 0,\n    'target-distance-from-node': 0,\n    'source-endpoint': 'outside-to-node',\n    'target-endpoint': 'outside-to-node',\n    'line-dash-pattern': [6, 3],\n    'line-dash-offset': 0\n  }, [{\n    name: 'arrow-shape',\n    value: 'none'\n  }, {\n    name: 'arrow-color',\n    value: '#999'\n  }, {\n    name: 'arrow-fill',\n    value: 'filled'\n  }].reduce(function (css, prop) {\n    styfn$2.arrowPrefixes.forEach(function (prefix) {\n      var name = prefix + '-' + prop.name;\n      var val = prop.value;\n      css[name] = val;\n    });\n    return css;\n  }, {}));\n  var parsedProps = {};\n\n  for (var i = 0; i < this.properties.length; i++) {\n    var prop = this.properties[i];\n\n    if (prop.pointsTo) {\n      continue;\n    }\n\n    var name = prop.name;\n    var val = rawProps[name];\n    var parsedProp = this.parse(name, val);\n    parsedProps[name] = parsedProp;\n  }\n\n  _p.defaultProperties = parsedProps;\n  return _p.defaultProperties;\n};\n\nstyfn$2.addDefaultStylesheet = function () {\n  this.selector(':parent').css({\n    'shape': 'rectangle',\n    'padding': 10,\n    'background-color': '#eee',\n    'border-color': '#ccc',\n    'border-width': 1\n  }).selector('edge').css({\n    'width': 3\n  }).selector(':loop').css({\n    'curve-style': 'bezier'\n  }).selector('edge:compound').css({\n    'curve-style': 'bezier',\n    'source-endpoint': 'outside-to-line',\n    'target-endpoint': 'outside-to-line'\n  }).selector(':selected').css({\n    'background-color': '#0169D9',\n    'line-color': '#0169D9',\n    'source-arrow-color': '#0169D9',\n    'target-arrow-color': '#0169D9',\n    'mid-source-arrow-color': '#0169D9',\n    'mid-target-arrow-color': '#0169D9'\n  }).selector(':parent:selected').css({\n    'background-color': '#CCE1F9',\n    'border-color': '#aec8e5'\n  }).selector(':active').css({\n    'overlay-color': 'black',\n    'overlay-padding': 10,\n    'overlay-opacity': 0.25\n  });\n  this.defaultLength = this.length;\n};\n\nvar styfn$1 = {}; // a caching layer for property parsing\n\nstyfn$1.parse = function (name, value, propIsBypass, propIsFlat) {\n  var self = this; // function values can't be cached in all cases, and there isn't much benefit of caching them anyway\n\n  if (fn$6(value)) {\n    return self.parseImplWarn(name, value, propIsBypass, propIsFlat);\n  }\n\n  var flatKey = propIsFlat === 'mapping' || propIsFlat === true || propIsFlat === false || propIsFlat == null ? 'dontcare' : propIsFlat;\n  var bypassKey = propIsBypass ? 't' : 'f';\n  var valueKey = '' + value;\n  var argHash = hashStrings(name, valueKey, bypassKey, flatKey);\n  var propCache = self.propCache = self.propCache || [];\n  var ret;\n\n  if (!(ret = propCache[argHash])) {\n    ret = propCache[argHash] = self.parseImplWarn(name, value, propIsBypass, propIsFlat);\n  } // - bypasses can't be shared b/c the value can be changed by animations or otherwise overridden\n  // - mappings can't be shared b/c mappings are per-element\n\n\n  if (propIsBypass || propIsFlat === 'mapping') {\n    // need a copy since props are mutated later in their lifecycles\n    ret = copy(ret);\n\n    if (ret) {\n      ret.value = copy(ret.value); // because it could be an array, e.g. colour\n    }\n  }\n\n  return ret;\n};\n\nstyfn$1.parseImplWarn = function (name, value, propIsBypass, propIsFlat) {\n  var prop = this.parseImpl(name, value, propIsBypass, propIsFlat);\n\n  if (!prop && value != null) {\n    warn(\"The style property `\".concat(name, \": \").concat(value, \"` is invalid\"));\n  }\n\n  if (prop && (prop.name === 'width' || prop.name === 'height') && value === 'label') {\n    warn('The style value of `label` is deprecated for `' + prop.name + '`');\n  }\n\n  return prop;\n}; // parse a property; return null on invalid; return parsed property otherwise\n// fields :\n// - name : the name of the property\n// - value : the parsed, native-typed value of the property\n// - strValue : a string value that represents the property value in valid css\n// - bypass : true iff the property is a bypass property\n\n\nstyfn$1.parseImpl = function (name, value, propIsBypass, propIsFlat) {\n  var self = this;\n  name = camel2dash(name); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')\n\n  var property = self.properties[name];\n  var passedValue = value;\n  var types = self.types;\n\n  if (!property) {\n    return null;\n  } // return null on property of unknown name\n\n\n  if (value === undefined) {\n    return null;\n  } // can't assign undefined\n  // the property may be an alias\n\n\n  if (property.alias) {\n    property = property.pointsTo;\n    name = property.name;\n  }\n\n  var valueIsString = string(value);\n\n  if (valueIsString) {\n    // trim the value to make parsing easier\n    value = value.trim();\n  }\n\n  var type = property.type;\n\n  if (!type) {\n    return null;\n  } // no type, no luck\n  // check if bypass is null or empty string (i.e. indication to delete bypass property)\n\n\n  if (propIsBypass && (value === '' || value === null)) {\n    return {\n      name: name,\n      value: value,\n      bypass: true,\n      deleteBypass: true\n    };\n  } // check if value is a function used as a mapper\n\n\n  if (fn$6(value)) {\n    return {\n      name: name,\n      value: value,\n      strValue: 'fn',\n      mapped: types.fn,\n      bypass: propIsBypass\n    };\n  } // check if value is mapped\n\n\n  var data, mapData;\n\n  if (!valueIsString || propIsFlat || value.length < 7 || value[1] !== 'a') ; else if (value.length >= 7 && value[0] === 'd' && (data = new RegExp(types.data.regex).exec(value))) {\n    if (propIsBypass) {\n      return false;\n    } // mappers not allowed in bypass\n\n\n    var mapped = types.data;\n    return {\n      name: name,\n      value: data,\n      strValue: '' + value,\n      mapped: mapped,\n      field: data[1],\n      bypass: propIsBypass\n    };\n  } else if (value.length >= 10 && value[0] === 'm' && (mapData = new RegExp(types.mapData.regex).exec(value))) {\n    if (propIsBypass) {\n      return false;\n    } // mappers not allowed in bypass\n\n\n    if (type.multiple) {\n      return false;\n    } // impossible to map to num\n\n\n    var _mapped = types.mapData; // we can map only if the type is a colour or a number\n\n    if (!(type.color || type.number)) {\n      return false;\n    }\n\n    var valueMin = this.parse(name, mapData[4]); // parse to validate\n\n    if (!valueMin || valueMin.mapped) {\n      return false;\n    } // can't be invalid or mapped\n\n\n    var valueMax = this.parse(name, mapData[5]); // parse to validate\n\n    if (!valueMax || valueMax.mapped) {\n      return false;\n    } // can't be invalid or mapped\n    // check if valueMin and valueMax are the same\n\n\n    if (valueMin.pfValue === valueMax.pfValue || valueMin.strValue === valueMax.strValue) {\n      warn('`' + name + ': ' + value + '` is not a valid mapper because the output range is zero; converting to `' + name + ': ' + valueMin.strValue + '`');\n      return this.parse(name, valueMin.strValue); // can't make much of a mapper without a range\n    } else if (type.color) {\n      var c1 = valueMin.value;\n      var c2 = valueMax.value;\n      var same = c1[0] === c2[0] // red\n      && c1[1] === c2[1] // green\n      && c1[2] === c2[2] // blue\n      && ( // optional alpha\n      c1[3] === c2[3] // same alpha outright\n      || (c1[3] == null || c1[3] === 1 // full opacity for colour 1?\n      ) && (c2[3] == null || c2[3] === 1) // full opacity for colour 2?\n      );\n\n      if (same) {\n        return false;\n      } // can't make a mapper without a range\n\n    }\n\n    return {\n      name: name,\n      value: mapData,\n      strValue: '' + value,\n      mapped: _mapped,\n      field: mapData[1],\n      fieldMin: parseFloat(mapData[2]),\n      // min & max are numeric\n      fieldMax: parseFloat(mapData[3]),\n      valueMin: valueMin.value,\n      valueMax: valueMax.value,\n      bypass: propIsBypass\n    };\n  }\n\n  if (type.multiple && propIsFlat !== 'multiple') {\n    var vals;\n\n    if (valueIsString) {\n      vals = value.split(/\\s+/);\n    } else if (array(value)) {\n      vals = value;\n    } else {\n      vals = [value];\n    }\n\n    if (type.evenMultiple && vals.length % 2 !== 0) {\n      return null;\n    }\n\n    var valArr = [];\n    var unitsArr = [];\n    var pfValArr = [];\n    var strVal = '';\n    var hasEnum = false;\n\n    for (var i = 0; i < vals.length; i++) {\n      var p = self.parse(name, vals[i], propIsBypass, 'multiple');\n      hasEnum = hasEnum || string(p.value);\n      valArr.push(p.value);\n      pfValArr.push(p.pfValue != null ? p.pfValue : p.value);\n      unitsArr.push(p.units);\n      strVal += (i > 0 ? ' ' : '') + p.strValue;\n    }\n\n    if (type.validate && !type.validate(valArr, unitsArr)) {\n      return null;\n    }\n\n    if (type.singleEnum && hasEnum) {\n      if (valArr.length === 1 && string(valArr[0])) {\n        return {\n          name: name,\n          value: valArr[0],\n          strValue: valArr[0],\n          bypass: propIsBypass\n        };\n      } else {\n        return null;\n      }\n    }\n\n    return {\n      name: name,\n      value: valArr,\n      pfValue: pfValArr,\n      strValue: strVal,\n      bypass: propIsBypass,\n      units: unitsArr\n    };\n  } // several types also allow enums\n\n\n  var checkEnums = function checkEnums() {\n    for (var _i = 0; _i < type.enums.length; _i++) {\n      var en = type.enums[_i];\n\n      if (en === value) {\n        return {\n          name: name,\n          value: value,\n          strValue: '' + value,\n          bypass: propIsBypass\n        };\n      }\n    }\n\n    return null;\n  }; // check the type and return the appropriate object\n\n\n  if (type.number) {\n    var units;\n    var implicitUnits = 'px'; // not set => px\n\n    if (type.units) {\n      // use specified units if set\n      units = type.units;\n    }\n\n    if (type.implicitUnits) {\n      implicitUnits = type.implicitUnits;\n    }\n\n    if (!type.unitless) {\n      if (valueIsString) {\n        var unitsRegex = 'px|em' + (type.allowPercent ? '|\\\\%' : '');\n\n        if (units) {\n          unitsRegex = units;\n        } // only allow explicit units if so set\n\n\n        var match = value.match('^(' + number + ')(' + unitsRegex + ')?' + '$');\n\n        if (match) {\n          value = match[1];\n          units = match[2] || implicitUnits;\n        }\n      } else if (!units || type.implicitUnits) {\n        units = implicitUnits; // implicitly px if unspecified\n      }\n    }\n\n    value = parseFloat(value); // if not a number and enums not allowed, then the value is invalid\n\n    if (isNaN(value) && type.enums === undefined) {\n      return null;\n    } // check if this number type also accepts special keywords in place of numbers\n    // (i.e. `left`, `auto`, etc)\n\n\n    if (isNaN(value) && type.enums !== undefined) {\n      value = passedValue;\n      return checkEnums();\n    } // check if value must be an integer\n\n\n    if (type.integer && !integer(value)) {\n      return null;\n    } // check value is within range\n\n\n    if (type.min !== undefined && (value < type.min || type.strictMin && value === type.min) || type.max !== undefined && (value > type.max || type.strictMax && value === type.max)) {\n      return null;\n    }\n\n    var ret = {\n      name: name,\n      value: value,\n      strValue: '' + value + (units ? units : ''),\n      units: units,\n      bypass: propIsBypass\n    }; // normalise value in pixels\n\n    if (type.unitless || units !== 'px' && units !== 'em') {\n      ret.pfValue = value;\n    } else {\n      ret.pfValue = units === 'px' || !units ? value : this.getEmSizeInPixels() * value;\n    } // normalise value in ms\n\n\n    if (units === 'ms' || units === 's') {\n      ret.pfValue = units === 'ms' ? value : 1000 * value;\n    } // normalise value in rad\n\n\n    if (units === 'deg' || units === 'rad') {\n      ret.pfValue = units === 'rad' ? value : deg2rad(value);\n    } // normalize value in %\n\n\n    if (units === '%') {\n      ret.pfValue = value / 100;\n    }\n\n    return ret;\n  } else if (type.propList) {\n    var props = [];\n    var propsStr = '' + value;\n\n    if (propsStr === 'none') ; else {\n      // go over each prop\n      var propsSplit = propsStr.split(/\\s*,\\s*|\\s+/);\n\n      for (var _i2 = 0; _i2 < propsSplit.length; _i2++) {\n        var propName = propsSplit[_i2].trim();\n\n        if (self.properties[propName]) {\n          props.push(propName);\n        } else {\n          warn('`' + propName + '` is not a valid property name');\n        }\n      }\n\n      if (props.length === 0) {\n        return null;\n      }\n    }\n\n    return {\n      name: name,\n      value: props,\n      strValue: props.length === 0 ? 'none' : props.join(' '),\n      bypass: propIsBypass\n    };\n  } else if (type.color) {\n    var tuple = color2tuple(value);\n\n    if (!tuple) {\n      return null;\n    }\n\n    return {\n      name: name,\n      value: tuple,\n      pfValue: tuple,\n      strValue: 'rgb(' + tuple[0] + ',' + tuple[1] + ',' + tuple[2] + ')',\n      // n.b. no spaces b/c of multiple support\n      bypass: propIsBypass\n    };\n  } else if (type.regex || type.regexes) {\n    // first check enums\n    if (type.enums) {\n      var enumProp = checkEnums();\n\n      if (enumProp) {\n        return enumProp;\n      }\n    }\n\n    var regexes = type.regexes ? type.regexes : [type.regex];\n\n    for (var _i3 = 0; _i3 < regexes.length; _i3++) {\n      var regex = new RegExp(regexes[_i3]); // make a regex from the type string\n\n      var m = regex.exec(value);\n\n      if (m) {\n        // regex matches\n        return {\n          name: name,\n          value: type.singleRegexMatchValue ? m[1] : m,\n          strValue: '' + value,\n          bypass: propIsBypass\n        };\n      }\n    }\n\n    return null; // didn't match any\n  } else if (type.string) {\n    // just return\n    return {\n      name: name,\n      value: '' + value,\n      strValue: '' + value,\n      bypass: propIsBypass\n    };\n  } else if (type.enums) {\n    // check enums last because it's a combo type in others\n    return checkEnums();\n  } else {\n    return null; // not a type we can handle\n  }\n};\n\nvar Style = function Style(cy) {\n  if (!(this instanceof Style)) {\n    return new Style(cy);\n  }\n\n  if (!core(cy)) {\n    error('A style must have a core reference');\n    return;\n  }\n\n  this._private = {\n    cy: cy,\n    coreStyle: {}\n  };\n  this.length = 0;\n  this.resetToDefault();\n};\n\nvar styfn = Style.prototype;\n\nstyfn.instanceString = function () {\n  return 'style';\n}; // remove all contexts\n\n\nstyfn.clear = function () {\n  var _p = this._private;\n  var cy = _p.cy;\n  var eles = cy.elements();\n\n  for (var i = 0; i < this.length; i++) {\n    this[i] = undefined;\n  }\n\n  this.length = 0;\n  _p.contextStyles = {};\n  _p.propDiffs = {};\n  this.cleanElements(eles, true);\n  eles.forEach(function (ele) {\n    var ele_p = ele[0]._private;\n    ele_p.styleDirty = true;\n    ele_p.appliedInitStyle = false;\n  });\n  return this; // chaining\n};\n\nstyfn.resetToDefault = function () {\n  this.clear();\n  this.addDefaultStylesheet();\n  return this;\n}; // builds a style object for the 'core' selector\n\n\nstyfn.core = function (propName) {\n  return this._private.coreStyle[propName] || this.getDefaultProperty(propName);\n}; // create a new context from the specified selector string and switch to that context\n\n\nstyfn.selector = function (selectorStr) {\n  // 'core' is a special case and does not need a selector\n  var selector = selectorStr === 'core' ? null : new Selector(selectorStr);\n  var i = this.length++; // new context means new index\n\n  this[i] = {\n    selector: selector,\n    properties: [],\n    mappedProperties: [],\n    index: i\n  };\n  return this; // chaining\n}; // add one or many css rules to the current context\n\n\nstyfn.css = function () {\n  var self = this;\n  var args = arguments;\n\n  if (args.length === 1) {\n    var map = args[0];\n\n    for (var i = 0; i < self.properties.length; i++) {\n      var prop = self.properties[i];\n      var mapVal = map[prop.name];\n\n      if (mapVal === undefined) {\n        mapVal = map[dash2camel(prop.name)];\n      }\n\n      if (mapVal !== undefined) {\n        this.cssRule(prop.name, mapVal);\n      }\n    }\n  } else if (args.length === 2) {\n    this.cssRule(args[0], args[1]);\n  } // do nothing if args are invalid\n\n\n  return this; // chaining\n};\n\nstyfn.style = styfn.css; // add a single css rule to the current context\n\nstyfn.cssRule = function (name, value) {\n  // name-value pair\n  var property = this.parse(name, value); // add property to current context if valid\n\n  if (property) {\n    var i = this.length - 1;\n    this[i].properties.push(property);\n    this[i].properties[property.name] = property; // allow access by name as well\n\n    if (property.name.match(/pie-(\\d+)-background-size/) && property.value) {\n      this._private.hasPie = true;\n    }\n\n    if (property.mapped) {\n      this[i].mappedProperties.push(property);\n    } // add to core style if necessary\n\n\n    var currentSelectorIsCore = !this[i].selector;\n\n    if (currentSelectorIsCore) {\n      this._private.coreStyle[property.name] = property;\n    }\n  }\n\n  return this; // chaining\n};\n\nstyfn.append = function (style) {\n  if (stylesheet(style)) {\n    style.appendToStyle(this);\n  } else if (array(style)) {\n    this.appendFromJson(style);\n  } else if (string(style)) {\n    this.appendFromString(style);\n  } // you probably wouldn't want to append a Style, since you'd duplicate the default parts\n\n\n  return this;\n}; // static function\n\n\nStyle.fromJson = function (cy, json) {\n  var style = new Style(cy);\n  style.fromJson(json);\n  return style;\n};\n\nStyle.fromString = function (cy, string) {\n  return new Style(cy).fromString(string);\n};\n\n[styfn$8, styfn$7, styfn$6, styfn$5, styfn$4, styfn$3, styfn$2, styfn$1].forEach(function (props) {\n  extend(styfn, props);\n});\nStyle.types = styfn.types;\nStyle.properties = styfn.properties;\nStyle.propertyGroups = styfn.propertyGroups;\nStyle.propertyGroupNames = styfn.propertyGroupNames;\nStyle.propertyGroupKeys = styfn.propertyGroupKeys;\n\nvar corefn$2 = {\n  style: function style(newStyle) {\n    if (newStyle) {\n      var s = this.setStyle(newStyle);\n      s.update();\n    }\n\n    return this._private.style;\n  },\n  setStyle: function setStyle(style) {\n    var _p = this._private;\n\n    if (stylesheet(style)) {\n      _p.style = style.generateStyle(this);\n    } else if (array(style)) {\n      _p.style = Style.fromJson(this, style);\n    } else if (string(style)) {\n      _p.style = Style.fromString(this, style);\n    } else {\n      _p.style = Style(this);\n    }\n\n    return _p.style;\n  },\n  // e.g. cy.data() changed => recalc ele mappers\n  updateStyle: function updateStyle() {\n    this.mutableElements().updateStyle(); // just send to all eles\n  }\n};\n\nvar defaultSelectionType = 'single';\nvar corefn$1 = {\n  autolock: function autolock(bool) {\n    if (bool !== undefined) {\n      this._private.autolock = bool ? true : false;\n    } else {\n      return this._private.autolock;\n    }\n\n    return this; // chaining\n  },\n  autoungrabify: function autoungrabify(bool) {\n    if (bool !== undefined) {\n      this._private.autoungrabify = bool ? true : false;\n    } else {\n      return this._private.autoungrabify;\n    }\n\n    return this; // chaining\n  },\n  autounselectify: function autounselectify(bool) {\n    if (bool !== undefined) {\n      this._private.autounselectify = bool ? true : false;\n    } else {\n      return this._private.autounselectify;\n    }\n\n    return this; // chaining\n  },\n  selectionType: function selectionType(selType) {\n    var _p = this._private;\n\n    if (_p.selectionType == null) {\n      _p.selectionType = defaultSelectionType;\n    }\n\n    if (selType !== undefined) {\n      if (selType === 'additive' || selType === 'single') {\n        _p.selectionType = selType;\n      }\n    } else {\n      return _p.selectionType;\n    }\n\n    return this;\n  },\n  panningEnabled: function panningEnabled(bool) {\n    if (bool !== undefined) {\n      this._private.panningEnabled = bool ? true : false;\n    } else {\n      return this._private.panningEnabled;\n    }\n\n    return this; // chaining\n  },\n  userPanningEnabled: function userPanningEnabled(bool) {\n    if (bool !== undefined) {\n      this._private.userPanningEnabled = bool ? true : false;\n    } else {\n      return this._private.userPanningEnabled;\n    }\n\n    return this; // chaining\n  },\n  zoomingEnabled: function zoomingEnabled(bool) {\n    if (bool !== undefined) {\n      this._private.zoomingEnabled = bool ? true : false;\n    } else {\n      return this._private.zoomingEnabled;\n    }\n\n    return this; // chaining\n  },\n  userZoomingEnabled: function userZoomingEnabled(bool) {\n    if (bool !== undefined) {\n      this._private.userZoomingEnabled = bool ? true : false;\n    } else {\n      return this._private.userZoomingEnabled;\n    }\n\n    return this; // chaining\n  },\n  boxSelectionEnabled: function boxSelectionEnabled(bool) {\n    if (bool !== undefined) {\n      this._private.boxSelectionEnabled = bool ? true : false;\n    } else {\n      return this._private.boxSelectionEnabled;\n    }\n\n    return this; // chaining\n  },\n  pan: function pan() {\n    var args = arguments;\n    var pan = this._private.pan;\n    var dim, val, dims, x, y;\n\n    switch (args.length) {\n      case 0:\n        // .pan()\n        return pan;\n\n      case 1:\n        if (string(args[0])) {\n          // .pan('x')\n          dim = args[0];\n          return pan[dim];\n        } else if (plainObject(args[0])) {\n          // .pan({ x: 0, y: 100 })\n          if (!this._private.panningEnabled) {\n            return this;\n          }\n\n          dims = args[0];\n          x = dims.x;\n          y = dims.y;\n\n          if (number$1(x)) {\n            pan.x = x;\n          }\n\n          if (number$1(y)) {\n            pan.y = y;\n          }\n\n          this.emit('pan viewport');\n        }\n\n        break;\n\n      case 2:\n        // .pan('x', 100)\n        if (!this._private.panningEnabled) {\n          return this;\n        }\n\n        dim = args[0];\n        val = args[1];\n\n        if ((dim === 'x' || dim === 'y') && number$1(val)) {\n          pan[dim] = val;\n        }\n\n        this.emit('pan viewport');\n        break;\n      // invalid\n    }\n\n    this.notify('viewport');\n    return this; // chaining\n  },\n  panBy: function panBy(arg0, arg1) {\n    var args = arguments;\n    var pan = this._private.pan;\n    var dim, val, dims, x, y;\n\n    if (!this._private.panningEnabled) {\n      return this;\n    }\n\n    switch (args.length) {\n      case 1:\n        if (plainObject(arg0)) {\n          // .panBy({ x: 0, y: 100 })\n          dims = args[0];\n          x = dims.x;\n          y = dims.y;\n\n          if (number$1(x)) {\n            pan.x += x;\n          }\n\n          if (number$1(y)) {\n            pan.y += y;\n          }\n\n          this.emit('pan viewport');\n        }\n\n        break;\n\n      case 2:\n        // .panBy('x', 100)\n        dim = arg0;\n        val = arg1;\n\n        if ((dim === 'x' || dim === 'y') && number$1(val)) {\n          pan[dim] += val;\n        }\n\n        this.emit('pan viewport');\n        break;\n      // invalid\n    }\n\n    this.notify('viewport');\n    return this; // chaining\n  },\n  fit: function fit(elements, padding) {\n    var viewportState = this.getFitViewport(elements, padding);\n\n    if (viewportState) {\n      var _p = this._private;\n      _p.zoom = viewportState.zoom;\n      _p.pan = viewportState.pan;\n      this.emit('pan zoom viewport');\n      this.notify('viewport');\n    }\n\n    return this; // chaining\n  },\n  getFitViewport: function getFitViewport(elements, padding) {\n    if (number$1(elements) && padding === undefined) {\n      // elements is optional\n      padding = elements;\n      elements = undefined;\n    }\n\n    if (!this._private.panningEnabled || !this._private.zoomingEnabled) {\n      return;\n    }\n\n    var bb;\n\n    if (string(elements)) {\n      var sel = elements;\n      elements = this.$(sel);\n    } else if (boundingBox(elements)) {\n      // assume bb\n      var bbe = elements;\n      bb = {\n        x1: bbe.x1,\n        y1: bbe.y1,\n        x2: bbe.x2,\n        y2: bbe.y2\n      };\n      bb.w = bb.x2 - bb.x1;\n      bb.h = bb.y2 - bb.y1;\n    } else if (!elementOrCollection(elements)) {\n      elements = this.mutableElements();\n    }\n\n    if (elementOrCollection(elements) && elements.empty()) {\n      return;\n    } // can't fit to nothing\n\n\n    bb = bb || elements.boundingBox();\n    var w = this.width();\n    var h = this.height();\n    var zoom;\n    padding = number$1(padding) ? padding : 0;\n\n    if (!isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) && bb.w > 0 && bb.h > 0) {\n      zoom = Math.min((w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h); // crop zoom\n\n      zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;\n      zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;\n      var pan = {\n        // now pan to middle\n        x: (w - zoom * (bb.x1 + bb.x2)) / 2,\n        y: (h - zoom * (bb.y1 + bb.y2)) / 2\n      };\n      return {\n        zoom: zoom,\n        pan: pan\n      };\n    }\n\n    return;\n  },\n  zoomRange: function zoomRange(min, max) {\n    var _p = this._private;\n\n    if (max == null) {\n      var opts = min;\n      min = opts.min;\n      max = opts.max;\n    }\n\n    if (number$1(min) && number$1(max) && min <= max) {\n      _p.minZoom = min;\n      _p.maxZoom = max;\n    } else if (number$1(min) && max === undefined && min <= _p.maxZoom) {\n      _p.minZoom = min;\n    } else if (number$1(max) && min === undefined && max >= _p.minZoom) {\n      _p.maxZoom = max;\n    }\n\n    return this;\n  },\n  minZoom: function minZoom(zoom) {\n    if (zoom === undefined) {\n      return this._private.minZoom;\n    } else {\n      return this.zoomRange({\n        min: zoom\n      });\n    }\n  },\n  maxZoom: function maxZoom(zoom) {\n    if (zoom === undefined) {\n      return this._private.maxZoom;\n    } else {\n      return this.zoomRange({\n        max: zoom\n      });\n    }\n  },\n  getZoomedViewport: function getZoomedViewport(params) {\n    var _p = this._private;\n    var currentPan = _p.pan;\n    var currentZoom = _p.zoom;\n    var pos; // in rendered px\n\n    var zoom;\n    var bail = false;\n\n    if (!_p.zoomingEnabled) {\n      // zooming disabled\n      bail = true;\n    }\n\n    if (number$1(params)) {\n      // then set the zoom\n      zoom = params;\n    } else if (plainObject(params)) {\n      // then zoom about a point\n      zoom = params.level;\n\n      if (params.position != null) {\n        pos = modelToRenderedPosition(params.position, currentZoom, currentPan);\n      } else if (params.renderedPosition != null) {\n        pos = params.renderedPosition;\n      }\n\n      if (pos != null && !_p.panningEnabled) {\n        // panning disabled\n        bail = true;\n      }\n    } // crop zoom\n\n\n    zoom = zoom > _p.maxZoom ? _p.maxZoom : zoom;\n    zoom = zoom < _p.minZoom ? _p.minZoom : zoom; // can't zoom with invalid params\n\n    if (bail || !number$1(zoom) || zoom === currentZoom || pos != null && (!number$1(pos.x) || !number$1(pos.y))) {\n      return null;\n    }\n\n    if (pos != null) {\n      // set zoom about position\n      var pan1 = currentPan;\n      var zoom1 = currentZoom;\n      var zoom2 = zoom;\n      var pan2 = {\n        x: -zoom2 / zoom1 * (pos.x - pan1.x) + pos.x,\n        y: -zoom2 / zoom1 * (pos.y - pan1.y) + pos.y\n      };\n      return {\n        zoomed: true,\n        panned: true,\n        zoom: zoom2,\n        pan: pan2\n      };\n    } else {\n      // just set the zoom\n      return {\n        zoomed: true,\n        panned: false,\n        zoom: zoom,\n        pan: currentPan\n      };\n    }\n  },\n  zoom: function zoom(params) {\n    if (params === undefined) {\n      // get\n      return this._private.zoom;\n    } else {\n      // set\n      var vp = this.getZoomedViewport(params);\n      var _p = this._private;\n\n      if (vp == null || !vp.zoomed) {\n        return this;\n      }\n\n      _p.zoom = vp.zoom;\n\n      if (vp.panned) {\n        _p.pan.x = vp.pan.x;\n        _p.pan.y = vp.pan.y;\n      }\n\n      this.emit('zoom' + (vp.panned ? ' pan' : '') + ' viewport');\n      this.notify('viewport');\n      return this; // chaining\n    }\n  },\n  viewport: function viewport(opts) {\n    var _p = this._private;\n    var zoomDefd = true;\n    var panDefd = true;\n    var events = []; // to trigger\n\n    var zoomFailed = false;\n    var panFailed = false;\n\n    if (!opts) {\n      return this;\n    }\n\n    if (!number$1(opts.zoom)) {\n      zoomDefd = false;\n    }\n\n    if (!plainObject(opts.pan)) {\n      panDefd = false;\n    }\n\n    if (!zoomDefd && !panDefd) {\n      return this;\n    }\n\n    if (zoomDefd) {\n      var z = opts.zoom;\n\n      if (z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled) {\n        zoomFailed = true;\n      } else {\n        _p.zoom = z;\n        events.push('zoom');\n      }\n    }\n\n    if (panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled) {\n      var p = opts.pan;\n\n      if (number$1(p.x)) {\n        _p.pan.x = p.x;\n        panFailed = false;\n      }\n\n      if (number$1(p.y)) {\n        _p.pan.y = p.y;\n        panFailed = false;\n      }\n\n      if (!panFailed) {\n        events.push('pan');\n      }\n    }\n\n    if (events.length > 0) {\n      events.push('viewport');\n      this.emit(events.join(' '));\n      this.notify('viewport');\n    }\n\n    return this; // chaining\n  },\n  center: function center(elements) {\n    var pan = this.getCenterPan(elements);\n\n    if (pan) {\n      this._private.pan = pan;\n      this.emit('pan viewport');\n      this.notify('viewport');\n    }\n\n    return this; // chaining\n  },\n  getCenterPan: function getCenterPan(elements, zoom) {\n    if (!this._private.panningEnabled) {\n      return;\n    }\n\n    if (string(elements)) {\n      var selector = elements;\n      elements = this.mutableElements().filter(selector);\n    } else if (!elementOrCollection(elements)) {\n      elements = this.mutableElements();\n    }\n\n    if (elements.length === 0) {\n      return;\n    } // can't centre pan to nothing\n\n\n    var bb = elements.boundingBox();\n    var w = this.width();\n    var h = this.height();\n    zoom = zoom === undefined ? this._private.zoom : zoom;\n    var pan = {\n      // middle\n      x: (w - zoom * (bb.x1 + bb.x2)) / 2,\n      y: (h - zoom * (bb.y1 + bb.y2)) / 2\n    };\n    return pan;\n  },\n  reset: function reset() {\n    if (!this._private.panningEnabled || !this._private.zoomingEnabled) {\n      return this;\n    }\n\n    this.viewport({\n      pan: {\n        x: 0,\n        y: 0\n      },\n      zoom: 1\n    });\n    return this; // chaining\n  },\n  invalidateSize: function invalidateSize() {\n    this._private.sizeCache = null;\n  },\n  size: function size() {\n    var _p = this._private;\n    var container = _p.container;\n    var cy = this;\n    return _p.sizeCache = _p.sizeCache || (container ? function () {\n      var style = cy.window().getComputedStyle(container);\n\n      var val = function val(name) {\n        return parseFloat(style.getPropertyValue(name));\n      };\n\n      return {\n        width: container.clientWidth - val('padding-left') - val('padding-right'),\n        height: container.clientHeight - val('padding-top') - val('padding-bottom')\n      };\n    }() : {\n      // fallback if no container (not 0 b/c can be used for dividing etc)\n      width: 1,\n      height: 1\n    });\n  },\n  width: function width() {\n    return this.size().width;\n  },\n  height: function height() {\n    return this.size().height;\n  },\n  extent: function extent() {\n    var pan = this._private.pan;\n    var zoom = this._private.zoom;\n    var rb = this.renderedExtent();\n    var b = {\n      x1: (rb.x1 - pan.x) / zoom,\n      x2: (rb.x2 - pan.x) / zoom,\n      y1: (rb.y1 - pan.y) / zoom,\n      y2: (rb.y2 - pan.y) / zoom\n    };\n    b.w = b.x2 - b.x1;\n    b.h = b.y2 - b.y1;\n    return b;\n  },\n  renderedExtent: function renderedExtent() {\n    var width = this.width();\n    var height = this.height();\n    return {\n      x1: 0,\n      y1: 0,\n      x2: width,\n      y2: height,\n      w: width,\n      h: height\n    };\n  },\n  multiClickDebounceTime: function multiClickDebounceTime(_int) {\n    if (_int) this._private.multiClickDebounceTime = _int;else return this._private.multiClickDebounceTime;\n    return this; // chaining\n  }\n}; // aliases\n\ncorefn$1.centre = corefn$1.center; // backwards compatibility\n\ncorefn$1.autolockNodes = corefn$1.autolock;\ncorefn$1.autoungrabifyNodes = corefn$1.autoungrabify;\n\nvar fn = {\n  data: define.data({\n    field: 'data',\n    bindingEvent: 'data',\n    allowBinding: true,\n    allowSetting: true,\n    settingEvent: 'data',\n    settingTriggersEvent: true,\n    triggerFnName: 'trigger',\n    allowGetting: true,\n    updateStyle: true\n  }),\n  removeData: define.removeData({\n    field: 'data',\n    event: 'data',\n    triggerFnName: 'trigger',\n    triggerEvent: true,\n    updateStyle: true\n  }),\n  scratch: define.data({\n    field: 'scratch',\n    bindingEvent: 'scratch',\n    allowBinding: true,\n    allowSetting: true,\n    settingEvent: 'scratch',\n    settingTriggersEvent: true,\n    triggerFnName: 'trigger',\n    allowGetting: true,\n    updateStyle: true\n  }),\n  removeScratch: define.removeData({\n    field: 'scratch',\n    event: 'scratch',\n    triggerFnName: 'trigger',\n    triggerEvent: true,\n    updateStyle: true\n  })\n}; // aliases\n\nfn.attr = fn.data;\nfn.removeAttr = fn.removeData;\n\nvar Core = function Core(opts) {\n  var cy = this;\n  opts = extend({}, opts);\n  var container = opts.container; // allow for passing a wrapped jquery object\n  // e.g. cytoscape({ container: $('#cy') })\n\n  if (container && !htmlElement(container) && htmlElement(container[0])) {\n    container = container[0];\n  }\n\n  var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery\n\n  reg = reg || {};\n\n  if (reg && reg.cy) {\n    reg.cy.destroy();\n    reg = {}; // old instance => replace reg completely\n  }\n\n  var readies = reg.readies = reg.readies || [];\n\n  if (container) {\n    container._cyreg = reg;\n  } // make sure container assoc'd reg points to this cy\n\n\n  reg.cy = cy;\n  var head = _window !== undefined && container !== undefined && !opts.headless;\n  var options = opts;\n  options.layout = extend({\n    name: head ? 'grid' : 'null'\n  }, options.layout);\n  options.renderer = extend({\n    name: head ? 'canvas' : 'null'\n  }, options.renderer);\n\n  var defVal = function defVal(def, val, altVal) {\n    if (val !== undefined) {\n      return val;\n    } else if (altVal !== undefined) {\n      return altVal;\n    } else {\n      return def;\n    }\n  };\n\n  var _p = this._private = {\n    container: container,\n    // html dom ele container\n    ready: false,\n    // whether ready has been triggered\n    options: options,\n    // cached options\n    elements: new Collection(this),\n    // elements in the graph\n    listeners: [],\n    // list of listeners\n    aniEles: new Collection(this),\n    // elements being animated\n    data: options.data || {},\n    // data for the core\n    scratch: {},\n    // scratch object for core\n    layout: null,\n    renderer: null,\n    destroyed: false,\n    // whether destroy was called\n    notificationsEnabled: true,\n    // whether notifications are sent to the renderer\n    minZoom: 1e-50,\n    maxZoom: 1e50,\n    zoomingEnabled: defVal(true, options.zoomingEnabled),\n    userZoomingEnabled: defVal(true, options.userZoomingEnabled),\n    panningEnabled: defVal(true, options.panningEnabled),\n    userPanningEnabled: defVal(true, options.userPanningEnabled),\n    boxSelectionEnabled: defVal(true, options.boxSelectionEnabled),\n    autolock: defVal(false, options.autolock, options.autolockNodes),\n    autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),\n    autounselectify: defVal(false, options.autounselectify),\n    styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,\n    zoom: number$1(options.zoom) ? options.zoom : 1,\n    pan: {\n      x: plainObject(options.pan) && number$1(options.pan.x) ? options.pan.x : 0,\n      y: plainObject(options.pan) && number$1(options.pan.y) ? options.pan.y : 0\n    },\n    animation: {\n      // object for currently-running animations\n      current: [],\n      queue: []\n    },\n    hasCompoundNodes: false,\n    multiClickDebounceTime: defVal(250, options.multiClickDebounceTime)\n  };\n\n  this.createEmitter(); // set selection type\n\n  this.selectionType(options.selectionType); // init zoom bounds\n\n  this.zoomRange({\n    min: options.minZoom,\n    max: options.maxZoom\n  });\n\n  var loadExtData = function loadExtData(extData, next) {\n    var anyIsPromise = extData.some(promise);\n\n    if (anyIsPromise) {\n      return Promise$1.all(extData).then(next); // load all data asynchronously, then exec rest of init\n    } else {\n      next(extData); // exec synchronously for convenience\n    }\n  }; // start with the default stylesheet so we have something before loading an external stylesheet\n\n\n  if (_p.styleEnabled) {\n    cy.setStyle([]);\n  } // create the renderer\n\n\n  var rendererOptions = extend({}, options, options.renderer); // allow rendering hints in top level options\n\n  cy.initRenderer(rendererOptions);\n\n  var setElesAndLayout = function setElesAndLayout(elements, onload, ondone) {\n    cy.notifications(false); // remove old elements\n\n    var oldEles = cy.mutableElements();\n\n    if (oldEles.length > 0) {\n      oldEles.remove();\n    }\n\n    if (elements != null) {\n      if (plainObject(elements) || array(elements)) {\n        cy.add(elements);\n      }\n    }\n\n    cy.one('layoutready', function (e) {\n      cy.notifications(true);\n      cy.emit(e); // we missed this event by turning notifications off, so pass it on\n\n      cy.one('load', onload);\n      cy.emitAndNotify('load');\n    }).one('layoutstop', function () {\n      cy.one('done', ondone);\n      cy.emit('done');\n    });\n    var layoutOpts = extend({}, cy._private.options.layout);\n    layoutOpts.eles = cy.elements();\n    cy.layout(layoutOpts).run();\n  };\n\n  loadExtData([options.style, options.elements], function (thens) {\n    var initStyle = thens[0];\n    var initEles = thens[1]; // init style\n\n    if (_p.styleEnabled) {\n      cy.style().append(initStyle);\n    } // initial load\n\n\n    setElesAndLayout(initEles, function () {\n      // onready\n      cy.startAnimationLoop();\n      _p.ready = true; // if a ready callback is specified as an option, the bind it\n\n      if (fn$6(options.ready)) {\n        cy.on('ready', options.ready);\n      } // bind all the ready handlers registered before creating this instance\n\n\n      for (var i = 0; i < readies.length; i++) {\n        var fn = readies[i];\n        cy.on('ready', fn);\n      }\n\n      if (reg) {\n        reg.readies = [];\n      } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc\n\n\n      cy.emit('ready');\n    }, options.done);\n  });\n};\n\nvar corefn = Core.prototype; // short alias\n\nextend(corefn, {\n  instanceString: function instanceString() {\n    return 'core';\n  },\n  isReady: function isReady() {\n    return this._private.ready;\n  },\n  destroyed: function destroyed() {\n    return this._private.destroyed;\n  },\n  ready: function ready(fn) {\n    if (this.isReady()) {\n      this.emitter().emit('ready', [], fn); // just calls fn as though triggered via ready event\n    } else {\n      this.on('ready', fn);\n    }\n\n    return this;\n  },\n  destroy: function destroy() {\n    var cy = this;\n    if (cy.destroyed()) return;\n    cy.stopAnimationLoop();\n    cy.destroyRenderer();\n    this.emit('destroy');\n    cy._private.destroyed = true;\n    return cy;\n  },\n  hasElementWithId: function hasElementWithId(id) {\n    return this._private.elements.hasElementWithId(id);\n  },\n  getElementById: function getElementById(id) {\n    return this._private.elements.getElementById(id);\n  },\n  hasCompoundNodes: function hasCompoundNodes() {\n    return this._private.hasCompoundNodes;\n  },\n  headless: function headless() {\n    return this._private.renderer.isHeadless();\n  },\n  styleEnabled: function styleEnabled() {\n    return this._private.styleEnabled;\n  },\n  addToPool: function addToPool(eles) {\n    this._private.elements.merge(eles);\n\n    return this; // chaining\n  },\n  removeFromPool: function removeFromPool(eles) {\n    this._private.elements.unmerge(eles);\n\n    return this;\n  },\n  container: function container() {\n    return this._private.container || null;\n  },\n  window: function window() {\n    var container = this._private.container;\n    if (container == null) return _window;\n    var ownerDocument = this._private.container.ownerDocument;\n\n    if (ownerDocument === undefined || ownerDocument == null) {\n      return _window;\n    }\n\n    return ownerDocument.defaultView || _window;\n  },\n  mount: function mount(container) {\n    if (container == null) {\n      return;\n    }\n\n    var cy = this;\n    var _p = cy._private;\n    var options = _p.options;\n\n    if (!htmlElement(container) && htmlElement(container[0])) {\n      container = container[0];\n    }\n\n    cy.stopAnimationLoop();\n    cy.destroyRenderer();\n    _p.container = container;\n    _p.styleEnabled = true;\n    cy.invalidateSize();\n    cy.initRenderer(extend({}, options, options.renderer, {\n      // allow custom renderer name to be re-used, otherwise use canvas\n      name: options.renderer.name === 'null' ? 'canvas' : options.renderer.name\n    }));\n    cy.startAnimationLoop();\n    cy.style(options.style);\n    cy.emit('mount');\n    return cy;\n  },\n  unmount: function unmount() {\n    var cy = this;\n    cy.stopAnimationLoop();\n    cy.destroyRenderer();\n    cy.initRenderer({\n      name: 'null'\n    });\n    cy.emit('unmount');\n    return cy;\n  },\n  options: function options() {\n    return copy(this._private.options);\n  },\n  json: function json(obj) {\n    var cy = this;\n    var _p = cy._private;\n    var eles = cy.mutableElements();\n\n    var getFreshRef = function getFreshRef(ele) {\n      return cy.getElementById(ele.id());\n    };\n\n    if (plainObject(obj)) {\n      // set\n      cy.startBatch();\n\n      if (obj.elements) {\n        var idInJson = {};\n\n        var updateEles = function updateEles(jsons, gr) {\n          var toAdd = [];\n          var toMod = [];\n\n          for (var i = 0; i < jsons.length; i++) {\n            var json = jsons[i];\n\n            if (!json.data.id) {\n              warn('cy.json() cannot handle elements without an ID attribute');\n              continue;\n            }\n\n            var id = '' + json.data.id; // id must be string\n\n            var ele = cy.getElementById(id);\n            idInJson[id] = true;\n\n            if (ele.length !== 0) {\n              // existing element should be updated\n              toMod.push({\n                ele: ele,\n                json: json\n              });\n            } else {\n              // otherwise should be added\n              if (gr) {\n                json.group = gr;\n                toAdd.push(json);\n              } else {\n                toAdd.push(json);\n              }\n            }\n          }\n\n          cy.add(toAdd);\n\n          for (var _i = 0; _i < toMod.length; _i++) {\n            var _toMod$_i = toMod[_i],\n                _ele = _toMod$_i.ele,\n                _json = _toMod$_i.json;\n\n            _ele.json(_json);\n          }\n        };\n\n        if (array(obj.elements)) {\n          // elements: []\n          updateEles(obj.elements);\n        } else {\n          // elements: { nodes: [], edges: [] }\n          var grs = ['nodes', 'edges'];\n\n          for (var i = 0; i < grs.length; i++) {\n            var gr = grs[i];\n            var elements = obj.elements[gr];\n\n            if (array(elements)) {\n              updateEles(elements, gr);\n            }\n          }\n        }\n\n        var parentsToRemove = cy.collection();\n        eles.filter(function (ele) {\n          return !idInJson[ele.id()];\n        }).forEach(function (ele) {\n          if (ele.isParent()) {\n            parentsToRemove.merge(ele);\n          } else {\n            ele.remove();\n          }\n        }); // so that children are not removed w/parent\n\n        parentsToRemove.forEach(function (ele) {\n          return ele.children().move({\n            parent: null\n          });\n        }); // intermediate parents may be moved by prior line, so make sure we remove by fresh refs\n\n        parentsToRemove.forEach(function (ele) {\n          return getFreshRef(ele).remove();\n        });\n      }\n\n      if (obj.style) {\n        cy.style(obj.style);\n      }\n\n      if (obj.zoom != null && obj.zoom !== _p.zoom) {\n        cy.zoom(obj.zoom);\n      }\n\n      if (obj.pan) {\n        if (obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y) {\n          cy.pan(obj.pan);\n        }\n      }\n\n      if (obj.data) {\n        cy.data(obj.data);\n      }\n\n      var fields = ['minZoom', 'maxZoom', 'zoomingEnabled', 'userZoomingEnabled', 'panningEnabled', 'userPanningEnabled', 'boxSelectionEnabled', 'autolock', 'autoungrabify', 'autounselectify', 'multiClickDebounceTime'];\n\n      for (var _i2 = 0; _i2 < fields.length; _i2++) {\n        var f = fields[_i2];\n\n        if (obj[f] != null) {\n          cy[f](obj[f]);\n        }\n      }\n\n      cy.endBatch();\n      return this; // chaining\n    } else {\n      // get\n      var flat = !!obj;\n      var json = {};\n\n      if (flat) {\n        json.elements = this.elements().map(function (ele) {\n          return ele.json();\n        });\n      } else {\n        json.elements = {};\n        eles.forEach(function (ele) {\n          var group = ele.group();\n\n          if (!json.elements[group]) {\n            json.elements[group] = [];\n          }\n\n          json.elements[group].push(ele.json());\n        });\n      }\n\n      if (this._private.styleEnabled) {\n        json.style = cy.style().json();\n      }\n\n      json.data = copy(cy.data());\n      var options = _p.options;\n      json.zoomingEnabled = _p.zoomingEnabled;\n      json.userZoomingEnabled = _p.userZoomingEnabled;\n      json.zoom = _p.zoom;\n      json.minZoom = _p.minZoom;\n      json.maxZoom = _p.maxZoom;\n      json.panningEnabled = _p.panningEnabled;\n      json.userPanningEnabled = _p.userPanningEnabled;\n      json.pan = copy(_p.pan);\n      json.boxSelectionEnabled = _p.boxSelectionEnabled;\n      json.renderer = copy(options.renderer);\n      json.hideEdgesOnViewport = options.hideEdgesOnViewport;\n      json.textureOnViewport = options.textureOnViewport;\n      json.wheelSensitivity = options.wheelSensitivity;\n      json.motionBlur = options.motionBlur;\n      json.multiClickDebounceTime = options.multiClickDebounceTime;\n      return json;\n    }\n  }\n});\ncorefn.$id = corefn.getElementById;\n[corefn$9, corefn$8, elesfn, corefn$7, corefn$6, corefn$5, corefn$4, corefn$3, corefn$2, corefn$1, fn].forEach(function (props) {\n  extend(corefn, props);\n});\n\n/* eslint-disable no-unused-vars */\n\nvar defaults$7 = {\n  fit: true,\n  // whether to fit the viewport to the graph\n  directed: false,\n  // whether the tree is directed downwards (or edges can point in any direction if false)\n  padding: 30,\n  // padding on fit\n  circle: false,\n  // put depths in concentric circles if true, put depths top down if false\n  grid: false,\n  // whether to create an even grid into which the DAG is placed (circle:false only)\n  spacingFactor: 1.75,\n  // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)\n  boundingBox: undefined,\n  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  avoidOverlap: true,\n  // prevents node overlap, may overflow boundingBox if not enough space\n  nodeDimensionsIncludeLabels: false,\n  // Excludes the label when calculating node bounding boxes for the layout algorithm\n  roots: undefined,\n  // the roots of the trees\n  depthSort: undefined,\n  // a sorting function to order nodes at equal depth. e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n  animate: false,\n  // whether to transition the node positions\n  animationDuration: 500,\n  // duration of animation in ms if enabled\n  animationEasing: undefined,\n  // easing of animation if enabled,\n  animateFilter: function animateFilter(node, i) {\n    return true;\n  },\n  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n  ready: undefined,\n  // callback on layoutready\n  stop: undefined,\n  // callback on layoutstop\n  transform: function transform(node, position) {\n    return position;\n  } // transform a given node position. Useful for changing flow direction in discrete layouts\n\n};\nvar deprecatedOptionDefaults = {\n  maximal: false,\n  // whether to shift nodes down their natural BFS depths in order to avoid upwards edges (DAGS only); setting acyclic to true sets maximal to true also\n  acyclic: false // whether the tree is acyclic and thus a node could be shifted (due to the maximal option) multiple times without causing an infinite loop; setting to true sets maximal to true also; if you are uncertain whether a tree is acyclic, set to false to avoid potential infinite loops\n\n};\n/* eslint-enable */\n\nvar getInfo = function getInfo(ele) {\n  return ele.scratch('breadthfirst');\n};\n\nvar setInfo = function setInfo(ele, obj) {\n  return ele.scratch('breadthfirst', obj);\n};\n\nfunction BreadthFirstLayout(options) {\n  this.options = extend({}, defaults$7, deprecatedOptionDefaults, options);\n}\n\nBreadthFirstLayout.prototype.run = function () {\n  var params = this.options;\n  var options = params;\n  var cy = params.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes().filter(function (n) {\n    return !n.isParent();\n  });\n  var graph = eles;\n  var directed = options.directed;\n  var maximal = options.acyclic || options.maximal || options.maximalAdjustments > 0; // maximalAdjustments for compat. w/ old code; also, setting acyclic to true sets maximal to true\n\n  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n    x1: 0,\n    y1: 0,\n    w: cy.width(),\n    h: cy.height()\n  });\n  var roots;\n\n  if (elementOrCollection(options.roots)) {\n    roots = options.roots;\n  } else if (array(options.roots)) {\n    var rootsArray = [];\n\n    for (var i = 0; i < options.roots.length; i++) {\n      var id = options.roots[i];\n      var ele = cy.getElementById(id);\n      rootsArray.push(ele);\n    }\n\n    roots = cy.collection(rootsArray);\n  } else if (string(options.roots)) {\n    roots = cy.$(options.roots);\n  } else {\n    if (directed) {\n      roots = nodes.roots();\n    } else {\n      var components = eles.components();\n      roots = cy.collection();\n\n      var _loop = function _loop(_i) {\n        var comp = components[_i];\n        var maxDegree = comp.maxDegree(false);\n        var compRoots = comp.filter(function (ele) {\n          return ele.degree(false) === maxDegree;\n        });\n        roots = roots.add(compRoots);\n      };\n\n      for (var _i = 0; _i < components.length; _i++) {\n        _loop(_i);\n      }\n    }\n  }\n\n  var depths = [];\n  var foundByBfs = {};\n\n  var addToDepth = function addToDepth(ele, d) {\n    if (depths[d] == null) {\n      depths[d] = [];\n    }\n\n    var i = depths[d].length;\n    depths[d].push(ele);\n    setInfo(ele, {\n      index: i,\n      depth: d\n    });\n  };\n\n  var changeDepth = function changeDepth(ele, newDepth) {\n    var _getInfo = getInfo(ele),\n        depth = _getInfo.depth,\n        index = _getInfo.index;\n\n    depths[depth][index] = null;\n    addToDepth(ele, newDepth);\n  }; // find the depths of the nodes\n\n\n  graph.bfs({\n    roots: roots,\n    directed: options.directed,\n    visit: function visit(node, edge, pNode, i, depth) {\n      var ele = node[0];\n      var id = ele.id();\n      addToDepth(ele, depth);\n      foundByBfs[id] = true;\n    }\n  }); // check for nodes not found by bfs\n\n  var orphanNodes = [];\n\n  for (var _i2 = 0; _i2 < nodes.length; _i2++) {\n    var _ele = nodes[_i2];\n\n    if (foundByBfs[_ele.id()]) {\n      continue;\n    } else {\n      orphanNodes.push(_ele);\n    }\n  } // assign the nodes a depth and index\n\n\n  var assignDepthsAt = function assignDepthsAt(i) {\n    var eles = depths[i];\n\n    for (var j = 0; j < eles.length; j++) {\n      var _ele2 = eles[j];\n\n      if (_ele2 == null) {\n        eles.splice(j, 1);\n        j--;\n        continue;\n      }\n\n      setInfo(_ele2, {\n        depth: i,\n        index: j\n      });\n    }\n  };\n\n  var assignDepths = function assignDepths() {\n    for (var _i3 = 0; _i3 < depths.length; _i3++) {\n      assignDepthsAt(_i3);\n    }\n  };\n\n  var adjustMaximally = function adjustMaximally(ele, shifted) {\n    var eInfo = getInfo(ele);\n    var incomers = ele.incomers().filter(function (el) {\n      return el.isNode() && eles.has(el);\n    });\n    var maxDepth = -1;\n    var id = ele.id();\n\n    for (var k = 0; k < incomers.length; k++) {\n      var incmr = incomers[k];\n      var iInfo = getInfo(incmr);\n      maxDepth = Math.max(maxDepth, iInfo.depth);\n    }\n\n    if (eInfo.depth <= maxDepth) {\n      if (!options.acyclic && shifted[id]) {\n        return null;\n      }\n\n      var newDepth = maxDepth + 1;\n      changeDepth(ele, newDepth);\n      shifted[id] = newDepth;\n      return true;\n    }\n\n    return false;\n  }; // for the directed case, try to make the edges all go down (i.e. depth i => depth i + 1)\n\n\n  if (directed && maximal) {\n    var Q = [];\n    var shifted = {};\n\n    var enqueue = function enqueue(n) {\n      return Q.push(n);\n    };\n\n    var dequeue = function dequeue() {\n      return Q.shift();\n    };\n\n    nodes.forEach(function (n) {\n      return Q.push(n);\n    });\n\n    while (Q.length > 0) {\n      var _ele3 = dequeue();\n\n      var didShift = adjustMaximally(_ele3, shifted);\n\n      if (didShift) {\n        _ele3.outgoers().filter(function (el) {\n          return el.isNode() && eles.has(el);\n        }).forEach(enqueue);\n      } else if (didShift === null) {\n        warn('Detected double maximal shift for node `' + _ele3.id() + '`.  Bailing maximal adjustment due to cycle.  Use `options.maximal: true` only on DAGs.');\n        break; // exit on failure\n      }\n    }\n  }\n\n  assignDepths(); // clear holes\n  // find min distance we need to leave between nodes\n\n  var minDistance = 0;\n\n  if (options.avoidOverlap) {\n    for (var _i4 = 0; _i4 < nodes.length; _i4++) {\n      var n = nodes[_i4];\n      var nbb = n.layoutDimensions(options);\n      var w = nbb.w;\n      var h = nbb.h;\n      minDistance = Math.max(minDistance, w, h);\n    }\n  } // get the weighted percent for an element based on its connectivity to other levels\n\n\n  var cachedWeightedPercent = {};\n\n  var getWeightedPercent = function getWeightedPercent(ele) {\n    if (cachedWeightedPercent[ele.id()]) {\n      return cachedWeightedPercent[ele.id()];\n    }\n\n    var eleDepth = getInfo(ele).depth;\n    var neighbors = ele.neighborhood();\n    var percent = 0;\n    var samples = 0;\n\n    for (var _i5 = 0; _i5 < neighbors.length; _i5++) {\n      var neighbor = neighbors[_i5];\n\n      if (neighbor.isEdge() || neighbor.isParent() || !nodes.has(neighbor)) {\n        continue;\n      }\n\n      var bf = getInfo(neighbor);\n\n      if (bf == null) {\n        continue;\n      }\n\n      var index = bf.index;\n      var depth = bf.depth; // unassigned neighbours shouldn't affect the ordering\n\n      if (index == null || depth == null) {\n        continue;\n      }\n\n      var nDepth = depths[depth].length;\n\n      if (depth < eleDepth) {\n        // only get influenced by elements above\n        percent += index / nDepth;\n        samples++;\n      }\n    }\n\n    samples = Math.max(1, samples);\n    percent = percent / samples;\n\n    if (samples === 0) {\n      // put lone nodes at the start\n      percent = 0;\n    }\n\n    cachedWeightedPercent[ele.id()] = percent;\n    return percent;\n  }; // rearrange the indices in each depth level based on connectivity\n\n\n  var sortFn = function sortFn(a, b) {\n    var apct = getWeightedPercent(a);\n    var bpct = getWeightedPercent(b);\n    var diff = apct - bpct;\n\n    if (diff === 0) {\n      return ascending(a.id(), b.id()); // make sure sort doesn't have don't-care comparisons\n    } else {\n      return diff;\n    }\n  };\n\n  if (options.depthSort !== undefined) {\n    sortFn = options.depthSort;\n  } // sort each level to make connected nodes closer\n\n\n  for (var _i6 = 0; _i6 < depths.length; _i6++) {\n    depths[_i6].sort(sortFn);\n\n    assignDepthsAt(_i6);\n  } // assign orphan nodes to a new top-level depth\n\n\n  var orphanDepth = [];\n\n  for (var _i7 = 0; _i7 < orphanNodes.length; _i7++) {\n    orphanDepth.push(orphanNodes[_i7]);\n  }\n\n  depths.unshift(orphanDepth);\n  assignDepths();\n  var biggestDepthSize = 0;\n\n  for (var _i8 = 0; _i8 < depths.length; _i8++) {\n    biggestDepthSize = Math.max(depths[_i8].length, biggestDepthSize);\n  }\n\n  var center = {\n    x: bb.x1 + bb.w / 2,\n    y: bb.x1 + bb.h / 2\n  };\n  var maxDepthSize = depths.reduce(function (max, eles) {\n    return Math.max(max, eles.length);\n  }, 0);\n\n  var getPosition = function getPosition(ele) {\n    var _getInfo2 = getInfo(ele),\n        depth = _getInfo2.depth,\n        index = _getInfo2.index;\n\n    var depthSize = depths[depth].length;\n    var distanceX = Math.max(bb.w / ((options.grid ? maxDepthSize : depthSize) + 1), minDistance);\n    var distanceY = Math.max(bb.h / (depths.length + 1), minDistance);\n    var radiusStepSize = Math.min(bb.w / 2 / depths.length, bb.h / 2 / depths.length);\n    radiusStepSize = Math.max(radiusStepSize, minDistance);\n\n    if (!options.circle) {\n      var epos = {\n        x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,\n        y: (depth + 1) * distanceY\n      };\n      return epos;\n    } else {\n      var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize / 2 : 0);\n      var theta = 2 * Math.PI / depths[depth].length * index;\n\n      if (depth === 0 && depths[0].length === 1) {\n        radius = 1;\n      }\n\n      return {\n        x: center.x + radius * Math.cos(theta),\n        y: center.y + radius * Math.sin(theta)\n      };\n    }\n  };\n\n  eles.nodes().layoutPositions(this, options, getPosition);\n  return this; // chaining\n};\n\nvar defaults$6 = {\n  fit: true,\n  // whether to fit the viewport to the graph\n  padding: 30,\n  // the padding on fit\n  boundingBox: undefined,\n  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  avoidOverlap: true,\n  // prevents node overlap, may overflow boundingBox and radius if not enough space\n  nodeDimensionsIncludeLabels: false,\n  // Excludes the label when calculating node bounding boxes for the layout algorithm\n  spacingFactor: undefined,\n  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n  radius: undefined,\n  // the radius of the circle\n  startAngle: 3 / 2 * Math.PI,\n  // where nodes start in radians\n  sweep: undefined,\n  // how many radians should be between the first and last node (defaults to full circle)\n  clockwise: true,\n  // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)\n  sort: undefined,\n  // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n  animate: false,\n  // whether to transition the node positions\n  animationDuration: 500,\n  // duration of animation in ms if enabled\n  animationEasing: undefined,\n  // easing of animation if enabled\n  animateFilter: function animateFilter(node, i) {\n    return true;\n  },\n  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n  ready: undefined,\n  // callback on layoutready\n  stop: undefined,\n  // callback on layoutstop\n  transform: function transform(node, position) {\n    return position;\n  } // transform a given node position. Useful for changing flow direction in discrete layouts \n\n};\n\nfunction CircleLayout(options) {\n  this.options = extend({}, defaults$6, options);\n}\n\nCircleLayout.prototype.run = function () {\n  var params = this.options;\n  var options = params;\n  var cy = params.cy;\n  var eles = options.eles;\n  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;\n  var nodes = eles.nodes().not(':parent');\n\n  if (options.sort) {\n    nodes = nodes.sort(options.sort);\n  }\n\n  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n    x1: 0,\n    y1: 0,\n    w: cy.width(),\n    h: cy.height()\n  });\n  var center = {\n    x: bb.x1 + bb.w / 2,\n    y: bb.y1 + bb.h / 2\n  };\n  var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / nodes.length : options.sweep;\n  var dTheta = sweep / Math.max(1, nodes.length - 1);\n  var r;\n  var minDistance = 0;\n\n  for (var i = 0; i < nodes.length; i++) {\n    var n = nodes[i];\n    var nbb = n.layoutDimensions(options);\n    var w = nbb.w;\n    var h = nbb.h;\n    minDistance = Math.max(minDistance, w, h);\n  }\n\n  if (number$1(options.radius)) {\n    r = options.radius;\n  } else if (nodes.length <= 1) {\n    r = 0;\n  } else {\n    r = Math.min(bb.h, bb.w) / 2 - minDistance;\n  } // calculate the radius\n\n\n  if (nodes.length > 1 && options.avoidOverlap) {\n    // but only if more than one node (can't overlap)\n    minDistance *= 1.75; // just to have some nice spacing\n\n    var dcos = Math.cos(dTheta) - Math.cos(0);\n    var dsin = Math.sin(dTheta) - Math.sin(0);\n    var rMin = Math.sqrt(minDistance * minDistance / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n\n    r = Math.max(rMin, r);\n  }\n\n  var getPos = function getPos(ele, i) {\n    var theta = options.startAngle + i * dTheta * (clockwise ? 1 : -1);\n    var rx = r * Math.cos(theta);\n    var ry = r * Math.sin(theta);\n    var pos = {\n      x: center.x + rx,\n      y: center.y + ry\n    };\n    return pos;\n  };\n\n  eles.nodes().layoutPositions(this, options, getPos);\n  return this; // chaining\n};\n\nvar defaults$5 = {\n  fit: true,\n  // whether to fit the viewport to the graph\n  padding: 30,\n  // the padding on fit\n  startAngle: 3 / 2 * Math.PI,\n  // where nodes start in radians\n  sweep: undefined,\n  // how many radians should be between the first and last node (defaults to full circle)\n  clockwise: true,\n  // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)\n  equidistant: false,\n  // whether levels have an equal radial distance betwen them, may cause bounding box overflow\n  minNodeSpacing: 10,\n  // min spacing between outside of nodes (used for radius adjustment)\n  boundingBox: undefined,\n  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  avoidOverlap: true,\n  // prevents node overlap, may overflow boundingBox if not enough space\n  nodeDimensionsIncludeLabels: false,\n  // Excludes the label when calculating node bounding boxes for the layout algorithm\n  height: undefined,\n  // height of layout area (overrides container height)\n  width: undefined,\n  // width of layout area (overrides container width)\n  spacingFactor: undefined,\n  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n  concentric: function concentric(node) {\n    // returns numeric value for each node, placing higher nodes in levels towards the centre\n    return node.degree();\n  },\n  levelWidth: function levelWidth(nodes) {\n    // the variation of concentric values in each level\n    return nodes.maxDegree() / 4;\n  },\n  animate: false,\n  // whether to transition the node positions\n  animationDuration: 500,\n  // duration of animation in ms if enabled\n  animationEasing: undefined,\n  // easing of animation if enabled\n  animateFilter: function animateFilter(node, i) {\n    return true;\n  },\n  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n  ready: undefined,\n  // callback on layoutready\n  stop: undefined,\n  // callback on layoutstop\n  transform: function transform(node, position) {\n    return position;\n  } // transform a given node position. Useful for changing flow direction in discrete layouts\n\n};\n\nfunction ConcentricLayout(options) {\n  this.options = extend({}, defaults$5, options);\n}\n\nConcentricLayout.prototype.run = function () {\n  var params = this.options;\n  var options = params;\n  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;\n  var cy = params.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes().not(':parent');\n  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n    x1: 0,\n    y1: 0,\n    w: cy.width(),\n    h: cy.height()\n  });\n  var center = {\n    x: bb.x1 + bb.w / 2,\n    y: bb.y1 + bb.h / 2\n  };\n  var nodeValues = []; // { node, value }\n\n  var maxNodeSize = 0;\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    var value = void 0; // calculate the node value\n\n    value = options.concentric(node);\n    nodeValues.push({\n      value: value,\n      node: node\n    }); // for style mapping\n\n    node._private.scratch.concentric = value;\n  } // in case we used the `concentric` in style\n\n\n  nodes.updateStyle(); // calculate max size now based on potentially updated mappers\n\n  for (var _i = 0; _i < nodes.length; _i++) {\n    var _node = nodes[_i];\n\n    var nbb = _node.layoutDimensions(options);\n\n    maxNodeSize = Math.max(maxNodeSize, nbb.w, nbb.h);\n  } // sort node values in descreasing order\n\n\n  nodeValues.sort(function (a, b) {\n    return b.value - a.value;\n  });\n  var levelWidth = options.levelWidth(nodes); // put the values into levels\n\n  var levels = [[]];\n  var currentLevel = levels[0];\n\n  for (var _i2 = 0; _i2 < nodeValues.length; _i2++) {\n    var val = nodeValues[_i2];\n\n    if (currentLevel.length > 0) {\n      var diff = Math.abs(currentLevel[0].value - val.value);\n\n      if (diff >= levelWidth) {\n        currentLevel = [];\n        levels.push(currentLevel);\n      }\n    }\n\n    currentLevel.push(val);\n  } // create positions from levels\n\n\n  var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes\n\n  if (!options.avoidOverlap) {\n    // then strictly constrain to bb\n    var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;\n    var maxR = Math.min(bb.w, bb.h) / 2 - minDist;\n    var rStep = maxR / (levels.length + firstLvlHasMulti ? 1 : 0);\n    minDist = Math.min(minDist, rStep);\n  } // find the metrics for each level\n\n\n  var r = 0;\n\n  for (var _i3 = 0; _i3 < levels.length; _i3++) {\n    var level = levels[_i3];\n    var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / level.length : options.sweep;\n    var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1); // calculate the radius\n\n    if (level.length > 1 && options.avoidOverlap) {\n      // but only if more than one node (can't overlap)\n      var dcos = Math.cos(dTheta) - Math.cos(0);\n      var dsin = Math.sin(dTheta) - Math.sin(0);\n      var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n\n      r = Math.max(rMin, r);\n    }\n\n    level.r = r;\n    r += minDist;\n  }\n\n  if (options.equidistant) {\n    var rDeltaMax = 0;\n    var _r = 0;\n\n    for (var _i4 = 0; _i4 < levels.length; _i4++) {\n      var _level = levels[_i4];\n      var rDelta = _level.r - _r;\n      rDeltaMax = Math.max(rDeltaMax, rDelta);\n    }\n\n    _r = 0;\n\n    for (var _i5 = 0; _i5 < levels.length; _i5++) {\n      var _level2 = levels[_i5];\n\n      if (_i5 === 0) {\n        _r = _level2.r;\n      }\n\n      _level2.r = _r;\n      _r += rDeltaMax;\n    }\n  } // calculate the node positions\n\n\n  var pos = {}; // id => position\n\n  for (var _i6 = 0; _i6 < levels.length; _i6++) {\n    var _level3 = levels[_i6];\n    var _dTheta = _level3.dTheta;\n    var _r2 = _level3.r;\n\n    for (var j = 0; j < _level3.length; j++) {\n      var _val = _level3[j];\n      var theta = options.startAngle + (clockwise ? 1 : -1) * _dTheta * j;\n      var p = {\n        x: center.x + _r2 * Math.cos(theta),\n        y: center.y + _r2 * Math.sin(theta)\n      };\n      pos[_val.node.id()] = p;\n    }\n  } // position the nodes\n\n\n  eles.nodes().layoutPositions(this, options, function (ele) {\n    var id = ele.id();\n    return pos[id];\n  });\n  return this; // chaining\n};\n\n/*\nThe CoSE layout was written by Gerardo Huck.\nhttps://www.linkedin.com/in/gerardohuck/\n\nBased on the following article:\nhttp://dl.acm.org/citation.cfm?id=1498047\n\nModifications tracked on Github.\n*/\nvar DEBUG;\n/**\n * @brief :  default layout options\n */\n\nvar defaults$4 = {\n  // Called on `layoutready`\n  ready: function ready() {},\n  // Called on `layoutstop`\n  stop: function stop() {},\n  // Whether to animate while running the layout\n  // true : Animate continuously as the layout is running\n  // false : Just show the end result\n  // 'end' : Animate with the end result, from the initial positions to the end positions\n  animate: true,\n  // Easing of the animation for animate:'end'\n  animationEasing: undefined,\n  // The duration of the animation for animate:'end'\n  animationDuration: undefined,\n  // A function that determines whether the node should be animated\n  // All nodes animated by default on animate enabled\n  // Non-animated nodes are positioned immediately when the layout starts\n  animateFilter: function animateFilter(node, i) {\n    return true;\n  },\n  // The layout animates only after this many milliseconds for animate:true\n  // (prevents flashing on fast runs)\n  animationThreshold: 250,\n  // Number of iterations between consecutive screen positions update\n  refresh: 20,\n  // Whether to fit the network view after when done\n  fit: true,\n  // Padding on fit\n  padding: 30,\n  // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  boundingBox: undefined,\n  // Excludes the label when calculating node bounding boxes for the layout algorithm\n  nodeDimensionsIncludeLabels: false,\n  // Randomize the initial positions of the nodes (true) or use existing positions (false)\n  randomize: false,\n  // Extra spacing between components in non-compound graphs\n  componentSpacing: 40,\n  // Node repulsion (non overlapping) multiplier\n  nodeRepulsion: function nodeRepulsion(node) {\n    return 2048;\n  },\n  // Node repulsion (overlapping) multiplier\n  nodeOverlap: 4,\n  // Ideal edge (non nested) length\n  idealEdgeLength: function idealEdgeLength(edge) {\n    return 32;\n  },\n  // Divisor to compute edge forces\n  edgeElasticity: function edgeElasticity(edge) {\n    return 32;\n  },\n  // Nesting factor (multiplier) to compute ideal edge length for nested edges\n  nestingFactor: 1.2,\n  // Gravity force (constant)\n  gravity: 1,\n  // Maximum number of iterations to perform\n  numIter: 1000,\n  // Initial temperature (maximum node displacement)\n  initialTemp: 1000,\n  // Cooling factor (how the temperature is reduced between consecutive iterations\n  coolingFactor: 0.99,\n  // Lower temperature threshold (below this point the layout will end)\n  minTemp: 1.0\n};\n/**\n * @brief       : constructor\n * @arg options : object containing layout options\n */\n\nfunction CoseLayout(options) {\n  this.options = extend({}, defaults$4, options);\n  this.options.layout = this;\n}\n/**\n * @brief : runs the layout\n */\n\n\nCoseLayout.prototype.run = function () {\n  var options = this.options;\n  var cy = options.cy;\n  var layout = this;\n  layout.stopped = false;\n\n  if (options.animate === true || options.animate === false) {\n    layout.emit({\n      type: 'layoutstart',\n      layout: layout\n    });\n  } // Set DEBUG - Global variable\n\n\n  if (true === options.debug) {\n    DEBUG = true;\n  } else {\n    DEBUG = false;\n  } // Initialize layout info\n\n\n  var layoutInfo = createLayoutInfo(cy, layout, options); // Show LayoutInfo contents if debugging\n\n  if (DEBUG) {\n    printLayoutInfo(layoutInfo);\n  } // If required, randomize node positions\n\n\n  if (options.randomize) {\n    randomizePositions(layoutInfo);\n  }\n\n  var startTime = performanceNow();\n\n  var refresh = function refresh() {\n    refreshPositions(layoutInfo, cy, options); // Fit the graph if necessary\n\n    if (true === options.fit) {\n      cy.fit(options.padding);\n    }\n  };\n\n  var mainLoop = function mainLoop(i) {\n    if (layout.stopped || i >= options.numIter) {\n      // logDebug(\"Layout manually stopped. Stopping computation in step \" + i);\n      return false;\n    } // Do one step in the phisical simulation\n\n\n    step(layoutInfo, options); // Update temperature\n\n    layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor; // logDebug(\"New temperature: \" + layoutInfo.temperature);\n\n    if (layoutInfo.temperature < options.minTemp) {\n      // logDebug(\"Temperature drop below minimum threshold. Stopping computation in step \" + i);\n      return false;\n    }\n\n    return true;\n  };\n\n  var done = function done() {\n    if (options.animate === true || options.animate === false) {\n      refresh(); // Layout has finished\n\n      layout.one('layoutstop', options.stop);\n      layout.emit({\n        type: 'layoutstop',\n        layout: layout\n      });\n    } else {\n      var nodes = options.eles.nodes();\n      var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);\n      nodes.layoutPositions(layout, options, getScaledPos);\n    }\n  };\n\n  var i = 0;\n  var loopRet = true;\n\n  if (options.animate === true) {\n    var frame = function frame() {\n      var f = 0;\n\n      while (loopRet && f < options.refresh) {\n        loopRet = mainLoop(i);\n        i++;\n        f++;\n      }\n\n      if (!loopRet) {\n        // it's done\n        separateComponents(layoutInfo, options);\n        done();\n      } else {\n        var now = performanceNow();\n\n        if (now - startTime >= options.animationThreshold) {\n          refresh();\n        }\n\n        requestAnimationFrame(frame);\n      }\n    };\n\n    frame();\n  } else {\n    while (loopRet) {\n      loopRet = mainLoop(i);\n      i++;\n    }\n\n    separateComponents(layoutInfo, options);\n    done();\n  }\n\n  return this; // chaining\n};\n/**\n * @brief : called on continuous layouts to stop them before they finish\n */\n\n\nCoseLayout.prototype.stop = function () {\n  this.stopped = true;\n\n  if (this.thread) {\n    this.thread.stop();\n  }\n\n  this.emit('layoutstop');\n  return this; // chaining\n};\n\nCoseLayout.prototype.destroy = function () {\n  if (this.thread) {\n    this.thread.stop();\n  }\n\n  return this; // chaining\n};\n/**\n * @brief     : Creates an object which is contains all the data\n *              used in the layout process\n * @arg cy    : cytoscape.js object\n * @return    : layoutInfo object initialized\n */\n\n\nvar createLayoutInfo = function createLayoutInfo(cy, layout, options) {\n  // Shortcut\n  var edges = options.eles.edges();\n  var nodes = options.eles.nodes();\n  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n    x1: 0,\n    y1: 0,\n    w: cy.width(),\n    h: cy.height()\n  });\n  var layoutInfo = {\n    isCompound: cy.hasCompoundNodes(),\n    layoutNodes: [],\n    idToIndex: {},\n    nodeSize: nodes.size(),\n    graphSet: [],\n    indexToGraph: [],\n    layoutEdges: [],\n    edgeSize: edges.size(),\n    temperature: options.initialTemp,\n    clientWidth: bb.w,\n    clientHeight: bb.h,\n    boundingBox: bb\n  };\n  var components = options.eles.components();\n  var id2cmptId = {};\n\n  for (var i = 0; i < components.length; i++) {\n    var component = components[i];\n\n    for (var j = 0; j < component.length; j++) {\n      var node = component[j];\n      id2cmptId[node.id()] = i;\n    }\n  } // Iterate over all nodes, creating layout nodes\n\n\n  for (var i = 0; i < layoutInfo.nodeSize; i++) {\n    var n = nodes[i];\n    var nbb = n.layoutDimensions(options);\n    var tempNode = {};\n    tempNode.isLocked = n.locked();\n    tempNode.id = n.data('id');\n    tempNode.parentId = n.data('parent');\n    tempNode.cmptId = id2cmptId[n.id()];\n    tempNode.children = [];\n    tempNode.positionX = n.position('x');\n    tempNode.positionY = n.position('y');\n    tempNode.offsetX = 0;\n    tempNode.offsetY = 0;\n    tempNode.height = nbb.w;\n    tempNode.width = nbb.h;\n    tempNode.maxX = tempNode.positionX + tempNode.width / 2;\n    tempNode.minX = tempNode.positionX - tempNode.width / 2;\n    tempNode.maxY = tempNode.positionY + tempNode.height / 2;\n    tempNode.minY = tempNode.positionY - tempNode.height / 2;\n    tempNode.padLeft = parseFloat(n.style('padding'));\n    tempNode.padRight = parseFloat(n.style('padding'));\n    tempNode.padTop = parseFloat(n.style('padding'));\n    tempNode.padBottom = parseFloat(n.style('padding')); // forces\n\n    tempNode.nodeRepulsion = fn$6(options.nodeRepulsion) ? options.nodeRepulsion(n) : options.nodeRepulsion; // Add new node\n\n    layoutInfo.layoutNodes.push(tempNode); // Add entry to id-index map\n\n    layoutInfo.idToIndex[tempNode.id] = i;\n  } // Inline implementation of a queue, used for traversing the graph in BFS order\n\n\n  var queue = [];\n  var start = 0; // Points to the start the queue\n\n  var end = -1; // Points to the end of the queue\n\n  var tempGraph = []; // Second pass to add child information and\n  // initialize queue for hierarchical traversal\n\n  for (var i = 0; i < layoutInfo.nodeSize; i++) {\n    var n = layoutInfo.layoutNodes[i];\n    var p_id = n.parentId; // Check if node n has a parent node\n\n    if (null != p_id) {\n      // Add node Id to parent's list of children\n      layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);\n    } else {\n      // If a node doesn't have a parent, then it's in the root graph\n      queue[++end] = n.id;\n      tempGraph.push(n.id);\n    }\n  } // Add root graph to graphSet\n\n\n  layoutInfo.graphSet.push(tempGraph); // Traverse the graph, level by level,\n\n  while (start <= end) {\n    // Get the node to visit and remove it from queue\n    var node_id = queue[start++];\n    var node_ix = layoutInfo.idToIndex[node_id];\n    var node = layoutInfo.layoutNodes[node_ix];\n    var children = node.children;\n\n    if (children.length > 0) {\n      // Add children nodes as a new graph to graph set\n      layoutInfo.graphSet.push(children); // Add children to que queue to be visited\n\n      for (var i = 0; i < children.length; i++) {\n        queue[++end] = children[i];\n      }\n    }\n  } // Create indexToGraph map\n\n\n  for (var i = 0; i < layoutInfo.graphSet.length; i++) {\n    var graph = layoutInfo.graphSet[i];\n\n    for (var j = 0; j < graph.length; j++) {\n      var index = layoutInfo.idToIndex[graph[j]];\n      layoutInfo.indexToGraph[index] = i;\n    }\n  } // Iterate over all edges, creating Layout Edges\n\n\n  for (var i = 0; i < layoutInfo.edgeSize; i++) {\n    var e = edges[i];\n    var tempEdge = {};\n    tempEdge.id = e.data('id');\n    tempEdge.sourceId = e.data('source');\n    tempEdge.targetId = e.data('target'); // Compute ideal length\n\n    var idealLength = fn$6(options.idealEdgeLength) ? options.idealEdgeLength(e) : options.idealEdgeLength;\n    var elasticity = fn$6(options.edgeElasticity) ? options.edgeElasticity(e) : options.edgeElasticity; // Check if it's an inter graph edge\n\n    var sourceIx = layoutInfo.idToIndex[tempEdge.sourceId];\n    var targetIx = layoutInfo.idToIndex[tempEdge.targetId];\n    var sourceGraph = layoutInfo.indexToGraph[sourceIx];\n    var targetGraph = layoutInfo.indexToGraph[targetIx];\n\n    if (sourceGraph != targetGraph) {\n      // Find lowest common graph ancestor\n      var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo); // Compute sum of node depths, relative to lca graph\n\n      var lcaGraph = layoutInfo.graphSet[lca];\n      var depth = 0; // Source depth\n\n      var tempNode = layoutInfo.layoutNodes[sourceIx];\n\n      while (-1 === lcaGraph.indexOf(tempNode.id)) {\n        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];\n        depth++;\n      } // Target depth\n\n\n      tempNode = layoutInfo.layoutNodes[targetIx];\n\n      while (-1 === lcaGraph.indexOf(tempNode.id)) {\n        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];\n        depth++;\n      } // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +\n      //  \". Index: \" + lca + \" Contents: \" + lcaGraph.toString() +\n      //  \". Depth: \" + depth);\n      // Update idealLength\n\n\n      idealLength *= depth * options.nestingFactor;\n    }\n\n    tempEdge.idealLength = idealLength;\n    tempEdge.elasticity = elasticity;\n    layoutInfo.layoutEdges.push(tempEdge);\n  } // Finally, return layoutInfo object\n\n\n  return layoutInfo;\n};\n/**\n * @brief : This function finds the index of the lowest common\n *          graph ancestor between 2 nodes in the subtree\n *          (from the graph hierarchy induced tree) whose\n *          root is graphIx\n *\n * @arg node1: node1's ID\n * @arg node2: node2's ID\n * @arg layoutInfo: layoutInfo object\n *\n */\n\n\nvar findLCA = function findLCA(node1, node2, layoutInfo) {\n  // Find their common ancester, starting from the root graph\n  var res = findLCA_aux(node1, node2, 0, layoutInfo);\n\n  if (2 > res.count) {\n    // If aux function couldn't find the common ancester,\n    // then it is the root graph\n    return 0;\n  } else {\n    return res.graph;\n  }\n};\n/**\n * @brief          : Auxiliary function used for LCA computation\n *\n * @arg node1      : node1's ID\n * @arg node2      : node2's ID\n * @arg graphIx    : subgraph index\n * @arg layoutInfo : layoutInfo object\n *\n * @return         : object of the form {count: X, graph: Y}, where:\n *                   X is the number of ancestors (max: 2) found in\n *                   graphIx (and it's subgraphs),\n *                   Y is the graph index of the lowest graph containing\n *                   all X nodes\n */\n\n\nvar findLCA_aux = function findLCA_aux(node1, node2, graphIx, layoutInfo) {\n  var graph = layoutInfo.graphSet[graphIx]; // If both nodes belongs to graphIx\n\n  if (-1 < graph.indexOf(node1) && -1 < graph.indexOf(node2)) {\n    return {\n      count: 2,\n      graph: graphIx\n    };\n  } // Make recursive calls for all subgraphs\n\n\n  var c = 0;\n\n  for (var i = 0; i < graph.length; i++) {\n    var nodeId = graph[i];\n    var nodeIx = layoutInfo.idToIndex[nodeId];\n    var children = layoutInfo.layoutNodes[nodeIx].children; // If the node has no child, skip it\n\n    if (0 === children.length) {\n      continue;\n    }\n\n    var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];\n    var result = findLCA_aux(node1, node2, childGraphIx, layoutInfo);\n\n    if (0 === result.count) {\n      // Neither node1 nor node2 are present in this subgraph\n      continue;\n    } else if (1 === result.count) {\n      // One of (node1, node2) is present in this subgraph\n      c++;\n\n      if (2 === c) {\n        // We've already found both nodes, no need to keep searching\n        break;\n      }\n    } else {\n      // Both nodes are present in this subgraph\n      return result;\n    }\n  }\n\n  return {\n    count: c,\n    graph: graphIx\n  };\n};\n/**\n * @brief: printsLayoutInfo into js console\n *         Only used for debbuging\n */\n\n\nvar printLayoutInfo; \n/**\n * @brief : Randomizes the position of all nodes\n */\n\n\nvar randomizePositions = function randomizePositions(layoutInfo, cy) {\n  var width = layoutInfo.clientWidth;\n  var height = layoutInfo.clientHeight;\n\n  for (var i = 0; i < layoutInfo.nodeSize; i++) {\n    var n = layoutInfo.layoutNodes[i]; // No need to randomize compound nodes or locked nodes\n\n    if (0 === n.children.length && !n.isLocked) {\n      n.positionX = Math.random() * width;\n      n.positionY = Math.random() * height;\n    }\n  }\n};\n\nvar getScaleInBoundsFn = function getScaleInBoundsFn(layoutInfo, options, nodes) {\n  var bb = layoutInfo.boundingBox;\n  var coseBB = {\n    x1: Infinity,\n    x2: -Infinity,\n    y1: Infinity,\n    y2: -Infinity\n  };\n\n  if (options.boundingBox) {\n    nodes.forEach(function (node) {\n      var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];\n      coseBB.x1 = Math.min(coseBB.x1, lnode.positionX);\n      coseBB.x2 = Math.max(coseBB.x2, lnode.positionX);\n      coseBB.y1 = Math.min(coseBB.y1, lnode.positionY);\n      coseBB.y2 = Math.max(coseBB.y2, lnode.positionY);\n    });\n    coseBB.w = coseBB.x2 - coseBB.x1;\n    coseBB.h = coseBB.y2 - coseBB.y1;\n  }\n\n  return function (ele, i) {\n    var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];\n\n    if (options.boundingBox) {\n      // then add extra bounding box constraint\n      var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;\n      var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;\n      return {\n        x: bb.x1 + pctX * bb.w,\n        y: bb.y1 + pctY * bb.h\n      };\n    } else {\n      return {\n        x: lnode.positionX,\n        y: lnode.positionY\n      };\n    }\n  };\n};\n/**\n * @brief          : Updates the positions of nodes in the network\n * @arg layoutInfo : LayoutInfo object\n * @arg cy         : Cytoscape object\n * @arg options    : Layout options\n */\n\n\nvar refreshPositions = function refreshPositions(layoutInfo, cy, options) {\n  // var s = 'Refreshing positions';\n  // logDebug(s);\n  var layout = options.layout;\n  var nodes = options.eles.nodes();\n  var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);\n  nodes.positions(getScaledPos); // Trigger layoutReady only on first call\n\n  if (true !== layoutInfo.ready) {\n    // s = 'Triggering layoutready';\n    // logDebug(s);\n    layoutInfo.ready = true;\n    layout.one('layoutready', options.ready);\n    layout.emit({\n      type: 'layoutready',\n      layout: this\n    });\n  }\n};\n/**\n * @brief : Logs a debug message in JS console, if DEBUG is ON\n */\n// var logDebug = function(text) {\n//   if (DEBUG) {\n//     console.debug(text);\n//   }\n// };\n\n/**\n * @brief          : Performs one iteration of the physical simulation\n * @arg layoutInfo : LayoutInfo object already initialized\n * @arg cy         : Cytoscape object\n * @arg options    : Layout options\n */\n\n\nvar step = function step(layoutInfo, options, _step) {\n  // var s = \"\\n\\n###############################\";\n  // s += \"\\nSTEP: \" + step;\n  // s += \"\\n###############################\\n\";\n  // logDebug(s);\n  // Calculate node repulsions\n  calculateNodeForces(layoutInfo, options); // Calculate edge forces\n\n  calculateEdgeForces(layoutInfo); // Calculate gravity forces\n\n  calculateGravityForces(layoutInfo, options); // Propagate forces from parent to child\n\n  propagateForces(layoutInfo); // Update positions based on calculated forces\n\n  updatePositions(layoutInfo);\n};\n/**\n * @brief : Computes the node repulsion forces\n */\n\n\nvar calculateNodeForces = function calculateNodeForces(layoutInfo, options) {\n  // Go through each of the graphs in graphSet\n  // Nodes only repel each other if they belong to the same graph\n  // var s = 'calculateNodeForces';\n  // logDebug(s);\n  for (var i = 0; i < layoutInfo.graphSet.length; i++) {\n    var graph = layoutInfo.graphSet[i];\n    var numNodes = graph.length; // s = \"Set: \" + graph.toString();\n    // logDebug(s);\n    // Now get all the pairs of nodes\n    // Only get each pair once, (A, B) = (B, A)\n\n    for (var j = 0; j < numNodes; j++) {\n      var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];\n\n      for (var k = j + 1; k < numNodes; k++) {\n        var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];\n        nodeRepulsion(node1, node2, layoutInfo, options);\n      }\n    }\n  }\n};\n\nvar randomDistance = function randomDistance(max) {\n  return -max + 2 * max * Math.random();\n};\n/**\n * @brief : Compute the node repulsion forces between a pair of nodes\n */\n\n\nvar nodeRepulsion = function nodeRepulsion(node1, node2, layoutInfo, options) {\n  // var s = \"Node repulsion. Node1: \" + node1.id + \" Node2: \" + node2.id;\n  var cmptId1 = node1.cmptId;\n  var cmptId2 = node2.cmptId;\n\n  if (cmptId1 !== cmptId2 && !layoutInfo.isCompound) {\n    return;\n  } // Get direction of line connecting both node centers\n\n\n  var directionX = node2.positionX - node1.positionX;\n  var directionY = node2.positionY - node1.positionY;\n  var maxRandDist = 1; // s += \"\\ndirectionX: \" + directionX + \", directionY: \" + directionY;\n  // If both centers are the same, apply a random force\n\n  if (0 === directionX && 0 === directionY) {\n    directionX = randomDistance(maxRandDist);\n    directionY = randomDistance(maxRandDist);\n  }\n\n  var overlap = nodesOverlap(node1, node2, directionX, directionY);\n\n  if (overlap > 0) {\n    // s += \"\\nNodes DO overlap.\";\n    // s += \"\\nOverlap: \" + overlap;\n    // If nodes overlap, repulsion force is proportional\n    // to the overlap\n    var force = options.nodeOverlap * overlap; // Compute the module and components of the force vector\n\n    var distance = Math.sqrt(directionX * directionX + directionY * directionY); // s += \"\\nDistance: \" + distance;\n\n    var forceX = force * directionX / distance;\n    var forceY = force * directionY / distance;\n  } else {\n    // s += \"\\nNodes do NOT overlap.\";\n    // If there's no overlap, force is inversely proportional\n    // to squared distance\n    // Get clipping points for both nodes\n    var point1 = findClippingPoint(node1, directionX, directionY);\n    var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY); // Use clipping points to compute distance\n\n    var distanceX = point2.x - point1.x;\n    var distanceY = point2.y - point1.y;\n    var distanceSqr = distanceX * distanceX + distanceY * distanceY;\n    var distance = Math.sqrt(distanceSqr); // s += \"\\nDistance: \" + distance;\n    // Compute the module and components of the force vector\n\n    var force = (node1.nodeRepulsion + node2.nodeRepulsion) / distanceSqr;\n    var forceX = force * distanceX / distance;\n    var forceY = force * distanceY / distance;\n  } // Apply force\n\n\n  if (!node1.isLocked) {\n    node1.offsetX -= forceX;\n    node1.offsetY -= forceY;\n  }\n\n  if (!node2.isLocked) {\n    node2.offsetX += forceX;\n    node2.offsetY += forceY;\n  } // s += \"\\nForceX: \" + forceX + \" ForceY: \" + forceY;\n  // logDebug(s);\n\n\n  return;\n};\n/**\n * @brief  : Determines whether two nodes overlap or not\n * @return : Amount of overlapping (0 => no overlap)\n */\n\n\nvar nodesOverlap = function nodesOverlap(node1, node2, dX, dY) {\n  if (dX > 0) {\n    var overlapX = node1.maxX - node2.minX;\n  } else {\n    var overlapX = node2.maxX - node1.minX;\n  }\n\n  if (dY > 0) {\n    var overlapY = node1.maxY - node2.minY;\n  } else {\n    var overlapY = node2.maxY - node1.minY;\n  }\n\n  if (overlapX >= 0 && overlapY >= 0) {\n    return Math.sqrt(overlapX * overlapX + overlapY * overlapY);\n  } else {\n    return 0;\n  }\n};\n/**\n * @brief : Finds the point in which an edge (direction dX, dY) intersects\n *          the rectangular bounding box of it's source/target node\n */\n\n\nvar findClippingPoint = function findClippingPoint(node, dX, dY) {\n  // Shorcuts\n  var X = node.positionX;\n  var Y = node.positionY;\n  var H = node.height || 1;\n  var W = node.width || 1;\n  var dirSlope = dY / dX;\n  var nodeSlope = H / W; // var s = 'Computing clipping point of node ' + node.id +\n  //   \" . Height:  \" + H + \", Width: \" + W +\n  //   \"\\nDirection \" + dX + \", \" + dY;\n  //\n  // Compute intersection\n\n  var res = {}; // Case: Vertical direction (up)\n\n  if (0 === dX && 0 < dY) {\n    res.x = X; // s += \"\\nUp direction\";\n\n    res.y = Y + H / 2;\n    return res;\n  } // Case: Vertical direction (down)\n\n\n  if (0 === dX && 0 > dY) {\n    res.x = X;\n    res.y = Y + H / 2; // s += \"\\nDown direction\";\n\n    return res;\n  } // Case: Intersects the right border\n\n\n  if (0 < dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {\n    res.x = X + W / 2;\n    res.y = Y + W * dY / 2 / dX; // s += \"\\nRightborder\";\n\n    return res;\n  } // Case: Intersects the left border\n\n\n  if (0 > dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {\n    res.x = X - W / 2;\n    res.y = Y - W * dY / 2 / dX; // s += \"\\nLeftborder\";\n\n    return res;\n  } // Case: Intersects the top border\n\n\n  if (0 < dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {\n    res.x = X + H * dX / 2 / dY;\n    res.y = Y + H / 2; // s += \"\\nTop border\";\n\n    return res;\n  } // Case: Intersects the bottom border\n\n\n  if (0 > dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {\n    res.x = X - H * dX / 2 / dY;\n    res.y = Y - H / 2; // s += \"\\nBottom border\";\n\n    return res;\n  } // s += \"\\nClipping point found at \" + res.x + \", \" + res.y;\n  // logDebug(s);\n\n\n  return res;\n};\n/**\n * @brief : Calculates all edge forces\n */\n\n\nvar calculateEdgeForces = function calculateEdgeForces(layoutInfo, options) {\n  // Iterate over all edges\n  for (var i = 0; i < layoutInfo.edgeSize; i++) {\n    // Get edge, source & target nodes\n    var edge = layoutInfo.layoutEdges[i];\n    var sourceIx = layoutInfo.idToIndex[edge.sourceId];\n    var source = layoutInfo.layoutNodes[sourceIx];\n    var targetIx = layoutInfo.idToIndex[edge.targetId];\n    var target = layoutInfo.layoutNodes[targetIx]; // Get direction of line connecting both node centers\n\n    var directionX = target.positionX - source.positionX;\n    var directionY = target.positionY - source.positionY; // If both centers are the same, do nothing.\n    // A random force has already been applied as node repulsion\n\n    if (0 === directionX && 0 === directionY) {\n      continue;\n    } // Get clipping points for both nodes\n\n\n    var point1 = findClippingPoint(source, directionX, directionY);\n    var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);\n    var lx = point2.x - point1.x;\n    var ly = point2.y - point1.y;\n    var l = Math.sqrt(lx * lx + ly * ly);\n    var force = Math.pow(edge.idealLength - l, 2) / edge.elasticity;\n\n    if (0 !== l) {\n      var forceX = force * lx / l;\n      var forceY = force * ly / l;\n    } else {\n      var forceX = 0;\n      var forceY = 0;\n    } // Add this force to target and source nodes\n\n\n    if (!source.isLocked) {\n      source.offsetX += forceX;\n      source.offsetY += forceY;\n    }\n\n    if (!target.isLocked) {\n      target.offsetX -= forceX;\n      target.offsetY -= forceY;\n    } // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;\n    // s += \"\\nDistance: \" + l + \" Force: (\" + forceX + \", \" + forceY + \")\";\n    // logDebug(s);\n\n  }\n};\n/**\n * @brief : Computes gravity forces for all nodes\n */\n\n\nvar calculateGravityForces = function calculateGravityForces(layoutInfo, options) {\n  if (options.gravity === 0) {\n    return;\n  }\n\n  var distThreshold = 1; // var s = 'calculateGravityForces';\n  // logDebug(s);\n\n  for (var i = 0; i < layoutInfo.graphSet.length; i++) {\n    var graph = layoutInfo.graphSet[i];\n    var numNodes = graph.length; // s = \"Set: \" + graph.toString();\n    // logDebug(s);\n    // Compute graph center\n\n    if (0 === i) {\n      var centerX = layoutInfo.clientHeight / 2;\n      var centerY = layoutInfo.clientWidth / 2;\n    } else {\n      // Get Parent node for this graph, and use its position as center\n      var temp = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];\n      var parent = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];\n      var centerX = parent.positionX;\n      var centerY = parent.positionY;\n    } // s = \"Center found at: \" + centerX + \", \" + centerY;\n    // logDebug(s);\n    // Apply force to all nodes in graph\n\n\n    for (var j = 0; j < numNodes; j++) {\n      var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]]; // s = \"Node: \" + node.id;\n\n      if (node.isLocked) {\n        continue;\n      }\n\n      var dx = centerX - node.positionX;\n      var dy = centerY - node.positionY;\n      var d = Math.sqrt(dx * dx + dy * dy);\n\n      if (d > distThreshold) {\n        var fx = options.gravity * dx / d;\n        var fy = options.gravity * dy / d;\n        node.offsetX += fx;\n        node.offsetY += fy; // s += \": Applied force: \" + fx + \", \" + fy;\n      } // logDebug(s);\n\n    }\n  }\n};\n/**\n * @brief          : This function propagates the existing offsets from\n *                   parent nodes to its descendents.\n * @arg layoutInfo : layoutInfo Object\n * @arg cy         : cytoscape Object\n * @arg options    : Layout options\n */\n\n\nvar propagateForces = function propagateForces(layoutInfo, options) {\n  // Inline implementation of a queue, used for traversing the graph in BFS order\n  var queue = [];\n  var start = 0; // Points to the start the queue\n\n  var end = -1; // Points to the end of the queue\n  // logDebug('propagateForces');\n  // Start by visiting the nodes in the root graph\n\n  queue.push.apply(queue, layoutInfo.graphSet[0]);\n  end += layoutInfo.graphSet[0].length; // Traverse the graph, level by level,\n\n  while (start <= end) {\n    // Get the node to visit and remove it from queue\n    var nodeId = queue[start++];\n    var nodeIndex = layoutInfo.idToIndex[nodeId];\n    var node = layoutInfo.layoutNodes[nodeIndex];\n    var children = node.children; // We only need to process the node if it's compound\n\n    if (0 < children.length && !node.isLocked) {\n      var offX = node.offsetX;\n      var offY = node.offsetY; // var s = \"Propagating offset from parent node : \" + node.id +\n      //   \". OffsetX: \" + offX + \". OffsetY: \" + offY;\n      // s += \"\\n Children: \" + children.toString();\n      // logDebug(s);\n\n      for (var i = 0; i < children.length; i++) {\n        var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]]; // Propagate offset\n\n        childNode.offsetX += offX;\n        childNode.offsetY += offY; // Add children to queue to be visited\n\n        queue[++end] = children[i];\n      } // Reset parent offsets\n\n\n      node.offsetX = 0;\n      node.offsetY = 0;\n    }\n  }\n};\n/**\n * @brief : Updates the layout model positions, based on\n *          the accumulated forces\n */\n\n\nvar updatePositions = function updatePositions(layoutInfo, options) {\n  // var s = 'Updating positions';\n  // logDebug(s);\n  // Reset boundaries for compound nodes\n  for (var i = 0; i < layoutInfo.nodeSize; i++) {\n    var n = layoutInfo.layoutNodes[i];\n\n    if (0 < n.children.length) {\n      // logDebug(\"Resetting boundaries of compound node: \" + n.id);\n      n.maxX = undefined;\n      n.minX = undefined;\n      n.maxY = undefined;\n      n.minY = undefined;\n    }\n  }\n\n  for (var i = 0; i < layoutInfo.nodeSize; i++) {\n    var n = layoutInfo.layoutNodes[i];\n\n    if (0 < n.children.length || n.isLocked) {\n      // No need to set compound or locked node position\n      // logDebug(\"Skipping position update of node: \" + n.id);\n      continue;\n    } // s = \"Node: \" + n.id + \" Previous position: (\" +\n    // n.positionX + \", \" + n.positionY + \").\";\n    // Limit displacement in order to improve stability\n\n\n    var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);\n    n.positionX += tempForce.x;\n    n.positionY += tempForce.y;\n    n.offsetX = 0;\n    n.offsetY = 0;\n    n.minX = n.positionX - n.width;\n    n.maxX = n.positionX + n.width;\n    n.minY = n.positionY - n.height;\n    n.maxY = n.positionY + n.height; // s += \" New Position: (\" + n.positionX + \", \" + n.positionY + \").\";\n    // logDebug(s);\n    // Update ancestry boudaries\n\n    updateAncestryBoundaries(n, layoutInfo);\n  } // Update size, position of compund nodes\n\n\n  for (var i = 0; i < layoutInfo.nodeSize; i++) {\n    var n = layoutInfo.layoutNodes[i];\n\n    if (0 < n.children.length && !n.isLocked) {\n      n.positionX = (n.maxX + n.minX) / 2;\n      n.positionY = (n.maxY + n.minY) / 2;\n      n.width = n.maxX - n.minX;\n      n.height = n.maxY - n.minY; // s = \"Updating position, size of compound node \" + n.id;\n      // s += \"\\nPositionX: \" + n.positionX + \", PositionY: \" + n.positionY;\n      // s += \"\\nWidth: \" + n.width + \", Height: \" + n.height;\n      // logDebug(s);\n    }\n  }\n};\n/**\n * @brief : Limits a force (forceX, forceY) to be not\n *          greater (in modulo) than max.\n 8          Preserves force direction.\n  */\n\n\nvar limitForce = function limitForce(forceX, forceY, max) {\n  // var s = \"Limiting force: (\" + forceX + \", \" + forceY + \"). Max: \" + max;\n  var force = Math.sqrt(forceX * forceX + forceY * forceY);\n\n  if (force > max) {\n    var res = {\n      x: max * forceX / force,\n      y: max * forceY / force\n    };\n  } else {\n    var res = {\n      x: forceX,\n      y: forceY\n    };\n  } // s += \".\\nResult: (\" + res.x + \", \" + res.y + \")\";\n  // logDebug(s);\n\n\n  return res;\n};\n/**\n * @brief : Function used for keeping track of compound node\n *          sizes, since they should bound all their subnodes.\n */\n\n\nvar updateAncestryBoundaries = function updateAncestryBoundaries(node, layoutInfo) {\n  // var s = \"Propagating new position/size of node \" + node.id;\n  var parentId = node.parentId;\n\n  if (null == parentId) {\n    // If there's no parent, we are done\n    // s += \". No parent node.\";\n    // logDebug(s);\n    return;\n  } // Get Parent Node\n\n\n  var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];\n  var flag = false; // MaxX\n\n  if (null == p.maxX || node.maxX + p.padRight > p.maxX) {\n    p.maxX = node.maxX + p.padRight;\n    flag = true; // s += \"\\nNew maxX for parent node \" + p.id + \": \" + p.maxX;\n  } // MinX\n\n\n  if (null == p.minX || node.minX - p.padLeft < p.minX) {\n    p.minX = node.minX - p.padLeft;\n    flag = true; // s += \"\\nNew minX for parent node \" + p.id + \": \" + p.minX;\n  } // MaxY\n\n\n  if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {\n    p.maxY = node.maxY + p.padBottom;\n    flag = true; // s += \"\\nNew maxY for parent node \" + p.id + \": \" + p.maxY;\n  } // MinY\n\n\n  if (null == p.minY || node.minY - p.padTop < p.minY) {\n    p.minY = node.minY - p.padTop;\n    flag = true; // s += \"\\nNew minY for parent node \" + p.id + \": \" + p.minY;\n  } // If updated boundaries, propagate changes upward\n\n\n  if (flag) {\n    // logDebug(s);\n    return updateAncestryBoundaries(p, layoutInfo);\n  } // s += \". No changes in boundaries/position of parent node \" + p.id;\n  // logDebug(s);\n\n\n  return;\n};\n\nvar separateComponents = function separateComponents(layoutInfo, options) {\n  var nodes = layoutInfo.layoutNodes;\n  var components = [];\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    var cid = node.cmptId;\n    var component = components[cid] = components[cid] || [];\n    component.push(node);\n  }\n\n  var totalA = 0;\n\n  for (var i = 0; i < components.length; i++) {\n    var c = components[i];\n\n    if (!c) {\n      continue;\n    }\n\n    c.x1 = Infinity;\n    c.x2 = -Infinity;\n    c.y1 = Infinity;\n    c.y2 = -Infinity;\n\n    for (var j = 0; j < c.length; j++) {\n      var n = c[j];\n      c.x1 = Math.min(c.x1, n.positionX - n.width / 2);\n      c.x2 = Math.max(c.x2, n.positionX + n.width / 2);\n      c.y1 = Math.min(c.y1, n.positionY - n.height / 2);\n      c.y2 = Math.max(c.y2, n.positionY + n.height / 2);\n    }\n\n    c.w = c.x2 - c.x1;\n    c.h = c.y2 - c.y1;\n    totalA += c.w * c.h;\n  }\n\n  components.sort(function (c1, c2) {\n    return c2.w * c2.h - c1.w * c1.h;\n  });\n  var x = 0;\n  var y = 0;\n  var usedW = 0;\n  var rowH = 0;\n  var maxRowW = Math.sqrt(totalA) * layoutInfo.clientWidth / layoutInfo.clientHeight;\n\n  for (var i = 0; i < components.length; i++) {\n    var c = components[i];\n\n    if (!c) {\n      continue;\n    }\n\n    for (var j = 0; j < c.length; j++) {\n      var n = c[j];\n\n      if (!n.isLocked) {\n        n.positionX += x - c.x1;\n        n.positionY += y - c.y1;\n      }\n    }\n\n    x += c.w + options.componentSpacing;\n    usedW += c.w + options.componentSpacing;\n    rowH = Math.max(rowH, c.h);\n\n    if (usedW > maxRowW) {\n      y += rowH + options.componentSpacing;\n      x = 0;\n      usedW = 0;\n      rowH = 0;\n    }\n  }\n};\n\nvar defaults$3 = {\n  fit: true,\n  // whether to fit the viewport to the graph\n  padding: 30,\n  // padding used on fit\n  boundingBox: undefined,\n  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  avoidOverlap: true,\n  // prevents node overlap, may overflow boundingBox if not enough space\n  avoidOverlapPadding: 10,\n  // extra spacing around nodes when avoidOverlap: true\n  nodeDimensionsIncludeLabels: false,\n  // Excludes the label when calculating node bounding boxes for the layout algorithm\n  spacingFactor: undefined,\n  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n  condense: false,\n  // uses all available space on false, uses minimal space on true\n  rows: undefined,\n  // force num of rows in the grid\n  cols: undefined,\n  // force num of columns in the grid\n  position: function position(node) {},\n  // returns { row, col } for element\n  sort: undefined,\n  // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n  animate: false,\n  // whether to transition the node positions\n  animationDuration: 500,\n  // duration of animation in ms if enabled\n  animationEasing: undefined,\n  // easing of animation if enabled\n  animateFilter: function animateFilter(node, i) {\n    return true;\n  },\n  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n  ready: undefined,\n  // callback on layoutready\n  stop: undefined,\n  // callback on layoutstop\n  transform: function transform(node, position) {\n    return position;\n  } // transform a given node position. Useful for changing flow direction in discrete layouts \n\n};\n\nfunction GridLayout(options) {\n  this.options = extend({}, defaults$3, options);\n}\n\nGridLayout.prototype.run = function () {\n  var params = this.options;\n  var options = params;\n  var cy = params.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes().not(':parent');\n\n  if (options.sort) {\n    nodes = nodes.sort(options.sort);\n  }\n\n  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n    x1: 0,\n    y1: 0,\n    w: cy.width(),\n    h: cy.height()\n  });\n\n  if (bb.h === 0 || bb.w === 0) {\n    eles.nodes().layoutPositions(this, options, function (ele) {\n      return {\n        x: bb.x1,\n        y: bb.y1\n      };\n    });\n  } else {\n    // width/height * splits^2 = cells where splits is number of times to split width\n    var cells = nodes.size();\n    var splits = Math.sqrt(cells * bb.h / bb.w);\n    var rows = Math.round(splits);\n    var cols = Math.round(bb.w / bb.h * splits);\n\n    var small = function small(val) {\n      if (val == null) {\n        return Math.min(rows, cols);\n      } else {\n        var min = Math.min(rows, cols);\n\n        if (min == rows) {\n          rows = val;\n        } else {\n          cols = val;\n        }\n      }\n    };\n\n    var large = function large(val) {\n      if (val == null) {\n        return Math.max(rows, cols);\n      } else {\n        var max = Math.max(rows, cols);\n\n        if (max == rows) {\n          rows = val;\n        } else {\n          cols = val;\n        }\n      }\n    };\n\n    var oRows = options.rows;\n    var oCols = options.cols != null ? options.cols : options.columns; // if rows or columns were set in options, use those values\n\n    if (oRows != null && oCols != null) {\n      rows = oRows;\n      cols = oCols;\n    } else if (oRows != null && oCols == null) {\n      rows = oRows;\n      cols = Math.ceil(cells / rows);\n    } else if (oRows == null && oCols != null) {\n      cols = oCols;\n      rows = Math.ceil(cells / cols);\n    } // otherwise use the automatic values and adjust accordingly\n    // if rounding was up, see if we can reduce rows or columns\n    else if (cols * rows > cells) {\n      var sm = small();\n      var lg = large(); // reducing the small side takes away the most cells, so try it first\n\n      if ((sm - 1) * lg >= cells) {\n        small(sm - 1);\n      } else if ((lg - 1) * sm >= cells) {\n        large(lg - 1);\n      }\n    } else {\n      // if rounding was too low, add rows or columns\n      while (cols * rows < cells) {\n        var _sm = small();\n\n        var _lg = large(); // try to add to larger side first (adds less in multiplication)\n\n\n        if ((_lg + 1) * _sm >= cells) {\n          large(_lg + 1);\n        } else {\n          small(_sm + 1);\n        }\n      }\n    }\n\n    var cellWidth = bb.w / cols;\n    var cellHeight = bb.h / rows;\n\n    if (options.condense) {\n      cellWidth = 0;\n      cellHeight = 0;\n    }\n\n    if (options.avoidOverlap) {\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var pos = node._private.position;\n\n        if (pos.x == null || pos.y == null) {\n          // for bb\n          pos.x = 0;\n          pos.y = 0;\n        }\n\n        var nbb = node.layoutDimensions(options);\n        var p = options.avoidOverlapPadding;\n        var w = nbb.w + p;\n        var h = nbb.h + p;\n        cellWidth = Math.max(cellWidth, w);\n        cellHeight = Math.max(cellHeight, h);\n      }\n    }\n\n    var cellUsed = {}; // e.g. 'c-0-2' => true\n\n    var used = function used(row, col) {\n      return cellUsed['c-' + row + '-' + col] ? true : false;\n    };\n\n    var use = function use(row, col) {\n      cellUsed['c-' + row + '-' + col] = true;\n    }; // to keep track of current cell position\n\n\n    var row = 0;\n    var col = 0;\n\n    var moveToNextCell = function moveToNextCell() {\n      col++;\n\n      if (col >= cols) {\n        col = 0;\n        row++;\n      }\n    }; // get a cache of all the manual positions\n\n\n    var id2manPos = {};\n\n    for (var _i = 0; _i < nodes.length; _i++) {\n      var _node = nodes[_i];\n      var rcPos = options.position(_node);\n\n      if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {\n        // must have at least row or col def'd\n        var _pos = {\n          row: rcPos.row,\n          col: rcPos.col\n        };\n\n        if (_pos.col === undefined) {\n          // find unused col\n          _pos.col = 0;\n\n          while (used(_pos.row, _pos.col)) {\n            _pos.col++;\n          }\n        } else if (_pos.row === undefined) {\n          // find unused row\n          _pos.row = 0;\n\n          while (used(_pos.row, _pos.col)) {\n            _pos.row++;\n          }\n        }\n\n        id2manPos[_node.id()] = _pos;\n        use(_pos.row, _pos.col);\n      }\n    }\n\n    var getPos = function getPos(element, i) {\n      var x, y;\n\n      if (element.locked() || element.isParent()) {\n        return false;\n      } // see if we have a manual position set\n\n\n      var rcPos = id2manPos[element.id()];\n\n      if (rcPos) {\n        x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;\n        y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;\n      } else {\n        // otherwise set automatically\n        while (used(row, col)) {\n          moveToNextCell();\n        }\n\n        x = col * cellWidth + cellWidth / 2 + bb.x1;\n        y = row * cellHeight + cellHeight / 2 + bb.y1;\n        use(row, col);\n        moveToNextCell();\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    };\n\n    nodes.layoutPositions(this, options, getPos);\n  }\n\n  return this; // chaining\n};\n\nvar defaults$2 = {\n  ready: function ready() {},\n  // on layoutready\n  stop: function stop() {} // on layoutstop\n\n}; // constructor\n// options : object containing layout options\n\nfunction NullLayout(options) {\n  this.options = extend({}, defaults$2, options);\n} // runs the layout\n\n\nNullLayout.prototype.run = function () {\n  var options = this.options;\n  var eles = options.eles; // elements to consider in the layout\n\n  var layout = this; // cy is automatically populated for us in the constructor\n  // (disable eslint for next line as this serves as example layout code to external developers)\n  // eslint-disable-next-line no-unused-vars\n\n  options.cy;\n  layout.emit('layoutstart'); // puts all nodes at (0, 0)\n  // n.b. most layouts would use layoutPositions(), instead of positions() and manual events\n\n  eles.nodes().positions(function () {\n    return {\n      x: 0,\n      y: 0\n    };\n  }); // trigger layoutready when each node has had its position set at least once\n\n  layout.one('layoutready', options.ready);\n  layout.emit('layoutready'); // trigger layoutstop when the layout stops (e.g. finishes)\n\n  layout.one('layoutstop', options.stop);\n  layout.emit('layoutstop');\n  return this; // chaining\n}; // called on continuous layouts to stop them before they finish\n\n\nNullLayout.prototype.stop = function () {\n  return this; // chaining\n};\n\nvar defaults$1 = {\n  positions: undefined,\n  // map of (node id) => (position obj); or function(node){ return somPos; }\n  zoom: undefined,\n  // the zoom level to set (prob want fit = false if set)\n  pan: undefined,\n  // the pan level to set (prob want fit = false if set)\n  fit: true,\n  // whether to fit to viewport\n  padding: 30,\n  // padding on fit\n  animate: false,\n  // whether to transition the node positions\n  animationDuration: 500,\n  // duration of animation in ms if enabled\n  animationEasing: undefined,\n  // easing of animation if enabled\n  animateFilter: function animateFilter(node, i) {\n    return true;\n  },\n  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n  ready: undefined,\n  // callback on layoutready\n  stop: undefined,\n  // callback on layoutstop\n  transform: function transform(node, position) {\n    return position;\n  } // transform a given node position. Useful for changing flow direction in discrete layouts\n\n};\n\nfunction PresetLayout(options) {\n  this.options = extend({}, defaults$1, options);\n}\n\nPresetLayout.prototype.run = function () {\n  var options = this.options;\n  var eles = options.eles;\n  var nodes = eles.nodes();\n  var posIsFn = fn$6(options.positions);\n\n  function getPosition(node) {\n    if (options.positions == null) {\n      return copyPosition(node.position());\n    }\n\n    if (posIsFn) {\n      return options.positions(node);\n    }\n\n    var pos = options.positions[node._private.data.id];\n\n    if (pos == null) {\n      return null;\n    }\n\n    return pos;\n  }\n\n  nodes.layoutPositions(this, options, function (node, i) {\n    var position = getPosition(node);\n\n    if (node.locked() || position == null) {\n      return false;\n    }\n\n    return position;\n  });\n  return this; // chaining\n};\n\nvar defaults = {\n  fit: true,\n  // whether to fit to viewport\n  padding: 30,\n  // fit padding\n  boundingBox: undefined,\n  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  animate: false,\n  // whether to transition the node positions\n  animationDuration: 500,\n  // duration of animation in ms if enabled\n  animationEasing: undefined,\n  // easing of animation if enabled\n  animateFilter: function animateFilter(node, i) {\n    return true;\n  },\n  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n  ready: undefined,\n  // callback on layoutready\n  stop: undefined,\n  // callback on layoutstop\n  transform: function transform(node, position) {\n    return position;\n  } // transform a given node position. Useful for changing flow direction in discrete layouts \n\n};\n\nfunction RandomLayout(options) {\n  this.options = extend({}, defaults, options);\n}\n\nRandomLayout.prototype.run = function () {\n  var options = this.options;\n  var cy = options.cy;\n  var eles = options.eles;\n  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n    x1: 0,\n    y1: 0,\n    w: cy.width(),\n    h: cy.height()\n  });\n\n  var getPos = function getPos(node, i) {\n    return {\n      x: bb.x1 + Math.round(Math.random() * bb.w),\n      y: bb.y1 + Math.round(Math.random() * bb.h)\n    };\n  };\n\n  eles.nodes().layoutPositions(this, options, getPos);\n  return this; // chaining\n};\n\nvar layout = [{\n  name: 'breadthfirst',\n  impl: BreadthFirstLayout\n}, {\n  name: 'circle',\n  impl: CircleLayout\n}, {\n  name: 'concentric',\n  impl: ConcentricLayout\n}, {\n  name: 'cose',\n  impl: CoseLayout\n}, {\n  name: 'grid',\n  impl: GridLayout\n}, {\n  name: 'null',\n  impl: NullLayout\n}, {\n  name: 'preset',\n  impl: PresetLayout\n}, {\n  name: 'random',\n  impl: RandomLayout\n}];\n\nfunction NullRenderer(options) {\n  this.options = options;\n  this.notifications = 0; // for testing\n}\n\nvar noop = function noop() {};\n\nvar throwImgErr = function throwImgErr() {\n  throw new Error('A headless instance can not render images');\n};\n\nNullRenderer.prototype = {\n  recalculateRenderedStyle: noop,\n  notify: function notify() {\n    this.notifications++;\n  },\n  init: noop,\n  isHeadless: function isHeadless() {\n    return true;\n  },\n  png: throwImgErr,\n  jpg: throwImgErr\n};\n\nvar BRp$f = {};\nBRp$f.arrowShapeWidth = 0.3;\n\nBRp$f.registerArrowShapes = function () {\n  var arrowShapes = this.arrowShapes = {};\n  var renderer = this; // Contract for arrow shapes:\n  // 0, 0 is arrow tip\n  // (0, 1) is direction towards node\n  // (1, 0) is right\n  //\n  // functional api:\n  // collide: check x, y in shape\n  // roughCollide: called before collide, no false negatives\n  // draw: draw\n  // spacing: dist(arrowTip, nodeBoundary)\n  // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip\n\n  var bbCollide = function bbCollide(x, y, size, angle, translation, edgeWidth, padding) {\n    var x1 = translation.x - size / 2 - padding;\n    var x2 = translation.x + size / 2 + padding;\n    var y1 = translation.y - size / 2 - padding;\n    var y2 = translation.y + size / 2 + padding;\n    var inside = x1 <= x && x <= x2 && y1 <= y && y <= y2;\n    return inside;\n  };\n\n  var transform = function transform(x, y, size, angle, translation) {\n    var xRotated = x * Math.cos(angle) - y * Math.sin(angle);\n    var yRotated = x * Math.sin(angle) + y * Math.cos(angle);\n    var xScaled = xRotated * size;\n    var yScaled = yRotated * size;\n    var xTranslated = xScaled + translation.x;\n    var yTranslated = yScaled + translation.y;\n    return {\n      x: xTranslated,\n      y: yTranslated\n    };\n  };\n\n  var transformPoints = function transformPoints(pts, size, angle, translation) {\n    var retPts = [];\n\n    for (var i = 0; i < pts.length; i += 2) {\n      var x = pts[i];\n      var y = pts[i + 1];\n      retPts.push(transform(x, y, size, angle, translation));\n    }\n\n    return retPts;\n  };\n\n  var pointsToArr = function pointsToArr(pts) {\n    var ret = [];\n\n    for (var i = 0; i < pts.length; i++) {\n      var p = pts[i];\n      ret.push(p.x, p.y);\n    }\n\n    return ret;\n  };\n\n  var standardGap = function standardGap(edge) {\n    return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').pfValue * 2;\n  };\n\n  var defineArrowShape = function defineArrowShape(name, defn) {\n    if (string(defn)) {\n      defn = arrowShapes[defn];\n    }\n\n    arrowShapes[name] = extend({\n      name: name,\n      points: [-0.15, -0.3, 0.15, -0.3, 0.15, 0.3, -0.15, 0.3],\n      collide: function collide(x, y, size, angle, translation, padding) {\n        var points = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n        var inside = pointInsidePolygonPoints(x, y, points);\n        return inside;\n      },\n      roughCollide: bbCollide,\n      draw: function draw(context, size, angle, translation) {\n        var points = transformPoints(this.points, size, angle, translation);\n        renderer.arrowShapeImpl('polygon')(context, points);\n      },\n      spacing: function spacing(edge) {\n        return 0;\n      },\n      gap: standardGap\n    }, defn);\n  };\n\n  defineArrowShape('none', {\n    collide: falsify,\n    roughCollide: falsify,\n    draw: noop$1,\n    spacing: zeroify,\n    gap: zeroify\n  });\n  defineArrowShape('triangle', {\n    points: [-0.15, -0.3, 0, 0, 0.15, -0.3]\n  });\n  defineArrowShape('arrow', 'triangle');\n  defineArrowShape('triangle-backcurve', {\n    points: arrowShapes['triangle'].points,\n    controlPoint: [0, -0.15],\n    roughCollide: bbCollide,\n    draw: function draw(context, size, angle, translation, edgeWidth) {\n      var ptsTrans = transformPoints(this.points, size, angle, translation);\n      var ctrlPt = this.controlPoint;\n      var ctrlPtTrans = transform(ctrlPt[0], ctrlPt[1], size, angle, translation);\n      renderer.arrowShapeImpl(this.name)(context, ptsTrans, ctrlPtTrans);\n    },\n    gap: function gap(edge) {\n      return standardGap(edge) * 0.8;\n    }\n  });\n  defineArrowShape('triangle-tee', {\n    points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],\n    pointsTee: [-0.15, -0.4, -0.15, -0.5, 0.15, -0.5, 0.15, -0.4],\n    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n      var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n      var teePts = pointsToArr(transformPoints(this.pointsTee, size + 2 * padding, angle, translation));\n      var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);\n      return inside;\n    },\n    draw: function draw(context, size, angle, translation, edgeWidth) {\n      var triPts = transformPoints(this.points, size, angle, translation);\n      var teePts = transformPoints(this.pointsTee, size, angle, translation);\n      renderer.arrowShapeImpl(this.name)(context, triPts, teePts);\n    }\n  });\n  defineArrowShape('circle-triangle', {\n    radius: 0.15,\n    pointsTr: [0, -0.15, 0.15, -0.45, -0.15, -0.45, 0, -0.15],\n    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n      var t = translation;\n      var circleInside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);\n      var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n      return pointInsidePolygonPoints(x, y, triPts) || circleInside;\n    },\n    draw: function draw(context, size, angle, translation, edgeWidth) {\n      var triPts = transformPoints(this.pointsTr, size, angle, translation);\n      renderer.arrowShapeImpl(this.name)(context, triPts, translation.x, translation.y, this.radius * size);\n    },\n    spacing: function spacing(edge) {\n      return renderer.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.radius;\n    }\n  });\n  defineArrowShape('triangle-cross', {\n    points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],\n    baseCrossLinePts: [-0.15, -0.4, // first half of the rectangle\n    -0.15, -0.4, 0.15, -0.4, // second half of the rectangle\n    0.15, -0.4],\n    crossLinePts: function crossLinePts(size, edgeWidth) {\n      // shift points so that the distance between the cross points matches edge width\n      var p = this.baseCrossLinePts.slice();\n      var shiftFactor = edgeWidth / size;\n      var y0 = 3;\n      var y1 = 5;\n      p[y0] = p[y0] - shiftFactor;\n      p[y1] = p[y1] - shiftFactor;\n      return p;\n    },\n    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n      var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n      var teePts = pointsToArr(transformPoints(this.crossLinePts(size, edgeWidth), size + 2 * padding, angle, translation));\n      var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);\n      return inside;\n    },\n    draw: function draw(context, size, angle, translation, edgeWidth) {\n      var triPts = transformPoints(this.points, size, angle, translation);\n      var crossLinePts = transformPoints(this.crossLinePts(size, edgeWidth), size, angle, translation);\n      renderer.arrowShapeImpl(this.name)(context, triPts, crossLinePts);\n    }\n  });\n  defineArrowShape('vee', {\n    points: [-0.15, -0.3, 0, 0, 0.15, -0.3, 0, -0.15],\n    gap: function gap(edge) {\n      return standardGap(edge) * 0.525;\n    }\n  });\n  defineArrowShape('circle', {\n    radius: 0.15,\n    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n      var t = translation;\n      var inside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);\n      return inside;\n    },\n    draw: function draw(context, size, angle, translation, edgeWidth) {\n      renderer.arrowShapeImpl(this.name)(context, translation.x, translation.y, this.radius * size);\n    },\n    spacing: function spacing(edge) {\n      return renderer.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.radius;\n    }\n  });\n  defineArrowShape('tee', {\n    points: [-0.15, 0, -0.15, -0.1, 0.15, -0.1, 0.15, 0],\n    spacing: function spacing(edge) {\n      return 1;\n    },\n    gap: function gap(edge) {\n      return 1;\n    }\n  });\n  defineArrowShape('square', {\n    points: [-0.15, 0.00, 0.15, 0.00, 0.15, -0.3, -0.15, -0.3]\n  });\n  defineArrowShape('diamond', {\n    points: [-0.15, -0.15, 0, -0.3, 0.15, -0.15, 0, 0],\n    gap: function gap(edge) {\n      return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;\n    }\n  });\n  defineArrowShape('chevron', {\n    points: [0, 0, -0.15, -0.15, -0.1, -0.2, 0, -0.1, 0.1, -0.2, 0.15, -0.15],\n    gap: function gap(edge) {\n      return 0.95 * edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;\n    }\n  });\n};\n\nvar BRp$e = {}; // Project mouse\n\nBRp$e.projectIntoViewport = function (clientX, clientY) {\n  var cy = this.cy;\n  var offsets = this.findContainerClientCoords();\n  var offsetLeft = offsets[0];\n  var offsetTop = offsets[1];\n  var scale = offsets[4];\n  var pan = cy.pan();\n  var zoom = cy.zoom();\n  var x = ((clientX - offsetLeft) / scale - pan.x) / zoom;\n  var y = ((clientY - offsetTop) / scale - pan.y) / zoom;\n  return [x, y];\n};\n\nBRp$e.findContainerClientCoords = function () {\n  if (this.containerBB) {\n    return this.containerBB;\n  }\n\n  var container = this.container;\n  var rect = container.getBoundingClientRect();\n  var style = this.cy.window().getComputedStyle(container);\n\n  var styleValue = function styleValue(name) {\n    return parseFloat(style.getPropertyValue(name));\n  };\n\n  var padding = {\n    left: styleValue('padding-left'),\n    right: styleValue('padding-right'),\n    top: styleValue('padding-top'),\n    bottom: styleValue('padding-bottom')\n  };\n  var border = {\n    left: styleValue('border-left-width'),\n    right: styleValue('border-right-width'),\n    top: styleValue('border-top-width'),\n    bottom: styleValue('border-bottom-width')\n  };\n  var clientWidth = container.clientWidth;\n  var clientHeight = container.clientHeight;\n  var paddingHor = padding.left + padding.right;\n  var paddingVer = padding.top + padding.bottom;\n  var borderHor = border.left + border.right;\n  var scale = rect.width / (clientWidth + borderHor);\n  var unscaledW = clientWidth - paddingHor;\n  var unscaledH = clientHeight - paddingVer;\n  var left = rect.left + padding.left + border.left;\n  var top = rect.top + padding.top + border.top;\n  return this.containerBB = [left, top, unscaledW, unscaledH, scale];\n};\n\nBRp$e.invalidateContainerClientCoordsCache = function () {\n  this.containerBB = null;\n};\n\nBRp$e.findNearestElement = function (x, y, interactiveElementsOnly, isTouch) {\n  return this.findNearestElements(x, y, interactiveElementsOnly, isTouch)[0];\n};\n\nBRp$e.findNearestElements = function (x, y, interactiveElementsOnly, isTouch) {\n  var self = this;\n  var r = this;\n  var eles = r.getCachedZSortedEles();\n  var near = []; // 1 node max, 1 edge max\n\n  var zoom = r.cy.zoom();\n  var hasCompounds = r.cy.hasCompoundNodes();\n  var edgeThreshold = (isTouch ? 24 : 8) / zoom;\n  var nodeThreshold = (isTouch ? 8 : 2) / zoom;\n  var labelThreshold = (isTouch ? 8 : 2) / zoom;\n  var minSqDist = Infinity;\n  var nearEdge;\n  var nearNode;\n\n  if (interactiveElementsOnly) {\n    eles = eles.interactive;\n  }\n\n  function addEle(ele, sqDist) {\n    if (ele.isNode()) {\n      if (nearNode) {\n        return; // can't replace node\n      } else {\n        nearNode = ele;\n        near.push(ele);\n      }\n    }\n\n    if (ele.isEdge() && (sqDist == null || sqDist < minSqDist)) {\n      if (nearEdge) {\n        // then replace existing edge\n        // can replace only if same z-index\n        if (nearEdge.pstyle('z-compound-depth').value === ele.pstyle('z-compound-depth').value && nearEdge.pstyle('z-compound-depth').value === ele.pstyle('z-compound-depth').value) {\n          for (var i = 0; i < near.length; i++) {\n            if (near[i].isEdge()) {\n              near[i] = ele;\n              nearEdge = ele;\n              minSqDist = sqDist != null ? sqDist : minSqDist;\n              break;\n            }\n          }\n        }\n      } else {\n        near.push(ele);\n        nearEdge = ele;\n        minSqDist = sqDist != null ? sqDist : minSqDist;\n      }\n    }\n  }\n\n  function checkNode(node) {\n    var width = node.outerWidth() + 2 * nodeThreshold;\n    var height = node.outerHeight() + 2 * nodeThreshold;\n    var hw = width / 2;\n    var hh = height / 2;\n    var pos = node.position();\n\n    if (pos.x - hw <= x && x <= pos.x + hw // bb check x\n    && pos.y - hh <= y && y <= pos.y + hh // bb check y\n    ) {\n      var shape = r.nodeShapes[self.getNodeShape(node)];\n\n      if (shape.checkPoint(x, y, 0, width, height, pos.x, pos.y)) {\n        addEle(node, 0);\n        return true;\n      }\n    }\n  }\n\n  function checkEdge(edge) {\n    var _p = edge._private;\n    var rs = _p.rscratch;\n    var styleWidth = edge.pstyle('width').pfValue;\n    var scale = edge.pstyle('arrow-scale').value;\n    var width = styleWidth / 2 + edgeThreshold; // more like a distance radius from centre\n\n    var widthSq = width * width;\n    var width2 = width * 2;\n    var src = _p.source;\n    var tgt = _p.target;\n    var sqDist;\n\n    if (rs.edgeType === 'segments' || rs.edgeType === 'straight' || rs.edgeType === 'haystack') {\n      var pts = rs.allpts;\n\n      for (var i = 0; i + 3 < pts.length; i += 2) {\n        if (inLineVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], width2) && widthSq > (sqDist = sqdistToFiniteLine(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3]))) {\n          addEle(edge, sqDist);\n          return true;\n        }\n      }\n    } else if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {\n      var pts = rs.allpts;\n\n      for (var i = 0; i + 5 < rs.allpts.length; i += 4) {\n        if (inBezierVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5], width2) && widthSq > (sqDist = sqdistToQuadraticBezier(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5]))) {\n          addEle(edge, sqDist);\n          return true;\n        }\n      }\n    } // if we're close to the edge but didn't hit it, maybe we hit its arrows\n\n\n    var src = src || _p.source;\n    var tgt = tgt || _p.target;\n    var arSize = self.getArrowWidth(styleWidth, scale);\n    var arrows = [{\n      name: 'source',\n      x: rs.arrowStartX,\n      y: rs.arrowStartY,\n      angle: rs.srcArrowAngle\n    }, {\n      name: 'target',\n      x: rs.arrowEndX,\n      y: rs.arrowEndY,\n      angle: rs.tgtArrowAngle\n    }, {\n      name: 'mid-source',\n      x: rs.midX,\n      y: rs.midY,\n      angle: rs.midsrcArrowAngle\n    }, {\n      name: 'mid-target',\n      x: rs.midX,\n      y: rs.midY,\n      angle: rs.midtgtArrowAngle\n    }];\n\n    for (var i = 0; i < arrows.length; i++) {\n      var ar = arrows[i];\n      var shape = r.arrowShapes[edge.pstyle(ar.name + '-arrow-shape').value];\n      var edgeWidth = edge.pstyle('width').pfValue;\n\n      if (shape.roughCollide(x, y, arSize, ar.angle, {\n        x: ar.x,\n        y: ar.y\n      }, edgeWidth, edgeThreshold) && shape.collide(x, y, arSize, ar.angle, {\n        x: ar.x,\n        y: ar.y\n      }, edgeWidth, edgeThreshold)) {\n        addEle(edge);\n        return true;\n      }\n    } // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)\n\n\n    if (hasCompounds && near.length > 0) {\n      checkNode(src);\n      checkNode(tgt);\n    }\n  }\n\n  function preprop(obj, name, pre) {\n    return getPrefixedProperty(obj, name, pre);\n  }\n\n  function checkLabel(ele, prefix) {\n    var _p = ele._private;\n    var th = labelThreshold;\n    var prefixDash;\n\n    if (prefix) {\n      prefixDash = prefix + '-';\n    } else {\n      prefixDash = '';\n    }\n\n    ele.boundingBox();\n    var bb = _p.labelBounds[prefix || 'main'];\n    var text = ele.pstyle(prefixDash + 'label').value;\n    var eventsEnabled = ele.pstyle('text-events').strValue === 'yes';\n\n    if (!eventsEnabled || !text) {\n      return;\n    }\n\n    var lx = preprop(_p.rscratch, 'labelX', prefix);\n    var ly = preprop(_p.rscratch, 'labelY', prefix);\n    var theta = preprop(_p.rscratch, 'labelAngle', prefix);\n    var ox = ele.pstyle(prefixDash + 'text-margin-x').pfValue;\n    var oy = ele.pstyle(prefixDash + 'text-margin-y').pfValue;\n    var lx1 = bb.x1 - th - ox; // (-ox, -oy) as bb already includes margin\n\n    var lx2 = bb.x2 + th - ox; // and rotation is about (lx, ly)\n\n    var ly1 = bb.y1 - th - oy;\n    var ly2 = bb.y2 + th - oy;\n\n    if (theta) {\n      var cos = Math.cos(theta);\n      var sin = Math.sin(theta);\n\n      var rotate = function rotate(x, y) {\n        x = x - lx;\n        y = y - ly;\n        return {\n          x: x * cos - y * sin + lx,\n          y: x * sin + y * cos + ly\n        };\n      };\n\n      var px1y1 = rotate(lx1, ly1);\n      var px1y2 = rotate(lx1, ly2);\n      var px2y1 = rotate(lx2, ly1);\n      var px2y2 = rotate(lx2, ly2);\n      var points = [// with the margin added after the rotation is applied\n      px1y1.x + ox, px1y1.y + oy, px2y1.x + ox, px2y1.y + oy, px2y2.x + ox, px2y2.y + oy, px1y2.x + ox, px1y2.y + oy];\n\n      if (pointInsidePolygonPoints(x, y, points)) {\n        addEle(ele);\n        return true;\n      }\n    } else {\n      // do a cheaper bb check\n      if (inBoundingBox(bb, x, y)) {\n        addEle(ele);\n        return true;\n      }\n    }\n  }\n\n  for (var i = eles.length - 1; i >= 0; i--) {\n    // reverse order for precedence\n    var ele = eles[i];\n\n    if (ele.isNode()) {\n      checkNode(ele) || checkLabel(ele);\n    } else {\n      // then edge\n      checkEdge(ele) || checkLabel(ele) || checkLabel(ele, 'source') || checkLabel(ele, 'target');\n    }\n  }\n\n  return near;\n}; // 'Give me everything from this box'\n\n\nBRp$e.getAllInBox = function (x1, y1, x2, y2) {\n  var eles = this.getCachedZSortedEles().interactive;\n  var box = [];\n  var x1c = Math.min(x1, x2);\n  var x2c = Math.max(x1, x2);\n  var y1c = Math.min(y1, y2);\n  var y2c = Math.max(y1, y2);\n  x1 = x1c;\n  x2 = x2c;\n  y1 = y1c;\n  y2 = y2c;\n  var boxBb = makeBoundingBox({\n    x1: x1,\n    y1: y1,\n    x2: x2,\n    y2: y2\n  });\n\n  for (var e = 0; e < eles.length; e++) {\n    var ele = eles[e];\n\n    if (ele.isNode()) {\n      var node = ele;\n      var nodeBb = node.boundingBox({\n        includeNodes: true,\n        includeEdges: false,\n        includeLabels: false\n      });\n\n      if (boundingBoxesIntersect(boxBb, nodeBb) && !boundingBoxInBoundingBox(nodeBb, boxBb)) {\n        box.push(node);\n      }\n    } else {\n      var edge = ele;\n      var _p = edge._private;\n      var rs = _p.rscratch;\n\n      if (rs.startX != null && rs.startY != null && !inBoundingBox(boxBb, rs.startX, rs.startY)) {\n        continue;\n      }\n\n      if (rs.endX != null && rs.endY != null && !inBoundingBox(boxBb, rs.endX, rs.endY)) {\n        continue;\n      }\n\n      if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' || rs.edgeType === 'segments' || rs.edgeType === 'haystack') {\n        var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;\n        var allInside = true;\n\n        for (var i = 0; i < pts.length; i++) {\n          if (!pointInBoundingBox(boxBb, pts[i])) {\n            allInside = false;\n            break;\n          }\n        }\n\n        if (allInside) {\n          box.push(edge);\n        }\n      } else if (rs.edgeType === 'haystack' || rs.edgeType === 'straight') {\n        box.push(edge);\n      }\n    }\n  }\n\n  return box;\n};\n\nvar BRp$d = {};\n\nBRp$d.calculateArrowAngles = function (edge) {\n  var rs = edge._private.rscratch;\n  var isHaystack = rs.edgeType === 'haystack';\n  var isBezier = rs.edgeType === 'bezier';\n  var isMultibezier = rs.edgeType === 'multibezier';\n  var isSegments = rs.edgeType === 'segments';\n  var isCompound = rs.edgeType === 'compound';\n  var isSelf = rs.edgeType === 'self'; // Displacement gives direction for arrowhead orientation\n\n  var dispX, dispY;\n  var startX, startY, endX, endY, midX, midY;\n\n  if (isHaystack) {\n    startX = rs.haystackPts[0];\n    startY = rs.haystackPts[1];\n    endX = rs.haystackPts[2];\n    endY = rs.haystackPts[3];\n  } else {\n    startX = rs.arrowStartX;\n    startY = rs.arrowStartY;\n    endX = rs.arrowEndX;\n    endY = rs.arrowEndY;\n  }\n\n  midX = rs.midX;\n  midY = rs.midY; // source\n  //\n\n  if (isSegments) {\n    dispX = startX - rs.segpts[0];\n    dispY = startY - rs.segpts[1];\n  } else if (isMultibezier || isCompound || isSelf || isBezier) {\n    var pts = rs.allpts;\n    var bX = qbezierAt(pts[0], pts[2], pts[4], 0.1);\n    var bY = qbezierAt(pts[1], pts[3], pts[5], 0.1);\n    dispX = startX - bX;\n    dispY = startY - bY;\n  } else {\n    dispX = startX - midX;\n    dispY = startY - midY;\n  }\n\n  rs.srcArrowAngle = getAngleFromDisp(dispX, dispY); // mid target\n  //\n\n  var midX = rs.midX;\n  var midY = rs.midY;\n\n  if (isHaystack) {\n    midX = (startX + endX) / 2;\n    midY = (startY + endY) / 2;\n  }\n\n  dispX = endX - startX;\n  dispY = endY - startY;\n\n  if (isSegments) {\n    var pts = rs.allpts;\n\n    if (pts.length / 2 % 2 === 0) {\n      var i2 = pts.length / 2;\n      var i1 = i2 - 2;\n      dispX = pts[i2] - pts[i1];\n      dispY = pts[i2 + 1] - pts[i1 + 1];\n    } else {\n      var i2 = pts.length / 2 - 1;\n      var i1 = i2 - 2;\n      var i3 = i2 + 2;\n      dispX = pts[i2] - pts[i1];\n      dispY = pts[i2 + 1] - pts[i1 + 1];\n    }\n  } else if (isMultibezier || isCompound || isSelf) {\n    var pts = rs.allpts;\n    var cpts = rs.ctrlpts;\n    var bp0x, bp0y;\n    var bp1x, bp1y;\n\n    if (cpts.length / 2 % 2 === 0) {\n      var p0 = pts.length / 2 - 1; // startpt\n\n      var ic = p0 + 2;\n      var p1 = ic + 2;\n      bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0);\n      bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0);\n      bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0001);\n      bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0001);\n    } else {\n      var ic = pts.length / 2 - 1; // ctrpt\n\n      var p0 = ic - 2; // startpt\n\n      var p1 = ic + 2; // endpt\n\n      bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.4999);\n      bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.4999);\n      bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.5);\n      bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.5);\n    }\n\n    dispX = bp1x - bp0x;\n    dispY = bp1y - bp0y;\n  }\n\n  rs.midtgtArrowAngle = getAngleFromDisp(dispX, dispY);\n  rs.midDispX = dispX;\n  rs.midDispY = dispY; // mid source\n  //\n\n  dispX *= -1;\n  dispY *= -1;\n\n  if (isSegments) {\n    var pts = rs.allpts;\n\n    if (pts.length / 2 % 2 === 0) ; else {\n      var i2 = pts.length / 2 - 1;\n      var i3 = i2 + 2;\n      dispX = -(pts[i3] - pts[i2]);\n      dispY = -(pts[i3 + 1] - pts[i2 + 1]);\n    }\n  }\n\n  rs.midsrcArrowAngle = getAngleFromDisp(dispX, dispY); // target\n  //\n\n  if (isSegments) {\n    dispX = endX - rs.segpts[rs.segpts.length - 2];\n    dispY = endY - rs.segpts[rs.segpts.length - 1];\n  } else if (isMultibezier || isCompound || isSelf || isBezier) {\n    var pts = rs.allpts;\n    var l = pts.length;\n    var bX = qbezierAt(pts[l - 6], pts[l - 4], pts[l - 2], 0.9);\n    var bY = qbezierAt(pts[l - 5], pts[l - 3], pts[l - 1], 0.9);\n    dispX = endX - bX;\n    dispY = endY - bY;\n  } else {\n    dispX = endX - midX;\n    dispY = endY - midY;\n  }\n\n  rs.tgtArrowAngle = getAngleFromDisp(dispX, dispY);\n};\n\nBRp$d.getArrowWidth = BRp$d.getArrowHeight = function (edgeWidth, scale) {\n  var cache = this.arrowWidthCache = this.arrowWidthCache || {};\n  var cachedVal = cache[edgeWidth + ', ' + scale];\n\n  if (cachedVal) {\n    return cachedVal;\n  }\n\n  cachedVal = Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29) * scale;\n  cache[edgeWidth + ', ' + scale] = cachedVal;\n  return cachedVal;\n};\n\nvar BRp$c = {};\n\nBRp$c.findHaystackPoints = function (edges) {\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n    var _p = edge._private;\n    var rs = _p.rscratch;\n\n    if (!rs.haystack) {\n      var angle = Math.random() * 2 * Math.PI;\n      rs.source = {\n        x: Math.cos(angle),\n        y: Math.sin(angle)\n      };\n      angle = Math.random() * 2 * Math.PI;\n      rs.target = {\n        x: Math.cos(angle),\n        y: Math.sin(angle)\n      };\n    }\n\n    var src = _p.source;\n    var tgt = _p.target;\n    var srcPos = src.position();\n    var tgtPos = tgt.position();\n    var srcW = src.width();\n    var tgtW = tgt.width();\n    var srcH = src.height();\n    var tgtH = tgt.height();\n    var radius = edge.pstyle('haystack-radius').value;\n    var halfRadius = radius / 2; // b/c have to half width/height\n\n    rs.haystackPts = rs.allpts = [rs.source.x * srcW * halfRadius + srcPos.x, rs.source.y * srcH * halfRadius + srcPos.y, rs.target.x * tgtW * halfRadius + tgtPos.x, rs.target.y * tgtH * halfRadius + tgtPos.y];\n    rs.midX = (rs.allpts[0] + rs.allpts[2]) / 2;\n    rs.midY = (rs.allpts[1] + rs.allpts[3]) / 2; // always override as haystack in case set to different type previously\n\n    rs.edgeType = 'haystack';\n    rs.haystack = true;\n    this.storeEdgeProjections(edge);\n    this.calculateArrowAngles(edge);\n    this.recalculateEdgeLabelProjections(edge);\n    this.calculateLabelAngles(edge);\n  }\n};\n\nBRp$c.findSegmentsPoints = function (edge, pairInfo) {\n  // Segments (multiple straight lines)\n  var rs = edge._private.rscratch;\n  var posPts = pairInfo.posPts,\n      intersectionPts = pairInfo.intersectionPts,\n      vectorNormInverse = pairInfo.vectorNormInverse;\n  var edgeDistances = edge.pstyle('edge-distances').value;\n  var segmentWs = edge.pstyle('segment-weights');\n  var segmentDs = edge.pstyle('segment-distances');\n  var segmentsN = Math.min(segmentWs.pfValue.length, segmentDs.pfValue.length);\n  rs.edgeType = 'segments';\n  rs.segpts = [];\n\n  for (var s = 0; s < segmentsN; s++) {\n    var w = segmentWs.pfValue[s];\n    var d = segmentDs.pfValue[s];\n    var w1 = 1 - w;\n    var w2 = w;\n    var midptPts = edgeDistances === 'node-position' ? posPts : intersectionPts;\n    var adjustedMidpt = {\n      x: midptPts.x1 * w1 + midptPts.x2 * w2,\n      y: midptPts.y1 * w1 + midptPts.y2 * w2\n    };\n    rs.segpts.push(adjustedMidpt.x + vectorNormInverse.x * d, adjustedMidpt.y + vectorNormInverse.y * d);\n  }\n};\n\nBRp$c.findLoopPoints = function (edge, pairInfo, i, edgeIsUnbundled) {\n  // Self-edge\n  var rs = edge._private.rscratch;\n  var dirCounts = pairInfo.dirCounts,\n      srcPos = pairInfo.srcPos;\n  var ctrlptDists = edge.pstyle('control-point-distances');\n  var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n  var loopDir = edge.pstyle('loop-direction').pfValue;\n  var loopSwp = edge.pstyle('loop-sweep').pfValue;\n  var stepSize = edge.pstyle('control-point-step-size').pfValue;\n  rs.edgeType = 'self';\n  var j = i;\n  var loopDist = stepSize;\n\n  if (edgeIsUnbundled) {\n    j = 0;\n    loopDist = ctrlptDist;\n  }\n\n  var loopAngle = loopDir - Math.PI / 2;\n  var outAngle = loopAngle - loopSwp / 2;\n  var inAngle = loopAngle + loopSwp / 2; // increase by step size for overlapping loops, keyed on direction and sweep values\n\n  var dc = String(loopDir + '_' + loopSwp);\n  j = dirCounts[dc] === undefined ? dirCounts[dc] = 0 : ++dirCounts[dc];\n  rs.ctrlpts = [srcPos.x + Math.cos(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.x + Math.cos(inAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(inAngle) * 1.4 * loopDist * (j / 3 + 1)];\n};\n\nBRp$c.findCompoundLoopPoints = function (edge, pairInfo, i, edgeIsUnbundled) {\n  // Compound edge\n  var rs = edge._private.rscratch;\n  rs.edgeType = 'compound';\n  var srcPos = pairInfo.srcPos,\n      tgtPos = pairInfo.tgtPos,\n      srcW = pairInfo.srcW,\n      srcH = pairInfo.srcH,\n      tgtW = pairInfo.tgtW,\n      tgtH = pairInfo.tgtH;\n  var stepSize = edge.pstyle('control-point-step-size').pfValue;\n  var ctrlptDists = edge.pstyle('control-point-distances');\n  var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n  var j = i;\n  var loopDist = stepSize;\n\n  if (edgeIsUnbundled) {\n    j = 0;\n    loopDist = ctrlptDist;\n  }\n\n  var loopW = 50;\n  var loopaPos = {\n    x: srcPos.x - srcW / 2,\n    y: srcPos.y - srcH / 2\n  };\n  var loopbPos = {\n    x: tgtPos.x - tgtW / 2,\n    y: tgtPos.y - tgtH / 2\n  };\n  var loopPos = {\n    x: Math.min(loopaPos.x, loopbPos.x),\n    y: Math.min(loopaPos.y, loopbPos.y)\n  }; // avoids cases with impossible beziers\n\n  var minCompoundStretch = 0.5;\n  var compoundStretchA = Math.max(minCompoundStretch, Math.log(srcW * 0.01));\n  var compoundStretchB = Math.max(minCompoundStretch, Math.log(tgtW * 0.01));\n  rs.ctrlpts = [loopPos.x, loopPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchA, loopPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchB, loopPos.y];\n};\n\nBRp$c.findStraightEdgePoints = function (edge) {\n  // Straight edge within bundle\n  edge._private.rscratch.edgeType = 'straight';\n};\n\nBRp$c.findBezierPoints = function (edge, pairInfo, i, edgeIsUnbundled, edgeIsSwapped) {\n  var rs = edge._private.rscratch;\n  var vectorNormInverse = pairInfo.vectorNormInverse,\n      posPts = pairInfo.posPts,\n      intersectionPts = pairInfo.intersectionPts;\n  var edgeDistances = edge.pstyle('edge-distances').value;\n  var stepSize = edge.pstyle('control-point-step-size').pfValue;\n  var ctrlptDists = edge.pstyle('control-point-distances');\n  var ctrlptWs = edge.pstyle('control-point-weights');\n  var bezierN = ctrlptDists && ctrlptWs ? Math.min(ctrlptDists.value.length, ctrlptWs.value.length) : 1;\n  var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n  var ctrlptWeight = ctrlptWs.value[0]; // (Multi)bezier\n\n  var multi = edgeIsUnbundled;\n  rs.edgeType = multi ? 'multibezier' : 'bezier';\n  rs.ctrlpts = [];\n\n  for (var b = 0; b < bezierN; b++) {\n    var normctrlptDist = (0.5 - pairInfo.eles.length / 2 + i) * stepSize * (edgeIsSwapped ? -1 : 1);\n    var manctrlptDist = void 0;\n    var sign = signum(normctrlptDist);\n\n    if (multi) {\n      ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[b] : stepSize; // fall back on step size\n\n      ctrlptWeight = ctrlptWs.value[b];\n    }\n\n    if (edgeIsUnbundled) {\n      // multi or single unbundled\n      manctrlptDist = ctrlptDist;\n    } else {\n      manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;\n    }\n\n    var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;\n    var w1 = 1 - ctrlptWeight;\n    var w2 = ctrlptWeight;\n    var midptPts = edgeDistances === 'node-position' ? posPts : intersectionPts;\n    var adjustedMidpt = {\n      x: midptPts.x1 * w1 + midptPts.x2 * w2,\n      y: midptPts.y1 * w1 + midptPts.y2 * w2\n    };\n    rs.ctrlpts.push(adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint, adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint);\n  }\n};\n\nBRp$c.findTaxiPoints = function (edge, pairInfo) {\n  // Taxicab geometry with two turns maximum\n  var rs = edge._private.rscratch;\n  rs.edgeType = 'segments';\n  var VERTICAL = 'vertical';\n  var HORIZONTAL = 'horizontal';\n  var LEFTWARD = 'leftward';\n  var RIGHTWARD = 'rightward';\n  var DOWNWARD = 'downward';\n  var UPWARD = 'upward';\n  var AUTO = 'auto';\n  var posPts = pairInfo.posPts,\n      srcW = pairInfo.srcW,\n      srcH = pairInfo.srcH,\n      tgtW = pairInfo.tgtW,\n      tgtH = pairInfo.tgtH;\n  var edgeDistances = edge.pstyle('edge-distances').value;\n  var dIncludesNodeBody = edgeDistances !== 'node-position';\n  var taxiDir = edge.pstyle('taxi-direction').value;\n  var rawTaxiDir = taxiDir; // unprocessed value\n\n  var taxiTurn = edge.pstyle('taxi-turn');\n  var turnIsPercent = taxiTurn.units === '%';\n  var taxiTurnPfVal = taxiTurn.pfValue;\n  var turnIsNegative = taxiTurnPfVal < 0; // i.e. from target side\n\n  var minD = edge.pstyle('taxi-turn-min-distance').pfValue;\n  var dw = dIncludesNodeBody ? (srcW + tgtW) / 2 : 0;\n  var dh = dIncludesNodeBody ? (srcH + tgtH) / 2 : 0;\n  var pdx = posPts.x2 - posPts.x1;\n  var pdy = posPts.y2 - posPts.y1; // take away the effective w/h from the magnitude of the delta value\n\n  var subDWH = function subDWH(dxy, dwh) {\n    if (dxy > 0) {\n      return Math.max(dxy - dwh, 0);\n    } else {\n      return Math.min(dxy + dwh, 0);\n    }\n  };\n\n  var dx = subDWH(pdx, dw);\n  var dy = subDWH(pdy, dh);\n  var isExplicitDir = false;\n\n  if (rawTaxiDir === AUTO) {\n    taxiDir = Math.abs(dx) > Math.abs(dy) ? HORIZONTAL : VERTICAL;\n  } else if (rawTaxiDir === UPWARD || rawTaxiDir === DOWNWARD) {\n    taxiDir = VERTICAL;\n    isExplicitDir = true;\n  } else if (rawTaxiDir === LEFTWARD || rawTaxiDir === RIGHTWARD) {\n    taxiDir = HORIZONTAL;\n    isExplicitDir = true;\n  }\n\n  var isVert = taxiDir === VERTICAL;\n  var l = isVert ? dy : dx;\n  var pl = isVert ? pdy : pdx;\n  var sgnL = signum(pl);\n  var forcedDir = false;\n\n  if (!(isExplicitDir && (turnIsPercent || turnIsNegative)) // forcing in this case would cause weird growing in the opposite direction\n  && (rawTaxiDir === DOWNWARD && pl < 0 || rawTaxiDir === UPWARD && pl > 0 || rawTaxiDir === LEFTWARD && pl > 0 || rawTaxiDir === RIGHTWARD && pl < 0)) {\n    sgnL *= -1;\n    l = sgnL * Math.abs(l);\n    forcedDir = true;\n  }\n\n  var d;\n\n  if (turnIsPercent) {\n    var p = taxiTurnPfVal < 0 ? 1 + taxiTurnPfVal : taxiTurnPfVal;\n    d = p * l;\n  } else {\n    var k = taxiTurnPfVal < 0 ? l : 0;\n    d = k + taxiTurnPfVal * sgnL;\n  }\n\n  var getIsTooClose = function getIsTooClose(d) {\n    return Math.abs(d) < minD || Math.abs(d) >= Math.abs(l);\n  };\n\n  var isTooCloseSrc = getIsTooClose(d);\n  var isTooCloseTgt = getIsTooClose(Math.abs(l) - Math.abs(d));\n  var isTooClose = isTooCloseSrc || isTooCloseTgt;\n\n  if (isTooClose && !forcedDir) {\n    // non-ideal routing\n    if (isVert) {\n      // vertical fallbacks\n      var lShapeInsideSrc = Math.abs(pl) <= srcH / 2;\n      var lShapeInsideTgt = Math.abs(pdx) <= tgtW / 2;\n\n      if (lShapeInsideSrc) {\n        // horizontal Z-shape (direction not respected)\n        var x = (posPts.x1 + posPts.x2) / 2;\n        var y1 = posPts.y1,\n            y2 = posPts.y2;\n        rs.segpts = [x, y1, x, y2];\n      } else if (lShapeInsideTgt) {\n        // vertical Z-shape (distance not respected)\n        var y = (posPts.y1 + posPts.y2) / 2;\n        var x1 = posPts.x1,\n            x2 = posPts.x2;\n        rs.segpts = [x1, y, x2, y];\n      } else {\n        // L-shape fallback (turn distance not respected, but works well with tree siblings)\n        rs.segpts = [posPts.x1, posPts.y2];\n      }\n    } else {\n      // horizontal fallbacks\n      var _lShapeInsideSrc = Math.abs(pl) <= srcW / 2;\n\n      var _lShapeInsideTgt = Math.abs(pdy) <= tgtH / 2;\n\n      if (_lShapeInsideSrc) {\n        // vertical Z-shape (direction not respected)\n        var _y = (posPts.y1 + posPts.y2) / 2;\n\n        var _x = posPts.x1,\n            _x2 = posPts.x2;\n        rs.segpts = [_x, _y, _x2, _y];\n      } else if (_lShapeInsideTgt) {\n        // horizontal Z-shape (turn distance not respected)\n        var _x3 = (posPts.x1 + posPts.x2) / 2;\n\n        var _y2 = posPts.y1,\n            _y3 = posPts.y2;\n        rs.segpts = [_x3, _y2, _x3, _y3];\n      } else {\n        // L-shape (turn distance not respected, but works well for tree siblings)\n        rs.segpts = [posPts.x2, posPts.y1];\n      }\n    }\n  } else {\n    // ideal routing\n    if (isVert) {\n      var _y4 = posPts.y1 + d + (dIncludesNodeBody ? srcH / 2 * sgnL : 0);\n\n      var _x4 = posPts.x1,\n          _x5 = posPts.x2;\n      rs.segpts = [_x4, _y4, _x5, _y4];\n    } else {\n      // horizontal\n      var _x6 = posPts.x1 + d + (dIncludesNodeBody ? srcW / 2 * sgnL : 0);\n\n      var _y5 = posPts.y1,\n          _y6 = posPts.y2;\n      rs.segpts = [_x6, _y5, _x6, _y6];\n    }\n  }\n};\n\nBRp$c.tryToCorrectInvalidPoints = function (edge, pairInfo) {\n  var rs = edge._private.rscratch; // can only correct beziers for now...\n\n  if (rs.edgeType === 'bezier') {\n    var srcPos = pairInfo.srcPos,\n        tgtPos = pairInfo.tgtPos,\n        srcW = pairInfo.srcW,\n        srcH = pairInfo.srcH,\n        tgtW = pairInfo.tgtW,\n        tgtH = pairInfo.tgtH,\n        srcShape = pairInfo.srcShape,\n        tgtShape = pairInfo.tgtShape;\n    var badStart = !number$1(rs.startX) || !number$1(rs.startY);\n    var badAStart = !number$1(rs.arrowStartX) || !number$1(rs.arrowStartY);\n    var badEnd = !number$1(rs.endX) || !number$1(rs.endY);\n    var badAEnd = !number$1(rs.arrowEndX) || !number$1(rs.arrowEndY);\n    var minCpADistFactor = 3;\n    var arrowW = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;\n    var minCpADist = minCpADistFactor * arrowW;\n    var startACpDist = dist({\n      x: rs.ctrlpts[0],\n      y: rs.ctrlpts[1]\n    }, {\n      x: rs.startX,\n      y: rs.startY\n    });\n    var closeStartACp = startACpDist < minCpADist;\n    var endACpDist = dist({\n      x: rs.ctrlpts[0],\n      y: rs.ctrlpts[1]\n    }, {\n      x: rs.endX,\n      y: rs.endY\n    });\n    var closeEndACp = endACpDist < minCpADist;\n    var overlapping = false;\n\n    if (badStart || badAStart || closeStartACp) {\n      overlapping = true; // project control point along line from src centre to outside the src shape\n      // (otherwise intersection will yield nothing)\n\n      var cpD = {\n        // delta\n        x: rs.ctrlpts[0] - srcPos.x,\n        y: rs.ctrlpts[1] - srcPos.y\n      };\n      var cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y); // length of line\n\n      var cpM = {\n        // normalised delta\n        x: cpD.x / cpL,\n        y: cpD.y / cpL\n      };\n      var radius = Math.max(srcW, srcH);\n      var cpProj = {\n        // *2 radius guarantees outside shape\n        x: rs.ctrlpts[0] + cpM.x * 2 * radius,\n        y: rs.ctrlpts[1] + cpM.y * 2 * radius\n      };\n      var srcCtrlPtIntn = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, cpProj.x, cpProj.y, 0);\n\n      if (closeStartACp) {\n        rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);\n        rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);\n      } else {\n        rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;\n        rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;\n      }\n    }\n\n    if (badEnd || badAEnd || closeEndACp) {\n      overlapping = true; // project control point along line from tgt centre to outside the tgt shape\n      // (otherwise intersection will yield nothing)\n\n      var _cpD = {\n        // delta\n        x: rs.ctrlpts[0] - tgtPos.x,\n        y: rs.ctrlpts[1] - tgtPos.y\n      };\n\n      var _cpL = Math.sqrt(_cpD.x * _cpD.x + _cpD.y * _cpD.y); // length of line\n\n\n      var _cpM = {\n        // normalised delta\n        x: _cpD.x / _cpL,\n        y: _cpD.y / _cpL\n      };\n\n      var _radius = Math.max(srcW, srcH);\n\n      var _cpProj = {\n        // *2 radius guarantees outside shape\n        x: rs.ctrlpts[0] + _cpM.x * 2 * _radius,\n        y: rs.ctrlpts[1] + _cpM.y * 2 * _radius\n      };\n      var tgtCtrlPtIntn = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, _cpProj.x, _cpProj.y, 0);\n\n      if (closeEndACp) {\n        rs.ctrlpts[0] = rs.ctrlpts[0] + _cpM.x * (minCpADist - endACpDist);\n        rs.ctrlpts[1] = rs.ctrlpts[1] + _cpM.y * (minCpADist - endACpDist);\n      } else {\n        rs.ctrlpts[0] = tgtCtrlPtIntn[0] + _cpM.x * minCpADist;\n        rs.ctrlpts[1] = tgtCtrlPtIntn[1] + _cpM.y * minCpADist;\n      }\n    }\n\n    if (overlapping) {\n      // recalc endpts\n      this.findEndpoints(edge);\n    }\n  }\n};\n\nBRp$c.storeAllpts = function (edge) {\n  var rs = edge._private.rscratch;\n\n  if (rs.edgeType === 'multibezier' || rs.edgeType === 'bezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {\n    rs.allpts = [];\n    rs.allpts.push(rs.startX, rs.startY);\n\n    for (var b = 0; b + 1 < rs.ctrlpts.length; b += 2) {\n      // ctrl pt itself\n      rs.allpts.push(rs.ctrlpts[b], rs.ctrlpts[b + 1]); // the midpt between ctrlpts as intermediate destination pts\n\n      if (b + 3 < rs.ctrlpts.length) {\n        rs.allpts.push((rs.ctrlpts[b] + rs.ctrlpts[b + 2]) / 2, (rs.ctrlpts[b + 1] + rs.ctrlpts[b + 3]) / 2);\n      }\n    }\n\n    rs.allpts.push(rs.endX, rs.endY);\n    var m, mt;\n\n    if (rs.ctrlpts.length / 2 % 2 === 0) {\n      m = rs.allpts.length / 2 - 1;\n      rs.midX = rs.allpts[m];\n      rs.midY = rs.allpts[m + 1];\n    } else {\n      m = rs.allpts.length / 2 - 3;\n      mt = 0.5;\n      rs.midX = qbezierAt(rs.allpts[m], rs.allpts[m + 2], rs.allpts[m + 4], mt);\n      rs.midY = qbezierAt(rs.allpts[m + 1], rs.allpts[m + 3], rs.allpts[m + 5], mt);\n    }\n  } else if (rs.edgeType === 'straight') {\n    // need to calc these after endpts\n    rs.allpts = [rs.startX, rs.startY, rs.endX, rs.endY]; // default midpt for labels etc\n\n    rs.midX = (rs.startX + rs.endX + rs.arrowStartX + rs.arrowEndX) / 4;\n    rs.midY = (rs.startY + rs.endY + rs.arrowStartY + rs.arrowEndY) / 4;\n  } else if (rs.edgeType === 'segments') {\n    rs.allpts = [];\n    rs.allpts.push(rs.startX, rs.startY);\n    rs.allpts.push.apply(rs.allpts, rs.segpts);\n    rs.allpts.push(rs.endX, rs.endY);\n\n    if (rs.segpts.length % 4 === 0) {\n      var i2 = rs.segpts.length / 2;\n      var i1 = i2 - 2;\n      rs.midX = (rs.segpts[i1] + rs.segpts[i2]) / 2;\n      rs.midY = (rs.segpts[i1 + 1] + rs.segpts[i2 + 1]) / 2;\n    } else {\n      var _i = rs.segpts.length / 2 - 1;\n\n      rs.midX = rs.segpts[_i];\n      rs.midY = rs.segpts[_i + 1];\n    }\n  }\n};\n\nBRp$c.checkForInvalidEdgeWarning = function (edge) {\n  var rs = edge[0]._private.rscratch;\n\n  if (rs.nodesOverlap || number$1(rs.startX) && number$1(rs.startY) && number$1(rs.endX) && number$1(rs.endY)) {\n    rs.loggedErr = false;\n  } else {\n    if (!rs.loggedErr) {\n      rs.loggedErr = true;\n      warn('Edge `' + edge.id() + '` has invalid endpoints and so it is impossible to draw.  Adjust your edge style (e.g. control points) accordingly or use an alternative edge type.  This is expected behaviour when the source node and the target node overlap.');\n    }\n  }\n};\n\nBRp$c.findEdgeControlPoints = function (edges) {\n  var _this = this;\n\n  if (!edges || edges.length === 0) {\n    return;\n  }\n\n  var r = this;\n  var cy = r.cy;\n  var hasCompounds = cy.hasCompoundNodes();\n  var hashTable = {\n    map: new Map$1(),\n    get: function get(pairId) {\n      var map2 = this.map.get(pairId[0]);\n\n      if (map2 != null) {\n        return map2.get(pairId[1]);\n      } else {\n        return null;\n      }\n    },\n    set: function set(pairId, val) {\n      var map2 = this.map.get(pairId[0]);\n\n      if (map2 == null) {\n        map2 = new Map$1();\n        this.map.set(pairId[0], map2);\n      }\n\n      map2.set(pairId[1], val);\n    }\n  };\n  var pairIds = [];\n  var haystackEdges = []; // create a table of edge (src, tgt) => list of edges between them\n\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n    var _p = edge._private;\n    var curveStyle = edge.pstyle('curve-style').value; // ignore edges who are not to be displayed\n    // they shouldn't take up space\n\n    if (edge.removed() || !edge.takesUpSpace()) {\n      continue;\n    }\n\n    if (curveStyle === 'haystack') {\n      haystackEdges.push(edge);\n      continue;\n    }\n\n    var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments' || curveStyle === 'straight' || curveStyle === 'straight-triangle' || curveStyle === 'taxi';\n    var edgeIsBezier = curveStyle === 'unbundled-bezier' || curveStyle === 'bezier';\n    var src = _p.source;\n    var tgt = _p.target;\n    var srcIndex = src.poolIndex();\n    var tgtIndex = tgt.poolIndex();\n    var pairId = [srcIndex, tgtIndex].sort();\n    var tableEntry = hashTable.get(pairId);\n\n    if (tableEntry == null) {\n      tableEntry = {\n        eles: []\n      };\n      hashTable.set(pairId, tableEntry);\n      pairIds.push(pairId);\n    }\n\n    tableEntry.eles.push(edge);\n\n    if (edgeIsUnbundled) {\n      tableEntry.hasUnbundled = true;\n    }\n\n    if (edgeIsBezier) {\n      tableEntry.hasBezier = true;\n    }\n  } // for each pair (src, tgt), create the ctrl pts\n  // Nested for loop is OK; total number of iterations for both loops = edgeCount\n\n\n  var _loop = function _loop(p) {\n    var pairId = pairIds[p];\n    var pairInfo = hashTable.get(pairId);\n    var swappedpairInfo = void 0;\n\n    if (!pairInfo.hasUnbundled) {\n      var pllEdges = pairInfo.eles[0].parallelEdges().filter(function (e) {\n        return e.isBundledBezier();\n      });\n      clearArray(pairInfo.eles);\n      pllEdges.forEach(function (edge) {\n        return pairInfo.eles.push(edge);\n      }); // for each pair id, the edges should be sorted by index\n\n      pairInfo.eles.sort(function (edge1, edge2) {\n        return edge1.poolIndex() - edge2.poolIndex();\n      });\n    }\n\n    var firstEdge = pairInfo.eles[0];\n    var src = firstEdge.source();\n    var tgt = firstEdge.target(); // make sure src/tgt distinction is consistent w.r.t. pairId\n\n    if (src.poolIndex() > tgt.poolIndex()) {\n      var temp = src;\n      src = tgt;\n      tgt = temp;\n    }\n\n    var srcPos = pairInfo.srcPos = src.position();\n    var tgtPos = pairInfo.tgtPos = tgt.position();\n    var srcW = pairInfo.srcW = src.outerWidth();\n    var srcH = pairInfo.srcH = src.outerHeight();\n    var tgtW = pairInfo.tgtW = tgt.outerWidth();\n    var tgtH = pairInfo.tgtH = tgt.outerHeight();\n\n    var srcShape = pairInfo.srcShape = r.nodeShapes[_this.getNodeShape(src)];\n\n    var tgtShape = pairInfo.tgtShape = r.nodeShapes[_this.getNodeShape(tgt)];\n\n    pairInfo.dirCounts = {\n      'north': 0,\n      'west': 0,\n      'south': 0,\n      'east': 0,\n      'northwest': 0,\n      'southwest': 0,\n      'northeast': 0,\n      'southeast': 0\n    };\n\n    for (var _i2 = 0; _i2 < pairInfo.eles.length; _i2++) {\n      var _edge = pairInfo.eles[_i2];\n      var rs = _edge[0]._private.rscratch;\n\n      var _curveStyle = _edge.pstyle('curve-style').value;\n\n      var _edgeIsUnbundled = _curveStyle === 'unbundled-bezier' || _curveStyle === 'segments' || _curveStyle === 'taxi'; // whether the normalised pair order is the reverse of the edge's src-tgt order\n\n\n      var edgeIsSwapped = !src.same(_edge.source());\n\n      if (!pairInfo.calculatedIntersection && src !== tgt && (pairInfo.hasBezier || pairInfo.hasUnbundled)) {\n        pairInfo.calculatedIntersection = true; // pt outside src shape to calc distance/displacement from src to tgt\n\n        var srcOutside = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, tgtPos.x, tgtPos.y, 0);\n        var srcIntn = pairInfo.srcIntn = srcOutside; // pt outside tgt shape to calc distance/displacement from src to tgt\n\n        var tgtOutside = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, srcPos.x, srcPos.y, 0);\n        var tgtIntn = pairInfo.tgtIntn = tgtOutside;\n        var intersectionPts = pairInfo.intersectionPts = {\n          x1: srcOutside[0],\n          x2: tgtOutside[0],\n          y1: srcOutside[1],\n          y2: tgtOutside[1]\n        };\n        var posPts = pairInfo.posPts = {\n          x1: srcPos.x,\n          x2: tgtPos.x,\n          y1: srcPos.y,\n          y2: tgtPos.y\n        };\n        var dy = tgtOutside[1] - srcOutside[1];\n        var dx = tgtOutside[0] - srcOutside[0];\n        var l = Math.sqrt(dx * dx + dy * dy);\n        var vector = pairInfo.vector = {\n          x: dx,\n          y: dy\n        };\n        var vectorNorm = pairInfo.vectorNorm = {\n          x: vector.x / l,\n          y: vector.y / l\n        };\n        var vectorNormInverse = {\n          x: -vectorNorm.y,\n          y: vectorNorm.x\n        }; // if node shapes overlap, then no ctrl pts to draw\n\n        pairInfo.nodesOverlap = !number$1(l) || tgtShape.checkPoint(srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y) || srcShape.checkPoint(tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y);\n        pairInfo.vectorNormInverse = vectorNormInverse;\n        swappedpairInfo = {\n          nodesOverlap: pairInfo.nodesOverlap,\n          dirCounts: pairInfo.dirCounts,\n          calculatedIntersection: true,\n          hasBezier: pairInfo.hasBezier,\n          hasUnbundled: pairInfo.hasUnbundled,\n          eles: pairInfo.eles,\n          srcPos: tgtPos,\n          tgtPos: srcPos,\n          srcW: tgtW,\n          srcH: tgtH,\n          tgtW: srcW,\n          tgtH: srcH,\n          srcIntn: tgtIntn,\n          tgtIntn: srcIntn,\n          srcShape: tgtShape,\n          tgtShape: srcShape,\n          posPts: {\n            x1: posPts.x2,\n            y1: posPts.y2,\n            x2: posPts.x1,\n            y2: posPts.y1\n          },\n          intersectionPts: {\n            x1: intersectionPts.x2,\n            y1: intersectionPts.y2,\n            x2: intersectionPts.x1,\n            y2: intersectionPts.y1\n          },\n          vector: {\n            x: -vector.x,\n            y: -vector.y\n          },\n          vectorNorm: {\n            x: -vectorNorm.x,\n            y: -vectorNorm.y\n          },\n          vectorNormInverse: {\n            x: -vectorNormInverse.x,\n            y: -vectorNormInverse.y\n          }\n        };\n      }\n\n      var passedPairInfo = edgeIsSwapped ? swappedpairInfo : pairInfo;\n      rs.nodesOverlap = passedPairInfo.nodesOverlap;\n      rs.srcIntn = passedPairInfo.srcIntn;\n      rs.tgtIntn = passedPairInfo.tgtIntn;\n\n      if (hasCompounds && (src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild()) && (src.parents().anySame(tgt) || tgt.parents().anySame(src) || src.same(tgt) && src.isParent())) {\n        _this.findCompoundLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);\n      } else if (src === tgt) {\n        _this.findLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);\n      } else if (_curveStyle === 'segments') {\n        _this.findSegmentsPoints(_edge, passedPairInfo);\n      } else if (_curveStyle === 'taxi') {\n        _this.findTaxiPoints(_edge, passedPairInfo);\n      } else if (_curveStyle === 'straight' || !_edgeIsUnbundled && pairInfo.eles.length % 2 === 1 && _i2 === Math.floor(pairInfo.eles.length / 2)) {\n        _this.findStraightEdgePoints(_edge);\n      } else {\n        _this.findBezierPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled, edgeIsSwapped);\n      }\n\n      _this.findEndpoints(_edge);\n\n      _this.tryToCorrectInvalidPoints(_edge, passedPairInfo);\n\n      _this.checkForInvalidEdgeWarning(_edge);\n\n      _this.storeAllpts(_edge);\n\n      _this.storeEdgeProjections(_edge);\n\n      _this.calculateArrowAngles(_edge);\n\n      _this.recalculateEdgeLabelProjections(_edge);\n\n      _this.calculateLabelAngles(_edge);\n    } // for pair edges\n\n  };\n\n  for (var p = 0; p < pairIds.length; p++) {\n    _loop(p);\n  } // for pair ids\n  // haystacks avoid the expense of pairInfo stuff (intersections etc.)\n\n\n  this.findHaystackPoints(haystackEdges);\n};\n\nfunction getPts(pts) {\n  var retPts = [];\n\n  if (pts == null) {\n    return;\n  }\n\n  for (var i = 0; i < pts.length; i += 2) {\n    var x = pts[i];\n    var y = pts[i + 1];\n    retPts.push({\n      x: x,\n      y: y\n    });\n  }\n\n  return retPts;\n}\n\nBRp$c.getSegmentPoints = function (edge) {\n  var rs = edge[0]._private.rscratch;\n  var type = rs.edgeType;\n\n  if (type === 'segments') {\n    this.recalculateRenderedStyle(edge);\n    return getPts(rs.segpts);\n  }\n};\n\nBRp$c.getControlPoints = function (edge) {\n  var rs = edge[0]._private.rscratch;\n  var type = rs.edgeType;\n\n  if (type === 'bezier' || type === 'multibezier' || type === 'self' || type === 'compound') {\n    this.recalculateRenderedStyle(edge);\n    return getPts(rs.ctrlpts);\n  }\n};\n\nBRp$c.getEdgeMidpoint = function (edge) {\n  var rs = edge[0]._private.rscratch;\n  this.recalculateRenderedStyle(edge);\n  return {\n    x: rs.midX,\n    y: rs.midY\n  };\n};\n\nvar BRp$b = {};\n\nBRp$b.manualEndptToPx = function (node, prop) {\n  var r = this;\n  var npos = node.position();\n  var w = node.outerWidth();\n  var h = node.outerHeight();\n\n  if (prop.value.length === 2) {\n    var p = [prop.pfValue[0], prop.pfValue[1]];\n\n    if (prop.units[0] === '%') {\n      p[0] = p[0] * w;\n    }\n\n    if (prop.units[1] === '%') {\n      p[1] = p[1] * h;\n    }\n\n    p[0] += npos.x;\n    p[1] += npos.y;\n    return p;\n  } else {\n    var angle = prop.pfValue[0];\n    angle = -Math.PI / 2 + angle; // start at 12 o'clock\n\n    var l = 2 * Math.max(w, h);\n    var _p = [npos.x + Math.cos(angle) * l, npos.y + Math.sin(angle) * l];\n    return r.nodeShapes[this.getNodeShape(node)].intersectLine(npos.x, npos.y, w, h, _p[0], _p[1], 0);\n  }\n};\n\nBRp$b.findEndpoints = function (edge) {\n  var r = this;\n  var intersect;\n  var source = edge.source()[0];\n  var target = edge.target()[0];\n  var srcPos = source.position();\n  var tgtPos = target.position();\n  var tgtArShape = edge.pstyle('target-arrow-shape').value;\n  var srcArShape = edge.pstyle('source-arrow-shape').value;\n  var tgtDist = edge.pstyle('target-distance-from-node').pfValue;\n  var srcDist = edge.pstyle('source-distance-from-node').pfValue;\n  var curveStyle = edge.pstyle('curve-style').value;\n  var rs = edge._private.rscratch;\n  var et = rs.edgeType;\n  var taxi = curveStyle === 'taxi';\n  var self = et === 'self' || et === 'compound';\n  var bezier = et === 'bezier' || et === 'multibezier' || self;\n  var multi = et !== 'bezier';\n  var lines = et === 'straight' || et === 'segments';\n  var segments = et === 'segments';\n  var hasEndpts = bezier || multi || lines;\n  var overrideEndpts = self || taxi;\n  var srcManEndpt = edge.pstyle('source-endpoint');\n  var srcManEndptVal = overrideEndpts ? 'outside-to-node' : srcManEndpt.value;\n  var tgtManEndpt = edge.pstyle('target-endpoint');\n  var tgtManEndptVal = overrideEndpts ? 'outside-to-node' : tgtManEndpt.value;\n  rs.srcManEndpt = srcManEndpt;\n  rs.tgtManEndpt = tgtManEndpt;\n  var p1; // last known point of edge on target side\n\n  var p2; // last known point of edge on source side\n\n  var p1_i; // point to intersect with target shape\n\n  var p2_i; // point to intersect with source shape\n\n  if (bezier) {\n    var cpStart = [rs.ctrlpts[0], rs.ctrlpts[1]];\n    var cpEnd = multi ? [rs.ctrlpts[rs.ctrlpts.length - 2], rs.ctrlpts[rs.ctrlpts.length - 1]] : cpStart;\n    p1 = cpEnd;\n    p2 = cpStart;\n  } else if (lines) {\n    var srcArrowFromPt = !segments ? [tgtPos.x, tgtPos.y] : rs.segpts.slice(0, 2);\n    var tgtArrowFromPt = !segments ? [srcPos.x, srcPos.y] : rs.segpts.slice(rs.segpts.length - 2);\n    p1 = tgtArrowFromPt;\n    p2 = srcArrowFromPt;\n  }\n\n  if (tgtManEndptVal === 'inside-to-node') {\n    intersect = [tgtPos.x, tgtPos.y];\n  } else if (tgtManEndpt.units) {\n    intersect = this.manualEndptToPx(target, tgtManEndpt);\n  } else if (tgtManEndptVal === 'outside-to-line') {\n    intersect = rs.tgtIntn; // use cached value from ctrlpt calc\n  } else {\n    if (tgtManEndptVal === 'outside-to-node' || tgtManEndptVal === 'outside-to-node-or-label') {\n      p1_i = p1;\n    } else if (tgtManEndptVal === 'outside-to-line' || tgtManEndptVal === 'outside-to-line-or-label') {\n      p1_i = [srcPos.x, srcPos.y];\n    }\n\n    intersect = r.nodeShapes[this.getNodeShape(target)].intersectLine(tgtPos.x, tgtPos.y, target.outerWidth(), target.outerHeight(), p1_i[0], p1_i[1], 0);\n\n    if (tgtManEndptVal === 'outside-to-node-or-label' || tgtManEndptVal === 'outside-to-line-or-label') {\n      var trs = target._private.rscratch;\n      var lw = trs.labelWidth;\n      var lh = trs.labelHeight;\n      var lx = trs.labelX;\n      var ly = trs.labelY;\n      var lw2 = lw / 2;\n      var lh2 = lh / 2;\n      var va = target.pstyle('text-valign').value;\n\n      if (va === 'top') {\n        ly -= lh2;\n      } else if (va === 'bottom') {\n        ly += lh2;\n      }\n\n      var ha = target.pstyle('text-halign').value;\n\n      if (ha === 'left') {\n        lx -= lw2;\n      } else if (ha === 'right') {\n        lx += lw2;\n      }\n\n      var labelIntersect = polygonIntersectLine(p1_i[0], p1_i[1], [lx - lw2, ly - lh2, lx + lw2, ly - lh2, lx + lw2, ly + lh2, lx - lw2, ly + lh2], tgtPos.x, tgtPos.y);\n\n      if (labelIntersect.length > 0) {\n        var refPt = srcPos;\n        var intSqdist = sqdist(refPt, array2point(intersect));\n        var labIntSqdist = sqdist(refPt, array2point(labelIntersect));\n        var minSqDist = intSqdist;\n\n        if (labIntSqdist < intSqdist) {\n          intersect = labelIntersect;\n          minSqDist = labIntSqdist;\n        }\n\n        if (labelIntersect.length > 2) {\n          var labInt2SqDist = sqdist(refPt, {\n            x: labelIntersect[2],\n            y: labelIntersect[3]\n          });\n\n          if (labInt2SqDist < minSqDist) {\n            intersect = [labelIntersect[2], labelIntersect[3]];\n          }\n        }\n      }\n    }\n  }\n\n  var arrowEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].spacing(edge) + tgtDist);\n  var edgeEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].gap(edge) + tgtDist);\n  rs.endX = edgeEnd[0];\n  rs.endY = edgeEnd[1];\n  rs.arrowEndX = arrowEnd[0];\n  rs.arrowEndY = arrowEnd[1];\n\n  if (srcManEndptVal === 'inside-to-node') {\n    intersect = [srcPos.x, srcPos.y];\n  } else if (srcManEndpt.units) {\n    intersect = this.manualEndptToPx(source, srcManEndpt);\n  } else if (srcManEndptVal === 'outside-to-line') {\n    intersect = rs.srcIntn; // use cached value from ctrlpt calc\n  } else {\n    if (srcManEndptVal === 'outside-to-node' || srcManEndptVal === 'outside-to-node-or-label') {\n      p2_i = p2;\n    } else if (srcManEndptVal === 'outside-to-line' || srcManEndptVal === 'outside-to-line-or-label') {\n      p2_i = [tgtPos.x, tgtPos.y];\n    }\n\n    intersect = r.nodeShapes[this.getNodeShape(source)].intersectLine(srcPos.x, srcPos.y, source.outerWidth(), source.outerHeight(), p2_i[0], p2_i[1], 0);\n\n    if (srcManEndptVal === 'outside-to-node-or-label' || srcManEndptVal === 'outside-to-line-or-label') {\n      var srs = source._private.rscratch;\n      var _lw = srs.labelWidth;\n      var _lh = srs.labelHeight;\n      var _lx = srs.labelX;\n      var _ly = srs.labelY;\n\n      var _lw2 = _lw / 2;\n\n      var _lh2 = _lh / 2;\n\n      var _va = source.pstyle('text-valign').value;\n\n      if (_va === 'top') {\n        _ly -= _lh2;\n      } else if (_va === 'bottom') {\n        _ly += _lh2;\n      }\n\n      var _ha = source.pstyle('text-halign').value;\n\n      if (_ha === 'left') {\n        _lx -= _lw2;\n      } else if (_ha === 'right') {\n        _lx += _lw2;\n      }\n\n      var _labelIntersect = polygonIntersectLine(p2_i[0], p2_i[1], [_lx - _lw2, _ly - _lh2, _lx + _lw2, _ly - _lh2, _lx + _lw2, _ly + _lh2, _lx - _lw2, _ly + _lh2], srcPos.x, srcPos.y);\n\n      if (_labelIntersect.length > 0) {\n        var _refPt = tgtPos;\n\n        var _intSqdist = sqdist(_refPt, array2point(intersect));\n\n        var _labIntSqdist = sqdist(_refPt, array2point(_labelIntersect));\n\n        var _minSqDist = _intSqdist;\n\n        if (_labIntSqdist < _intSqdist) {\n          intersect = [_labelIntersect[0], _labelIntersect[1]];\n          _minSqDist = _labIntSqdist;\n        }\n\n        if (_labelIntersect.length > 2) {\n          var _labInt2SqDist = sqdist(_refPt, {\n            x: _labelIntersect[2],\n            y: _labelIntersect[3]\n          });\n\n          if (_labInt2SqDist < _minSqDist) {\n            intersect = [_labelIntersect[2], _labelIntersect[3]];\n          }\n        }\n      }\n    }\n  }\n\n  var arrowStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].spacing(edge) + srcDist);\n  var edgeStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].gap(edge) + srcDist);\n  rs.startX = edgeStart[0];\n  rs.startY = edgeStart[1];\n  rs.arrowStartX = arrowStart[0];\n  rs.arrowStartY = arrowStart[1];\n\n  if (hasEndpts) {\n    if (!number$1(rs.startX) || !number$1(rs.startY) || !number$1(rs.endX) || !number$1(rs.endY)) {\n      rs.badLine = true;\n    } else {\n      rs.badLine = false;\n    }\n  }\n};\n\nBRp$b.getSourceEndpoint = function (edge) {\n  var rs = edge[0]._private.rscratch;\n  this.recalculateRenderedStyle(edge);\n\n  switch (rs.edgeType) {\n    case 'haystack':\n      return {\n        x: rs.haystackPts[0],\n        y: rs.haystackPts[1]\n      };\n\n    default:\n      return {\n        x: rs.arrowStartX,\n        y: rs.arrowStartY\n      };\n  }\n};\n\nBRp$b.getTargetEndpoint = function (edge) {\n  var rs = edge[0]._private.rscratch;\n  this.recalculateRenderedStyle(edge);\n\n  switch (rs.edgeType) {\n    case 'haystack':\n      return {\n        x: rs.haystackPts[2],\n        y: rs.haystackPts[3]\n      };\n\n    default:\n      return {\n        x: rs.arrowEndX,\n        y: rs.arrowEndY\n      };\n  }\n};\n\nvar BRp$a = {};\n\nfunction pushBezierPts(r, edge, pts) {\n  var qbezierAt$1 = function qbezierAt$1(p1, p2, p3, t) {\n    return qbezierAt(p1, p2, p3, t);\n  };\n\n  var _p = edge._private;\n  var bpts = _p.rstyle.bezierPts;\n\n  for (var i = 0; i < r.bezierProjPcts.length; i++) {\n    var p = r.bezierProjPcts[i];\n    bpts.push({\n      x: qbezierAt$1(pts[0], pts[2], pts[4], p),\n      y: qbezierAt$1(pts[1], pts[3], pts[5], p)\n    });\n  }\n}\n\nBRp$a.storeEdgeProjections = function (edge) {\n  var _p = edge._private;\n  var rs = _p.rscratch;\n  var et = rs.edgeType; // clear the cached points state\n\n  _p.rstyle.bezierPts = null;\n  _p.rstyle.linePts = null;\n  _p.rstyle.haystackPts = null;\n\n  if (et === 'multibezier' || et === 'bezier' || et === 'self' || et === 'compound') {\n    _p.rstyle.bezierPts = [];\n\n    for (var i = 0; i + 5 < rs.allpts.length; i += 4) {\n      pushBezierPts(this, edge, rs.allpts.slice(i, i + 6));\n    }\n  } else if (et === 'segments') {\n    var lpts = _p.rstyle.linePts = [];\n\n    for (var i = 0; i + 1 < rs.allpts.length; i += 2) {\n      lpts.push({\n        x: rs.allpts[i],\n        y: rs.allpts[i + 1]\n      });\n    }\n  } else if (et === 'haystack') {\n    var hpts = rs.haystackPts;\n    _p.rstyle.haystackPts = [{\n      x: hpts[0],\n      y: hpts[1]\n    }, {\n      x: hpts[2],\n      y: hpts[3]\n    }];\n  }\n\n  _p.rstyle.arrowWidth = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;\n};\n\nBRp$a.recalculateEdgeProjections = function (edges) {\n  this.findEdgeControlPoints(edges);\n};\n\n/* global document */\n\nvar BRp$9 = {};\n\nBRp$9.recalculateNodeLabelProjection = function (node) {\n  var content = node.pstyle('label').strValue;\n\n  if (emptyString(content)) {\n    return;\n  }\n\n  var textX, textY;\n  var _p = node._private;\n  var nodeWidth = node.width();\n  var nodeHeight = node.height();\n  var padding = node.padding();\n  var nodePos = node.position();\n  var textHalign = node.pstyle('text-halign').strValue;\n  var textValign = node.pstyle('text-valign').strValue;\n  var rs = _p.rscratch;\n  var rstyle = _p.rstyle;\n\n  switch (textHalign) {\n    case 'left':\n      textX = nodePos.x - nodeWidth / 2 - padding;\n      break;\n\n    case 'right':\n      textX = nodePos.x + nodeWidth / 2 + padding;\n      break;\n\n    default:\n      // e.g. center\n      textX = nodePos.x;\n  }\n\n  switch (textValign) {\n    case 'top':\n      textY = nodePos.y - nodeHeight / 2 - padding;\n      break;\n\n    case 'bottom':\n      textY = nodePos.y + nodeHeight / 2 + padding;\n      break;\n\n    default:\n      // e.g. middle\n      textY = nodePos.y;\n  }\n\n  rs.labelX = textX;\n  rs.labelY = textY;\n  rstyle.labelX = textX;\n  rstyle.labelY = textY;\n  this.calculateLabelAngles(node);\n  this.applyLabelDimensions(node);\n};\n\nvar lineAngleFromDelta = function lineAngleFromDelta(dx, dy) {\n  var angle = Math.atan(dy / dx);\n\n  if (dx === 0 && angle < 0) {\n    angle = angle * -1;\n  }\n\n  return angle;\n};\n\nvar lineAngle = function lineAngle(p0, p1) {\n  var dx = p1.x - p0.x;\n  var dy = p1.y - p0.y;\n  return lineAngleFromDelta(dx, dy);\n};\n\nvar bezierAngle = function bezierAngle(p0, p1, p2, t) {\n  var t0 = bound(0, t - 0.001, 1);\n  var t1 = bound(0, t + 0.001, 1);\n  var lp0 = qbezierPtAt(p0, p1, p2, t0);\n  var lp1 = qbezierPtAt(p0, p1, p2, t1);\n  return lineAngle(lp0, lp1);\n};\n\nBRp$9.recalculateEdgeLabelProjections = function (edge) {\n  var p;\n  var _p = edge._private;\n  var rs = _p.rscratch;\n  var r = this;\n  var content = {\n    mid: edge.pstyle('label').strValue,\n    source: edge.pstyle('source-label').strValue,\n    target: edge.pstyle('target-label').strValue\n  };\n\n  if (content.mid || content.source || content.target) ; else {\n    return; // no labels => no calcs\n  } // add center point to style so bounding box calculations can use it\n  //\n\n\n  p = {\n    x: rs.midX,\n    y: rs.midY\n  };\n\n  var setRs = function setRs(propName, prefix, value) {\n    setPrefixedProperty(_p.rscratch, propName, prefix, value);\n    setPrefixedProperty(_p.rstyle, propName, prefix, value);\n  };\n\n  setRs('labelX', null, p.x);\n  setRs('labelY', null, p.y);\n  var midAngle = lineAngleFromDelta(rs.midDispX, rs.midDispY);\n  setRs('labelAutoAngle', null, midAngle);\n\n  var createControlPointInfo = function createControlPointInfo() {\n    if (createControlPointInfo.cache) {\n      return createControlPointInfo.cache;\n    } // use cache so only 1x per edge\n\n\n    var ctrlpts = []; // store each ctrlpt info init\n\n    for (var i = 0; i + 5 < rs.allpts.length; i += 4) {\n      var p0 = {\n        x: rs.allpts[i],\n        y: rs.allpts[i + 1]\n      };\n      var p1 = {\n        x: rs.allpts[i + 2],\n        y: rs.allpts[i + 3]\n      }; // ctrlpt\n\n      var p2 = {\n        x: rs.allpts[i + 4],\n        y: rs.allpts[i + 5]\n      };\n      ctrlpts.push({\n        p0: p0,\n        p1: p1,\n        p2: p2,\n        startDist: 0,\n        length: 0,\n        segments: []\n      });\n    }\n\n    var bpts = _p.rstyle.bezierPts;\n    var nProjs = r.bezierProjPcts.length;\n\n    function addSegment(cp, p0, p1, t0, t1) {\n      var length = dist(p0, p1);\n      var prevSegment = cp.segments[cp.segments.length - 1];\n      var segment = {\n        p0: p0,\n        p1: p1,\n        t0: t0,\n        t1: t1,\n        startDist: prevSegment ? prevSegment.startDist + prevSegment.length : 0,\n        length: length\n      };\n      cp.segments.push(segment);\n      cp.length += length;\n    } // update each ctrlpt with segment info\n\n\n    for (var _i = 0; _i < ctrlpts.length; _i++) {\n      var cp = ctrlpts[_i];\n      var prevCp = ctrlpts[_i - 1];\n\n      if (prevCp) {\n        cp.startDist = prevCp.startDist + prevCp.length;\n      }\n\n      addSegment(cp, cp.p0, bpts[_i * nProjs], 0, r.bezierProjPcts[0]); // first\n\n      for (var j = 0; j < nProjs - 1; j++) {\n        addSegment(cp, bpts[_i * nProjs + j], bpts[_i * nProjs + j + 1], r.bezierProjPcts[j], r.bezierProjPcts[j + 1]);\n      }\n\n      addSegment(cp, bpts[_i * nProjs + nProjs - 1], cp.p2, r.bezierProjPcts[nProjs - 1], 1); // last\n    }\n\n    return createControlPointInfo.cache = ctrlpts;\n  };\n\n  var calculateEndProjection = function calculateEndProjection(prefix) {\n    var angle;\n    var isSrc = prefix === 'source';\n\n    if (!content[prefix]) {\n      return;\n    }\n\n    var offset = edge.pstyle(prefix + '-text-offset').pfValue;\n\n    switch (rs.edgeType) {\n      case 'self':\n      case 'compound':\n      case 'bezier':\n      case 'multibezier':\n        {\n          var cps = createControlPointInfo();\n          var selected;\n          var startDist = 0;\n          var totalDist = 0; // find the segment we're on\n\n          for (var i = 0; i < cps.length; i++) {\n            var _cp = cps[isSrc ? i : cps.length - 1 - i];\n\n            for (var j = 0; j < _cp.segments.length; j++) {\n              var _seg = _cp.segments[isSrc ? j : _cp.segments.length - 1 - j];\n              var lastSeg = i === cps.length - 1 && j === _cp.segments.length - 1;\n              startDist = totalDist;\n              totalDist += _seg.length;\n\n              if (totalDist >= offset || lastSeg) {\n                selected = {\n                  cp: _cp,\n                  segment: _seg\n                };\n                break;\n              }\n            }\n\n            if (selected) {\n              break;\n            }\n          }\n\n          var cp = selected.cp;\n          var seg = selected.segment;\n          var tSegment = (offset - startDist) / seg.length;\n          var segDt = seg.t1 - seg.t0;\n          var t = isSrc ? seg.t0 + segDt * tSegment : seg.t1 - segDt * tSegment;\n          t = bound(0, t, 1);\n          p = qbezierPtAt(cp.p0, cp.p1, cp.p2, t);\n          angle = bezierAngle(cp.p0, cp.p1, cp.p2, t);\n          break;\n        }\n\n      case 'straight':\n      case 'segments':\n      case 'haystack':\n        {\n          var d = 0,\n              di,\n              d0;\n          var p0, p1;\n          var l = rs.allpts.length;\n\n          for (var _i2 = 0; _i2 + 3 < l; _i2 += 2) {\n            if (isSrc) {\n              p0 = {\n                x: rs.allpts[_i2],\n                y: rs.allpts[_i2 + 1]\n              };\n              p1 = {\n                x: rs.allpts[_i2 + 2],\n                y: rs.allpts[_i2 + 3]\n              };\n            } else {\n              p0 = {\n                x: rs.allpts[l - 2 - _i2],\n                y: rs.allpts[l - 1 - _i2]\n              };\n              p1 = {\n                x: rs.allpts[l - 4 - _i2],\n                y: rs.allpts[l - 3 - _i2]\n              };\n            }\n\n            di = dist(p0, p1);\n            d0 = d;\n            d += di;\n\n            if (d >= offset) {\n              break;\n            }\n          }\n\n          var pD = offset - d0;\n\n          var _t = pD / di;\n\n          _t = bound(0, _t, 1);\n          p = lineAt(p0, p1, _t);\n          angle = lineAngle(p0, p1);\n          break;\n        }\n    }\n\n    setRs('labelX', prefix, p.x);\n    setRs('labelY', prefix, p.y);\n    setRs('labelAutoAngle', prefix, angle);\n  };\n\n  calculateEndProjection('source');\n  calculateEndProjection('target');\n  this.applyLabelDimensions(edge);\n};\n\nBRp$9.applyLabelDimensions = function (ele) {\n  this.applyPrefixedLabelDimensions(ele);\n\n  if (ele.isEdge()) {\n    this.applyPrefixedLabelDimensions(ele, 'source');\n    this.applyPrefixedLabelDimensions(ele, 'target');\n  }\n};\n\nBRp$9.applyPrefixedLabelDimensions = function (ele, prefix) {\n  var _p = ele._private;\n  var text = this.getLabelText(ele, prefix);\n  var labelDims = this.calculateLabelDimensions(ele, text);\n  var lineHeight = ele.pstyle('line-height').pfValue;\n  var textWrap = ele.pstyle('text-wrap').strValue;\n  var lines = getPrefixedProperty(_p.rscratch, 'labelWrapCachedLines', prefix) || [];\n  var numLines = textWrap !== 'wrap' ? 1 : Math.max(lines.length, 1);\n  var normPerLineHeight = labelDims.height / numLines;\n  var labelLineHeight = normPerLineHeight * lineHeight;\n  var width = labelDims.width;\n  var height = labelDims.height + (numLines - 1) * (lineHeight - 1) * normPerLineHeight;\n  setPrefixedProperty(_p.rstyle, 'labelWidth', prefix, width);\n  setPrefixedProperty(_p.rscratch, 'labelWidth', prefix, width);\n  setPrefixedProperty(_p.rstyle, 'labelHeight', prefix, height);\n  setPrefixedProperty(_p.rscratch, 'labelHeight', prefix, height);\n  setPrefixedProperty(_p.rscratch, 'labelLineHeight', prefix, labelLineHeight);\n};\n\nBRp$9.getLabelText = function (ele, prefix) {\n  var _p = ele._private;\n  var pfd = prefix ? prefix + '-' : '';\n  var text = ele.pstyle(pfd + 'label').strValue;\n  var textTransform = ele.pstyle('text-transform').value;\n\n  var rscratch = function rscratch(propName, value) {\n    if (value) {\n      setPrefixedProperty(_p.rscratch, propName, prefix, value);\n      return value;\n    } else {\n      return getPrefixedProperty(_p.rscratch, propName, prefix);\n    }\n  }; // for empty text, skip all processing\n\n\n  if (!text) {\n    return '';\n  }\n\n  if (textTransform == 'none') ; else if (textTransform == 'uppercase') {\n    text = text.toUpperCase();\n  } else if (textTransform == 'lowercase') {\n    text = text.toLowerCase();\n  }\n\n  var wrapStyle = ele.pstyle('text-wrap').value;\n\n  if (wrapStyle === 'wrap') {\n    var labelKey = rscratch('labelKey'); // save recalc if the label is the same as before\n\n    if (labelKey != null && rscratch('labelWrapKey') === labelKey) {\n      return rscratch('labelWrapCachedText');\n    }\n\n    var zwsp = \"\\u200B\";\n    var lines = text.split('\\n');\n    var maxW = ele.pstyle('text-max-width').pfValue;\n    var overflow = ele.pstyle('text-overflow-wrap').value;\n    var overflowAny = overflow === 'anywhere';\n    var wrappedLines = [];\n    var wordsRegex = /[\\s\\u200b]+/;\n    var wordSeparator = overflowAny ? '' : ' ';\n\n    for (var l = 0; l < lines.length; l++) {\n      var line = lines[l];\n      var lineDims = this.calculateLabelDimensions(ele, line);\n      var lineW = lineDims.width;\n\n      if (overflowAny) {\n        var processedLine = line.split('').join(zwsp);\n        line = processedLine;\n      }\n\n      if (lineW > maxW) {\n        // line is too long\n        var words = line.split(wordsRegex);\n        var subline = '';\n\n        for (var w = 0; w < words.length; w++) {\n          var word = words[w];\n          var testLine = subline.length === 0 ? word : subline + wordSeparator + word;\n          var testDims = this.calculateLabelDimensions(ele, testLine);\n          var testW = testDims.width;\n\n          if (testW <= maxW) {\n            // word fits on current line\n            subline += word + wordSeparator;\n          } else {\n            // word starts new line\n            if (subline) {\n              wrappedLines.push(subline);\n            }\n\n            subline = word + wordSeparator;\n          }\n        } // if there's remaining text, put it in a wrapped line\n\n\n        if (!subline.match(/^[\\s\\u200b]+$/)) {\n          wrappedLines.push(subline);\n        }\n      } else {\n        // line is already short enough\n        wrappedLines.push(line);\n      }\n    } // for\n\n\n    rscratch('labelWrapCachedLines', wrappedLines);\n    text = rscratch('labelWrapCachedText', wrappedLines.join('\\n'));\n    rscratch('labelWrapKey', labelKey);\n  } else if (wrapStyle === 'ellipsis') {\n    var _maxW = ele.pstyle('text-max-width').pfValue;\n    var ellipsized = '';\n    var ellipsis = \"\\u2026\";\n    var incLastCh = false;\n\n    if (this.calculateLabelDimensions(ele, text).width < _maxW) {\n      // the label already fits\n      return text;\n    }\n\n    for (var i = 0; i < text.length; i++) {\n      var widthWithNextCh = this.calculateLabelDimensions(ele, ellipsized + text[i] + ellipsis).width;\n\n      if (widthWithNextCh > _maxW) {\n        break;\n      }\n\n      ellipsized += text[i];\n\n      if (i === text.length - 1) {\n        incLastCh = true;\n      }\n    }\n\n    if (!incLastCh) {\n      ellipsized += ellipsis;\n    }\n\n    return ellipsized;\n  } // if ellipsize\n\n\n  return text;\n};\n\nBRp$9.getLabelJustification = function (ele) {\n  var justification = ele.pstyle('text-justification').strValue;\n  var textHalign = ele.pstyle('text-halign').strValue;\n\n  if (justification === 'auto') {\n    if (ele.isNode()) {\n      switch (textHalign) {\n        case 'left':\n          return 'right';\n\n        case 'right':\n          return 'left';\n\n        default:\n          return 'center';\n      }\n    } else {\n      return 'center';\n    }\n  } else {\n    return justification;\n  }\n};\n\nBRp$9.calculateLabelDimensions = function (ele, text) {\n  var r = this;\n  var cacheKey = hashString(text, ele._private.labelDimsKey);\n  var cache = r.labelDimCache || (r.labelDimCache = []);\n  var existingVal = cache[cacheKey];\n\n  if (existingVal != null) {\n    return existingVal;\n  }\n\n  var padding = 0; // add padding around text dims, as the measurement isn't that accurate\n\n  var fStyle = ele.pstyle('font-style').strValue;\n  var size = ele.pstyle('font-size').pfValue;\n  var family = ele.pstyle('font-family').strValue;\n  var weight = ele.pstyle('font-weight').strValue;\n  var canvas = this.labelCalcCanvas;\n  var c2d = this.labelCalcCanvasContext;\n\n  if (!canvas) {\n    canvas = this.labelCalcCanvas = document.createElement('canvas');\n    c2d = this.labelCalcCanvasContext = canvas.getContext('2d');\n    var ds = canvas.style;\n    ds.position = 'absolute';\n    ds.left = '-9999px';\n    ds.top = '-9999px';\n    ds.zIndex = '-1';\n    ds.visibility = 'hidden';\n    ds.pointerEvents = 'none';\n  }\n\n  c2d.font = \"\".concat(fStyle, \" \").concat(weight, \" \").concat(size, \"px \").concat(family);\n  var width = 0;\n  var height = 0;\n  var lines = text.split('\\n');\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    var metrics = c2d.measureText(line);\n    var w = Math.ceil(metrics.width);\n    var h = size;\n    width = Math.max(w, width);\n    height += h;\n  }\n\n  width += padding;\n  height += padding;\n  return cache[cacheKey] = {\n    width: width,\n    height: height\n  };\n};\n\nBRp$9.calculateLabelAngle = function (ele, prefix) {\n  var _p = ele._private;\n  var rs = _p.rscratch;\n  var isEdge = ele.isEdge();\n  var prefixDash = prefix ? prefix + '-' : '';\n  var rot = ele.pstyle(prefixDash + 'text-rotation');\n  var rotStr = rot.strValue;\n\n  if (rotStr === 'none') {\n    return 0;\n  } else if (isEdge && rotStr === 'autorotate') {\n    return rs.labelAutoAngle;\n  } else if (rotStr === 'autorotate') {\n    return 0;\n  } else {\n    return rot.pfValue;\n  }\n};\n\nBRp$9.calculateLabelAngles = function (ele) {\n  var r = this;\n  var isEdge = ele.isEdge();\n  var _p = ele._private;\n  var rs = _p.rscratch;\n  rs.labelAngle = r.calculateLabelAngle(ele);\n\n  if (isEdge) {\n    rs.sourceLabelAngle = r.calculateLabelAngle(ele, 'source');\n    rs.targetLabelAngle = r.calculateLabelAngle(ele, 'target');\n  }\n};\n\nvar BRp$8 = {};\nvar TOO_SMALL_CUT_RECT = 28;\nvar warnedCutRect = false;\n\nBRp$8.getNodeShape = function (node) {\n  var r = this;\n  var shape = node.pstyle('shape').value;\n\n  if (shape === 'cutrectangle' && (node.width() < TOO_SMALL_CUT_RECT || node.height() < TOO_SMALL_CUT_RECT)) {\n    if (!warnedCutRect) {\n      warn('The `cutrectangle` node shape can not be used at small sizes so `rectangle` is used instead');\n      warnedCutRect = true;\n    }\n\n    return 'rectangle';\n  }\n\n  if (node.isParent()) {\n    if (shape === 'rectangle' || shape === 'roundrectangle' || shape === 'round-rectangle' || shape === 'cutrectangle' || shape === 'cut-rectangle' || shape === 'barrel') {\n      return shape;\n    } else {\n      return 'rectangle';\n    }\n  }\n\n  if (shape === 'polygon') {\n    var points = node.pstyle('shape-polygon-points').value;\n    return r.nodeShapes.makePolygon(points).name;\n  }\n\n  return shape;\n};\n\nvar BRp$7 = {};\n\nBRp$7.registerCalculationListeners = function () {\n  var cy = this.cy;\n  var elesToUpdate = cy.collection();\n  var r = this;\n\n  var enqueue = function enqueue(eles) {\n    var dirtyStyleCaches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    elesToUpdate.merge(eles);\n\n    if (dirtyStyleCaches) {\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        var _p = ele._private;\n        var rstyle = _p.rstyle;\n        rstyle.clean = false;\n        rstyle.cleanConnected = false;\n      }\n    }\n  };\n\n  r.binder(cy).on('bounds.* dirty.*', function onDirtyBounds(e) {\n    var ele = e.target;\n    enqueue(ele);\n  }).on('style.* background.*', function onDirtyStyle(e) {\n    var ele = e.target;\n    enqueue(ele, false);\n  });\n\n  var updateEleCalcs = function updateEleCalcs(willDraw) {\n    if (willDraw) {\n      var fns = r.onUpdateEleCalcsFns; // because we need to have up-to-date style (e.g. stylesheet mappers)\n      // before calculating rendered style (and pstyle might not be called yet)\n\n      elesToUpdate.cleanStyle();\n\n      for (var i = 0; i < elesToUpdate.length; i++) {\n        var ele = elesToUpdate[i];\n        var rstyle = ele._private.rstyle;\n\n        if (ele.isNode() && !rstyle.cleanConnected) {\n          enqueue(ele.connectedEdges());\n          rstyle.cleanConnected = true;\n        }\n      }\n\n      if (fns) {\n        for (var _i = 0; _i < fns.length; _i++) {\n          var fn = fns[_i];\n          fn(willDraw, elesToUpdate);\n        }\n      }\n\n      r.recalculateRenderedStyle(elesToUpdate);\n      elesToUpdate = cy.collection();\n    }\n  };\n\n  r.flushRenderedStyleQueue = function () {\n    updateEleCalcs(true);\n  };\n\n  r.beforeRender(updateEleCalcs, r.beforeRenderPriorities.eleCalcs);\n};\n\nBRp$7.onUpdateEleCalcs = function (fn) {\n  var fns = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];\n  fns.push(fn);\n};\n\nBRp$7.recalculateRenderedStyle = function (eles, useCache) {\n  var isCleanConnected = function isCleanConnected(ele) {\n    return ele._private.rstyle.cleanConnected;\n  };\n\n  var edges = [];\n  var nodes = []; // the renderer can't be used for calcs when destroyed, e.g. ele.boundingBox()\n\n  if (this.destroyed) {\n    return;\n  } // use cache by default for perf\n\n\n  if (useCache === undefined) {\n    useCache = true;\n  }\n\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n    var _p = ele._private;\n    var rstyle = _p.rstyle; // an edge may be implicitly dirty b/c of one of its connected nodes\n    // (and a request for recalc may come in between frames)\n\n    if (ele.isEdge() && (!isCleanConnected(ele.source()) || !isCleanConnected(ele.target()))) {\n      rstyle.clean = false;\n    } // only update if dirty and in graph\n\n\n    if (useCache && rstyle.clean || ele.removed()) {\n      continue;\n    } // only update if not display: none\n\n\n    if (ele.pstyle('display').value === 'none') {\n      continue;\n    }\n\n    if (_p.group === 'nodes') {\n      nodes.push(ele);\n    } else {\n      // edges\n      edges.push(ele);\n    }\n\n    rstyle.clean = true;\n  } // update node data from projections\n\n\n  for (var _i2 = 0; _i2 < nodes.length; _i2++) {\n    var _ele = nodes[_i2];\n    var _p2 = _ele._private;\n    var _rstyle = _p2.rstyle;\n\n    var pos = _ele.position();\n\n    this.recalculateNodeLabelProjection(_ele);\n    _rstyle.nodeX = pos.x;\n    _rstyle.nodeY = pos.y;\n    _rstyle.nodeW = _ele.pstyle('width').pfValue;\n    _rstyle.nodeH = _ele.pstyle('height').pfValue;\n  }\n\n  this.recalculateEdgeProjections(edges); // update edge data from projections\n\n  for (var _i3 = 0; _i3 < edges.length; _i3++) {\n    var _ele2 = edges[_i3];\n    var _p3 = _ele2._private;\n    var _rstyle2 = _p3.rstyle;\n    var rs = _p3.rscratch; // update rstyle positions\n\n    _rstyle2.srcX = rs.arrowStartX;\n    _rstyle2.srcY = rs.arrowStartY;\n    _rstyle2.tgtX = rs.arrowEndX;\n    _rstyle2.tgtY = rs.arrowEndY;\n    _rstyle2.midX = rs.midX;\n    _rstyle2.midY = rs.midY;\n    _rstyle2.labelAngle = rs.labelAngle;\n    _rstyle2.sourceLabelAngle = rs.sourceLabelAngle;\n    _rstyle2.targetLabelAngle = rs.targetLabelAngle;\n  }\n};\n\nvar BRp$6 = {};\n\nBRp$6.updateCachedGrabbedEles = function () {\n  var eles = this.cachedZSortedEles;\n\n  if (!eles) {\n    // just let this be recalculated on the next z sort tick\n    return;\n  }\n\n  eles.drag = [];\n  eles.nondrag = [];\n  var grabTargets = [];\n\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n    var rs = ele._private.rscratch;\n\n    if (ele.grabbed() && !ele.isParent()) {\n      grabTargets.push(ele);\n    } else if (rs.inDragLayer) {\n      eles.drag.push(ele);\n    } else {\n      eles.nondrag.push(ele);\n    }\n  } // put the grab target nodes last so it's on top of its neighbourhood\n\n\n  for (var i = 0; i < grabTargets.length; i++) {\n    var ele = grabTargets[i];\n    eles.drag.push(ele);\n  }\n};\n\nBRp$6.invalidateCachedZSortedEles = function () {\n  this.cachedZSortedEles = null;\n};\n\nBRp$6.getCachedZSortedEles = function (forceRecalc) {\n  if (forceRecalc || !this.cachedZSortedEles) {\n    var eles = this.cy.mutableElements().toArray();\n    eles.sort(zIndexSort);\n    eles.interactive = eles.filter(function (ele) {\n      return ele.interactive();\n    });\n    this.cachedZSortedEles = eles;\n    this.updateCachedGrabbedEles();\n  } else {\n    eles = this.cachedZSortedEles;\n  }\n\n  return eles;\n};\n\nvar BRp$5 = {};\n[BRp$e, BRp$d, BRp$c, BRp$b, BRp$a, BRp$9, BRp$8, BRp$7, BRp$6].forEach(function (props) {\n  extend(BRp$5, props);\n});\n\nvar BRp$4 = {};\n\nBRp$4.getCachedImage = function (url, crossOrigin, onLoad) {\n  var r = this;\n  var imageCache = r.imageCache = r.imageCache || {};\n  var cache = imageCache[url];\n\n  if (cache) {\n    if (!cache.image.complete) {\n      cache.image.addEventListener('load', onLoad);\n    }\n\n    return cache.image;\n  } else {\n    cache = imageCache[url] = imageCache[url] || {};\n    var image = cache.image = new Image(); // eslint-disable-line no-undef\n\n    image.addEventListener('load', onLoad);\n    image.addEventListener('error', function () {\n      image.error = true;\n    }); // #1582 safari doesn't load data uris with crossOrigin properly\n    // https://bugs.webkit.org/show_bug.cgi?id=123978\n\n    var dataUriPrefix = 'data:';\n    var isDataUri = url.substring(0, dataUriPrefix.length).toLowerCase() === dataUriPrefix;\n\n    if (!isDataUri) {\n      // if crossorigin is 'null'(stringified), then manually set it to null \n      crossOrigin = crossOrigin === 'null' ? null : crossOrigin;\n      image.crossOrigin = crossOrigin; // prevent tainted canvas\n    }\n\n    image.src = url;\n    return image;\n  }\n};\n\nvar BRp$3 = {};\n/* global document, window, ResizeObserver, MutationObserver */\n\nBRp$3.registerBinding = function (target, event, handler, useCapture) {\n  // eslint-disable-line no-unused-vars\n  var args = Array.prototype.slice.apply(arguments, [1]); // copy\n\n  var b = this.binder(target);\n  return b.on.apply(b, args);\n};\n\nBRp$3.binder = function (tgt) {\n  var r = this;\n  var containerWindow = r.cy.window();\n  var tgtIsDom = tgt === containerWindow || tgt === containerWindow.document || tgt === containerWindow.document.body || domElement(tgt);\n\n  if (r.supportsPassiveEvents == null) {\n    // from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n    var supportsPassive = false;\n\n    try {\n      var opts = Object.defineProperty({}, 'passive', {\n        get: function get() {\n          supportsPassive = true;\n          return true;\n        }\n      });\n      containerWindow.addEventListener('test', null, opts);\n    } catch (err) {// not supported\n    }\n\n    r.supportsPassiveEvents = supportsPassive;\n  }\n\n  var on = function on(event, handler, useCapture) {\n    var args = Array.prototype.slice.call(arguments);\n\n    if (tgtIsDom && r.supportsPassiveEvents) {\n      // replace useCapture w/ opts obj\n      args[2] = {\n        capture: useCapture != null ? useCapture : false,\n        passive: false,\n        once: false\n      };\n    }\n\n    r.bindings.push({\n      target: tgt,\n      args: args\n    });\n    (tgt.addEventListener || tgt.on).apply(tgt, args);\n    return this;\n  };\n\n  return {\n    on: on,\n    addEventListener: on,\n    addListener: on,\n    bind: on\n  };\n};\n\nBRp$3.nodeIsDraggable = function (node) {\n  return node && node.isNode() && !node.locked() && node.grabbable();\n};\n\nBRp$3.nodeIsGrabbable = function (node) {\n  return this.nodeIsDraggable(node) && node.interactive();\n};\n\nBRp$3.load = function () {\n  var r = this;\n  var containerWindow = r.cy.window();\n\n  var isSelected = function isSelected(ele) {\n    return ele.selected();\n  };\n\n  var triggerEvents = function triggerEvents(target, names, e, position) {\n    if (target == null) {\n      target = r.cy;\n    }\n\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n      target.emit({\n        originalEvent: e,\n        type: name,\n        position: position\n      });\n    }\n  };\n\n  var isMultSelKeyDown = function isMultSelKeyDown(e) {\n    return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey\n  };\n\n  var allowPanningPassthrough = function allowPanningPassthrough(down, downs) {\n    var allowPassthrough = true;\n\n    if (r.cy.hasCompoundNodes() && down && down.pannable()) {\n      // a grabbable compound node below the ele => no passthrough panning\n      for (var i = 0; downs && i < downs.length; i++) {\n        var down = downs[i]; //if any parent node in event hierarchy isn't pannable, reject passthrough\n\n        if (down.isNode() && down.isParent() && !down.pannable()) {\n          allowPassthrough = false;\n          break;\n        }\n      }\n    } else {\n      allowPassthrough = true;\n    }\n\n    return allowPassthrough;\n  };\n\n  var setGrabbed = function setGrabbed(ele) {\n    ele[0]._private.grabbed = true;\n  };\n\n  var setFreed = function setFreed(ele) {\n    ele[0]._private.grabbed = false;\n  };\n\n  var setInDragLayer = function setInDragLayer(ele) {\n    ele[0]._private.rscratch.inDragLayer = true;\n  };\n\n  var setOutDragLayer = function setOutDragLayer(ele) {\n    ele[0]._private.rscratch.inDragLayer = false;\n  };\n\n  var setGrabTarget = function setGrabTarget(ele) {\n    ele[0]._private.rscratch.isGrabTarget = true;\n  };\n\n  var removeGrabTarget = function removeGrabTarget(ele) {\n    ele[0]._private.rscratch.isGrabTarget = false;\n  };\n\n  var addToDragList = function addToDragList(ele, opts) {\n    var list = opts.addToList;\n    var listHasEle = list.has(ele);\n\n    if (!listHasEle && ele.grabbable() && !ele.locked()) {\n      list.merge(ele);\n      setGrabbed(ele);\n    }\n  }; // helper function to determine which child nodes and inner edges\n  // of a compound node to be dragged as well as the grabbed and selected nodes\n\n\n  var addDescendantsToDrag = function addDescendantsToDrag(node, opts) {\n    if (!node.cy().hasCompoundNodes()) {\n      return;\n    }\n\n    if (opts.inDragLayer == null && opts.addToList == null) {\n      return;\n    } // nothing to do\n\n\n    var innerNodes = node.descendants();\n\n    if (opts.inDragLayer) {\n      innerNodes.forEach(setInDragLayer);\n      innerNodes.connectedEdges().forEach(setInDragLayer);\n    }\n\n    if (opts.addToList) {\n      addToDragList(innerNodes, opts);\n    }\n  }; // adds the given nodes and its neighbourhood to the drag layer\n\n\n  var addNodesToDrag = function addNodesToDrag(nodes, opts) {\n    opts = opts || {};\n    var hasCompoundNodes = nodes.cy().hasCompoundNodes();\n\n    if (opts.inDragLayer) {\n      nodes.forEach(setInDragLayer);\n      nodes.neighborhood().stdFilter(function (ele) {\n        return !hasCompoundNodes || ele.isEdge();\n      }).forEach(setInDragLayer);\n    }\n\n    if (opts.addToList) {\n      nodes.forEach(function (ele) {\n        addToDragList(ele, opts);\n      });\n    }\n\n    addDescendantsToDrag(nodes, opts); // always add to drag\n    // also add nodes and edges related to the topmost ancestor\n\n    updateAncestorsInDragLayer(nodes, {\n      inDragLayer: opts.inDragLayer\n    });\n    r.updateCachedGrabbedEles();\n  };\n\n  var addNodeToDrag = addNodesToDrag;\n\n  var freeDraggedElements = function freeDraggedElements(grabbedEles) {\n    if (!grabbedEles) {\n      return;\n    } // just go over all elements rather than doing a bunch of (possibly expensive) traversals\n\n\n    r.getCachedZSortedEles().forEach(function (ele) {\n      setFreed(ele);\n      setOutDragLayer(ele);\n      removeGrabTarget(ele);\n    });\n    r.updateCachedGrabbedEles();\n  }; // helper function to determine which ancestor nodes and edges should go\n  // to the drag layer (or should be removed from drag layer).\n\n\n  var updateAncestorsInDragLayer = function updateAncestorsInDragLayer(node, opts) {\n    if (opts.inDragLayer == null && opts.addToList == null) {\n      return;\n    } // nothing to do\n\n\n    if (!node.cy().hasCompoundNodes()) {\n      return;\n    } // find top-level parent\n\n\n    var parent = node.ancestors().orphans(); // no parent node: no nodes to add to the drag layer\n\n    if (parent.same(node)) {\n      return;\n    }\n\n    var nodes = parent.descendants().spawnSelf().merge(parent).unmerge(node).unmerge(node.descendants());\n    var edges = nodes.connectedEdges();\n\n    if (opts.inDragLayer) {\n      edges.forEach(setInDragLayer);\n      nodes.forEach(setInDragLayer);\n    }\n\n    if (opts.addToList) {\n      nodes.forEach(function (ele) {\n        addToDragList(ele, opts);\n      });\n    }\n  };\n\n  var blurActiveDomElement = function blurActiveDomElement() {\n    if (document.activeElement != null && document.activeElement.blur != null) {\n      document.activeElement.blur();\n    }\n  };\n\n  var haveMutationsApi = typeof MutationObserver !== 'undefined';\n  var haveResizeObserverApi = typeof ResizeObserver !== 'undefined'; // watch for when the cy container is removed from the dom\n\n  if (haveMutationsApi) {\n    r.removeObserver = new MutationObserver(function (mutns) {\n      // eslint-disable-line no-undef\n      for (var i = 0; i < mutns.length; i++) {\n        var mutn = mutns[i];\n        var rNodes = mutn.removedNodes;\n\n        if (rNodes) {\n          for (var j = 0; j < rNodes.length; j++) {\n            var rNode = rNodes[j];\n\n            if (rNode === r.container) {\n              r.destroy();\n              break;\n            }\n          }\n        }\n      }\n    });\n\n    if (r.container.parentNode) {\n      r.removeObserver.observe(r.container.parentNode, {\n        childList: true\n      });\n    }\n  } else {\n    r.registerBinding(r.container, 'DOMNodeRemoved', function (e) {\n      // eslint-disable-line no-unused-vars\n      r.destroy();\n    });\n  }\n\n  var onResize = debounce__default[\"default\"](function () {\n    r.cy.resize();\n  }, 100);\n\n  if (haveMutationsApi) {\n    r.styleObserver = new MutationObserver(onResize); // eslint-disable-line no-undef\n\n    r.styleObserver.observe(r.container, {\n      attributes: true\n    });\n  } // auto resize\n\n\n  r.registerBinding(containerWindow, 'resize', onResize); // eslint-disable-line no-undef\n\n  if (haveResizeObserverApi) {\n    r.resizeObserver = new ResizeObserver(onResize); // eslint-disable-line no-undef\n\n    r.resizeObserver.observe(r.container);\n  }\n\n  var forEachUp = function forEachUp(domEle, fn) {\n    while (domEle != null) {\n      fn(domEle);\n      domEle = domEle.parentNode;\n    }\n  };\n\n  var invalidateCoords = function invalidateCoords() {\n    r.invalidateContainerClientCoordsCache();\n  };\n\n  forEachUp(r.container, function (domEle) {\n    r.registerBinding(domEle, 'transitionend', invalidateCoords);\n    r.registerBinding(domEle, 'animationend', invalidateCoords);\n    r.registerBinding(domEle, 'scroll', invalidateCoords);\n  }); // stop right click menu from appearing on cy\n\n  r.registerBinding(r.container, 'contextmenu', function (e) {\n    e.preventDefault();\n  });\n\n  var inBoxSelection = function inBoxSelection() {\n    return r.selection[4] !== 0;\n  };\n\n  var eventInContainer = function eventInContainer(e) {\n    // save cycles if mouse events aren't to be captured\n    var containerPageCoords = r.findContainerClientCoords();\n    var x = containerPageCoords[0];\n    var y = containerPageCoords[1];\n    var width = containerPageCoords[2];\n    var height = containerPageCoords[3];\n    var positions = e.touches ? e.touches : [e];\n    var atLeastOnePosInside = false;\n\n    for (var i = 0; i < positions.length; i++) {\n      var p = positions[i];\n\n      if (x <= p.clientX && p.clientX <= x + width && y <= p.clientY && p.clientY <= y + height) {\n        atLeastOnePosInside = true;\n        break;\n      }\n    }\n\n    if (!atLeastOnePosInside) {\n      return false;\n    }\n\n    var container = r.container;\n    var target = e.target;\n    var tParent = target.parentNode;\n    var containerIsTarget = false;\n\n    while (tParent) {\n      if (tParent === container) {\n        containerIsTarget = true;\n        break;\n      }\n\n      tParent = tParent.parentNode;\n    }\n\n    if (!containerIsTarget) {\n      return false;\n    } // if target is outisde cy container, then this event is not for us\n\n\n    return true;\n  }; // Primary key\n\n\n  r.registerBinding(r.container, 'mousedown', function mousedownHandler(e) {\n    if (!eventInContainer(e)) {\n      return;\n    }\n\n    e.preventDefault();\n    blurActiveDomElement();\n    r.hoverData.capture = true;\n    r.hoverData.which = e.which;\n    var cy = r.cy;\n    var gpos = [e.clientX, e.clientY];\n    var pos = r.projectIntoViewport(gpos[0], gpos[1]);\n    var select = r.selection;\n    var nears = r.findNearestElements(pos[0], pos[1], true, false);\n    var near = nears[0];\n    var draggedElements = r.dragData.possibleDragElements;\n    r.hoverData.mdownPos = pos;\n    r.hoverData.mdownGPos = gpos;\n\n    var checkForTaphold = function checkForTaphold() {\n      r.hoverData.tapholdCancelled = false;\n      clearTimeout(r.hoverData.tapholdTimeout);\n      r.hoverData.tapholdTimeout = setTimeout(function () {\n        if (r.hoverData.tapholdCancelled) {\n          return;\n        } else {\n          var ele = r.hoverData.down;\n\n          if (ele) {\n            ele.emit({\n              originalEvent: e,\n              type: 'taphold',\n              position: {\n                x: pos[0],\n                y: pos[1]\n              }\n            });\n          } else {\n            cy.emit({\n              originalEvent: e,\n              type: 'taphold',\n              position: {\n                x: pos[0],\n                y: pos[1]\n              }\n            });\n          }\n        }\n      }, r.tapholdDuration);\n    }; // Right click button\n\n\n    if (e.which == 3) {\n      r.hoverData.cxtStarted = true;\n      var cxtEvt = {\n        originalEvent: e,\n        type: 'cxttapstart',\n        position: {\n          x: pos[0],\n          y: pos[1]\n        }\n      };\n\n      if (near) {\n        near.activate();\n        near.emit(cxtEvt);\n        r.hoverData.down = near;\n      } else {\n        cy.emit(cxtEvt);\n      }\n\n      r.hoverData.downTime = new Date().getTime();\n      r.hoverData.cxtDragged = false; // Primary button\n    } else if (e.which == 1) {\n      if (near) {\n        near.activate();\n      } // Element dragging\n\n\n      {\n        // If something is under the cursor and it is draggable, prepare to grab it\n        if (near != null) {\n          if (r.nodeIsGrabbable(near)) {\n            var makeEvent = function makeEvent(type) {\n              return {\n                originalEvent: e,\n                type: type,\n                position: {\n                  x: pos[0],\n                  y: pos[1]\n                }\n              };\n            };\n\n            var triggerGrab = function triggerGrab(ele) {\n              ele.emit(makeEvent('grab'));\n            };\n\n            setGrabTarget(near);\n\n            if (!near.selected()) {\n              draggedElements = r.dragData.possibleDragElements = cy.collection();\n              addNodeToDrag(near, {\n                addToList: draggedElements\n              });\n              near.emit(makeEvent('grabon')).emit(makeEvent('grab'));\n            } else {\n              draggedElements = r.dragData.possibleDragElements = cy.collection();\n              var selectedNodes = cy.$(function (ele) {\n                return ele.isNode() && ele.selected() && r.nodeIsGrabbable(ele);\n              });\n              addNodesToDrag(selectedNodes, {\n                addToList: draggedElements\n              });\n              near.emit(makeEvent('grabon'));\n              selectedNodes.forEach(triggerGrab);\n            }\n\n            r.redrawHint('eles', true);\n            r.redrawHint('drag', true);\n          }\n        }\n\n        r.hoverData.down = near;\n        r.hoverData.downs = nears;\n        r.hoverData.downTime = new Date().getTime();\n      }\n      triggerEvents(near, ['mousedown', 'tapstart', 'vmousedown'], e, {\n        x: pos[0],\n        y: pos[1]\n      });\n\n      if (near == null) {\n        select[4] = 1;\n        r.data.bgActivePosistion = {\n          x: pos[0],\n          y: pos[1]\n        };\n        r.redrawHint('select', true);\n        r.redraw();\n      } else if (near.pannable()) {\n        select[4] = 1; // for future pan\n      }\n\n      checkForTaphold();\n    } // Initialize selection box coordinates\n\n\n    select[0] = select[2] = pos[0];\n    select[1] = select[3] = pos[1];\n  }, false);\n  r.registerBinding(containerWindow, 'mousemove', function mousemoveHandler(e) {\n    // eslint-disable-line no-undef\n    var capture = r.hoverData.capture;\n\n    if (!capture && !eventInContainer(e)) {\n      return;\n    }\n\n    var preventDefault = false;\n    var cy = r.cy;\n    var zoom = cy.zoom();\n    var gpos = [e.clientX, e.clientY];\n    var pos = r.projectIntoViewport(gpos[0], gpos[1]);\n    var mdownPos = r.hoverData.mdownPos;\n    var mdownGPos = r.hoverData.mdownGPos;\n    var select = r.selection;\n    var near = null;\n\n    if (!r.hoverData.draggingEles && !r.hoverData.dragging && !r.hoverData.selecting) {\n      near = r.findNearestElement(pos[0], pos[1], true, false);\n    }\n\n    var last = r.hoverData.last;\n    var down = r.hoverData.down;\n    var disp = [pos[0] - select[2], pos[1] - select[3]];\n    var draggedElements = r.dragData.possibleDragElements;\n    var isOverThresholdDrag;\n\n    if (mdownGPos) {\n      var dx = gpos[0] - mdownGPos[0];\n      var dx2 = dx * dx;\n      var dy = gpos[1] - mdownGPos[1];\n      var dy2 = dy * dy;\n      var dist2 = dx2 + dy2;\n      r.hoverData.isOverThresholdDrag = isOverThresholdDrag = dist2 >= r.desktopTapThreshold2;\n    }\n\n    var multSelKeyDown = isMultSelKeyDown(e);\n\n    if (isOverThresholdDrag) {\n      r.hoverData.tapholdCancelled = true;\n    }\n\n    var updateDragDelta = function updateDragDelta() {\n      var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];\n\n      if (dragDelta.length === 0) {\n        dragDelta.push(disp[0]);\n        dragDelta.push(disp[1]);\n      } else {\n        dragDelta[0] += disp[0];\n        dragDelta[1] += disp[1];\n      }\n    };\n\n    preventDefault = true;\n    triggerEvents(near, ['mousemove', 'vmousemove', 'tapdrag'], e, {\n      x: pos[0],\n      y: pos[1]\n    });\n\n    var goIntoBoxMode = function goIntoBoxMode() {\n      r.data.bgActivePosistion = undefined;\n\n      if (!r.hoverData.selecting) {\n        cy.emit({\n          originalEvent: e,\n          type: 'boxstart',\n          position: {\n            x: pos[0],\n            y: pos[1]\n          }\n        });\n      }\n\n      select[4] = 1;\n      r.hoverData.selecting = true;\n      r.redrawHint('select', true);\n      r.redraw();\n    }; // trigger context drag if rmouse down\n\n\n    if (r.hoverData.which === 3) {\n      // but only if over threshold\n      if (isOverThresholdDrag) {\n        var cxtEvt = {\n          originalEvent: e,\n          type: 'cxtdrag',\n          position: {\n            x: pos[0],\n            y: pos[1]\n          }\n        };\n\n        if (down) {\n          down.emit(cxtEvt);\n        } else {\n          cy.emit(cxtEvt);\n        }\n\n        r.hoverData.cxtDragged = true;\n\n        if (!r.hoverData.cxtOver || near !== r.hoverData.cxtOver) {\n          if (r.hoverData.cxtOver) {\n            r.hoverData.cxtOver.emit({\n              originalEvent: e,\n              type: 'cxtdragout',\n              position: {\n                x: pos[0],\n                y: pos[1]\n              }\n            });\n          }\n\n          r.hoverData.cxtOver = near;\n\n          if (near) {\n            near.emit({\n              originalEvent: e,\n              type: 'cxtdragover',\n              position: {\n                x: pos[0],\n                y: pos[1]\n              }\n            });\n          }\n        }\n      } // Check if we are drag panning the entire graph\n\n    } else if (r.hoverData.dragging) {\n      preventDefault = true;\n\n      if (cy.panningEnabled() && cy.userPanningEnabled()) {\n        var deltaP;\n\n        if (r.hoverData.justStartedPan) {\n          var mdPos = r.hoverData.mdownPos;\n          deltaP = {\n            x: (pos[0] - mdPos[0]) * zoom,\n            y: (pos[1] - mdPos[1]) * zoom\n          };\n          r.hoverData.justStartedPan = false;\n        } else {\n          deltaP = {\n            x: disp[0] * zoom,\n            y: disp[1] * zoom\n          };\n        }\n\n        cy.panBy(deltaP);\n        cy.emit('dragpan');\n        r.hoverData.dragged = true;\n      } // Needs reproject due to pan changing viewport\n\n\n      pos = r.projectIntoViewport(e.clientX, e.clientY); // Checks primary button down & out of time & mouse not moved much\n    } else if (select[4] == 1 && (down == null || down.pannable())) {\n      if (isOverThresholdDrag) {\n        if (!r.hoverData.dragging && cy.boxSelectionEnabled() && (multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled())) {\n          goIntoBoxMode();\n        } else if (!r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled()) {\n          var allowPassthrough = allowPanningPassthrough(down, r.hoverData.downs);\n\n          if (allowPassthrough) {\n            r.hoverData.dragging = true;\n            r.hoverData.justStartedPan = true;\n            select[4] = 0;\n            r.data.bgActivePosistion = array2point(mdownPos);\n            r.redrawHint('select', true);\n            r.redraw();\n          }\n        }\n\n        if (down && down.pannable() && down.active()) {\n          down.unactivate();\n        }\n      }\n    } else {\n      if (down && down.pannable() && down.active()) {\n        down.unactivate();\n      }\n\n      if ((!down || !down.grabbed()) && near != last) {\n        if (last) {\n          triggerEvents(last, ['mouseout', 'tapdragout'], e, {\n            x: pos[0],\n            y: pos[1]\n          });\n        }\n\n        if (near) {\n          triggerEvents(near, ['mouseover', 'tapdragover'], e, {\n            x: pos[0],\n            y: pos[1]\n          });\n        }\n\n        r.hoverData.last = near;\n      }\n\n      if (down) {\n        if (isOverThresholdDrag) {\n          // then we can take action\n          if (cy.boxSelectionEnabled() && multSelKeyDown) {\n            // then selection overrides\n            if (down && down.grabbed()) {\n              freeDraggedElements(draggedElements);\n              down.emit('freeon');\n              draggedElements.emit('free');\n\n              if (r.dragData.didDrag) {\n                down.emit('dragfreeon');\n                draggedElements.emit('dragfree');\n              }\n            }\n\n            goIntoBoxMode();\n          } else if (down && down.grabbed() && r.nodeIsDraggable(down)) {\n            // drag node\n            var justStartedDrag = !r.dragData.didDrag;\n\n            if (justStartedDrag) {\n              r.redrawHint('eles', true);\n            }\n\n            r.dragData.didDrag = true; // indicate that we actually did drag the node\n            // now, add the elements to the drag layer if not done already\n\n            if (!r.hoverData.draggingEles) {\n              addNodesToDrag(draggedElements, {\n                inDragLayer: true\n              });\n            }\n\n            var totalShift = {\n              x: 0,\n              y: 0\n            };\n\n            if (number$1(disp[0]) && number$1(disp[1])) {\n              totalShift.x += disp[0];\n              totalShift.y += disp[1];\n\n              if (justStartedDrag) {\n                var dragDelta = r.hoverData.dragDelta;\n\n                if (dragDelta && number$1(dragDelta[0]) && number$1(dragDelta[1])) {\n                  totalShift.x += dragDelta[0];\n                  totalShift.y += dragDelta[1];\n                }\n              }\n            }\n\n            r.hoverData.draggingEles = true;\n            draggedElements.silentShift(totalShift).emit('position drag');\n            r.redrawHint('drag', true);\n            r.redraw();\n          }\n        } else {\n          // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant\n          updateDragDelta();\n        }\n      } // prevent the dragging from triggering text selection on the page\n\n\n      preventDefault = true;\n    }\n\n    select[2] = pos[0];\n    select[3] = pos[1];\n\n    if (preventDefault) {\n      if (e.stopPropagation) e.stopPropagation();\n      if (e.preventDefault) e.preventDefault();\n      return false;\n    }\n  }, false);\n  var clickTimeout, didDoubleClick, prevClickTimeStamp;\n  r.registerBinding(containerWindow, 'mouseup', function mouseupHandler(e) {\n    // eslint-disable-line no-undef\n    var capture = r.hoverData.capture;\n\n    if (!capture) {\n      return;\n    }\n\n    r.hoverData.capture = false;\n    var cy = r.cy;\n    var pos = r.projectIntoViewport(e.clientX, e.clientY);\n    var select = r.selection;\n    var near = r.findNearestElement(pos[0], pos[1], true, false);\n    var draggedElements = r.dragData.possibleDragElements;\n    var down = r.hoverData.down;\n    var multSelKeyDown = isMultSelKeyDown(e);\n\n    if (r.data.bgActivePosistion) {\n      r.redrawHint('select', true);\n      r.redraw();\n    }\n\n    r.hoverData.tapholdCancelled = true;\n    r.data.bgActivePosistion = undefined; // not active bg now\n\n    if (down) {\n      down.unactivate();\n    }\n\n    if (r.hoverData.which === 3) {\n      var cxtEvt = {\n        originalEvent: e,\n        type: 'cxttapend',\n        position: {\n          x: pos[0],\n          y: pos[1]\n        }\n      };\n\n      if (down) {\n        down.emit(cxtEvt);\n      } else {\n        cy.emit(cxtEvt);\n      }\n\n      if (!r.hoverData.cxtDragged) {\n        var cxtTap = {\n          originalEvent: e,\n          type: 'cxttap',\n          position: {\n            x: pos[0],\n            y: pos[1]\n          }\n        };\n\n        if (down) {\n          down.emit(cxtTap);\n        } else {\n          cy.emit(cxtTap);\n        }\n      }\n\n      r.hoverData.cxtDragged = false;\n      r.hoverData.which = null;\n    } else if (r.hoverData.which === 1) {\n      triggerEvents(near, ['mouseup', 'tapend', 'vmouseup'], e, {\n        x: pos[0],\n        y: pos[1]\n      });\n\n      if (!r.dragData.didDrag && // didn't move a node around\n      !r.hoverData.dragged && // didn't pan\n      !r.hoverData.selecting && // not box selection\n      !r.hoverData.isOverThresholdDrag // didn't move too much\n      ) {\n        triggerEvents(down, [\"click\", \"tap\", \"vclick\"], e, {\n          x: pos[0],\n          y: pos[1]\n        });\n        didDoubleClick = false;\n\n        if (e.timeStamp - prevClickTimeStamp <= cy.multiClickDebounceTime()) {\n          clickTimeout && clearTimeout(clickTimeout);\n          didDoubleClick = true;\n          prevClickTimeStamp = null;\n          triggerEvents(down, [\"dblclick\", \"dbltap\", \"vdblclick\"], e, {\n            x: pos[0],\n            y: pos[1]\n          });\n        } else {\n          clickTimeout = setTimeout(function () {\n            if (didDoubleClick) return;\n            triggerEvents(down, [\"oneclick\", \"onetap\", \"voneclick\"], e, {\n              x: pos[0],\n              y: pos[1]\n            });\n          }, cy.multiClickDebounceTime());\n          prevClickTimeStamp = e.timeStamp;\n        }\n      } // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something\n\n\n      if (down == null // not mousedown on node\n      && !r.dragData.didDrag // didn't move the node around\n      && !r.hoverData.selecting // not box selection\n      && !r.hoverData.dragged // didn't pan\n      && !isMultSelKeyDown(e)) {\n        cy.$(isSelected).unselect(['tapunselect']);\n\n        if (draggedElements.length > 0) {\n          r.redrawHint('eles', true);\n        }\n\n        r.dragData.possibleDragElements = draggedElements = cy.collection();\n      } // Single selection\n\n\n      if (near == down && !r.dragData.didDrag && !r.hoverData.selecting) {\n        if (near != null && near._private.selectable) {\n          if (r.hoverData.dragging) ; else if (cy.selectionType() === 'additive' || multSelKeyDown) {\n            if (near.selected()) {\n              near.unselect(['tapunselect']);\n            } else {\n              near.select(['tapselect']);\n            }\n          } else {\n            if (!multSelKeyDown) {\n              cy.$(isSelected).unmerge(near).unselect(['tapunselect']);\n              near.select(['tapselect']);\n            }\n          }\n\n          r.redrawHint('eles', true);\n        }\n      }\n\n      if (r.hoverData.selecting) {\n        var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));\n        r.redrawHint('select', true);\n\n        if (box.length > 0) {\n          r.redrawHint('eles', true);\n        }\n\n        cy.emit({\n          type: 'boxend',\n          originalEvent: e,\n          position: {\n            x: pos[0],\n            y: pos[1]\n          }\n        });\n\n        var eleWouldBeSelected = function eleWouldBeSelected(ele) {\n          return ele.selectable() && !ele.selected();\n        };\n\n        if (cy.selectionType() === 'additive') {\n          box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');\n        } else {\n          if (!multSelKeyDown) {\n            cy.$(isSelected).unmerge(box).unselect();\n          }\n\n          box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');\n        } // always need redraw in case eles unselectable\n\n\n        r.redraw();\n      } // Cancel drag pan\n\n\n      if (r.hoverData.dragging) {\n        r.hoverData.dragging = false;\n        r.redrawHint('select', true);\n        r.redrawHint('eles', true);\n        r.redraw();\n      }\n\n      if (!select[4]) {\n        r.redrawHint('drag', true);\n        r.redrawHint('eles', true);\n        var downWasGrabbed = down && down.grabbed();\n        freeDraggedElements(draggedElements);\n\n        if (downWasGrabbed) {\n          down.emit('freeon');\n          draggedElements.emit('free');\n\n          if (r.dragData.didDrag) {\n            down.emit('dragfreeon');\n            draggedElements.emit('dragfree');\n          }\n        }\n      }\n    } // else not right mouse\n\n\n    select[4] = 0;\n    r.hoverData.down = null;\n    r.hoverData.cxtStarted = false;\n    r.hoverData.draggingEles = false;\n    r.hoverData.selecting = false;\n    r.hoverData.isOverThresholdDrag = false;\n    r.dragData.didDrag = false;\n    r.hoverData.dragged = false;\n    r.hoverData.dragDelta = [];\n    r.hoverData.mdownPos = null;\n    r.hoverData.mdownGPos = null;\n  }, false);\n\n  var wheelHandler = function wheelHandler(e) {\n    if (r.scrollingPage) {\n      return;\n    } // while scrolling, ignore wheel-to-zoom\n\n\n    var cy = r.cy;\n    var zoom = cy.zoom();\n    var pan = cy.pan();\n    var pos = r.projectIntoViewport(e.clientX, e.clientY);\n    var rpos = [pos[0] * zoom + pan.x, pos[1] * zoom + pan.y];\n\n    if (r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection()) {\n      // if pan dragging or cxt dragging, wheel movements make no zoom\n      e.preventDefault();\n      return;\n    }\n\n    if (cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled()) {\n      e.preventDefault();\n      r.data.wheelZooming = true;\n      clearTimeout(r.data.wheelTimeout);\n      r.data.wheelTimeout = setTimeout(function () {\n        r.data.wheelZooming = false;\n        r.redrawHint('eles', true);\n        r.redraw();\n      }, 150);\n      var diff;\n\n      if (e.deltaY != null) {\n        diff = e.deltaY / -250;\n      } else if (e.wheelDeltaY != null) {\n        diff = e.wheelDeltaY / 1000;\n      } else {\n        diff = e.wheelDelta / 1000;\n      }\n\n      diff = diff * r.wheelSensitivity;\n      var needsWheelFix = e.deltaMode === 1;\n\n      if (needsWheelFix) {\n        // fixes slow wheel events on ff/linux and ff/windows\n        diff *= 33;\n      }\n\n      var newZoom = cy.zoom() * Math.pow(10, diff);\n\n      if (e.type === 'gesturechange') {\n        newZoom = r.gestureStartZoom * e.scale;\n      }\n\n      cy.zoom({\n        level: newZoom,\n        renderedPosition: {\n          x: rpos[0],\n          y: rpos[1]\n        }\n      });\n      cy.emit(e.type === 'gesturechange' ? 'pinchzoom' : 'scrollzoom');\n    }\n  }; // Functions to help with whether mouse wheel should trigger zooming\n  // --\n\n\n  r.registerBinding(r.container, 'wheel', wheelHandler, true); // disable nonstandard wheel events\n  // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);\n  // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);\n  // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox\n\n  r.registerBinding(containerWindow, 'scroll', function scrollHandler(e) {\n    // eslint-disable-line no-unused-vars\n    r.scrollingPage = true;\n    clearTimeout(r.scrollingPageTimeout);\n    r.scrollingPageTimeout = setTimeout(function () {\n      r.scrollingPage = false;\n    }, 250);\n  }, true); // desktop safari pinch to zoom start\n\n  r.registerBinding(r.container, 'gesturestart', function gestureStartHandler(e) {\n    r.gestureStartZoom = r.cy.zoom();\n\n    if (!r.hasTouchStarted) {\n      // don't affect touch devices like iphone\n      e.preventDefault();\n    }\n  }, true);\n  r.registerBinding(r.container, 'gesturechange', function (e) {\n    if (!r.hasTouchStarted) {\n      // don't affect touch devices like iphone\n      wheelHandler(e);\n    }\n  }, true); // Functions to help with handling mouseout/mouseover on the Cytoscape container\n  // Handle mouseout on Cytoscape container\n\n  r.registerBinding(r.container, 'mouseout', function mouseOutHandler(e) {\n    var pos = r.projectIntoViewport(e.clientX, e.clientY);\n    r.cy.emit({\n      originalEvent: e,\n      type: 'mouseout',\n      position: {\n        x: pos[0],\n        y: pos[1]\n      }\n    });\n  }, false);\n  r.registerBinding(r.container, 'mouseover', function mouseOverHandler(e) {\n    var pos = r.projectIntoViewport(e.clientX, e.clientY);\n    r.cy.emit({\n      originalEvent: e,\n      type: 'mouseover',\n      position: {\n        x: pos[0],\n        y: pos[1]\n      }\n    });\n  }, false);\n  var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom\n\n  var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom\n\n  var center1, modelCenter1; // center point on start pinch to zoom\n\n  var offsetLeft, offsetTop;\n  var containerWidth, containerHeight;\n  var twoFingersStartInside;\n\n  var distance = function distance(x1, y1, x2, y2) {\n    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  };\n\n  var distanceSq = function distanceSq(x1, y1, x2, y2) {\n    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n  };\n\n  var touchstartHandler;\n  r.registerBinding(r.container, 'touchstart', touchstartHandler = function touchstartHandler(e) {\n    r.hasTouchStarted = true;\n\n    if (!eventInContainer(e)) {\n      return;\n    }\n\n    blurActiveDomElement();\n    r.touchData.capture = true;\n    r.data.bgActivePosistion = undefined;\n    var cy = r.cy;\n    var now = r.touchData.now;\n    var earlier = r.touchData.earlier;\n\n    if (e.touches[0]) {\n      var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n      now[0] = pos[0];\n      now[1] = pos[1];\n    }\n\n    if (e.touches[1]) {\n      var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n      now[2] = pos[0];\n      now[3] = pos[1];\n    }\n\n    if (e.touches[2]) {\n      var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n      now[4] = pos[0];\n      now[5] = pos[1];\n    } // record starting points for pinch-to-zoom\n\n\n    if (e.touches[1]) {\n      r.touchData.singleTouchMoved = true;\n      freeDraggedElements(r.dragData.touchDragEles);\n      var offsets = r.findContainerClientCoords();\n      offsetLeft = offsets[0];\n      offsetTop = offsets[1];\n      containerWidth = offsets[2];\n      containerHeight = offsets[3];\n      f1x1 = e.touches[0].clientX - offsetLeft;\n      f1y1 = e.touches[0].clientY - offsetTop;\n      f2x1 = e.touches[1].clientX - offsetLeft;\n      f2y1 = e.touches[1].clientY - offsetTop;\n      twoFingersStartInside = 0 <= f1x1 && f1x1 <= containerWidth && 0 <= f2x1 && f2x1 <= containerWidth && 0 <= f1y1 && f1y1 <= containerHeight && 0 <= f2y1 && f2y1 <= containerHeight;\n      var pan = cy.pan();\n      var zoom = cy.zoom();\n      distance1 = distance(f1x1, f1y1, f2x1, f2y1);\n      distance1Sq = distanceSq(f1x1, f1y1, f2x1, f2y1);\n      center1 = [(f1x1 + f2x1) / 2, (f1y1 + f2y1) / 2];\n      modelCenter1 = [(center1[0] - pan.x) / zoom, (center1[1] - pan.y) / zoom]; // consider context tap\n\n      var cxtDistThreshold = 200;\n      var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;\n\n      if (distance1Sq < cxtDistThresholdSq && !e.touches[2]) {\n        var near1 = r.findNearestElement(now[0], now[1], true, true);\n        var near2 = r.findNearestElement(now[2], now[3], true, true);\n\n        if (near1 && near1.isNode()) {\n          near1.activate().emit({\n            originalEvent: e,\n            type: 'cxttapstart',\n            position: {\n              x: now[0],\n              y: now[1]\n            }\n          });\n          r.touchData.start = near1;\n        } else if (near2 && near2.isNode()) {\n          near2.activate().emit({\n            originalEvent: e,\n            type: 'cxttapstart',\n            position: {\n              x: now[0],\n              y: now[1]\n            }\n          });\n          r.touchData.start = near2;\n        } else {\n          cy.emit({\n            originalEvent: e,\n            type: 'cxttapstart',\n            position: {\n              x: now[0],\n              y: now[1]\n            }\n          });\n        }\n\n        if (r.touchData.start) {\n          r.touchData.start._private.grabbed = false;\n        }\n\n        r.touchData.cxt = true;\n        r.touchData.cxtDragged = false;\n        r.data.bgActivePosistion = undefined;\n        r.redraw();\n        return;\n      }\n    }\n\n    if (e.touches[2]) {\n      // ignore\n      // safari on ios pans the page otherwise (normally you should be able to preventdefault on touchmove...)\n      if (cy.boxSelectionEnabled()) {\n        e.preventDefault();\n      }\n    } else if (e.touches[1]) ; else if (e.touches[0]) {\n      var nears = r.findNearestElements(now[0], now[1], true, true);\n      var near = nears[0];\n\n      if (near != null) {\n        near.activate();\n        r.touchData.start = near;\n        r.touchData.starts = nears;\n\n        if (r.nodeIsGrabbable(near)) {\n          var draggedEles = r.dragData.touchDragEles = cy.collection();\n          var selectedNodes = null;\n          r.redrawHint('eles', true);\n          r.redrawHint('drag', true);\n\n          if (near.selected()) {\n            // reset drag elements, since near will be added again\n            selectedNodes = cy.$(function (ele) {\n              return ele.selected() && r.nodeIsGrabbable(ele);\n            });\n            addNodesToDrag(selectedNodes, {\n              addToList: draggedEles\n            });\n          } else {\n            addNodeToDrag(near, {\n              addToList: draggedEles\n            });\n          }\n\n          setGrabTarget(near);\n\n          var makeEvent = function makeEvent(type) {\n            return {\n              originalEvent: e,\n              type: type,\n              position: {\n                x: now[0],\n                y: now[1]\n              }\n            };\n          };\n\n          near.emit(makeEvent('grabon'));\n\n          if (selectedNodes) {\n            selectedNodes.forEach(function (n) {\n              n.emit(makeEvent('grab'));\n            });\n          } else {\n            near.emit(makeEvent('grab'));\n          }\n        }\n      }\n\n      triggerEvents(near, ['touchstart', 'tapstart', 'vmousedown'], e, {\n        x: now[0],\n        y: now[1]\n      });\n\n      if (near == null) {\n        r.data.bgActivePosistion = {\n          x: pos[0],\n          y: pos[1]\n        };\n        r.redrawHint('select', true);\n        r.redraw();\n      } // Tap, taphold\n      // -----\n\n\n      r.touchData.singleTouchMoved = false;\n      r.touchData.singleTouchStartTime = +new Date();\n      clearTimeout(r.touchData.tapholdTimeout);\n      r.touchData.tapholdTimeout = setTimeout(function () {\n        if (r.touchData.singleTouchMoved === false && !r.pinching // if pinching, then taphold unselect shouldn't take effect\n        && !r.touchData.selecting // box selection shouldn't allow taphold through\n        ) {\n          triggerEvents(r.touchData.start, ['taphold'], e, {\n            x: now[0],\n            y: now[1]\n          });\n        }\n      }, r.tapholdDuration);\n    }\n\n    if (e.touches.length >= 1) {\n      var sPos = r.touchData.startPosition = [null, null, null, null, null, null];\n\n      for (var i = 0; i < now.length; i++) {\n        sPos[i] = earlier[i] = now[i];\n      }\n\n      var touch0 = e.touches[0];\n      r.touchData.startGPosition = [touch0.clientX, touch0.clientY];\n    }\n  }, false);\n  var touchmoveHandler;\n  r.registerBinding(window, 'touchmove', touchmoveHandler = function touchmoveHandler(e) {\n    // eslint-disable-line no-undef\n    var capture = r.touchData.capture;\n\n    if (!capture && !eventInContainer(e)) {\n      return;\n    }\n\n    var select = r.selection;\n    var cy = r.cy;\n    var now = r.touchData.now;\n    var earlier = r.touchData.earlier;\n    var zoom = cy.zoom();\n\n    if (e.touches[0]) {\n      var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n      now[0] = pos[0];\n      now[1] = pos[1];\n    }\n\n    if (e.touches[1]) {\n      var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n      now[2] = pos[0];\n      now[3] = pos[1];\n    }\n\n    if (e.touches[2]) {\n      var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n      now[4] = pos[0];\n      now[5] = pos[1];\n    }\n\n    var startGPos = r.touchData.startGPosition;\n    var isOverThresholdDrag;\n\n    if (capture && e.touches[0] && startGPos) {\n      var disp = [];\n\n      for (var j = 0; j < now.length; j++) {\n        disp[j] = now[j] - earlier[j];\n      }\n\n      var dx = e.touches[0].clientX - startGPos[0];\n      var dx2 = dx * dx;\n      var dy = e.touches[0].clientY - startGPos[1];\n      var dy2 = dy * dy;\n      var dist2 = dx2 + dy2;\n      isOverThresholdDrag = dist2 >= r.touchTapThreshold2;\n    } // context swipe cancelling\n\n\n    if (capture && r.touchData.cxt) {\n      e.preventDefault();\n      var f1x2 = e.touches[0].clientX - offsetLeft,\n          f1y2 = e.touches[0].clientY - offsetTop;\n      var f2x2 = e.touches[1].clientX - offsetLeft,\n          f2y2 = e.touches[1].clientY - offsetTop; // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );\n\n      var distance2Sq = distanceSq(f1x2, f1y2, f2x2, f2y2);\n      var factorSq = distance2Sq / distance1Sq;\n      var distThreshold = 150;\n      var distThresholdSq = distThreshold * distThreshold;\n      var factorThreshold = 1.5;\n      var factorThresholdSq = factorThreshold * factorThreshold; // cancel ctx gestures if the distance b/t the fingers increases\n\n      if (factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq) {\n        r.touchData.cxt = false;\n        r.data.bgActivePosistion = undefined;\n        r.redrawHint('select', true);\n        var cxtEvt = {\n          originalEvent: e,\n          type: 'cxttapend',\n          position: {\n            x: now[0],\n            y: now[1]\n          }\n        };\n\n        if (r.touchData.start) {\n          r.touchData.start.unactivate().emit(cxtEvt);\n          r.touchData.start = null;\n        } else {\n          cy.emit(cxtEvt);\n        }\n      }\n    } // context swipe\n\n\n    if (capture && r.touchData.cxt) {\n      var cxtEvt = {\n        originalEvent: e,\n        type: 'cxtdrag',\n        position: {\n          x: now[0],\n          y: now[1]\n        }\n      };\n      r.data.bgActivePosistion = undefined;\n      r.redrawHint('select', true);\n\n      if (r.touchData.start) {\n        r.touchData.start.emit(cxtEvt);\n      } else {\n        cy.emit(cxtEvt);\n      }\n\n      if (r.touchData.start) {\n        r.touchData.start._private.grabbed = false;\n      }\n\n      r.touchData.cxtDragged = true;\n      var near = r.findNearestElement(now[0], now[1], true, true);\n\n      if (!r.touchData.cxtOver || near !== r.touchData.cxtOver) {\n        if (r.touchData.cxtOver) {\n          r.touchData.cxtOver.emit({\n            originalEvent: e,\n            type: 'cxtdragout',\n            position: {\n              x: now[0],\n              y: now[1]\n            }\n          });\n        }\n\n        r.touchData.cxtOver = near;\n\n        if (near) {\n          near.emit({\n            originalEvent: e,\n            type: 'cxtdragover',\n            position: {\n              x: now[0],\n              y: now[1]\n            }\n          });\n        }\n      } // box selection\n\n    } else if (capture && e.touches[2] && cy.boxSelectionEnabled()) {\n      e.preventDefault();\n      r.data.bgActivePosistion = undefined;\n      this.lastThreeTouch = +new Date();\n\n      if (!r.touchData.selecting) {\n        cy.emit({\n          originalEvent: e,\n          type: 'boxstart',\n          position: {\n            x: now[0],\n            y: now[1]\n          }\n        });\n      }\n\n      r.touchData.selecting = true;\n      r.touchData.didSelect = true;\n      select[4] = 1;\n\n      if (!select || select.length === 0 || select[0] === undefined) {\n        select[0] = (now[0] + now[2] + now[4]) / 3;\n        select[1] = (now[1] + now[3] + now[5]) / 3;\n        select[2] = (now[0] + now[2] + now[4]) / 3 + 1;\n        select[3] = (now[1] + now[3] + now[5]) / 3 + 1;\n      } else {\n        select[2] = (now[0] + now[2] + now[4]) / 3;\n        select[3] = (now[1] + now[3] + now[5]) / 3;\n      }\n\n      r.redrawHint('select', true);\n      r.redraw(); // pinch to zoom\n    } else if (capture && e.touches[1] && !r.touchData.didSelect // don't allow box selection to degrade to pinch-to-zoom\n    && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled()) {\n      // two fingers => pinch to zoom\n      e.preventDefault();\n      r.data.bgActivePosistion = undefined;\n      r.redrawHint('select', true);\n      var draggedEles = r.dragData.touchDragEles;\n\n      if (draggedEles) {\n        r.redrawHint('drag', true);\n\n        for (var i = 0; i < draggedEles.length; i++) {\n          var de_p = draggedEles[i]._private;\n          de_p.grabbed = false;\n          de_p.rscratch.inDragLayer = false;\n        }\n      }\n\n      var _start = r.touchData.start; // (x2, y2) for fingers 1 and 2\n\n      var f1x2 = e.touches[0].clientX - offsetLeft,\n          f1y2 = e.touches[0].clientY - offsetTop;\n      var f2x2 = e.touches[1].clientX - offsetLeft,\n          f2y2 = e.touches[1].clientY - offsetTop;\n      var distance2 = distance(f1x2, f1y2, f2x2, f2y2); // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );\n      // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );\n\n      var factor = distance2 / distance1;\n\n      if (twoFingersStartInside) {\n        // delta finger1\n        var df1x = f1x2 - f1x1;\n        var df1y = f1y2 - f1y1; // delta finger 2\n\n        var df2x = f2x2 - f2x1;\n        var df2y = f2y2 - f2y1; // translation is the normalised vector of the two fingers movement\n        // i.e. so pinching cancels out and moving together pans\n\n        var tx = (df1x + df2x) / 2;\n        var ty = (df1y + df2y) / 2; // now calculate the zoom\n\n        var zoom1 = cy.zoom();\n        var zoom2 = zoom1 * factor;\n        var pan1 = cy.pan(); // the model center point converted to the current rendered pos\n\n        var ctrx = modelCenter1[0] * zoom1 + pan1.x;\n        var ctry = modelCenter1[1] * zoom1 + pan1.y;\n        var pan2 = {\n          x: -zoom2 / zoom1 * (ctrx - pan1.x - tx) + ctrx,\n          y: -zoom2 / zoom1 * (ctry - pan1.y - ty) + ctry\n        }; // remove dragged eles\n\n        if (_start && _start.active()) {\n          var draggedEles = r.dragData.touchDragEles;\n          freeDraggedElements(draggedEles);\n          r.redrawHint('drag', true);\n          r.redrawHint('eles', true);\n\n          _start.unactivate().emit('freeon');\n\n          draggedEles.emit('free');\n\n          if (r.dragData.didDrag) {\n            _start.emit('dragfreeon');\n\n            draggedEles.emit('dragfree');\n          }\n        }\n\n        cy.viewport({\n          zoom: zoom2,\n          pan: pan2,\n          cancelOnFailedZoom: true\n        });\n        cy.emit('pinchzoom');\n        distance1 = distance2;\n        f1x1 = f1x2;\n        f1y1 = f1y2;\n        f2x1 = f2x2;\n        f2y1 = f2y2;\n        r.pinching = true;\n      } // Re-project\n\n\n      if (e.touches[0]) {\n        var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n        now[0] = pos[0];\n        now[1] = pos[1];\n      }\n\n      if (e.touches[1]) {\n        var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n        now[2] = pos[0];\n        now[3] = pos[1];\n      }\n\n      if (e.touches[2]) {\n        var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n        now[4] = pos[0];\n        now[5] = pos[1];\n      }\n    } else if (e.touches[0] && !r.touchData.didSelect // don't allow box selection to degrade to single finger events like panning\n    ) {\n      var start = r.touchData.start;\n      var last = r.touchData.last;\n      var near;\n\n      if (!r.hoverData.draggingEles && !r.swipePanning) {\n        near = r.findNearestElement(now[0], now[1], true, true);\n      }\n\n      if (capture && start != null) {\n        e.preventDefault();\n      } // dragging nodes\n\n\n      if (capture && start != null && r.nodeIsDraggable(start)) {\n        if (isOverThresholdDrag) {\n          // then dragging can happen\n          var draggedEles = r.dragData.touchDragEles;\n          var justStartedDrag = !r.dragData.didDrag;\n\n          if (justStartedDrag) {\n            addNodesToDrag(draggedEles, {\n              inDragLayer: true\n            });\n          }\n\n          r.dragData.didDrag = true;\n          var totalShift = {\n            x: 0,\n            y: 0\n          };\n\n          if (number$1(disp[0]) && number$1(disp[1])) {\n            totalShift.x += disp[0];\n            totalShift.y += disp[1];\n\n            if (justStartedDrag) {\n              r.redrawHint('eles', true);\n              var dragDelta = r.touchData.dragDelta;\n\n              if (dragDelta && number$1(dragDelta[0]) && number$1(dragDelta[1])) {\n                totalShift.x += dragDelta[0];\n                totalShift.y += dragDelta[1];\n              }\n            }\n          }\n\n          r.hoverData.draggingEles = true;\n          draggedEles.silentShift(totalShift).emit('position drag');\n          r.redrawHint('drag', true);\n\n          if (r.touchData.startPosition[0] == earlier[0] && r.touchData.startPosition[1] == earlier[1]) {\n            r.redrawHint('eles', true);\n          }\n\n          r.redraw();\n        } else {\n          // otherwise keep track of drag delta for later\n          var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];\n\n          if (dragDelta.length === 0) {\n            dragDelta.push(disp[0]);\n            dragDelta.push(disp[1]);\n          } else {\n            dragDelta[0] += disp[0];\n            dragDelta[1] += disp[1];\n          }\n        }\n      } // touchmove\n\n\n      {\n        triggerEvents(start || near, ['touchmove', 'tapdrag', 'vmousemove'], e, {\n          x: now[0],\n          y: now[1]\n        });\n\n        if ((!start || !start.grabbed()) && near != last) {\n          if (last) {\n            last.emit({\n              originalEvent: e,\n              type: 'tapdragout',\n              position: {\n                x: now[0],\n                y: now[1]\n              }\n            });\n          }\n\n          if (near) {\n            near.emit({\n              originalEvent: e,\n              type: 'tapdragover',\n              position: {\n                x: now[0],\n                y: now[1]\n              }\n            });\n          }\n        }\n\n        r.touchData.last = near;\n      } // check to cancel taphold\n\n      if (capture) {\n        for (var i = 0; i < now.length; i++) {\n          if (now[i] && r.touchData.startPosition[i] && isOverThresholdDrag) {\n            r.touchData.singleTouchMoved = true;\n          }\n        }\n      } // panning\n\n\n      if (capture && (start == null || start.pannable()) && cy.panningEnabled() && cy.userPanningEnabled()) {\n        var allowPassthrough = allowPanningPassthrough(start, r.touchData.starts);\n\n        if (allowPassthrough) {\n          e.preventDefault();\n\n          if (!r.data.bgActivePosistion) {\n            r.data.bgActivePosistion = array2point(r.touchData.startPosition);\n          }\n\n          if (r.swipePanning) {\n            cy.panBy({\n              x: disp[0] * zoom,\n              y: disp[1] * zoom\n            });\n            cy.emit('dragpan');\n          } else if (isOverThresholdDrag) {\n            r.swipePanning = true;\n            cy.panBy({\n              x: dx * zoom,\n              y: dy * zoom\n            });\n            cy.emit('dragpan');\n\n            if (start) {\n              start.unactivate();\n              r.redrawHint('select', true);\n              r.touchData.start = null;\n            }\n          }\n        } // Re-project\n\n\n        var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n        now[0] = pos[0];\n        now[1] = pos[1];\n      }\n    }\n\n    for (var j = 0; j < now.length; j++) {\n      earlier[j] = now[j];\n    } // the active bg indicator should be removed when making a swipe that is neither for dragging nodes or panning\n\n\n    if (capture && e.touches.length > 0 && !r.hoverData.draggingEles && !r.swipePanning && r.data.bgActivePosistion != null) {\n      r.data.bgActivePosistion = undefined;\n      r.redrawHint('select', true);\n      r.redraw();\n    }\n  }, false);\n  var touchcancelHandler;\n  r.registerBinding(containerWindow, 'touchcancel', touchcancelHandler = function touchcancelHandler(e) {\n    // eslint-disable-line no-unused-vars\n    var start = r.touchData.start;\n    r.touchData.capture = false;\n\n    if (start) {\n      start.unactivate();\n    }\n  });\n  var touchendHandler, didDoubleTouch, touchTimeout, prevTouchTimeStamp;\n  r.registerBinding(containerWindow, 'touchend', touchendHandler = function touchendHandler(e) {\n    // eslint-disable-line no-unused-vars\n    var start = r.touchData.start;\n    var capture = r.touchData.capture;\n\n    if (capture) {\n      if (e.touches.length === 0) {\n        r.touchData.capture = false;\n      }\n\n      e.preventDefault();\n    } else {\n      return;\n    }\n\n    var select = r.selection;\n    r.swipePanning = false;\n    r.hoverData.draggingEles = false;\n    var cy = r.cy;\n    var zoom = cy.zoom();\n    var now = r.touchData.now;\n    var earlier = r.touchData.earlier;\n\n    if (e.touches[0]) {\n      var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n      now[0] = pos[0];\n      now[1] = pos[1];\n    }\n\n    if (e.touches[1]) {\n      var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n      now[2] = pos[0];\n      now[3] = pos[1];\n    }\n\n    if (e.touches[2]) {\n      var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n      now[4] = pos[0];\n      now[5] = pos[1];\n    }\n\n    if (start) {\n      start.unactivate();\n    }\n\n    var ctxTapend;\n\n    if (r.touchData.cxt) {\n      ctxTapend = {\n        originalEvent: e,\n        type: 'cxttapend',\n        position: {\n          x: now[0],\n          y: now[1]\n        }\n      };\n\n      if (start) {\n        start.emit(ctxTapend);\n      } else {\n        cy.emit(ctxTapend);\n      }\n\n      if (!r.touchData.cxtDragged) {\n        var ctxTap = {\n          originalEvent: e,\n          type: 'cxttap',\n          position: {\n            x: now[0],\n            y: now[1]\n          }\n        };\n\n        if (start) {\n          start.emit(ctxTap);\n        } else {\n          cy.emit(ctxTap);\n        }\n      }\n\n      if (r.touchData.start) {\n        r.touchData.start._private.grabbed = false;\n      }\n\n      r.touchData.cxt = false;\n      r.touchData.start = null;\n      r.redraw();\n      return;\n    } // no more box selection if we don't have three fingers\n\n\n    if (!e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting) {\n      r.touchData.selecting = false;\n      var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));\n      select[0] = undefined;\n      select[1] = undefined;\n      select[2] = undefined;\n      select[3] = undefined;\n      select[4] = 0;\n      r.redrawHint('select', true);\n      cy.emit({\n        type: 'boxend',\n        originalEvent: e,\n        position: {\n          x: now[0],\n          y: now[1]\n        }\n      });\n\n      var eleWouldBeSelected = function eleWouldBeSelected(ele) {\n        return ele.selectable() && !ele.selected();\n      };\n\n      box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');\n\n      if (box.nonempty()) {\n        r.redrawHint('eles', true);\n      }\n\n      r.redraw();\n    }\n\n    if (start != null) {\n      start.unactivate();\n    }\n\n    if (e.touches[2]) {\n      r.data.bgActivePosistion = undefined;\n      r.redrawHint('select', true);\n    } else if (e.touches[1]) ; else if (e.touches[0]) ; else if (!e.touches[0]) {\n      r.data.bgActivePosistion = undefined;\n      r.redrawHint('select', true);\n      var draggedEles = r.dragData.touchDragEles;\n\n      if (start != null) {\n        var startWasGrabbed = start._private.grabbed;\n        freeDraggedElements(draggedEles);\n        r.redrawHint('drag', true);\n        r.redrawHint('eles', true);\n\n        if (startWasGrabbed) {\n          start.emit('freeon');\n          draggedEles.emit('free');\n\n          if (r.dragData.didDrag) {\n            start.emit('dragfreeon');\n            draggedEles.emit('dragfree');\n          }\n        }\n\n        triggerEvents(start, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {\n          x: now[0],\n          y: now[1]\n        });\n        start.unactivate();\n        r.touchData.start = null;\n      } else {\n        var near = r.findNearestElement(now[0], now[1], true, true);\n        triggerEvents(near, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {\n          x: now[0],\n          y: now[1]\n        });\n      }\n\n      var dx = r.touchData.startPosition[0] - now[0];\n      var dx2 = dx * dx;\n      var dy = r.touchData.startPosition[1] - now[1];\n      var dy2 = dy * dy;\n      var dist2 = dx2 + dy2;\n      var rdist2 = dist2 * zoom * zoom; // Tap event, roughly same as mouse click event for touch\n\n      if (!r.touchData.singleTouchMoved) {\n        if (!start) {\n          cy.$(':selected').unselect(['tapunselect']);\n        }\n\n        triggerEvents(start, ['tap', 'vclick'], e, {\n          x: now[0],\n          y: now[1]\n        });\n        didDoubleTouch = false;\n\n        if (e.timeStamp - prevTouchTimeStamp <= cy.multiClickDebounceTime()) {\n          touchTimeout && clearTimeout(touchTimeout);\n          didDoubleTouch = true;\n          prevTouchTimeStamp = null;\n          triggerEvents(start, ['dbltap', 'vdblclick'], e, {\n            x: now[0],\n            y: now[1]\n          });\n        } else {\n          touchTimeout = setTimeout(function () {\n            if (didDoubleTouch) return;\n            triggerEvents(start, ['onetap', 'voneclick'], e, {\n              x: now[0],\n              y: now[1]\n            });\n          }, cy.multiClickDebounceTime());\n          prevTouchTimeStamp = e.timeStamp;\n        }\n      } // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance\n\n\n      if (start != null && !r.dragData.didDrag // didn't drag nodes around\n      && start._private.selectable && rdist2 < r.touchTapThreshold2 && !r.pinching // pinch to zoom should not affect selection\n      ) {\n        if (cy.selectionType() === 'single') {\n          cy.$(isSelected).unmerge(start).unselect(['tapunselect']);\n          start.select(['tapselect']);\n        } else {\n          if (start.selected()) {\n            start.unselect(['tapunselect']);\n          } else {\n            start.select(['tapselect']);\n          }\n        }\n\n        r.redrawHint('eles', true);\n      }\n\n      r.touchData.singleTouchMoved = true;\n    }\n\n    for (var j = 0; j < now.length; j++) {\n      earlier[j] = now[j];\n    }\n\n    r.dragData.didDrag = false; // reset for next touchstart\n\n    if (e.touches.length === 0) {\n      r.touchData.dragDelta = [];\n      r.touchData.startPosition = [null, null, null, null, null, null];\n      r.touchData.startGPosition = null;\n      r.touchData.didSelect = false;\n    }\n\n    if (e.touches.length < 2) {\n      if (e.touches.length === 1) {\n        // the old start global pos'n may not be the same finger that remains\n        r.touchData.startGPosition = [e.touches[0].clientX, e.touches[0].clientY];\n      }\n\n      r.pinching = false;\n      r.redrawHint('eles', true);\n      r.redraw();\n    } //r.redraw();\n\n  }, false); // fallback compatibility layer for ms pointer events\n\n  if (typeof TouchEvent === 'undefined') {\n    var pointers = [];\n\n    var makeTouch = function makeTouch(e) {\n      return {\n        clientX: e.clientX,\n        clientY: e.clientY,\n        force: 1,\n        identifier: e.pointerId,\n        pageX: e.pageX,\n        pageY: e.pageY,\n        radiusX: e.width / 2,\n        radiusY: e.height / 2,\n        screenX: e.screenX,\n        screenY: e.screenY,\n        target: e.target\n      };\n    };\n\n    var makePointer = function makePointer(e) {\n      return {\n        event: e,\n        touch: makeTouch(e)\n      };\n    };\n\n    var addPointer = function addPointer(e) {\n      pointers.push(makePointer(e));\n    };\n\n    var removePointer = function removePointer(e) {\n      for (var i = 0; i < pointers.length; i++) {\n        var p = pointers[i];\n\n        if (p.event.pointerId === e.pointerId) {\n          pointers.splice(i, 1);\n          return;\n        }\n      }\n    };\n\n    var updatePointer = function updatePointer(e) {\n      var p = pointers.filter(function (p) {\n        return p.event.pointerId === e.pointerId;\n      })[0];\n      p.event = e;\n      p.touch = makeTouch(e);\n    };\n\n    var addTouchesToEvent = function addTouchesToEvent(e) {\n      e.touches = pointers.map(function (p) {\n        return p.touch;\n      });\n    };\n\n    var pointerIsMouse = function pointerIsMouse(e) {\n      return e.pointerType === 'mouse' || e.pointerType === 4;\n    };\n\n    r.registerBinding(r.container, 'pointerdown', function (e) {\n      if (pointerIsMouse(e)) {\n        return;\n      } // mouse already handled\n\n\n      e.preventDefault();\n      addPointer(e);\n      addTouchesToEvent(e);\n      touchstartHandler(e);\n    });\n    r.registerBinding(r.container, 'pointerup', function (e) {\n      if (pointerIsMouse(e)) {\n        return;\n      } // mouse already handled\n\n\n      removePointer(e);\n      addTouchesToEvent(e);\n      touchendHandler(e);\n    });\n    r.registerBinding(r.container, 'pointercancel', function (e) {\n      if (pointerIsMouse(e)) {\n        return;\n      } // mouse already handled\n\n\n      removePointer(e);\n      addTouchesToEvent(e);\n      touchcancelHandler(e);\n    });\n    r.registerBinding(r.container, 'pointermove', function (e) {\n      if (pointerIsMouse(e)) {\n        return;\n      } // mouse already handled\n\n\n      e.preventDefault();\n      updatePointer(e);\n      addTouchesToEvent(e);\n      touchmoveHandler(e);\n    });\n  }\n};\n\nvar BRp$2 = {};\n\nBRp$2.generatePolygon = function (name, points) {\n  return this.nodeShapes[name] = {\n    renderer: this,\n    name: name,\n    points: points,\n    draw: function draw(context, centerX, centerY, width, height) {\n      this.renderer.nodeShapeImpl('polygon', context, centerX, centerY, width, height, this.points);\n    },\n    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n      return polygonIntersectLine(x, y, this.points, nodeX, nodeY, width / 2, height / 2, padding);\n    },\n    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n      return pointInsidePolygon(x, y, this.points, centerX, centerY, width, height, [0, -1], padding);\n    }\n  };\n};\n\nBRp$2.generateEllipse = function () {\n  return this.nodeShapes['ellipse'] = {\n    renderer: this,\n    name: 'ellipse',\n    draw: function draw(context, centerX, centerY, width, height) {\n      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n    },\n    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n      return intersectLineEllipse(x, y, nodeX, nodeY, width / 2 + padding, height / 2 + padding);\n    },\n    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n      return checkInEllipse(x, y, width, height, centerX, centerY, padding);\n    }\n  };\n};\n\nBRp$2.generateRoundPolygon = function (name, points) {\n  // Pre-compute control points\n  // Since these points depend on the radius length (which in turns depend on the width/height of the node) we will only pre-compute\n  // the unit vectors.\n  // For simplicity the layout will be:\n  // [ p0, UnitVectorP0P1, p1, UniVectorP1P2, ..., pn, UnitVectorPnP0 ]\n  var allPoints = new Array(points.length * 2);\n\n  for (var i = 0; i < points.length / 2; i++) {\n    var sourceIndex = i * 2;\n    var destIndex = void 0;\n\n    if (i < points.length / 2 - 1) {\n      destIndex = (i + 1) * 2;\n    } else {\n      destIndex = 0;\n    }\n\n    allPoints[i * 4] = points[sourceIndex];\n    allPoints[i * 4 + 1] = points[sourceIndex + 1];\n    var xDest = points[destIndex] - points[sourceIndex];\n    var yDest = points[destIndex + 1] - points[sourceIndex + 1];\n    var norm = Math.sqrt(xDest * xDest + yDest * yDest);\n    allPoints[i * 4 + 2] = xDest / norm;\n    allPoints[i * 4 + 3] = yDest / norm;\n  }\n\n  return this.nodeShapes[name] = {\n    renderer: this,\n    name: name,\n    points: allPoints,\n    draw: function draw(context, centerX, centerY, width, height) {\n      this.renderer.nodeShapeImpl('round-polygon', context, centerX, centerY, width, height, this.points);\n    },\n    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n      return roundPolygonIntersectLine(x, y, this.points, nodeX, nodeY, width, height);\n    },\n    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n      return pointInsideRoundPolygon(x, y, this.points, centerX, centerY, width, height);\n    }\n  };\n};\n\nBRp$2.generateRoundRectangle = function () {\n  return this.nodeShapes['round-rectangle'] = this.nodeShapes['roundrectangle'] = {\n    renderer: this,\n    name: 'round-rectangle',\n    points: generateUnitNgonPointsFitToSquare(4, 0),\n    draw: function draw(context, centerX, centerY, width, height) {\n      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n    },\n    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n      return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);\n    },\n    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n      var cornerRadius = getRoundRectangleRadius(width, height);\n      var diam = cornerRadius * 2; // Check hBox\n\n      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {\n        return true;\n      } // Check vBox\n\n\n      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {\n        return true;\n      } // Check top left quarter circle\n\n\n      if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY - height / 2 + cornerRadius, padding)) {\n        return true;\n      } // Check top right quarter circle\n\n\n      if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY - height / 2 + cornerRadius, padding)) {\n        return true;\n      } // Check bottom right quarter circle\n\n\n      if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n        return true;\n      } // Check bottom left quarter circle\n\n\n      if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n        return true;\n      }\n\n      return false;\n    }\n  };\n};\n\nBRp$2.generateCutRectangle = function () {\n  return this.nodeShapes['cut-rectangle'] = this.nodeShapes['cutrectangle'] = {\n    renderer: this,\n    name: 'cut-rectangle',\n    cornerLength: getCutRectangleCornerLength(),\n    points: generateUnitNgonPointsFitToSquare(4, 0),\n    draw: function draw(context, centerX, centerY, width, height) {\n      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n    },\n    generateCutTrianglePts: function generateCutTrianglePts(width, height, centerX, centerY) {\n      var cl = this.cornerLength;\n      var hh = height / 2;\n      var hw = width / 2;\n      var xBegin = centerX - hw;\n      var xEnd = centerX + hw;\n      var yBegin = centerY - hh;\n      var yEnd = centerY + hh; // points are in clockwise order, inner (imaginary) triangle pt on [4, 5]\n\n      return {\n        topLeft: [xBegin, yBegin + cl, xBegin + cl, yBegin, xBegin + cl, yBegin + cl],\n        topRight: [xEnd - cl, yBegin, xEnd, yBegin + cl, xEnd - cl, yBegin + cl],\n        bottomRight: [xEnd, yEnd - cl, xEnd - cl, yEnd, xEnd - cl, yEnd - cl],\n        bottomLeft: [xBegin + cl, yEnd, xBegin, yEnd - cl, xBegin + cl, yEnd - cl]\n      };\n    },\n    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n      var cPts = this.generateCutTrianglePts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);\n      var pts = [].concat.apply([], [cPts.topLeft.splice(0, 4), cPts.topRight.splice(0, 4), cPts.bottomRight.splice(0, 4), cPts.bottomLeft.splice(0, 4)]);\n      return polygonIntersectLine(x, y, pts, nodeX, nodeY);\n    },\n    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n      // Check hBox\n      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * this.cornerLength, [0, -1], padding)) {\n        return true;\n      } // Check vBox\n\n\n      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * this.cornerLength, height, [0, -1], padding)) {\n        return true;\n      }\n\n      var cutTrianglePts = this.generateCutTrianglePts(width, height, centerX, centerY);\n      return pointInsidePolygonPoints(x, y, cutTrianglePts.topLeft) || pointInsidePolygonPoints(x, y, cutTrianglePts.topRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomLeft);\n    }\n  };\n};\n\nBRp$2.generateBarrel = function () {\n  return this.nodeShapes['barrel'] = {\n    renderer: this,\n    name: 'barrel',\n    points: generateUnitNgonPointsFitToSquare(4, 0),\n    draw: function draw(context, centerX, centerY, width, height) {\n      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n    },\n    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n      // use two fixed t values for the bezier curve approximation\n      var t0 = 0.15;\n      var t1 = 0.5;\n      var t2 = 0.85;\n      var bPts = this.generateBarrelBezierPts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);\n\n      var approximateBarrelCurvePts = function approximateBarrelCurvePts(pts) {\n        // approximate curve pts based on the two t values\n        var m0 = qbezierPtAt({\n          x: pts[0],\n          y: pts[1]\n        }, {\n          x: pts[2],\n          y: pts[3]\n        }, {\n          x: pts[4],\n          y: pts[5]\n        }, t0);\n        var m1 = qbezierPtAt({\n          x: pts[0],\n          y: pts[1]\n        }, {\n          x: pts[2],\n          y: pts[3]\n        }, {\n          x: pts[4],\n          y: pts[5]\n        }, t1);\n        var m2 = qbezierPtAt({\n          x: pts[0],\n          y: pts[1]\n        }, {\n          x: pts[2],\n          y: pts[3]\n        }, {\n          x: pts[4],\n          y: pts[5]\n        }, t2);\n        return [pts[0], pts[1], m0.x, m0.y, m1.x, m1.y, m2.x, m2.y, pts[4], pts[5]];\n      };\n\n      var pts = [].concat(approximateBarrelCurvePts(bPts.topLeft), approximateBarrelCurvePts(bPts.topRight), approximateBarrelCurvePts(bPts.bottomRight), approximateBarrelCurvePts(bPts.bottomLeft));\n      return polygonIntersectLine(x, y, pts, nodeX, nodeY);\n    },\n    generateBarrelBezierPts: function generateBarrelBezierPts(width, height, centerX, centerY) {\n      var hh = height / 2;\n      var hw = width / 2;\n      var xBegin = centerX - hw;\n      var xEnd = centerX + hw;\n      var yBegin = centerY - hh;\n      var yEnd = centerY + hh;\n      var curveConstants = getBarrelCurveConstants(width, height);\n      var hOffset = curveConstants.heightOffset;\n      var wOffset = curveConstants.widthOffset;\n      var ctrlPtXOffset = curveConstants.ctrlPtOffsetPct * width; // points are in clockwise order, inner (imaginary) control pt on [4, 5]\n\n      var pts = {\n        topLeft: [xBegin, yBegin + hOffset, xBegin + ctrlPtXOffset, yBegin, xBegin + wOffset, yBegin],\n        topRight: [xEnd - wOffset, yBegin, xEnd - ctrlPtXOffset, yBegin, xEnd, yBegin + hOffset],\n        bottomRight: [xEnd, yEnd - hOffset, xEnd - ctrlPtXOffset, yEnd, xEnd - wOffset, yEnd],\n        bottomLeft: [xBegin + wOffset, yEnd, xBegin + ctrlPtXOffset, yEnd, xBegin, yEnd - hOffset]\n      };\n      pts.topLeft.isTop = true;\n      pts.topRight.isTop = true;\n      pts.bottomLeft.isBottom = true;\n      pts.bottomRight.isBottom = true;\n      return pts;\n    },\n    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n      var curveConstants = getBarrelCurveConstants(width, height);\n      var hOffset = curveConstants.heightOffset;\n      var wOffset = curveConstants.widthOffset; // Check hBox\n\n      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * hOffset, [0, -1], padding)) {\n        return true;\n      } // Check vBox\n\n\n      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * wOffset, height, [0, -1], padding)) {\n        return true;\n      }\n\n      var barrelCurvePts = this.generateBarrelBezierPts(width, height, centerX, centerY);\n\n      var getCurveT = function getCurveT(x, y, curvePts) {\n        var x0 = curvePts[4];\n        var x1 = curvePts[2];\n        var x2 = curvePts[0];\n        var y0 = curvePts[5]; // var y1 = curvePts[ 3 ];\n\n        var y2 = curvePts[1];\n        var xMin = Math.min(x0, x2);\n        var xMax = Math.max(x0, x2);\n        var yMin = Math.min(y0, y2);\n        var yMax = Math.max(y0, y2);\n\n        if (xMin <= x && x <= xMax && yMin <= y && y <= yMax) {\n          var coeff = bezierPtsToQuadCoeff(x0, x1, x2);\n          var roots = solveQuadratic(coeff[0], coeff[1], coeff[2], x);\n          var validRoots = roots.filter(function (r) {\n            return 0 <= r && r <= 1;\n          });\n\n          if (validRoots.length > 0) {\n            return validRoots[0];\n          }\n        }\n\n        return null;\n      };\n\n      var curveRegions = Object.keys(barrelCurvePts);\n\n      for (var i = 0; i < curveRegions.length; i++) {\n        var corner = curveRegions[i];\n        var cornerPts = barrelCurvePts[corner];\n        var t = getCurveT(x, y, cornerPts);\n\n        if (t == null) {\n          continue;\n        }\n\n        var y0 = cornerPts[5];\n        var y1 = cornerPts[3];\n        var y2 = cornerPts[1];\n        var bezY = qbezierAt(y0, y1, y2, t);\n\n        if (cornerPts.isTop && bezY <= y) {\n          return true;\n        }\n\n        if (cornerPts.isBottom && y <= bezY) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  };\n};\n\nBRp$2.generateBottomRoundrectangle = function () {\n  return this.nodeShapes['bottom-round-rectangle'] = this.nodeShapes['bottomroundrectangle'] = {\n    renderer: this,\n    name: 'bottom-round-rectangle',\n    points: generateUnitNgonPointsFitToSquare(4, 0),\n    draw: function draw(context, centerX, centerY, width, height) {\n      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n    },\n    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n      var topStartX = nodeX - (width / 2 + padding);\n      var topStartY = nodeY - (height / 2 + padding);\n      var topEndY = topStartY;\n      var topEndX = nodeX + (width / 2 + padding);\n      var topIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);\n\n      if (topIntersections.length > 0) {\n        return topIntersections;\n      }\n\n      return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);\n    },\n    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n      var cornerRadius = getRoundRectangleRadius(width, height);\n      var diam = 2 * cornerRadius; // Check hBox\n\n      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {\n        return true;\n      } // Check vBox\n\n\n      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {\n        return true;\n      } // check non-rounded top side\n\n\n      var outerWidth = width / 2 + 2 * padding;\n      var outerHeight = height / 2 + 2 * padding;\n      var points = [centerX - outerWidth, centerY - outerHeight, centerX - outerWidth, centerY, centerX + outerWidth, centerY, centerX + outerWidth, centerY - outerHeight];\n\n      if (pointInsidePolygonPoints(x, y, points)) {\n        return true;\n      } // Check bottom right quarter circle\n\n\n      if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n        return true;\n      } // Check bottom left quarter circle\n\n\n      if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n        return true;\n      }\n\n      return false;\n    }\n  };\n};\n\nBRp$2.registerNodeShapes = function () {\n  var nodeShapes = this.nodeShapes = {};\n  var renderer = this;\n  this.generateEllipse();\n  this.generatePolygon('triangle', generateUnitNgonPointsFitToSquare(3, 0));\n  this.generateRoundPolygon('round-triangle', generateUnitNgonPointsFitToSquare(3, 0));\n  this.generatePolygon('rectangle', generateUnitNgonPointsFitToSquare(4, 0));\n  nodeShapes['square'] = nodeShapes['rectangle'];\n  this.generateRoundRectangle();\n  this.generateCutRectangle();\n  this.generateBarrel();\n  this.generateBottomRoundrectangle();\n  {\n    var diamondPoints = [0, 1, 1, 0, 0, -1, -1, 0];\n    this.generatePolygon('diamond', diamondPoints);\n    this.generateRoundPolygon('round-diamond', diamondPoints);\n  }\n  this.generatePolygon('pentagon', generateUnitNgonPointsFitToSquare(5, 0));\n  this.generateRoundPolygon('round-pentagon', generateUnitNgonPointsFitToSquare(5, 0));\n  this.generatePolygon('hexagon', generateUnitNgonPointsFitToSquare(6, 0));\n  this.generateRoundPolygon('round-hexagon', generateUnitNgonPointsFitToSquare(6, 0));\n  this.generatePolygon('heptagon', generateUnitNgonPointsFitToSquare(7, 0));\n  this.generateRoundPolygon('round-heptagon', generateUnitNgonPointsFitToSquare(7, 0));\n  this.generatePolygon('octagon', generateUnitNgonPointsFitToSquare(8, 0));\n  this.generateRoundPolygon('round-octagon', generateUnitNgonPointsFitToSquare(8, 0));\n  var star5Points = new Array(20);\n  {\n    var outerPoints = generateUnitNgonPoints(5, 0);\n    var innerPoints = generateUnitNgonPoints(5, Math.PI / 5); // Outer radius is 1; inner radius of star is smaller\n\n    var innerRadius = 0.5 * (3 - Math.sqrt(5));\n    innerRadius *= 1.57;\n\n    for (var i = 0; i < innerPoints.length / 2; i++) {\n      innerPoints[i * 2] *= innerRadius;\n      innerPoints[i * 2 + 1] *= innerRadius;\n    }\n\n    for (var i = 0; i < 20 / 4; i++) {\n      star5Points[i * 4] = outerPoints[i * 2];\n      star5Points[i * 4 + 1] = outerPoints[i * 2 + 1];\n      star5Points[i * 4 + 2] = innerPoints[i * 2];\n      star5Points[i * 4 + 3] = innerPoints[i * 2 + 1];\n    }\n  }\n  star5Points = fitPolygonToSquare(star5Points);\n  this.generatePolygon('star', star5Points);\n  this.generatePolygon('vee', [-1, -1, 0, -0.333, 1, -1, 0, 1]);\n  this.generatePolygon('rhomboid', [-1, -1, 0.333, -1, 1, 1, -0.333, 1]);\n  this.generatePolygon('right-rhomboid', [-0.333, -1, 1, -1, 0.333, 1, -1, 1]);\n  this.nodeShapes['concavehexagon'] = this.generatePolygon('concave-hexagon', [-1, -0.95, -0.75, 0, -1, 0.95, 1, 0.95, 0.75, 0, 1, -0.95]);\n  {\n    var tagPoints = [-1, -1, 0.25, -1, 1, 0, 0.25, 1, -1, 1];\n    this.generatePolygon('tag', tagPoints);\n    this.generateRoundPolygon('round-tag', tagPoints);\n  }\n\n  nodeShapes.makePolygon = function (points) {\n    // use caching on user-specified polygons so they are as fast as native shapes\n    var key = points.join('$');\n    var name = 'polygon-' + key;\n    var shape;\n\n    if (shape = this[name]) {\n      // got cached shape\n      return shape;\n    } // create and cache new shape\n\n\n    return renderer.generatePolygon(name, points);\n  };\n};\n\nvar BRp$1 = {};\n\nBRp$1.timeToRender = function () {\n  return this.redrawTotalTime / this.redrawCount;\n};\n\nBRp$1.redraw = function (options) {\n  options = options || staticEmptyObject();\n  var r = this;\n\n  if (r.averageRedrawTime === undefined) {\n    r.averageRedrawTime = 0;\n  }\n\n  if (r.lastRedrawTime === undefined) {\n    r.lastRedrawTime = 0;\n  }\n\n  if (r.lastDrawTime === undefined) {\n    r.lastDrawTime = 0;\n  }\n\n  r.requestedFrame = true;\n  r.renderOptions = options;\n};\n\nBRp$1.beforeRender = function (fn, priority) {\n  // the renderer can't add tick callbacks when destroyed\n  if (this.destroyed) {\n    return;\n  }\n\n  if (priority == null) {\n    error('Priority is not optional for beforeRender');\n  }\n\n  var cbs = this.beforeRenderCallbacks;\n  cbs.push({\n    fn: fn,\n    priority: priority\n  }); // higher priority callbacks executed first\n\n  cbs.sort(function (a, b) {\n    return b.priority - a.priority;\n  });\n};\n\nvar beforeRenderCallbacks = function beforeRenderCallbacks(r, willDraw, startTime) {\n  var cbs = r.beforeRenderCallbacks;\n\n  for (var i = 0; i < cbs.length; i++) {\n    cbs[i].fn(willDraw, startTime);\n  }\n};\n\nBRp$1.startRenderLoop = function () {\n  var r = this;\n  var cy = r.cy;\n\n  if (r.renderLoopStarted) {\n    return;\n  } else {\n    r.renderLoopStarted = true;\n  }\n\n  var renderFn = function renderFn(requestTime) {\n    if (r.destroyed) {\n      return;\n    }\n\n    if (cy.batching()) ; else if (r.requestedFrame && !r.skipFrame) {\n      beforeRenderCallbacks(r, true, requestTime);\n      var startTime = performanceNow();\n      r.render(r.renderOptions);\n      var endTime = r.lastDrawTime = performanceNow();\n\n      if (r.averageRedrawTime === undefined) {\n        r.averageRedrawTime = endTime - startTime;\n      }\n\n      if (r.redrawCount === undefined) {\n        r.redrawCount = 0;\n      }\n\n      r.redrawCount++;\n\n      if (r.redrawTotalTime === undefined) {\n        r.redrawTotalTime = 0;\n      }\n\n      var duration = endTime - startTime;\n      r.redrawTotalTime += duration;\n      r.lastRedrawTime = duration; // use a weighted average with a bias from the previous average so we don't spike so easily\n\n      r.averageRedrawTime = r.averageRedrawTime / 2 + duration / 2;\n      r.requestedFrame = false;\n    } else {\n      beforeRenderCallbacks(r, false, requestTime);\n    }\n\n    r.skipFrame = false;\n    requestAnimationFrame(renderFn);\n  };\n\n  requestAnimationFrame(renderFn);\n};\n\nvar BaseRenderer = function BaseRenderer(options) {\n  this.init(options);\n};\n\nvar BR = BaseRenderer;\nvar BRp = BR.prototype;\nBRp.clientFunctions = ['redrawHint', 'render', 'renderTo', 'matchCanvasSize', 'nodeShapeImpl', 'arrowShapeImpl'];\n\nBRp.init = function (options) {\n  var r = this;\n  r.options = options;\n  r.cy = options.cy;\n  var ctr = r.container = options.cy.container();\n  var containerWindow = r.cy.window(); // prepend a stylesheet in the head such that\n\n  if (containerWindow) {\n    var document = containerWindow.document;\n    var head = document.head;\n    var stylesheetId = '__________cytoscape_stylesheet';\n    var className = '__________cytoscape_container';\n    var stylesheetAlreadyExists = document.getElementById(stylesheetId) != null;\n\n    if (ctr.className.indexOf(className) < 0) {\n      ctr.className = (ctr.className || '') + ' ' + className;\n    }\n\n    if (!stylesheetAlreadyExists) {\n      var stylesheet = document.createElement('style');\n      stylesheet.id = stylesheetId;\n      stylesheet.textContent = '.' + className + ' { position: relative; }';\n      head.insertBefore(stylesheet, head.children[0]); // first so lowest priority\n    }\n\n    var computedStyle = containerWindow.getComputedStyle(ctr);\n    var position = computedStyle.getPropertyValue('position');\n\n    if (position === 'static') {\n      warn('A Cytoscape container has style position:static and so can not use UI extensions properly');\n    }\n  }\n\n  r.selection = [undefined, undefined, undefined, undefined, 0]; // Coordinates for selection box, plus enabled flag\n\n  r.bezierProjPcts = [0.05, 0.225, 0.4, 0.5, 0.6, 0.775, 0.95]; //--Pointer-related data\n\n  r.hoverData = {\n    down: null,\n    last: null,\n    downTime: null,\n    triggerMode: null,\n    dragging: false,\n    initialPan: [null, null],\n    capture: false\n  };\n  r.dragData = {\n    possibleDragElements: []\n  };\n  r.touchData = {\n    start: null,\n    capture: false,\n    // These 3 fields related to tap, taphold events\n    startPosition: [null, null, null, null, null, null],\n    singleTouchStartTime: null,\n    singleTouchMoved: true,\n    now: [null, null, null, null, null, null],\n    earlier: [null, null, null, null, null, null]\n  };\n  r.redraws = 0;\n  r.showFps = options.showFps;\n  r.debug = options.debug;\n  r.hideEdgesOnViewport = options.hideEdgesOnViewport;\n  r.textureOnViewport = options.textureOnViewport;\n  r.wheelSensitivity = options.wheelSensitivity;\n  r.motionBlurEnabled = options.motionBlur; // on by default\n\n  r.forcedPixelRatio = number$1(options.pixelRatio) ? options.pixelRatio : null;\n  r.motionBlur = options.motionBlur; // for initial kick off\n\n  r.motionBlurOpacity = options.motionBlurOpacity;\n  r.motionBlurTransparency = 1 - r.motionBlurOpacity;\n  r.motionBlurPxRatio = 1;\n  r.mbPxRBlurry = 1; //0.8;\n\n  r.minMbLowQualFrames = 4;\n  r.fullQualityMb = false;\n  r.clearedForMotionBlur = [];\n  r.desktopTapThreshold = options.desktopTapThreshold;\n  r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;\n  r.touchTapThreshold = options.touchTapThreshold;\n  r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;\n  r.tapholdDuration = 500;\n  r.bindings = [];\n  r.beforeRenderCallbacks = [];\n  r.beforeRenderPriorities = {\n    // higher priority execs before lower one\n    animations: 400,\n    eleCalcs: 300,\n    eleTxrDeq: 200,\n    lyrTxrDeq: 150,\n    lyrTxrSkip: 100\n  };\n  r.registerNodeShapes();\n  r.registerArrowShapes();\n  r.registerCalculationListeners();\n};\n\nBRp.notify = function (eventName, eles) {\n  var r = this;\n  var cy = r.cy; // the renderer can't be notified after it's destroyed\n\n  if (this.destroyed) {\n    return;\n  }\n\n  if (eventName === 'init') {\n    r.load();\n    return;\n  }\n\n  if (eventName === 'destroy') {\n    r.destroy();\n    return;\n  }\n\n  if (eventName === 'add' || eventName === 'remove' || eventName === 'move' && cy.hasCompoundNodes() || eventName === 'load' || eventName === 'zorder' || eventName === 'mount') {\n    r.invalidateCachedZSortedEles();\n  }\n\n  if (eventName === 'viewport') {\n    r.redrawHint('select', true);\n  }\n\n  if (eventName === 'load' || eventName === 'resize' || eventName === 'mount') {\n    r.invalidateContainerClientCoordsCache();\n    r.matchCanvasSize(r.container);\n  }\n\n  r.redrawHint('eles', true);\n  r.redrawHint('drag', true);\n  this.startRenderLoop();\n  this.redraw();\n};\n\nBRp.destroy = function () {\n  var r = this;\n  r.destroyed = true;\n  r.cy.stopAnimationLoop();\n\n  for (var i = 0; i < r.bindings.length; i++) {\n    var binding = r.bindings[i];\n    var b = binding;\n    var tgt = b.target;\n    (tgt.off || tgt.removeEventListener).apply(tgt, b.args);\n  }\n\n  r.bindings = [];\n  r.beforeRenderCallbacks = [];\n  r.onUpdateEleCalcsFns = [];\n\n  if (r.removeObserver) {\n    r.removeObserver.disconnect();\n  }\n\n  if (r.styleObserver) {\n    r.styleObserver.disconnect();\n  }\n\n  if (r.resizeObserver) {\n    r.resizeObserver.disconnect();\n  }\n\n  if (r.labelCalcDiv) {\n    try {\n      document.body.removeChild(r.labelCalcDiv); // eslint-disable-line no-undef\n    } catch (e) {// ie10 issue #1014\n    }\n  }\n};\n\nBRp.isHeadless = function () {\n  return false;\n};\n\n[BRp$f, BRp$5, BRp$4, BRp$3, BRp$2, BRp$1].forEach(function (props) {\n  extend(BRp, props);\n});\n\nvar fullFpsTime = 1000 / 60; // assume 60 frames per second\n\nvar defs = {\n  setupDequeueing: function setupDequeueing(opts) {\n    return function setupDequeueingImpl() {\n      var self = this;\n      var r = this.renderer;\n\n      if (self.dequeueingSetup) {\n        return;\n      } else {\n        self.dequeueingSetup = true;\n      }\n\n      var queueRedraw = debounce__default[\"default\"](function () {\n        r.redrawHint('eles', true);\n        r.redrawHint('drag', true);\n        r.redraw();\n      }, opts.deqRedrawThreshold);\n\n      var dequeue = function dequeue(willDraw, frameStartTime) {\n        var startTime = performanceNow();\n        var avgRenderTime = r.averageRedrawTime;\n        var renderTime = r.lastRedrawTime;\n        var deqd = [];\n        var extent = r.cy.extent();\n        var pixelRatio = r.getPixelRatio(); // if we aren't in a tick that causes a draw, then the rendered style\n        // queue won't automatically be flushed before dequeueing starts\n\n        if (!willDraw) {\n          r.flushRenderedStyleQueue();\n        }\n\n        while (true) {\n          // eslint-disable-line no-constant-condition\n          var now = performanceNow();\n          var duration = now - startTime;\n          var frameDuration = now - frameStartTime;\n\n          if (renderTime < fullFpsTime) {\n            // if we're rendering faster than the ideal fps, then do dequeueing\n            // during all of the remaining frame time\n            var timeAvailable = fullFpsTime - (willDraw ? avgRenderTime : 0);\n\n            if (frameDuration >= opts.deqFastCost * timeAvailable) {\n              break;\n            }\n          } else {\n            if (willDraw) {\n              if (duration >= opts.deqCost * renderTime || duration >= opts.deqAvgCost * avgRenderTime) {\n                break;\n              }\n            } else if (frameDuration >= opts.deqNoDrawCost * fullFpsTime) {\n              break;\n            }\n          }\n\n          var thisDeqd = opts.deq(self, pixelRatio, extent);\n\n          if (thisDeqd.length > 0) {\n            for (var i = 0; i < thisDeqd.length; i++) {\n              deqd.push(thisDeqd[i]);\n            }\n          } else {\n            break;\n          }\n        } // callbacks on dequeue\n\n\n        if (deqd.length > 0) {\n          opts.onDeqd(self, deqd);\n\n          if (!willDraw && opts.shouldRedraw(self, deqd, pixelRatio, extent)) {\n            queueRedraw();\n          }\n        }\n      };\n\n      var priority = opts.priority || noop$1;\n      r.beforeRender(dequeue, priority(self));\n    };\n  }\n};\n\n// Uses keys so elements may share the same cache.\n\nvar ElementTextureCacheLookup = /*#__PURE__*/function () {\n  function ElementTextureCacheLookup(getKey) {\n    var doesEleInvalidateKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : falsify;\n\n    _classCallCheck(this, ElementTextureCacheLookup);\n\n    this.idsByKey = new Map$1();\n    this.keyForId = new Map$1();\n    this.cachesByLvl = new Map$1();\n    this.lvls = [];\n    this.getKey = getKey;\n    this.doesEleInvalidateKey = doesEleInvalidateKey;\n  }\n\n  _createClass(ElementTextureCacheLookup, [{\n    key: \"getIdsFor\",\n    value: function getIdsFor(key) {\n      if (key == null) {\n        error(\"Can not get id list for null key\");\n      }\n\n      var idsByKey = this.idsByKey;\n      var ids = this.idsByKey.get(key);\n\n      if (!ids) {\n        ids = new Set$1();\n        idsByKey.set(key, ids);\n      }\n\n      return ids;\n    }\n  }, {\n    key: \"addIdForKey\",\n    value: function addIdForKey(key, id) {\n      if (key != null) {\n        this.getIdsFor(key).add(id);\n      }\n    }\n  }, {\n    key: \"deleteIdForKey\",\n    value: function deleteIdForKey(key, id) {\n      if (key != null) {\n        this.getIdsFor(key)[\"delete\"](id);\n      }\n    }\n  }, {\n    key: \"getNumberOfIdsForKey\",\n    value: function getNumberOfIdsForKey(key) {\n      if (key == null) {\n        return 0;\n      } else {\n        return this.getIdsFor(key).size;\n      }\n    }\n  }, {\n    key: \"updateKeyMappingFor\",\n    value: function updateKeyMappingFor(ele) {\n      var id = ele.id();\n      var prevKey = this.keyForId.get(id);\n      var currKey = this.getKey(ele);\n      this.deleteIdForKey(prevKey, id);\n      this.addIdForKey(currKey, id);\n      this.keyForId.set(id, currKey);\n    }\n  }, {\n    key: \"deleteKeyMappingFor\",\n    value: function deleteKeyMappingFor(ele) {\n      var id = ele.id();\n      var prevKey = this.keyForId.get(id);\n      this.deleteIdForKey(prevKey, id);\n      this.keyForId[\"delete\"](id);\n    }\n  }, {\n    key: \"keyHasChangedFor\",\n    value: function keyHasChangedFor(ele) {\n      var id = ele.id();\n      var prevKey = this.keyForId.get(id);\n      var newKey = this.getKey(ele);\n      return prevKey !== newKey;\n    }\n  }, {\n    key: \"isInvalid\",\n    value: function isInvalid(ele) {\n      return this.keyHasChangedFor(ele) || this.doesEleInvalidateKey(ele);\n    }\n  }, {\n    key: \"getCachesAt\",\n    value: function getCachesAt(lvl) {\n      var cachesByLvl = this.cachesByLvl,\n          lvls = this.lvls;\n      var caches = cachesByLvl.get(lvl);\n\n      if (!caches) {\n        caches = new Map$1();\n        cachesByLvl.set(lvl, caches);\n        lvls.push(lvl);\n      }\n\n      return caches;\n    }\n  }, {\n    key: \"getCache\",\n    value: function getCache(key, lvl) {\n      return this.getCachesAt(lvl).get(key);\n    }\n  }, {\n    key: \"get\",\n    value: function get(ele, lvl) {\n      var key = this.getKey(ele);\n      var cache = this.getCache(key, lvl); // getting for an element may need to add to the id list b/c eles can share keys\n\n      if (cache != null) {\n        this.updateKeyMappingFor(ele);\n      }\n\n      return cache;\n    }\n  }, {\n    key: \"getForCachedKey\",\n    value: function getForCachedKey(ele, lvl) {\n      var key = this.keyForId.get(ele.id()); // n.b. use cached key, not newly computed key\n\n      var cache = this.getCache(key, lvl);\n      return cache;\n    }\n  }, {\n    key: \"hasCache\",\n    value: function hasCache(key, lvl) {\n      return this.getCachesAt(lvl).has(key);\n    }\n  }, {\n    key: \"has\",\n    value: function has(ele, lvl) {\n      var key = this.getKey(ele);\n      return this.hasCache(key, lvl);\n    }\n  }, {\n    key: \"setCache\",\n    value: function setCache(key, lvl, cache) {\n      cache.key = key;\n      this.getCachesAt(lvl).set(key, cache);\n    }\n  }, {\n    key: \"set\",\n    value: function set(ele, lvl, cache) {\n      var key = this.getKey(ele);\n      this.setCache(key, lvl, cache);\n      this.updateKeyMappingFor(ele);\n    }\n  }, {\n    key: \"deleteCache\",\n    value: function deleteCache(key, lvl) {\n      this.getCachesAt(lvl)[\"delete\"](key);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(ele, lvl) {\n      var key = this.getKey(ele);\n      this.deleteCache(key, lvl);\n    }\n  }, {\n    key: \"invalidateKey\",\n    value: function invalidateKey(key) {\n      var _this = this;\n\n      this.lvls.forEach(function (lvl) {\n        return _this.deleteCache(key, lvl);\n      });\n    } // returns true if no other eles reference the invalidated cache (n.b. other eles may need the cache with the same key)\n\n  }, {\n    key: \"invalidate\",\n    value: function invalidate(ele) {\n      var id = ele.id();\n      var key = this.keyForId.get(id); // n.b. use stored key rather than current (potential key)\n\n      this.deleteKeyMappingFor(ele);\n      var entireKeyInvalidated = this.doesEleInvalidateKey(ele);\n\n      if (entireKeyInvalidated) {\n        // clear mapping for current key\n        this.invalidateKey(key);\n      }\n\n      return entireKeyInvalidated || this.getNumberOfIdsForKey(key) === 0;\n    }\n  }]);\n\n  return ElementTextureCacheLookup;\n}();\n\nvar minTxrH = 25; // the size of the texture cache for small height eles (special case)\n\nvar txrStepH = 50; // the min size of the regular cache, and the size it increases with each step up\n\nvar minLvl$1 = -4; // when scaling smaller than that we don't need to re-render\n\nvar maxLvl$1 = 3; // when larger than this scale just render directly (caching is not helpful)\n\nvar maxZoom$1 = 7.99; // beyond this zoom level, layered textures are not used\n\nvar eleTxrSpacing = 8; // spacing between elements on textures to avoid blitting overlaps\n\nvar defTxrWidth = 1024; // default/minimum texture width\n\nvar maxTxrW = 1024; // the maximum width of a texture\n\nvar maxTxrH = 1024; // the maximum height of a texture\n\nvar minUtility = 0.2; // if usage of texture is less than this, it is retired\n\nvar maxFullness = 0.8; // fullness of texture after which queue removal is checked\n\nvar maxFullnessChecks = 10; // dequeued after this many checks\n\nvar deqCost$1 = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame\n\nvar deqAvgCost$1 = 0.1; // % of add'l rendering cost compared to average overall redraw time\n\nvar deqNoDrawCost$1 = 0.9; // % of avg frame time that can be used for dequeueing when not drawing\n\nvar deqFastCost$1 = 0.9; // % of frame time to be used when >60fps\n\nvar deqRedrawThreshold$1 = 100; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile\n\nvar maxDeqSize$1 = 1; // number of eles to dequeue and render at higher texture in each batch\n\nvar getTxrReasons = {\n  dequeue: 'dequeue',\n  downscale: 'downscale',\n  highQuality: 'highQuality'\n};\nvar initDefaults = defaults$g({\n  getKey: null,\n  doesEleInvalidateKey: falsify,\n  drawElement: null,\n  getBoundingBox: null,\n  getRotationPoint: null,\n  getRotationOffset: null,\n  isVisible: trueify,\n  allowEdgeTxrCaching: true,\n  allowParentTxrCaching: true\n});\n\nvar ElementTextureCache = function ElementTextureCache(renderer, initOptions) {\n  var self = this;\n  self.renderer = renderer;\n  self.onDequeues = [];\n  var opts = initDefaults(initOptions);\n  extend(self, opts);\n  self.lookup = new ElementTextureCacheLookup(opts.getKey, opts.doesEleInvalidateKey);\n  self.setupDequeueing();\n};\n\nvar ETCp = ElementTextureCache.prototype;\nETCp.reasons = getTxrReasons; // the list of textures in which new subtextures for elements can be placed\n\nETCp.getTextureQueue = function (txrH) {\n  var self = this;\n  self.eleImgCaches = self.eleImgCaches || {};\n  return self.eleImgCaches[txrH] = self.eleImgCaches[txrH] || [];\n}; // the list of usused textures which can be recycled (in use in texture queue)\n\n\nETCp.getRetiredTextureQueue = function (txrH) {\n  var self = this;\n  var rtxtrQs = self.eleImgCaches.retired = self.eleImgCaches.retired || {};\n  var rtxtrQ = rtxtrQs[txrH] = rtxtrQs[txrH] || [];\n  return rtxtrQ;\n}; // queue of element draw requests at different scale levels\n\n\nETCp.getElementQueue = function () {\n  var self = this;\n  var q = self.eleCacheQueue = self.eleCacheQueue || new Heap__default[\"default\"](function (a, b) {\n    return b.reqs - a.reqs;\n  });\n  return q;\n}; // queue of element draw requests at different scale levels (element id lookup)\n\n\nETCp.getElementKeyToQueue = function () {\n  var self = this;\n  var k2q = self.eleKeyToCacheQueue = self.eleKeyToCacheQueue || {};\n  return k2q;\n};\n\nETCp.getElement = function (ele, bb, pxRatio, lvl, reason) {\n  var self = this;\n  var r = this.renderer;\n  var zoom = r.cy.zoom();\n  var lookup = this.lookup;\n\n  if (!bb || bb.w === 0 || bb.h === 0 || isNaN(bb.w) || isNaN(bb.h) || !ele.visible() || ele.removed()) {\n    return null;\n  }\n\n  if (!self.allowEdgeTxrCaching && ele.isEdge() || !self.allowParentTxrCaching && ele.isParent()) {\n    return null;\n  }\n\n  if (lvl == null) {\n    lvl = Math.ceil(log2(zoom * pxRatio));\n  }\n\n  if (lvl < minLvl$1) {\n    lvl = minLvl$1;\n  } else if (zoom >= maxZoom$1 || lvl > maxLvl$1) {\n    return null;\n  }\n\n  var scale = Math.pow(2, lvl);\n  var eleScaledH = bb.h * scale;\n  var eleScaledW = bb.w * scale;\n  var scaledLabelShown = r.eleTextBiggerThanMin(ele, scale);\n\n  if (!this.isVisible(ele, scaledLabelShown)) {\n    return null;\n  }\n\n  var eleCache = lookup.get(ele, lvl); // if this get was on an unused/invalidated cache, then restore the texture usage metric\n\n  if (eleCache && eleCache.invalidated) {\n    eleCache.invalidated = false;\n    eleCache.texture.invalidatedWidth -= eleCache.width;\n  }\n\n  if (eleCache) {\n    return eleCache;\n  }\n\n  var txrH; // which texture height this ele belongs to\n\n  if (eleScaledH <= minTxrH) {\n    txrH = minTxrH;\n  } else if (eleScaledH <= txrStepH) {\n    txrH = txrStepH;\n  } else {\n    txrH = Math.ceil(eleScaledH / txrStepH) * txrStepH;\n  }\n\n  if (eleScaledH > maxTxrH || eleScaledW > maxTxrW) {\n    return null; // caching large elements is not efficient\n  }\n\n  var txrQ = self.getTextureQueue(txrH); // first try the second last one in case it has space at the end\n\n  var txr = txrQ[txrQ.length - 2];\n\n  var addNewTxr = function addNewTxr() {\n    return self.recycleTexture(txrH, eleScaledW) || self.addTexture(txrH, eleScaledW);\n  }; // try the last one if there is no second last one\n\n\n  if (!txr) {\n    txr = txrQ[txrQ.length - 1];\n  } // if the last one doesn't exist, we need a first one\n\n\n  if (!txr) {\n    txr = addNewTxr();\n  } // if there's no room in the current texture, we need a new one\n\n\n  if (txr.width - txr.usedWidth < eleScaledW) {\n    txr = addNewTxr();\n  }\n\n  var scalableFrom = function scalableFrom(otherCache) {\n    return otherCache && otherCache.scaledLabelShown === scaledLabelShown;\n  };\n\n  var deqing = reason && reason === getTxrReasons.dequeue;\n  var highQualityReq = reason && reason === getTxrReasons.highQuality;\n  var downscaleReq = reason && reason === getTxrReasons.downscale;\n  var higherCache; // the nearest cache with a higher level\n\n  for (var l = lvl + 1; l <= maxLvl$1; l++) {\n    var c = lookup.get(ele, l);\n\n    if (c) {\n      higherCache = c;\n      break;\n    }\n  }\n\n  var oneUpCache = higherCache && higherCache.level === lvl + 1 ? higherCache : null;\n\n  var downscale = function downscale() {\n    txr.context.drawImage(oneUpCache.texture.canvas, oneUpCache.x, 0, oneUpCache.width, oneUpCache.height, txr.usedWidth, 0, eleScaledW, eleScaledH);\n  }; // reset ele area in texture\n\n\n  txr.context.setTransform(1, 0, 0, 1, 0, 0);\n  txr.context.clearRect(txr.usedWidth, 0, eleScaledW, txrH);\n\n  if (scalableFrom(oneUpCache)) {\n    // then we can relatively cheaply rescale the existing image w/o rerendering\n    downscale();\n  } else if (scalableFrom(higherCache)) {\n    // then use the higher cache for now and queue the next level down\n    // to cheaply scale towards the smaller level\n    if (highQualityReq) {\n      for (var _l = higherCache.level; _l > lvl; _l--) {\n        oneUpCache = self.getElement(ele, bb, pxRatio, _l, getTxrReasons.downscale);\n      }\n\n      downscale();\n    } else {\n      self.queueElement(ele, higherCache.level - 1);\n      return higherCache;\n    }\n  } else {\n    var lowerCache; // the nearest cache with a lower level\n\n    if (!deqing && !highQualityReq && !downscaleReq) {\n      for (var _l2 = lvl - 1; _l2 >= minLvl$1; _l2--) {\n        var _c = lookup.get(ele, _l2);\n\n        if (_c) {\n          lowerCache = _c;\n          break;\n        }\n      }\n    }\n\n    if (scalableFrom(lowerCache)) {\n      // then use the lower quality cache for now and queue the better one for later\n      self.queueElement(ele, lvl);\n      return lowerCache;\n    }\n\n    txr.context.translate(txr.usedWidth, 0);\n    txr.context.scale(scale, scale);\n    this.drawElement(txr.context, ele, bb, scaledLabelShown, false);\n    txr.context.scale(1 / scale, 1 / scale);\n    txr.context.translate(-txr.usedWidth, 0);\n  }\n\n  eleCache = {\n    x: txr.usedWidth,\n    texture: txr,\n    level: lvl,\n    scale: scale,\n    width: eleScaledW,\n    height: eleScaledH,\n    scaledLabelShown: scaledLabelShown\n  };\n  txr.usedWidth += Math.ceil(eleScaledW + eleTxrSpacing);\n  txr.eleCaches.push(eleCache);\n  lookup.set(ele, lvl, eleCache);\n  self.checkTextureFullness(txr);\n  return eleCache;\n};\n\nETCp.invalidateElements = function (eles) {\n  for (var i = 0; i < eles.length; i++) {\n    this.invalidateElement(eles[i]);\n  }\n};\n\nETCp.invalidateElement = function (ele) {\n  var self = this;\n  var lookup = self.lookup;\n  var caches = [];\n  var invalid = lookup.isInvalid(ele);\n\n  if (!invalid) {\n    return; // override the invalidation request if the element key has not changed\n  }\n\n  for (var lvl = minLvl$1; lvl <= maxLvl$1; lvl++) {\n    var cache = lookup.getForCachedKey(ele, lvl);\n\n    if (cache) {\n      caches.push(cache);\n    }\n  }\n\n  var noOtherElesUseCache = lookup.invalidate(ele);\n\n  if (noOtherElesUseCache) {\n    for (var i = 0; i < caches.length; i++) {\n      var _cache = caches[i];\n      var txr = _cache.texture; // remove space from the texture it belongs to\n\n      txr.invalidatedWidth += _cache.width; // mark the cache as invalidated\n\n      _cache.invalidated = true; // retire the texture if its utility is low\n\n      self.checkTextureUtility(txr);\n    }\n  } // remove from queue since the old req was for the old state\n\n\n  self.removeFromQueue(ele);\n};\n\nETCp.checkTextureUtility = function (txr) {\n  // invalidate all entries in the cache if the cache size is small\n  if (txr.invalidatedWidth >= minUtility * txr.width) {\n    this.retireTexture(txr);\n  }\n};\n\nETCp.checkTextureFullness = function (txr) {\n  // if texture has been mostly filled and passed over several times, remove\n  // it from the queue so we don't need to waste time looking at it to put new things\n  var self = this;\n  var txrQ = self.getTextureQueue(txr.height);\n\n  if (txr.usedWidth / txr.width > maxFullness && txr.fullnessChecks >= maxFullnessChecks) {\n    removeFromArray(txrQ, txr);\n  } else {\n    txr.fullnessChecks++;\n  }\n};\n\nETCp.retireTexture = function (txr) {\n  var self = this;\n  var txrH = txr.height;\n  var txrQ = self.getTextureQueue(txrH);\n  var lookup = this.lookup; // retire the texture from the active / searchable queue:\n\n  removeFromArray(txrQ, txr);\n  txr.retired = true; // remove the refs from the eles to the caches:\n\n  var eleCaches = txr.eleCaches;\n\n  for (var i = 0; i < eleCaches.length; i++) {\n    var eleCache = eleCaches[i];\n    lookup.deleteCache(eleCache.key, eleCache.level);\n  }\n\n  clearArray(eleCaches); // add the texture to a retired queue so it can be recycled in future:\n\n  var rtxtrQ = self.getRetiredTextureQueue(txrH);\n  rtxtrQ.push(txr);\n};\n\nETCp.addTexture = function (txrH, minW) {\n  var self = this;\n  var txrQ = self.getTextureQueue(txrH);\n  var txr = {};\n  txrQ.push(txr);\n  txr.eleCaches = [];\n  txr.height = txrH;\n  txr.width = Math.max(defTxrWidth, minW);\n  txr.usedWidth = 0;\n  txr.invalidatedWidth = 0;\n  txr.fullnessChecks = 0;\n  txr.canvas = self.renderer.makeOffscreenCanvas(txr.width, txr.height);\n  txr.context = txr.canvas.getContext('2d');\n  return txr;\n};\n\nETCp.recycleTexture = function (txrH, minW) {\n  var self = this;\n  var txrQ = self.getTextureQueue(txrH);\n  var rtxtrQ = self.getRetiredTextureQueue(txrH);\n\n  for (var i = 0; i < rtxtrQ.length; i++) {\n    var txr = rtxtrQ[i];\n\n    if (txr.width >= minW) {\n      txr.retired = false;\n      txr.usedWidth = 0;\n      txr.invalidatedWidth = 0;\n      txr.fullnessChecks = 0;\n      clearArray(txr.eleCaches);\n      txr.context.setTransform(1, 0, 0, 1, 0, 0);\n      txr.context.clearRect(0, 0, txr.width, txr.height);\n      removeFromArray(rtxtrQ, txr);\n      txrQ.push(txr);\n      return txr;\n    }\n  }\n};\n\nETCp.queueElement = function (ele, lvl) {\n  var self = this;\n  var q = self.getElementQueue();\n  var k2q = self.getElementKeyToQueue();\n  var key = this.getKey(ele);\n  var existingReq = k2q[key];\n\n  if (existingReq) {\n    // use the max lvl b/c in between lvls are cheap to make\n    existingReq.level = Math.max(existingReq.level, lvl);\n    existingReq.eles.merge(ele);\n    existingReq.reqs++;\n    q.updateItem(existingReq);\n  } else {\n    var req = {\n      eles: ele.spawn().merge(ele),\n      level: lvl,\n      reqs: 1,\n      key: key\n    };\n    q.push(req);\n    k2q[key] = req;\n  }\n};\n\nETCp.dequeue = function (pxRatio\n/*, extent*/\n) {\n  var self = this;\n  var q = self.getElementQueue();\n  var k2q = self.getElementKeyToQueue();\n  var dequeued = [];\n  var lookup = self.lookup;\n\n  for (var i = 0; i < maxDeqSize$1; i++) {\n    if (q.size() > 0) {\n      var req = q.pop();\n      var key = req.key;\n      var ele = req.eles[0]; // all eles have the same key\n\n      var cacheExists = lookup.hasCache(ele, req.level); // clear out the key to req lookup\n\n      k2q[key] = null; // dequeueing isn't necessary with an existing cache\n\n      if (cacheExists) {\n        continue;\n      }\n\n      dequeued.push(req);\n      var bb = self.getBoundingBox(ele);\n      self.getElement(ele, bb, pxRatio, req.level, getTxrReasons.dequeue);\n    } else {\n      break;\n    }\n  }\n\n  return dequeued;\n};\n\nETCp.removeFromQueue = function (ele) {\n  var self = this;\n  var q = self.getElementQueue();\n  var k2q = self.getElementKeyToQueue();\n  var key = this.getKey(ele);\n  var req = k2q[key];\n\n  if (req != null) {\n    if (req.eles.length === 1) {\n      // remove if last ele in the req\n      // bring to front of queue\n      req.reqs = MAX_INT$1;\n      q.updateItem(req);\n      q.pop(); // remove from queue\n\n      k2q[key] = null; // remove from lookup map\n    } else {\n      // otherwise just remove ele from req\n      req.eles.unmerge(ele);\n    }\n  }\n};\n\nETCp.onDequeue = function (fn) {\n  this.onDequeues.push(fn);\n};\n\nETCp.offDequeue = function (fn) {\n  removeFromArray(this.onDequeues, fn);\n};\n\nETCp.setupDequeueing = defs.setupDequeueing({\n  deqRedrawThreshold: deqRedrawThreshold$1,\n  deqCost: deqCost$1,\n  deqAvgCost: deqAvgCost$1,\n  deqNoDrawCost: deqNoDrawCost$1,\n  deqFastCost: deqFastCost$1,\n  deq: function deq(self, pxRatio, extent) {\n    return self.dequeue(pxRatio, extent);\n  },\n  onDeqd: function onDeqd(self, deqd) {\n    for (var i = 0; i < self.onDequeues.length; i++) {\n      var fn = self.onDequeues[i];\n      fn(deqd);\n    }\n  },\n  shouldRedraw: function shouldRedraw(self, deqd, pxRatio, extent) {\n    for (var i = 0; i < deqd.length; i++) {\n      var eles = deqd[i].eles;\n\n      for (var j = 0; j < eles.length; j++) {\n        var bb = eles[j].boundingBox();\n\n        if (boundingBoxesIntersect(bb, extent)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  },\n  priority: function priority(self) {\n    return self.renderer.beforeRenderPriorities.eleTxrDeq;\n  }\n});\n\nvar defNumLayers = 1; // default number of layers to use\n\nvar minLvl = -4; // when scaling smaller than that we don't need to re-render\n\nvar maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)\n\nvar maxZoom = 3.99; // beyond this zoom level, layered textures are not used\n\nvar deqRedrawThreshold = 50; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile\n\nvar refineEleDebounceTime = 50; // time to debounce sharper ele texture updates\n\nvar deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame\n\nvar deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time\n\nvar deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing\n\nvar deqFastCost = 0.9; // % of frame time to be used when >60fps\n\nvar maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch\n\nvar invalidThreshold = 250; // time threshold for disabling b/c of invalidations\n\nvar maxLayerArea = 4000 * 4000; // layers can't be bigger than this\n\nvar useHighQualityEleTxrReqs = true; // whether to use high quality ele txr requests (generally faster and cheaper in the longterm)\n// var log = function(){ console.log.apply( console, arguments ); };\n\nvar LayeredTextureCache = function LayeredTextureCache(renderer) {\n  var self = this;\n  var r = self.renderer = renderer;\n  var cy = r.cy;\n  self.layersByLevel = {}; // e.g. 2 => [ layer1, layer2, ..., layerN ]\n\n  self.firstGet = true;\n  self.lastInvalidationTime = performanceNow() - 2 * invalidThreshold;\n  self.skipping = false;\n  self.eleTxrDeqs = cy.collection();\n  self.scheduleElementRefinement = debounce__default[\"default\"](function () {\n    self.refineElementTextures(self.eleTxrDeqs);\n    self.eleTxrDeqs.unmerge(self.eleTxrDeqs);\n  }, refineEleDebounceTime);\n  r.beforeRender(function (willDraw, now) {\n    if (now - self.lastInvalidationTime <= invalidThreshold) {\n      self.skipping = true;\n    } else {\n      self.skipping = false;\n    }\n  }, r.beforeRenderPriorities.lyrTxrSkip);\n\n  var qSort = function qSort(a, b) {\n    return b.reqs - a.reqs;\n  };\n\n  self.layersQueue = new Heap__default[\"default\"](qSort);\n  self.setupDequeueing();\n};\n\nvar LTCp = LayeredTextureCache.prototype;\nvar layerIdPool = 0;\nvar MAX_INT = Math.pow(2, 53) - 1;\n\nLTCp.makeLayer = function (bb, lvl) {\n  var scale = Math.pow(2, lvl);\n  var w = Math.ceil(bb.w * scale);\n  var h = Math.ceil(bb.h * scale);\n  var canvas = this.renderer.makeOffscreenCanvas(w, h);\n  var layer = {\n    id: layerIdPool = ++layerIdPool % MAX_INT,\n    bb: bb,\n    level: lvl,\n    width: w,\n    height: h,\n    canvas: canvas,\n    context: canvas.getContext('2d'),\n    eles: [],\n    elesQueue: [],\n    reqs: 0\n  }; // log('make layer %s with w %s and h %s and lvl %s', layer.id, layer.width, layer.height, layer.level);\n\n  var cxt = layer.context;\n  var dx = -layer.bb.x1;\n  var dy = -layer.bb.y1; // do the transform on creation to save cycles (it's the same for all eles)\n\n  cxt.scale(scale, scale);\n  cxt.translate(dx, dy);\n  return layer;\n};\n\nLTCp.getLayers = function (eles, pxRatio, lvl) {\n  var self = this;\n  var r = self.renderer;\n  var cy = r.cy;\n  var zoom = cy.zoom();\n  var firstGet = self.firstGet;\n  self.firstGet = false; // log('--\\nget layers with %s eles', eles.length);\n  //log eles.map(function(ele){ return ele.id() }) );\n\n  if (lvl == null) {\n    lvl = Math.ceil(log2(zoom * pxRatio));\n\n    if (lvl < minLvl) {\n      lvl = minLvl;\n    } else if (zoom >= maxZoom || lvl > maxLvl) {\n      return null;\n    }\n  }\n\n  self.validateLayersElesOrdering(lvl, eles);\n  var layersByLvl = self.layersByLevel;\n  var scale = Math.pow(2, lvl);\n  var layers = layersByLvl[lvl] = layersByLvl[lvl] || [];\n  var bb;\n  var lvlComplete = self.levelIsComplete(lvl, eles);\n  var tmpLayers;\n\n  var checkTempLevels = function checkTempLevels() {\n    var canUseAsTmpLvl = function canUseAsTmpLvl(l) {\n      self.validateLayersElesOrdering(l, eles);\n\n      if (self.levelIsComplete(l, eles)) {\n        tmpLayers = layersByLvl[l];\n        return true;\n      }\n    };\n\n    var checkLvls = function checkLvls(dir) {\n      if (tmpLayers) {\n        return;\n      }\n\n      for (var l = lvl + dir; minLvl <= l && l <= maxLvl; l += dir) {\n        if (canUseAsTmpLvl(l)) {\n          break;\n        }\n      }\n    };\n\n    checkLvls(+1);\n    checkLvls(-1); // remove the invalid layers; they will be replaced as needed later in this function\n\n    for (var i = layers.length - 1; i >= 0; i--) {\n      var layer = layers[i];\n\n      if (layer.invalid) {\n        removeFromArray(layers, layer);\n      }\n    }\n  };\n\n  if (!lvlComplete) {\n    // if the current level is incomplete, then use the closest, best quality layerset temporarily\n    // and later queue the current layerset so we can get the proper quality level soon\n    checkTempLevels();\n  } else {\n    // log('level complete, using existing layers\\n--');\n    return layers;\n  }\n\n  var getBb = function getBb() {\n    if (!bb) {\n      bb = makeBoundingBox();\n\n      for (var i = 0; i < eles.length; i++) {\n        updateBoundingBox(bb, eles[i].boundingBox());\n      }\n    }\n\n    return bb;\n  };\n\n  var makeLayer = function makeLayer(opts) {\n    opts = opts || {};\n    var after = opts.after;\n    getBb();\n    var area = bb.w * scale * (bb.h * scale);\n\n    if (area > maxLayerArea) {\n      return null;\n    }\n\n    var layer = self.makeLayer(bb, lvl);\n\n    if (after != null) {\n      var index = layers.indexOf(after) + 1;\n      layers.splice(index, 0, layer);\n    } else if (opts.insert === undefined || opts.insert) {\n      // no after specified => first layer made so put at start\n      layers.unshift(layer);\n    } // if( tmpLayers ){\n    //self.queueLayer( layer );\n    // }\n\n\n    return layer;\n  };\n\n  if (self.skipping && !firstGet) {\n    // log('skip layers');\n    return null;\n  } // log('do layers');\n\n\n  var layer = null;\n  var maxElesPerLayer = eles.length / defNumLayers;\n  var allowLazyQueueing = !firstGet;\n\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n    var rs = ele._private.rscratch;\n    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {}; // log('look at ele', ele.id());\n\n    var existingLayer = caches[lvl];\n\n    if (existingLayer) {\n      // reuse layer for later eles\n      // log('reuse layer for', ele.id());\n      layer = existingLayer;\n      continue;\n    }\n\n    if (!layer || layer.eles.length >= maxElesPerLayer || !boundingBoxInBoundingBox(layer.bb, ele.boundingBox())) {\n      // log('make new layer for ele %s', ele.id());\n      layer = makeLayer({\n        insert: true,\n        after: layer\n      }); // if now layer can be built then we can't use layers at this level\n\n      if (!layer) {\n        return null;\n      } // log('new layer with id %s', layer.id);\n\n    }\n\n    if (tmpLayers || allowLazyQueueing) {\n      // log('queue ele %s in layer %s', ele.id(), layer.id);\n      self.queueLayer(layer, ele);\n    } else {\n      // log('draw ele %s in layer %s', ele.id(), layer.id);\n      self.drawEleInLayer(layer, ele, lvl, pxRatio);\n    }\n\n    layer.eles.push(ele);\n    caches[lvl] = layer;\n  } // log('--');\n\n\n  if (tmpLayers) {\n    // then we only queued the current layerset and can't draw it yet\n    return tmpLayers;\n  }\n\n  if (allowLazyQueueing) {\n    // log('lazy queue level', lvl);\n    return null;\n  }\n\n  return layers;\n}; // a layer may want to use an ele cache of a higher level to avoid blurriness\n// so the layer level might not equal the ele level\n\n\nLTCp.getEleLevelForLayerLevel = function (lvl, pxRatio) {\n  return lvl;\n};\n\nLTCp.drawEleInLayer = function (layer, ele, lvl, pxRatio) {\n  var self = this;\n  var r = this.renderer;\n  var context = layer.context;\n  var bb = ele.boundingBox();\n\n  if (bb.w === 0 || bb.h === 0 || !ele.visible()) {\n    return;\n  }\n\n  lvl = self.getEleLevelForLayerLevel(lvl, pxRatio);\n\n  {\n    r.setImgSmoothing(context, false);\n  }\n\n  {\n    r.drawCachedElement(context, ele, null, null, lvl, useHighQualityEleTxrReqs);\n  }\n\n  {\n    r.setImgSmoothing(context, true);\n  }\n};\n\nLTCp.levelIsComplete = function (lvl, eles) {\n  var self = this;\n  var layers = self.layersByLevel[lvl];\n\n  if (!layers || layers.length === 0) {\n    return false;\n  }\n\n  var numElesInLayers = 0;\n\n  for (var i = 0; i < layers.length; i++) {\n    var layer = layers[i]; // if there are any eles needed to be drawn yet, the level is not complete\n\n    if (layer.reqs > 0) {\n      return false;\n    } // if the layer is invalid, the level is not complete\n\n\n    if (layer.invalid) {\n      return false;\n    }\n\n    numElesInLayers += layer.eles.length;\n  } // we should have exactly the number of eles passed in to be complete\n\n\n  if (numElesInLayers !== eles.length) {\n    return false;\n  }\n\n  return true;\n};\n\nLTCp.validateLayersElesOrdering = function (lvl, eles) {\n  var layers = this.layersByLevel[lvl];\n\n  if (!layers) {\n    return;\n  } // if in a layer the eles are not in the same order, then the layer is invalid\n  // (i.e. there is an ele in between the eles in the layer)\n\n\n  for (var i = 0; i < layers.length; i++) {\n    var layer = layers[i];\n    var offset = -1; // find the offset\n\n    for (var j = 0; j < eles.length; j++) {\n      if (layer.eles[0] === eles[j]) {\n        offset = j;\n        break;\n      }\n    }\n\n    if (offset < 0) {\n      // then the layer has nonexistent elements and is invalid\n      this.invalidateLayer(layer);\n      continue;\n    } // the eles in the layer must be in the same continuous order, else the layer is invalid\n\n\n    var o = offset;\n\n    for (var j = 0; j < layer.eles.length; j++) {\n      if (layer.eles[j] !== eles[o + j]) {\n        // log('invalidate based on ordering', layer.id);\n        this.invalidateLayer(layer);\n        break;\n      }\n    }\n  }\n};\n\nLTCp.updateElementsInLayers = function (eles, update) {\n  var self = this;\n  var isEles = element(eles[0]); // collect udpated elements (cascaded from the layers) and update each\n  // layer itself along the way\n\n  for (var i = 0; i < eles.length; i++) {\n    var req = isEles ? null : eles[i];\n    var ele = isEles ? eles[i] : eles[i].ele;\n    var rs = ele._private.rscratch;\n    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};\n\n    for (var l = minLvl; l <= maxLvl; l++) {\n      var layer = caches[l];\n\n      if (!layer) {\n        continue;\n      } // if update is a request from the ele cache, then it affects only\n      // the matching level\n\n\n      if (req && self.getEleLevelForLayerLevel(layer.level) !== req.level) {\n        continue;\n      }\n\n      update(layer, ele, req);\n    }\n  }\n};\n\nLTCp.haveLayers = function () {\n  var self = this;\n  var haveLayers = false;\n\n  for (var l = minLvl; l <= maxLvl; l++) {\n    var layers = self.layersByLevel[l];\n\n    if (layers && layers.length > 0) {\n      haveLayers = true;\n      break;\n    }\n  }\n\n  return haveLayers;\n};\n\nLTCp.invalidateElements = function (eles) {\n  var self = this;\n\n  if (eles.length === 0) {\n    return;\n  }\n\n  self.lastInvalidationTime = performanceNow(); // log('update invalidate layer time from eles');\n\n  if (eles.length === 0 || !self.haveLayers()) {\n    return;\n  }\n\n  self.updateElementsInLayers(eles, function invalAssocLayers(layer, ele, req) {\n    self.invalidateLayer(layer);\n  });\n};\n\nLTCp.invalidateLayer = function (layer) {\n  // log('update invalidate layer time');\n  this.lastInvalidationTime = performanceNow();\n\n  if (layer.invalid) {\n    return;\n  } // save cycles\n\n\n  var lvl = layer.level;\n  var eles = layer.eles;\n  var layers = this.layersByLevel[lvl]; // log('invalidate layer', layer.id );\n\n  removeFromArray(layers, layer); // layer.eles = [];\n\n  layer.elesQueue = [];\n  layer.invalid = true;\n\n  if (layer.replacement) {\n    layer.replacement.invalid = true;\n  }\n\n  for (var i = 0; i < eles.length; i++) {\n    var caches = eles[i]._private.rscratch.imgLayerCaches;\n\n    if (caches) {\n      caches[lvl] = null;\n    }\n  }\n};\n\nLTCp.refineElementTextures = function (eles) {\n  var self = this; // log('refine', eles.length);\n\n  self.updateElementsInLayers(eles, function refineEachEle(layer, ele, req) {\n    var rLyr = layer.replacement;\n\n    if (!rLyr) {\n      rLyr = layer.replacement = self.makeLayer(layer.bb, layer.level);\n      rLyr.replaces = layer;\n      rLyr.eles = layer.eles; // log('make replacement layer %s for %s with level %s', rLyr.id, layer.id, rLyr.level);\n    }\n\n    if (!rLyr.reqs) {\n      for (var i = 0; i < rLyr.eles.length; i++) {\n        self.queueLayer(rLyr, rLyr.eles[i]);\n      } // log('queue replacement layer refinement', rLyr.id);\n\n    }\n  });\n};\n\nLTCp.enqueueElementRefinement = function (ele) {\n\n  this.eleTxrDeqs.merge(ele);\n  this.scheduleElementRefinement();\n};\n\nLTCp.queueLayer = function (layer, ele) {\n  var self = this;\n  var q = self.layersQueue;\n  var elesQ = layer.elesQueue;\n  var hasId = elesQ.hasId = elesQ.hasId || {}; // if a layer is going to be replaced, queuing is a waste of time\n\n  if (layer.replacement) {\n    return;\n  }\n\n  if (ele) {\n    if (hasId[ele.id()]) {\n      return;\n    }\n\n    elesQ.push(ele);\n    hasId[ele.id()] = true;\n  }\n\n  if (layer.reqs) {\n    layer.reqs++;\n    q.updateItem(layer);\n  } else {\n    layer.reqs = 1;\n    q.push(layer);\n  }\n};\n\nLTCp.dequeue = function (pxRatio) {\n  var self = this;\n  var q = self.layersQueue;\n  var deqd = [];\n  var eleDeqs = 0;\n\n  while (eleDeqs < maxDeqSize) {\n    if (q.size() === 0) {\n      break;\n    }\n\n    var layer = q.peek(); // if a layer has been or will be replaced, then don't waste time with it\n\n    if (layer.replacement) {\n      // log('layer %s in queue skipped b/c it already has a replacement', layer.id);\n      q.pop();\n      continue;\n    } // if this is a replacement layer that has been superceded, then forget it\n\n\n    if (layer.replaces && layer !== layer.replaces.replacement) {\n      // log('layer is no longer the most uptodate replacement; dequeued', layer.id)\n      q.pop();\n      continue;\n    }\n\n    if (layer.invalid) {\n      // log('replacement layer %s is invalid; dequeued', layer.id);\n      q.pop();\n      continue;\n    }\n\n    var ele = layer.elesQueue.shift();\n\n    if (ele) {\n      // log('dequeue layer %s', layer.id);\n      self.drawEleInLayer(layer, ele, layer.level, pxRatio);\n      eleDeqs++;\n    }\n\n    if (deqd.length === 0) {\n      // we need only one entry in deqd to queue redrawing etc\n      deqd.push(true);\n    } // if the layer has all its eles done, then remove from the queue\n\n\n    if (layer.elesQueue.length === 0) {\n      q.pop();\n      layer.reqs = 0; // log('dequeue of layer %s complete', layer.id);\n      // when a replacement layer is dequeued, it replaces the old layer in the level\n\n      if (layer.replaces) {\n        self.applyLayerReplacement(layer);\n      }\n\n      self.requestRedraw();\n    }\n  }\n\n  return deqd;\n};\n\nLTCp.applyLayerReplacement = function (layer) {\n  var self = this;\n  var layersInLevel = self.layersByLevel[layer.level];\n  var replaced = layer.replaces;\n  var index = layersInLevel.indexOf(replaced); // if the replaced layer is not in the active list for the level, then replacing\n  // refs would be a mistake (i.e. overwriting the true active layer)\n\n  if (index < 0 || replaced.invalid) {\n    // log('replacement layer would have no effect', layer.id);\n    return;\n  }\n\n  layersInLevel[index] = layer; // replace level ref\n  // replace refs in eles\n\n  for (var i = 0; i < layer.eles.length; i++) {\n    var _p = layer.eles[i]._private;\n    var cache = _p.imgLayerCaches = _p.imgLayerCaches || {};\n\n    if (cache) {\n      cache[layer.level] = layer;\n    }\n  } // log('apply replacement layer %s over %s', layer.id, replaced.id);\n\n\n  self.requestRedraw();\n};\n\nLTCp.requestRedraw = debounce__default[\"default\"](function () {\n  var r = this.renderer;\n  r.redrawHint('eles', true);\n  r.redrawHint('drag', true);\n  r.redraw();\n}, 100);\nLTCp.setupDequeueing = defs.setupDequeueing({\n  deqRedrawThreshold: deqRedrawThreshold,\n  deqCost: deqCost,\n  deqAvgCost: deqAvgCost,\n  deqNoDrawCost: deqNoDrawCost,\n  deqFastCost: deqFastCost,\n  deq: function deq(self, pxRatio) {\n    return self.dequeue(pxRatio);\n  },\n  onDeqd: noop$1,\n  shouldRedraw: trueify,\n  priority: function priority(self) {\n    return self.renderer.beforeRenderPriorities.lyrTxrDeq;\n  }\n});\n\nvar CRp$a = {};\nvar impl;\n\nfunction polygon(context, points) {\n  for (var i = 0; i < points.length; i++) {\n    var pt = points[i];\n    context.lineTo(pt.x, pt.y);\n  }\n}\n\nfunction triangleBackcurve(context, points, controlPoint) {\n  var firstPt;\n\n  for (var i = 0; i < points.length; i++) {\n    var pt = points[i];\n\n    if (i === 0) {\n      firstPt = pt;\n    }\n\n    context.lineTo(pt.x, pt.y);\n  }\n\n  context.quadraticCurveTo(controlPoint.x, controlPoint.y, firstPt.x, firstPt.y);\n}\n\nfunction triangleTee(context, trianglePoints, teePoints) {\n  if (context.beginPath) {\n    context.beginPath();\n  }\n\n  var triPts = trianglePoints;\n\n  for (var i = 0; i < triPts.length; i++) {\n    var pt = triPts[i];\n    context.lineTo(pt.x, pt.y);\n  }\n\n  var teePts = teePoints;\n  var firstTeePt = teePoints[0];\n  context.moveTo(firstTeePt.x, firstTeePt.y);\n\n  for (var i = 1; i < teePts.length; i++) {\n    var pt = teePts[i];\n    context.lineTo(pt.x, pt.y);\n  }\n\n  if (context.closePath) {\n    context.closePath();\n  }\n}\n\nfunction circleTriangle(context, trianglePoints, rx, ry, r) {\n  if (context.beginPath) {\n    context.beginPath();\n  }\n\n  context.arc(rx, ry, r, 0, Math.PI * 2, false);\n  var triPts = trianglePoints;\n  var firstTrPt = triPts[0];\n  context.moveTo(firstTrPt.x, firstTrPt.y);\n\n  for (var i = 0; i < triPts.length; i++) {\n    var pt = triPts[i];\n    context.lineTo(pt.x, pt.y);\n  }\n\n  if (context.closePath) {\n    context.closePath();\n  }\n}\n\nfunction circle(context, rx, ry, r) {\n  context.arc(rx, ry, r, 0, Math.PI * 2, false);\n}\n\nCRp$a.arrowShapeImpl = function (name) {\n  return (impl || (impl = {\n    'polygon': polygon,\n    'triangle-backcurve': triangleBackcurve,\n    'triangle-tee': triangleTee,\n    'circle-triangle': circleTriangle,\n    'triangle-cross': triangleTee,\n    'circle': circle\n  }))[name];\n};\n\nvar CRp$9 = {};\n\nCRp$9.drawElement = function (context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity) {\n  var r = this;\n\n  if (ele.isNode()) {\n    r.drawNode(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);\n  } else {\n    r.drawEdge(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);\n  }\n};\n\nCRp$9.drawElementOverlay = function (context, ele) {\n  var r = this;\n\n  if (ele.isNode()) {\n    r.drawNodeOverlay(context, ele);\n  } else {\n    r.drawEdgeOverlay(context, ele);\n  }\n};\n\nCRp$9.drawElementUnderlay = function (context, ele) {\n  var r = this;\n\n  if (ele.isNode()) {\n    r.drawNodeUnderlay(context, ele);\n  } else {\n    r.drawEdgeUnderlay(context, ele);\n  }\n};\n\nCRp$9.drawCachedElementPortion = function (context, ele, eleTxrCache, pxRatio, lvl, reason, getRotation, getOpacity) {\n  var r = this;\n  var bb = eleTxrCache.getBoundingBox(ele);\n\n  if (bb.w === 0 || bb.h === 0) {\n    return;\n  } // ignore zero size case\n\n\n  var eleCache = eleTxrCache.getElement(ele, bb, pxRatio, lvl, reason);\n\n  if (eleCache != null) {\n    var opacity = getOpacity(r, ele);\n\n    if (opacity === 0) {\n      return;\n    }\n\n    var theta = getRotation(r, ele);\n    var x1 = bb.x1,\n        y1 = bb.y1,\n        w = bb.w,\n        h = bb.h;\n    var x, y, sx, sy, smooth;\n\n    if (theta !== 0) {\n      var rotPt = eleTxrCache.getRotationPoint(ele);\n      sx = rotPt.x;\n      sy = rotPt.y;\n      context.translate(sx, sy);\n      context.rotate(theta);\n      smooth = r.getImgSmoothing(context);\n\n      if (!smooth) {\n        r.setImgSmoothing(context, true);\n      }\n\n      var off = eleTxrCache.getRotationOffset(ele);\n      x = off.x;\n      y = off.y;\n    } else {\n      x = x1;\n      y = y1;\n    }\n\n    var oldGlobalAlpha;\n\n    if (opacity !== 1) {\n      oldGlobalAlpha = context.globalAlpha;\n      context.globalAlpha = oldGlobalAlpha * opacity;\n    }\n\n    context.drawImage(eleCache.texture.canvas, eleCache.x, 0, eleCache.width, eleCache.height, x, y, w, h);\n\n    if (opacity !== 1) {\n      context.globalAlpha = oldGlobalAlpha;\n    }\n\n    if (theta !== 0) {\n      context.rotate(-theta);\n      context.translate(-sx, -sy);\n\n      if (!smooth) {\n        r.setImgSmoothing(context, false);\n      }\n    }\n  } else {\n    eleTxrCache.drawElement(context, ele); // direct draw fallback\n  }\n};\n\nvar getZeroRotation = function getZeroRotation() {\n  return 0;\n};\n\nvar getLabelRotation = function getLabelRotation(r, ele) {\n  return r.getTextAngle(ele, null);\n};\n\nvar getSourceLabelRotation = function getSourceLabelRotation(r, ele) {\n  return r.getTextAngle(ele, 'source');\n};\n\nvar getTargetLabelRotation = function getTargetLabelRotation(r, ele) {\n  return r.getTextAngle(ele, 'target');\n};\n\nvar getOpacity = function getOpacity(r, ele) {\n  return ele.effectiveOpacity();\n};\n\nvar getTextOpacity = function getTextOpacity(e, ele) {\n  return ele.pstyle('text-opacity').pfValue * ele.effectiveOpacity();\n};\n\nCRp$9.drawCachedElement = function (context, ele, pxRatio, extent, lvl, requestHighQuality) {\n  var r = this;\n  var _r$data = r.data,\n      eleTxrCache = _r$data.eleTxrCache,\n      lblTxrCache = _r$data.lblTxrCache,\n      slbTxrCache = _r$data.slbTxrCache,\n      tlbTxrCache = _r$data.tlbTxrCache;\n  var bb = ele.boundingBox();\n  var reason = requestHighQuality === true ? eleTxrCache.reasons.highQuality : null;\n\n  if (bb.w === 0 || bb.h === 0 || !ele.visible()) {\n    return;\n  }\n\n  if (!extent || boundingBoxesIntersect(bb, extent)) {\n    var isEdge = ele.isEdge();\n\n    var badLine = ele.element()._private.rscratch.badLine;\n\n    r.drawElementUnderlay(context, ele);\n    r.drawCachedElementPortion(context, ele, eleTxrCache, pxRatio, lvl, reason, getZeroRotation, getOpacity);\n\n    if (!isEdge || !badLine) {\n      r.drawCachedElementPortion(context, ele, lblTxrCache, pxRatio, lvl, reason, getLabelRotation, getTextOpacity);\n    }\n\n    if (isEdge && !badLine) {\n      r.drawCachedElementPortion(context, ele, slbTxrCache, pxRatio, lvl, reason, getSourceLabelRotation, getTextOpacity);\n      r.drawCachedElementPortion(context, ele, tlbTxrCache, pxRatio, lvl, reason, getTargetLabelRotation, getTextOpacity);\n    }\n\n    r.drawElementOverlay(context, ele);\n  }\n};\n\nCRp$9.drawElements = function (context, eles) {\n  var r = this;\n\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n    r.drawElement(context, ele);\n  }\n};\n\nCRp$9.drawCachedElements = function (context, eles, pxRatio, extent) {\n  var r = this;\n\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n    r.drawCachedElement(context, ele, pxRatio, extent);\n  }\n};\n\nCRp$9.drawCachedNodes = function (context, eles, pxRatio, extent) {\n  var r = this;\n\n  for (var i = 0; i < eles.length; i++) {\n    var ele = eles[i];\n\n    if (!ele.isNode()) {\n      continue;\n    }\n\n    r.drawCachedElement(context, ele, pxRatio, extent);\n  }\n};\n\nCRp$9.drawLayeredElements = function (context, eles, pxRatio, extent) {\n  var r = this;\n  var layers = r.data.lyrTxrCache.getLayers(eles, pxRatio);\n\n  if (layers) {\n    for (var i = 0; i < layers.length; i++) {\n      var layer = layers[i];\n      var bb = layer.bb;\n\n      if (bb.w === 0 || bb.h === 0) {\n        continue;\n      }\n\n      context.drawImage(layer.canvas, bb.x1, bb.y1, bb.w, bb.h);\n    }\n  } else {\n    // fall back on plain caching if no layers\n    r.drawCachedElements(context, eles, pxRatio, extent);\n  }\n};\n\n/* global Path2D */\nvar CRp$8 = {};\n\nCRp$8.drawEdge = function (context, edge, shiftToOriginWithBb) {\n  var drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var r = this;\n  var rs = edge._private.rscratch;\n\n  if (shouldDrawOpacity && !edge.visible()) {\n    return;\n  } // if bezier ctrl pts can not be calculated, then die\n\n\n  if (rs.badLine || rs.allpts == null || isNaN(rs.allpts[0])) {\n    // isNaN in case edge is impossible and browser bugs (e.g. safari)\n    return;\n  }\n\n  var bb;\n\n  if (shiftToOriginWithBb) {\n    bb = shiftToOriginWithBb;\n    context.translate(-bb.x1, -bb.y1);\n  }\n\n  var opacity = shouldDrawOpacity ? edge.pstyle('opacity').value : 1;\n  var lineOpacity = shouldDrawOpacity ? edge.pstyle('line-opacity').value : 1;\n  var curveStyle = edge.pstyle('curve-style').value;\n  var lineStyle = edge.pstyle('line-style').value;\n  var edgeWidth = edge.pstyle('width').pfValue;\n  var lineCap = edge.pstyle('line-cap').value;\n  var effectiveLineOpacity = opacity * lineOpacity; // separate arrow opacity would require arrow-opacity property\n\n  var effectiveArrowOpacity = opacity * lineOpacity;\n\n  var drawLine = function drawLine() {\n    var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : effectiveLineOpacity;\n\n    if (curveStyle === 'straight-triangle') {\n      r.eleStrokeStyle(context, edge, strokeOpacity);\n      r.drawEdgeTrianglePath(edge, context, rs.allpts);\n    } else {\n      context.lineWidth = edgeWidth;\n      context.lineCap = lineCap;\n      r.eleStrokeStyle(context, edge, strokeOpacity);\n      r.drawEdgePath(edge, context, rs.allpts, lineStyle);\n      context.lineCap = 'butt'; // reset for other drawing functions\n    }\n  };\n\n  var drawOverlay = function drawOverlay() {\n    if (!shouldDrawOverlay) {\n      return;\n    }\n\n    r.drawEdgeOverlay(context, edge);\n  };\n\n  var drawUnderlay = function drawUnderlay() {\n    if (!shouldDrawOverlay) {\n      return;\n    }\n\n    r.drawEdgeUnderlay(context, edge);\n  };\n\n  var drawArrows = function drawArrows() {\n    var arrowOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : effectiveArrowOpacity;\n    r.drawArrowheads(context, edge, arrowOpacity);\n  };\n\n  var drawText = function drawText() {\n    r.drawElementText(context, edge, null, drawLabel);\n  };\n\n  context.lineJoin = 'round';\n  var ghost = edge.pstyle('ghost').value === 'yes';\n\n  if (ghost) {\n    var gx = edge.pstyle('ghost-offset-x').pfValue;\n    var gy = edge.pstyle('ghost-offset-y').pfValue;\n    var ghostOpacity = edge.pstyle('ghost-opacity').value;\n    var effectiveGhostOpacity = effectiveLineOpacity * ghostOpacity;\n    context.translate(gx, gy);\n    drawLine(effectiveGhostOpacity);\n    drawArrows(effectiveGhostOpacity);\n    context.translate(-gx, -gy);\n  }\n\n  drawUnderlay();\n  drawLine();\n  drawArrows();\n  drawOverlay();\n  drawText();\n\n  if (shiftToOriginWithBb) {\n    context.translate(bb.x1, bb.y1);\n  }\n};\n\nvar drawEdgeOverlayUnderlay = function drawEdgeOverlayUnderlay(overlayOrUnderlay) {\n  if (!['overlay', 'underlay'].includes(overlayOrUnderlay)) {\n    throw new Error('Invalid state');\n  }\n\n  return function (context, edge) {\n    if (!edge.visible()) {\n      return;\n    }\n\n    var opacity = edge.pstyle(\"\".concat(overlayOrUnderlay, \"-opacity\")).value;\n\n    if (opacity === 0) {\n      return;\n    }\n\n    var r = this;\n    var usePaths = r.usePaths();\n    var rs = edge._private.rscratch;\n    var padding = edge.pstyle(\"\".concat(overlayOrUnderlay, \"-padding\")).pfValue;\n    var width = 2 * padding;\n    var color = edge.pstyle(\"\".concat(overlayOrUnderlay, \"-color\")).value;\n    context.lineWidth = width;\n\n    if (rs.edgeType === 'self' && !usePaths) {\n      context.lineCap = 'butt';\n    } else {\n      context.lineCap = 'round';\n    }\n\n    r.colorStrokeStyle(context, color[0], color[1], color[2], opacity);\n    r.drawEdgePath(edge, context, rs.allpts, 'solid');\n  };\n};\n\nCRp$8.drawEdgeOverlay = drawEdgeOverlayUnderlay('overlay');\nCRp$8.drawEdgeUnderlay = drawEdgeOverlayUnderlay('underlay');\n\nCRp$8.drawEdgePath = function (edge, context, pts, type) {\n  var rs = edge._private.rscratch;\n  var canvasCxt = context;\n  var path;\n  var pathCacheHit = false;\n  var usePaths = this.usePaths();\n  var lineDashPattern = edge.pstyle('line-dash-pattern').pfValue;\n  var lineDashOffset = edge.pstyle('line-dash-offset').pfValue;\n\n  if (usePaths) {\n    var pathCacheKey = pts.join('$');\n    var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;\n\n    if (keyMatches) {\n      path = context = rs.pathCache;\n      pathCacheHit = true;\n    } else {\n      path = context = new Path2D();\n      rs.pathCacheKey = pathCacheKey;\n      rs.pathCache = path;\n    }\n  }\n\n  if (canvasCxt.setLineDash) {\n    // for very outofdate browsers\n    switch (type) {\n      case 'dotted':\n        canvasCxt.setLineDash([1, 1]);\n        break;\n\n      case 'dashed':\n        canvasCxt.setLineDash(lineDashPattern);\n        canvasCxt.lineDashOffset = lineDashOffset;\n        break;\n\n      case 'solid':\n        canvasCxt.setLineDash([]);\n        break;\n    }\n  }\n\n  if (!pathCacheHit && !rs.badLine) {\n    if (context.beginPath) {\n      context.beginPath();\n    }\n\n    context.moveTo(pts[0], pts[1]);\n\n    switch (rs.edgeType) {\n      case 'bezier':\n      case 'self':\n      case 'compound':\n      case 'multibezier':\n        for (var i = 2; i + 3 < pts.length; i += 4) {\n          context.quadraticCurveTo(pts[i], pts[i + 1], pts[i + 2], pts[i + 3]);\n        }\n\n        break;\n\n      case 'straight':\n      case 'segments':\n      case 'haystack':\n        for (var _i = 2; _i + 1 < pts.length; _i += 2) {\n          context.lineTo(pts[_i], pts[_i + 1]);\n        }\n\n        break;\n    }\n  }\n\n  context = canvasCxt;\n\n  if (usePaths) {\n    context.stroke(path);\n  } else {\n    context.stroke();\n  } // reset any line dashes\n\n\n  if (context.setLineDash) {\n    // for very outofdate browsers\n    context.setLineDash([]);\n  }\n};\n\nCRp$8.drawEdgeTrianglePath = function (edge, context, pts) {\n  // use line stroke style for triangle fill style\n  context.fillStyle = context.strokeStyle;\n  var edgeWidth = edge.pstyle('width').pfValue;\n\n  for (var i = 0; i + 1 < pts.length; i += 2) {\n    var vector = [pts[i + 2] - pts[i], pts[i + 3] - pts[i + 1]];\n    var length = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]);\n    var normal = [vector[1] / length, -vector[0] / length];\n    var triangleHead = [normal[0] * edgeWidth / 2, normal[1] * edgeWidth / 2];\n    context.beginPath();\n    context.moveTo(pts[i] - triangleHead[0], pts[i + 1] - triangleHead[1]);\n    context.lineTo(pts[i] + triangleHead[0], pts[i + 1] + triangleHead[1]);\n    context.lineTo(pts[i + 2], pts[i + 3]);\n    context.closePath();\n    context.fill();\n  }\n};\n\nCRp$8.drawArrowheads = function (context, edge, opacity) {\n  var rs = edge._private.rscratch;\n  var isHaystack = rs.edgeType === 'haystack';\n\n  if (!isHaystack) {\n    this.drawArrowhead(context, edge, 'source', rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle, opacity);\n  }\n\n  this.drawArrowhead(context, edge, 'mid-target', rs.midX, rs.midY, rs.midtgtArrowAngle, opacity);\n  this.drawArrowhead(context, edge, 'mid-source', rs.midX, rs.midY, rs.midsrcArrowAngle, opacity);\n\n  if (!isHaystack) {\n    this.drawArrowhead(context, edge, 'target', rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle, opacity);\n  }\n};\n\nCRp$8.drawArrowhead = function (context, edge, prefix, x, y, angle, opacity) {\n  if (isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null) {\n    return;\n  }\n\n  var self = this;\n  var arrowShape = edge.pstyle(prefix + '-arrow-shape').value;\n\n  if (arrowShape === 'none') {\n    return;\n  }\n\n  var arrowClearFill = edge.pstyle(prefix + '-arrow-fill').value === 'hollow' ? 'both' : 'filled';\n  var arrowFill = edge.pstyle(prefix + '-arrow-fill').value;\n  var edgeWidth = edge.pstyle('width').pfValue;\n  var edgeOpacity = edge.pstyle('opacity').value;\n\n  if (opacity === undefined) {\n    opacity = edgeOpacity;\n  }\n\n  var gco = context.globalCompositeOperation;\n\n  if (opacity !== 1 || arrowFill === 'hollow') {\n    // then extra clear is needed\n    context.globalCompositeOperation = 'destination-out';\n    self.colorFillStyle(context, 255, 255, 255, 1);\n    self.colorStrokeStyle(context, 255, 255, 255, 1);\n    self.drawArrowShape(edge, context, arrowClearFill, edgeWidth, arrowShape, x, y, angle);\n    context.globalCompositeOperation = gco;\n  } // otherwise, the opaque arrow clears it for free :)\n\n\n  var color = edge.pstyle(prefix + '-arrow-color').value;\n  self.colorFillStyle(context, color[0], color[1], color[2], opacity);\n  self.colorStrokeStyle(context, color[0], color[1], color[2], opacity);\n  self.drawArrowShape(edge, context, arrowFill, edgeWidth, arrowShape, x, y, angle);\n};\n\nCRp$8.drawArrowShape = function (edge, context, fill, edgeWidth, shape, x, y, angle) {\n  var r = this;\n  var usePaths = this.usePaths() && shape !== 'triangle-cross';\n  var pathCacheHit = false;\n  var path;\n  var canvasContext = context;\n  var translation = {\n    x: x,\n    y: y\n  };\n  var scale = edge.pstyle('arrow-scale').value;\n  var size = this.getArrowWidth(edgeWidth, scale);\n  var shapeImpl = r.arrowShapes[shape];\n\n  if (usePaths) {\n    var cache = r.arrowPathCache = r.arrowPathCache || [];\n    var key = hashString(shape);\n    var cachedPath = cache[key];\n\n    if (cachedPath != null) {\n      path = context = cachedPath;\n      pathCacheHit = true;\n    } else {\n      path = context = new Path2D();\n      cache[key] = path;\n    }\n  }\n\n  if (!pathCacheHit) {\n    if (context.beginPath) {\n      context.beginPath();\n    }\n\n    if (usePaths) {\n      // store in the path cache with values easily manipulated later\n      shapeImpl.draw(context, 1, 0, {\n        x: 0,\n        y: 0\n      }, 1);\n    } else {\n      shapeImpl.draw(context, size, angle, translation, edgeWidth);\n    }\n\n    if (context.closePath) {\n      context.closePath();\n    }\n  }\n\n  context = canvasContext;\n\n  if (usePaths) {\n    // set transform to arrow position/orientation\n    context.translate(x, y);\n    context.rotate(angle);\n    context.scale(size, size);\n  }\n\n  if (fill === 'filled' || fill === 'both') {\n    if (usePaths) {\n      context.fill(path);\n    } else {\n      context.fill();\n    }\n  }\n\n  if (fill === 'hollow' || fill === 'both') {\n    context.lineWidth = (shapeImpl.matchEdgeWidth ? edgeWidth : 1) / (usePaths ? size : 1);\n    context.lineJoin = 'miter';\n\n    if (usePaths) {\n      context.stroke(path);\n    } else {\n      context.stroke();\n    }\n  }\n\n  if (usePaths) {\n    // reset transform by applying inverse\n    context.scale(1 / size, 1 / size);\n    context.rotate(-angle);\n    context.translate(-x, -y);\n  }\n};\n\nvar CRp$7 = {};\n\nCRp$7.safeDrawImage = function (context, img, ix, iy, iw, ih, x, y, w, h) {\n  // detect problematic cases for old browsers with bad images (cheaper than try-catch)\n  if (iw <= 0 || ih <= 0 || w <= 0 || h <= 0) {\n    return;\n  }\n\n  try {\n    context.drawImage(img, ix, iy, iw, ih, x, y, w, h);\n  } catch (e) {\n    warn(e);\n  }\n};\n\nCRp$7.drawInscribedImage = function (context, img, node, index, nodeOpacity) {\n  var r = this;\n  var pos = node.position();\n  var nodeX = pos.x;\n  var nodeY = pos.y;\n  var styleObj = node.cy().style();\n  var getIndexedStyle = styleObj.getIndexedStyle.bind(styleObj);\n  var fit = getIndexedStyle(node, 'background-fit', 'value', index);\n  var repeat = getIndexedStyle(node, 'background-repeat', 'value', index);\n  var nodeW = node.width();\n  var nodeH = node.height();\n  var paddingX2 = node.padding() * 2;\n  var nodeTW = nodeW + (getIndexedStyle(node, 'background-width-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);\n  var nodeTH = nodeH + (getIndexedStyle(node, 'background-height-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);\n  var rs = node._private.rscratch;\n  var clip = getIndexedStyle(node, 'background-clip', 'value', index);\n  var shouldClip = clip === 'node';\n  var imgOpacity = getIndexedStyle(node, 'background-image-opacity', 'value', index) * nodeOpacity;\n  var smooth = getIndexedStyle(node, 'background-image-smoothing', 'value', index);\n  var imgW = img.width || img.cachedW;\n  var imgH = img.height || img.cachedH; // workaround for broken browsers like ie\n\n  if (null == imgW || null == imgH) {\n    document.body.appendChild(img); // eslint-disable-line no-undef\n\n    imgW = img.cachedW = img.width || img.offsetWidth;\n    imgH = img.cachedH = img.height || img.offsetHeight;\n    document.body.removeChild(img); // eslint-disable-line no-undef\n  }\n\n  var w = imgW;\n  var h = imgH;\n\n  if (getIndexedStyle(node, 'background-width', 'value', index) !== 'auto') {\n    if (getIndexedStyle(node, 'background-width', 'units', index) === '%') {\n      w = getIndexedStyle(node, 'background-width', 'pfValue', index) * nodeTW;\n    } else {\n      w = getIndexedStyle(node, 'background-width', 'pfValue', index);\n    }\n  }\n\n  if (getIndexedStyle(node, 'background-height', 'value', index) !== 'auto') {\n    if (getIndexedStyle(node, 'background-height', 'units', index) === '%') {\n      h = getIndexedStyle(node, 'background-height', 'pfValue', index) * nodeTH;\n    } else {\n      h = getIndexedStyle(node, 'background-height', 'pfValue', index);\n    }\n  }\n\n  if (w === 0 || h === 0) {\n    return; // no point in drawing empty image (and chrome is broken in this case)\n  }\n\n  if (fit === 'contain') {\n    var scale = Math.min(nodeTW / w, nodeTH / h);\n    w *= scale;\n    h *= scale;\n  } else if (fit === 'cover') {\n    var scale = Math.max(nodeTW / w, nodeTH / h);\n    w *= scale;\n    h *= scale;\n  }\n\n  var x = nodeX - nodeTW / 2; // left\n\n  var posXUnits = getIndexedStyle(node, 'background-position-x', 'units', index);\n  var posXPfVal = getIndexedStyle(node, 'background-position-x', 'pfValue', index);\n\n  if (posXUnits === '%') {\n    x += (nodeTW - w) * posXPfVal;\n  } else {\n    x += posXPfVal;\n  }\n\n  var offXUnits = getIndexedStyle(node, 'background-offset-x', 'units', index);\n  var offXPfVal = getIndexedStyle(node, 'background-offset-x', 'pfValue', index);\n\n  if (offXUnits === '%') {\n    x += (nodeTW - w) * offXPfVal;\n  } else {\n    x += offXPfVal;\n  }\n\n  var y = nodeY - nodeTH / 2; // top\n\n  var posYUnits = getIndexedStyle(node, 'background-position-y', 'units', index);\n  var posYPfVal = getIndexedStyle(node, 'background-position-y', 'pfValue', index);\n\n  if (posYUnits === '%') {\n    y += (nodeTH - h) * posYPfVal;\n  } else {\n    y += posYPfVal;\n  }\n\n  var offYUnits = getIndexedStyle(node, 'background-offset-y', 'units', index);\n  var offYPfVal = getIndexedStyle(node, 'background-offset-y', 'pfValue', index);\n\n  if (offYUnits === '%') {\n    y += (nodeTH - h) * offYPfVal;\n  } else {\n    y += offYPfVal;\n  }\n\n  if (rs.pathCache) {\n    x -= nodeX;\n    y -= nodeY;\n    nodeX = 0;\n    nodeY = 0;\n  }\n\n  var gAlpha = context.globalAlpha;\n  context.globalAlpha = imgOpacity;\n  var smoothingEnabled = r.getImgSmoothing(context);\n  var isSmoothingSwitched = false;\n\n  if (smooth === 'no' && smoothingEnabled) {\n    r.setImgSmoothing(context, false);\n    isSmoothingSwitched = true;\n  } else if (smooth === 'yes' && !smoothingEnabled) {\n    r.setImgSmoothing(context, true);\n    isSmoothingSwitched = true;\n  }\n\n  if (repeat === 'no-repeat') {\n    if (shouldClip) {\n      context.save();\n\n      if (rs.pathCache) {\n        context.clip(rs.pathCache);\n      } else {\n        r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);\n        context.clip();\n      }\n    }\n\n    r.safeDrawImage(context, img, 0, 0, imgW, imgH, x, y, w, h);\n\n    if (shouldClip) {\n      context.restore();\n    }\n  } else {\n    var pattern = context.createPattern(img, repeat);\n    context.fillStyle = pattern;\n    r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);\n    context.translate(x, y);\n    context.fill();\n    context.translate(-x, -y);\n  }\n\n  context.globalAlpha = gAlpha;\n\n  if (isSmoothingSwitched) {\n    r.setImgSmoothing(context, smoothingEnabled);\n  }\n};\n\nvar CRp$6 = {};\n\nCRp$6.eleTextBiggerThanMin = function (ele, scale) {\n  if (!scale) {\n    var zoom = ele.cy().zoom();\n    var pxRatio = this.getPixelRatio();\n    var lvl = Math.ceil(log2(zoom * pxRatio)); // the effective texture level\n\n    scale = Math.pow(2, lvl);\n  }\n\n  var computedSize = ele.pstyle('font-size').pfValue * scale;\n  var minSize = ele.pstyle('min-zoomed-font-size').pfValue;\n\n  if (computedSize < minSize) {\n    return false;\n  }\n\n  return true;\n};\n\nCRp$6.drawElementText = function (context, ele, shiftToOriginWithBb, force, prefix) {\n  var useEleOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var r = this;\n\n  if (force == null) {\n    if (useEleOpacity && !r.eleTextBiggerThanMin(ele)) {\n      return;\n    }\n  } else if (force === false) {\n    return;\n  }\n\n  if (ele.isNode()) {\n    var label = ele.pstyle('label');\n\n    if (!label || !label.value) {\n      return;\n    }\n\n    var justification = r.getLabelJustification(ele);\n    context.textAlign = justification;\n    context.textBaseline = 'bottom';\n  } else {\n    var badLine = ele.element()._private.rscratch.badLine;\n\n    var _label = ele.pstyle('label');\n\n    var srcLabel = ele.pstyle('source-label');\n    var tgtLabel = ele.pstyle('target-label');\n\n    if (badLine || (!_label || !_label.value) && (!srcLabel || !srcLabel.value) && (!tgtLabel || !tgtLabel.value)) {\n      return;\n    }\n\n    context.textAlign = 'center';\n    context.textBaseline = 'bottom';\n  }\n\n  var applyRotation = !shiftToOriginWithBb;\n  var bb;\n\n  if (shiftToOriginWithBb) {\n    bb = shiftToOriginWithBb;\n    context.translate(-bb.x1, -bb.y1);\n  }\n\n  if (prefix == null) {\n    r.drawText(context, ele, null, applyRotation, useEleOpacity);\n\n    if (ele.isEdge()) {\n      r.drawText(context, ele, 'source', applyRotation, useEleOpacity);\n      r.drawText(context, ele, 'target', applyRotation, useEleOpacity);\n    }\n  } else {\n    r.drawText(context, ele, prefix, applyRotation, useEleOpacity);\n  }\n\n  if (shiftToOriginWithBb) {\n    context.translate(bb.x1, bb.y1);\n  }\n};\n\nCRp$6.getFontCache = function (context) {\n  var cache;\n  this.fontCaches = this.fontCaches || [];\n\n  for (var i = 0; i < this.fontCaches.length; i++) {\n    cache = this.fontCaches[i];\n\n    if (cache.context === context) {\n      return cache;\n    }\n  }\n\n  cache = {\n    context: context\n  };\n  this.fontCaches.push(cache);\n  return cache;\n}; // set up canvas context with font\n// returns transformed text string\n\n\nCRp$6.setupTextStyle = function (context, ele) {\n  var useEleOpacity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  // Font style\n  var labelStyle = ele.pstyle('font-style').strValue;\n  var labelSize = ele.pstyle('font-size').pfValue + 'px';\n  var labelFamily = ele.pstyle('font-family').strValue;\n  var labelWeight = ele.pstyle('font-weight').strValue;\n  var opacity = useEleOpacity ? ele.effectiveOpacity() * ele.pstyle('text-opacity').value : 1;\n  var outlineOpacity = ele.pstyle('text-outline-opacity').value * opacity;\n  var color = ele.pstyle('color').value;\n  var outlineColor = ele.pstyle('text-outline-color').value;\n  context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;\n  context.lineJoin = 'round'; // so text outlines aren't jagged\n\n  this.colorFillStyle(context, color[0], color[1], color[2], opacity);\n  this.colorStrokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);\n}; // TODO ensure re-used\n\n\nfunction roundRect(ctx, x, y, width, height) {\n  var radius = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 5;\n  ctx.beginPath();\n  ctx.moveTo(x + radius, y);\n  ctx.lineTo(x + width - radius, y);\n  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n  ctx.lineTo(x + width, y + height - radius);\n  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n  ctx.lineTo(x + radius, y + height);\n  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n  ctx.lineTo(x, y + radius);\n  ctx.quadraticCurveTo(x, y, x + radius, y);\n  ctx.closePath();\n  ctx.fill();\n}\n\nCRp$6.getTextAngle = function (ele, prefix) {\n  var theta;\n  var _p = ele._private;\n  var rscratch = _p.rscratch;\n  var pdash = prefix ? prefix + '-' : '';\n  var rotation = ele.pstyle(pdash + 'text-rotation');\n  var textAngle = getPrefixedProperty(rscratch, 'labelAngle', prefix);\n\n  if (rotation.strValue === 'autorotate') {\n    theta = ele.isEdge() ? textAngle : 0;\n  } else if (rotation.strValue === 'none') {\n    theta = 0;\n  } else {\n    theta = rotation.pfValue;\n  }\n\n  return theta;\n};\n\nCRp$6.drawText = function (context, ele, prefix) {\n  var applyRotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var useEleOpacity = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  var _p = ele._private;\n  var rscratch = _p.rscratch;\n  var parentOpacity = useEleOpacity ? ele.effectiveOpacity() : 1;\n\n  if (useEleOpacity && (parentOpacity === 0 || ele.pstyle('text-opacity').value === 0)) {\n    return;\n  } // use 'main' as an alias for the main label (i.e. null prefix)\n\n\n  if (prefix === 'main') {\n    prefix = null;\n  }\n\n  var textX = getPrefixedProperty(rscratch, 'labelX', prefix);\n  var textY = getPrefixedProperty(rscratch, 'labelY', prefix);\n  var orgTextX, orgTextY; // used for rotation\n\n  var text = this.getLabelText(ele, prefix);\n\n  if (text != null && text !== '' && !isNaN(textX) && !isNaN(textY)) {\n    this.setupTextStyle(context, ele, useEleOpacity);\n    var pdash = prefix ? prefix + '-' : '';\n    var textW = getPrefixedProperty(rscratch, 'labelWidth', prefix);\n    var textH = getPrefixedProperty(rscratch, 'labelHeight', prefix);\n    var marginX = ele.pstyle(pdash + 'text-margin-x').pfValue;\n    var marginY = ele.pstyle(pdash + 'text-margin-y').pfValue;\n    var isEdge = ele.isEdge();\n    var halign = ele.pstyle('text-halign').value;\n    var valign = ele.pstyle('text-valign').value;\n\n    if (isEdge) {\n      halign = 'center';\n      valign = 'center';\n    }\n\n    textX += marginX;\n    textY += marginY;\n    var theta;\n\n    if (!applyRotation) {\n      theta = 0;\n    } else {\n      theta = this.getTextAngle(ele, prefix);\n    }\n\n    if (theta !== 0) {\n      orgTextX = textX;\n      orgTextY = textY;\n      context.translate(orgTextX, orgTextY);\n      context.rotate(theta);\n      textX = 0;\n      textY = 0;\n    }\n\n    switch (valign) {\n      case 'top':\n        break;\n\n      case 'center':\n        textY += textH / 2;\n        break;\n\n      case 'bottom':\n        textY += textH;\n        break;\n    }\n\n    var backgroundOpacity = ele.pstyle('text-background-opacity').value;\n    var borderOpacity = ele.pstyle('text-border-opacity').value;\n    var textBorderWidth = ele.pstyle('text-border-width').pfValue;\n    var backgroundPadding = ele.pstyle('text-background-padding').pfValue;\n\n    if (backgroundOpacity > 0 || textBorderWidth > 0 && borderOpacity > 0) {\n      var bgX = textX - backgroundPadding;\n\n      switch (halign) {\n        case 'left':\n          bgX -= textW;\n          break;\n\n        case 'center':\n          bgX -= textW / 2;\n          break;\n      }\n\n      var bgY = textY - textH - backgroundPadding;\n      var bgW = textW + 2 * backgroundPadding;\n      var bgH = textH + 2 * backgroundPadding;\n\n      if (backgroundOpacity > 0) {\n        var textFill = context.fillStyle;\n        var textBackgroundColor = ele.pstyle('text-background-color').value;\n        context.fillStyle = 'rgba(' + textBackgroundColor[0] + ',' + textBackgroundColor[1] + ',' + textBackgroundColor[2] + ',' + backgroundOpacity * parentOpacity + ')';\n        var styleShape = ele.pstyle('text-background-shape').strValue;\n\n        if (styleShape.indexOf('round') === 0) {\n          roundRect(context, bgX, bgY, bgW, bgH, 2);\n        } else {\n          context.fillRect(bgX, bgY, bgW, bgH);\n        }\n\n        context.fillStyle = textFill;\n      }\n\n      if (textBorderWidth > 0 && borderOpacity > 0) {\n        var textStroke = context.strokeStyle;\n        var textLineWidth = context.lineWidth;\n        var textBorderColor = ele.pstyle('text-border-color').value;\n        var textBorderStyle = ele.pstyle('text-border-style').value;\n        context.strokeStyle = 'rgba(' + textBorderColor[0] + ',' + textBorderColor[1] + ',' + textBorderColor[2] + ',' + borderOpacity * parentOpacity + ')';\n        context.lineWidth = textBorderWidth;\n\n        if (context.setLineDash) {\n          // for very outofdate browsers\n          switch (textBorderStyle) {\n            case 'dotted':\n              context.setLineDash([1, 1]);\n              break;\n\n            case 'dashed':\n              context.setLineDash([4, 2]);\n              break;\n\n            case 'double':\n              context.lineWidth = textBorderWidth / 4; // 50% reserved for white between the two borders\n\n              context.setLineDash([]);\n              break;\n\n            case 'solid':\n              context.setLineDash([]);\n              break;\n          }\n        }\n\n        context.strokeRect(bgX, bgY, bgW, bgH);\n\n        if (textBorderStyle === 'double') {\n          var whiteWidth = textBorderWidth / 2;\n          context.strokeRect(bgX + whiteWidth, bgY + whiteWidth, bgW - whiteWidth * 2, bgH - whiteWidth * 2);\n        }\n\n        if (context.setLineDash) {\n          // for very outofdate browsers\n          context.setLineDash([]);\n        }\n\n        context.lineWidth = textLineWidth;\n        context.strokeStyle = textStroke;\n      }\n    }\n\n    var lineWidth = 2 * ele.pstyle('text-outline-width').pfValue; // *2 b/c the stroke is drawn centred on the middle\n\n    if (lineWidth > 0) {\n      context.lineWidth = lineWidth;\n    }\n\n    if (ele.pstyle('text-wrap').value === 'wrap') {\n      var lines = getPrefixedProperty(rscratch, 'labelWrapCachedLines', prefix);\n      var lineHeight = getPrefixedProperty(rscratch, 'labelLineHeight', prefix);\n      var halfTextW = textW / 2;\n      var justification = this.getLabelJustification(ele);\n\n      if (justification === 'auto') ; else if (halign === 'left') {\n        // auto justification : right\n        if (justification === 'left') {\n          textX += -textW;\n        } else if (justification === 'center') {\n          textX += -halfTextW;\n        } // else same as auto\n\n      } else if (halign === 'center') {\n        // auto justfication : center\n        if (justification === 'left') {\n          textX += -halfTextW;\n        } else if (justification === 'right') {\n          textX += halfTextW;\n        } // else same as auto\n\n      } else if (halign === 'right') {\n        // auto justification : left\n        if (justification === 'center') {\n          textX += halfTextW;\n        } else if (justification === 'right') {\n          textX += textW;\n        } // else same as auto\n\n      }\n\n      switch (valign) {\n        case 'top':\n          textY -= (lines.length - 1) * lineHeight;\n          break;\n\n        case 'center':\n        case 'bottom':\n          textY -= (lines.length - 1) * lineHeight;\n          break;\n      }\n\n      for (var l = 0; l < lines.length; l++) {\n        if (lineWidth > 0) {\n          context.strokeText(lines[l], textX, textY);\n        }\n\n        context.fillText(lines[l], textX, textY);\n        textY += lineHeight;\n      }\n    } else {\n      if (lineWidth > 0) {\n        context.strokeText(text, textX, textY);\n      }\n\n      context.fillText(text, textX, textY);\n    }\n\n    if (theta !== 0) {\n      context.rotate(-theta);\n      context.translate(-orgTextX, -orgTextY);\n    }\n  }\n};\n\n/* global Path2D */\nvar CRp$5 = {};\n\nCRp$5.drawNode = function (context, node, shiftToOriginWithBb) {\n  var drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var r = this;\n  var nodeWidth, nodeHeight;\n  var _p = node._private;\n  var rs = _p.rscratch;\n  var pos = node.position();\n\n  if (!number$1(pos.x) || !number$1(pos.y)) {\n    return; // can't draw node with undefined position\n  }\n\n  if (shouldDrawOpacity && !node.visible()) {\n    return;\n  }\n\n  var eleOpacity = shouldDrawOpacity ? node.effectiveOpacity() : 1;\n  var usePaths = r.usePaths();\n  var path;\n  var pathCacheHit = false;\n  var padding = node.padding();\n  nodeWidth = node.width() + 2 * padding;\n  nodeHeight = node.height() + 2 * padding; //\n  // setup shift\n\n  var bb;\n\n  if (shiftToOriginWithBb) {\n    bb = shiftToOriginWithBb;\n    context.translate(-bb.x1, -bb.y1);\n  } //\n  // load bg image\n\n\n  var bgImgProp = node.pstyle('background-image');\n  var urls = bgImgProp.value;\n  var urlDefined = new Array(urls.length);\n  var image = new Array(urls.length);\n  var numImages = 0;\n\n  for (var i = 0; i < urls.length; i++) {\n    var url = urls[i];\n    var defd = urlDefined[i] = url != null && url !== 'none';\n\n    if (defd) {\n      var bgImgCrossOrigin = node.cy().style().getIndexedStyle(node, 'background-image-crossorigin', 'value', i);\n      numImages++; // get image, and if not loaded then ask to redraw when later loaded\n\n      image[i] = r.getCachedImage(url, bgImgCrossOrigin, function () {\n        _p.backgroundTimestamp = Date.now();\n        node.emitAndNotify('background');\n      });\n    }\n  } //\n  // setup styles\n\n\n  var darkness = node.pstyle('background-blacken').value;\n  var borderWidth = node.pstyle('border-width').pfValue;\n  var bgOpacity = node.pstyle('background-opacity').value * eleOpacity;\n  var borderColor = node.pstyle('border-color').value;\n  var borderStyle = node.pstyle('border-style').value;\n  var borderOpacity = node.pstyle('border-opacity').value * eleOpacity;\n  context.lineJoin = 'miter'; // so borders are square with the node shape\n\n  var setupShapeColor = function setupShapeColor() {\n    var bgOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : bgOpacity;\n    r.eleFillStyle(context, node, bgOpy);\n  };\n\n  var setupBorderColor = function setupBorderColor() {\n    var bdrOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : borderOpacity;\n    r.colorStrokeStyle(context, borderColor[0], borderColor[1], borderColor[2], bdrOpy);\n  }; //\n  // setup shape\n\n\n  var styleShape = node.pstyle('shape').strValue;\n  var shapePts = node.pstyle('shape-polygon-points').pfValue;\n\n  if (usePaths) {\n    context.translate(pos.x, pos.y);\n    var pathCache = r.nodePathCache = r.nodePathCache || [];\n    var key = hashStrings(styleShape === 'polygon' ? styleShape + ',' + shapePts.join(',') : styleShape, '' + nodeHeight, '' + nodeWidth);\n    var cachedPath = pathCache[key];\n\n    if (cachedPath != null) {\n      path = cachedPath;\n      pathCacheHit = true;\n      rs.pathCache = path;\n    } else {\n      path = new Path2D();\n      pathCache[key] = rs.pathCache = path;\n    }\n  }\n\n  var drawShape = function drawShape() {\n    if (!pathCacheHit) {\n      var npos = pos;\n\n      if (usePaths) {\n        npos = {\n          x: 0,\n          y: 0\n        };\n      }\n\n      r.nodeShapes[r.getNodeShape(node)].draw(path || context, npos.x, npos.y, nodeWidth, nodeHeight);\n    }\n\n    if (usePaths) {\n      context.fill(path);\n    } else {\n      context.fill();\n    }\n  };\n\n  var drawImages = function drawImages() {\n    var nodeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;\n    var inside = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var prevBging = _p.backgrounding;\n    var totalCompleted = 0;\n\n    for (var _i = 0; _i < image.length; _i++) {\n      var bgContainment = node.cy().style().getIndexedStyle(node, 'background-image-containment', 'value', _i);\n\n      if (inside && bgContainment === 'over' || !inside && bgContainment === 'inside') {\n        totalCompleted++;\n        continue;\n      }\n\n      if (urlDefined[_i] && image[_i].complete && !image[_i].error) {\n        totalCompleted++;\n        r.drawInscribedImage(context, image[_i], node, _i, nodeOpacity);\n      }\n    }\n\n    _p.backgrounding = !(totalCompleted === numImages);\n\n    if (prevBging !== _p.backgrounding) {\n      // update style b/c :backgrounding state changed\n      node.updateStyle(false);\n    }\n  };\n\n  var drawPie = function drawPie() {\n    var redrawShape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var pieOpacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eleOpacity;\n\n    if (r.hasPie(node)) {\n      r.drawPie(context, node, pieOpacity); // redraw/restore path if steps after pie need it\n\n      if (redrawShape) {\n        if (!usePaths) {\n          r.nodeShapes[r.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight);\n        }\n      }\n    }\n  };\n\n  var darken = function darken() {\n    var darkenOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;\n    var opacity = (darkness > 0 ? darkness : -darkness) * darkenOpacity;\n    var c = darkness > 0 ? 0 : 255;\n\n    if (darkness !== 0) {\n      r.colorFillStyle(context, c, c, c, opacity);\n\n      if (usePaths) {\n        context.fill(path);\n      } else {\n        context.fill();\n      }\n    }\n  };\n\n  var drawBorder = function drawBorder() {\n    if (borderWidth > 0) {\n      context.lineWidth = borderWidth;\n      context.lineCap = 'butt';\n\n      if (context.setLineDash) {\n        // for very outofdate browsers\n        switch (borderStyle) {\n          case 'dotted':\n            context.setLineDash([1, 1]);\n            break;\n\n          case 'dashed':\n            context.setLineDash([4, 2]);\n            break;\n\n          case 'solid':\n          case 'double':\n            context.setLineDash([]);\n            break;\n        }\n      }\n\n      if (usePaths) {\n        context.stroke(path);\n      } else {\n        context.stroke();\n      }\n\n      if (borderStyle === 'double') {\n        context.lineWidth = borderWidth / 3;\n        var gco = context.globalCompositeOperation;\n        context.globalCompositeOperation = 'destination-out';\n\n        if (usePaths) {\n          context.stroke(path);\n        } else {\n          context.stroke();\n        }\n\n        context.globalCompositeOperation = gco;\n      } // reset in case we changed the border style\n\n\n      if (context.setLineDash) {\n        // for very outofdate browsers\n        context.setLineDash([]);\n      }\n    }\n  };\n\n  var drawOverlay = function drawOverlay() {\n    if (shouldDrawOverlay) {\n      r.drawNodeOverlay(context, node, pos, nodeWidth, nodeHeight);\n    }\n  };\n\n  var drawUnderlay = function drawUnderlay() {\n    if (shouldDrawOverlay) {\n      r.drawNodeUnderlay(context, node, pos, nodeWidth, nodeHeight);\n    }\n  };\n\n  var drawText = function drawText() {\n    r.drawElementText(context, node, null, drawLabel);\n  };\n\n  var ghost = node.pstyle('ghost').value === 'yes';\n\n  if (ghost) {\n    var gx = node.pstyle('ghost-offset-x').pfValue;\n    var gy = node.pstyle('ghost-offset-y').pfValue;\n    var ghostOpacity = node.pstyle('ghost-opacity').value;\n    var effGhostOpacity = ghostOpacity * eleOpacity;\n    context.translate(gx, gy);\n    setupShapeColor(ghostOpacity * bgOpacity);\n    drawShape();\n    drawImages(effGhostOpacity, true);\n    setupBorderColor(ghostOpacity * borderOpacity);\n    drawBorder();\n    drawPie(darkness !== 0 || borderWidth !== 0);\n    drawImages(effGhostOpacity, false);\n    darken(effGhostOpacity);\n    context.translate(-gx, -gy);\n  }\n\n  if (usePaths) {\n    context.translate(-pos.x, -pos.y);\n  }\n\n  drawUnderlay();\n\n  if (usePaths) {\n    context.translate(pos.x, pos.y);\n  }\n\n  setupShapeColor();\n  drawShape();\n  drawImages(eleOpacity, true);\n  setupBorderColor();\n  drawBorder();\n  drawPie(darkness !== 0 || borderWidth !== 0);\n  drawImages(eleOpacity, false);\n  darken();\n\n  if (usePaths) {\n    context.translate(-pos.x, -pos.y);\n  }\n\n  drawText();\n  drawOverlay(); //\n  // clean up shift\n\n  if (shiftToOriginWithBb) {\n    context.translate(bb.x1, bb.y1);\n  }\n};\n\nvar drawNodeOverlayUnderlay = function drawNodeOverlayUnderlay(overlayOrUnderlay) {\n  if (!['overlay', 'underlay'].includes(overlayOrUnderlay)) {\n    throw new Error('Invalid state');\n  }\n\n  return function (context, node, pos, nodeWidth, nodeHeight) {\n    var r = this;\n\n    if (!node.visible()) {\n      return;\n    }\n\n    var padding = node.pstyle(\"\".concat(overlayOrUnderlay, \"-padding\")).pfValue;\n    var opacity = node.pstyle(\"\".concat(overlayOrUnderlay, \"-opacity\")).value;\n    var color = node.pstyle(\"\".concat(overlayOrUnderlay, \"-color\")).value;\n    var shape = node.pstyle(\"\".concat(overlayOrUnderlay, \"-shape\")).value;\n\n    if (opacity > 0) {\n      pos = pos || node.position();\n\n      if (nodeWidth == null || nodeHeight == null) {\n        var _padding = node.padding();\n\n        nodeWidth = node.width() + 2 * _padding;\n        nodeHeight = node.height() + 2 * _padding;\n      }\n\n      r.colorFillStyle(context, color[0], color[1], color[2], opacity);\n      r.nodeShapes[shape].draw(context, pos.x, pos.y, nodeWidth + padding * 2, nodeHeight + padding * 2);\n      context.fill();\n    }\n  };\n};\n\nCRp$5.drawNodeOverlay = drawNodeOverlayUnderlay('overlay');\nCRp$5.drawNodeUnderlay = drawNodeOverlayUnderlay('underlay'); // does the node have at least one pie piece?\n\nCRp$5.hasPie = function (node) {\n  node = node[0]; // ensure ele ref\n\n  return node._private.hasPie;\n};\n\nCRp$5.drawPie = function (context, node, nodeOpacity, pos) {\n  node = node[0]; // ensure ele ref\n\n  pos = pos || node.position();\n  var cyStyle = node.cy().style();\n  var pieSize = node.pstyle('pie-size');\n  var x = pos.x;\n  var y = pos.y;\n  var nodeW = node.width();\n  var nodeH = node.height();\n  var radius = Math.min(nodeW, nodeH) / 2; // must fit in node\n\n  var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]\n\n  var usePaths = this.usePaths();\n\n  if (usePaths) {\n    x = 0;\n    y = 0;\n  }\n\n  if (pieSize.units === '%') {\n    radius = radius * pieSize.pfValue;\n  } else if (pieSize.pfValue !== undefined) {\n    radius = pieSize.pfValue / 2;\n  }\n\n  for (var i = 1; i <= cyStyle.pieBackgroundN; i++) {\n    // 1..N\n    var size = node.pstyle('pie-' + i + '-background-size').value;\n    var color = node.pstyle('pie-' + i + '-background-color').value;\n    var opacity = node.pstyle('pie-' + i + '-background-opacity').value * nodeOpacity;\n    var percent = size / 100; // map integer range [0, 100] to [0, 1]\n    // percent can't push beyond 1\n\n    if (percent + lastPercent > 1) {\n      percent = 1 - lastPercent;\n    }\n\n    var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise\n\n    var angleDelta = 2 * Math.PI * percent;\n    var angleEnd = angleStart + angleDelta; // ignore if\n    // - zero size\n    // - we're already beyond the full circle\n    // - adding the current slice would go beyond the full circle\n\n    if (size === 0 || lastPercent >= 1 || lastPercent + percent > 1) {\n      continue;\n    }\n\n    context.beginPath();\n    context.moveTo(x, y);\n    context.arc(x, y, radius, angleStart, angleEnd);\n    context.closePath();\n    this.colorFillStyle(context, color[0], color[1], color[2], opacity);\n    context.fill();\n    lastPercent += percent;\n  }\n};\n\nvar CRp$4 = {};\nvar motionBlurDelay = 100; // var isFirefox = typeof InstallTrigger !== 'undefined';\n\nCRp$4.getPixelRatio = function () {\n  var context = this.data.contexts[0];\n\n  if (this.forcedPixelRatio != null) {\n    return this.forcedPixelRatio;\n  }\n\n  var backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;\n  return (window.devicePixelRatio || 1) / backingStore; // eslint-disable-line no-undef\n};\n\nCRp$4.paintCache = function (context) {\n  var caches = this.paintCaches = this.paintCaches || [];\n  var needToCreateCache = true;\n  var cache;\n\n  for (var i = 0; i < caches.length; i++) {\n    cache = caches[i];\n\n    if (cache.context === context) {\n      needToCreateCache = false;\n      break;\n    }\n  }\n\n  if (needToCreateCache) {\n    cache = {\n      context: context\n    };\n    caches.push(cache);\n  }\n\n  return cache;\n};\n\nCRp$4.createGradientStyleFor = function (context, shapeStyleName, ele, fill, opacity) {\n  var gradientStyle;\n  var usePaths = this.usePaths();\n  var colors = ele.pstyle(shapeStyleName + '-gradient-stop-colors').value,\n      positions = ele.pstyle(shapeStyleName + '-gradient-stop-positions').pfValue;\n\n  if (fill === 'radial-gradient') {\n    if (ele.isEdge()) {\n      var start = ele.sourceEndpoint(),\n          end = ele.targetEndpoint(),\n          mid = ele.midpoint();\n      var d1 = dist(start, mid);\n      var d2 = dist(end, mid);\n      gradientStyle = context.createRadialGradient(mid.x, mid.y, 0, mid.x, mid.y, Math.max(d1, d2));\n    } else {\n      var pos = usePaths ? {\n        x: 0,\n        y: 0\n      } : ele.position(),\n          width = ele.paddedWidth(),\n          height = ele.paddedHeight();\n      gradientStyle = context.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, Math.max(width, height));\n    }\n  } else {\n    if (ele.isEdge()) {\n      var _start = ele.sourceEndpoint(),\n          _end = ele.targetEndpoint();\n\n      gradientStyle = context.createLinearGradient(_start.x, _start.y, _end.x, _end.y);\n    } else {\n      var _pos = usePaths ? {\n        x: 0,\n        y: 0\n      } : ele.position(),\n          _width = ele.paddedWidth(),\n          _height = ele.paddedHeight(),\n          halfWidth = _width / 2,\n          halfHeight = _height / 2;\n\n      var direction = ele.pstyle('background-gradient-direction').value;\n\n      switch (direction) {\n        case 'to-bottom':\n          gradientStyle = context.createLinearGradient(_pos.x, _pos.y - halfHeight, _pos.x, _pos.y + halfHeight);\n          break;\n\n        case 'to-top':\n          gradientStyle = context.createLinearGradient(_pos.x, _pos.y + halfHeight, _pos.x, _pos.y - halfHeight);\n          break;\n\n        case 'to-left':\n          gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y, _pos.x - halfWidth, _pos.y);\n          break;\n\n        case 'to-right':\n          gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y, _pos.x + halfWidth, _pos.y);\n          break;\n\n        case 'to-bottom-right':\n        case 'to-right-bottom':\n          gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y - halfHeight, _pos.x + halfWidth, _pos.y + halfHeight);\n          break;\n\n        case 'to-top-right':\n        case 'to-right-top':\n          gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y + halfHeight, _pos.x + halfWidth, _pos.y - halfHeight);\n          break;\n\n        case 'to-bottom-left':\n        case 'to-left-bottom':\n          gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y - halfHeight, _pos.x - halfWidth, _pos.y + halfHeight);\n          break;\n\n        case 'to-top-left':\n        case 'to-left-top':\n          gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y + halfHeight, _pos.x - halfWidth, _pos.y - halfHeight);\n          break;\n      }\n    }\n  }\n\n  if (!gradientStyle) return null; // invalid gradient style\n\n  var hasPositions = positions.length === colors.length;\n  var length = colors.length;\n\n  for (var i = 0; i < length; i++) {\n    gradientStyle.addColorStop(hasPositions ? positions[i] : i / (length - 1), 'rgba(' + colors[i][0] + ',' + colors[i][1] + ',' + colors[i][2] + ',' + opacity + ')');\n  }\n\n  return gradientStyle;\n};\n\nCRp$4.gradientFillStyle = function (context, ele, fill, opacity) {\n  var gradientStyle = this.createGradientStyleFor(context, 'background', ele, fill, opacity);\n  if (!gradientStyle) return null; // error\n\n  context.fillStyle = gradientStyle;\n};\n\nCRp$4.colorFillStyle = function (context, r, g, b, a) {\n  context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')'; // turn off for now, seems context does its own caching\n  // var cache = this.paintCache(context);\n  // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n  // if( cache.fillStyle !== fillStyle ){\n  //   context.fillStyle = cache.fillStyle = fillStyle;\n  // }\n};\n\nCRp$4.eleFillStyle = function (context, ele, opacity) {\n  var backgroundFill = ele.pstyle('background-fill').value;\n\n  if (backgroundFill === 'linear-gradient' || backgroundFill === 'radial-gradient') {\n    this.gradientFillStyle(context, ele, backgroundFill, opacity);\n  } else {\n    var backgroundColor = ele.pstyle('background-color').value;\n    this.colorFillStyle(context, backgroundColor[0], backgroundColor[1], backgroundColor[2], opacity);\n  }\n};\n\nCRp$4.gradientStrokeStyle = function (context, ele, fill, opacity) {\n  var gradientStyle = this.createGradientStyleFor(context, 'line', ele, fill, opacity);\n  if (!gradientStyle) return null; // error\n\n  context.strokeStyle = gradientStyle;\n};\n\nCRp$4.colorStrokeStyle = function (context, r, g, b, a) {\n  context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')'; // turn off for now, seems context does its own caching\n  // var cache = this.paintCache(context);\n  // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n  // if( cache.strokeStyle !== strokeStyle ){\n  //   context.strokeStyle = cache.strokeStyle = strokeStyle;\n  // }\n};\n\nCRp$4.eleStrokeStyle = function (context, ele, opacity) {\n  var lineFill = ele.pstyle('line-fill').value;\n\n  if (lineFill === 'linear-gradient' || lineFill === 'radial-gradient') {\n    this.gradientStrokeStyle(context, ele, lineFill, opacity);\n  } else {\n    var lineColor = ele.pstyle('line-color').value;\n    this.colorStrokeStyle(context, lineColor[0], lineColor[1], lineColor[2], opacity);\n  }\n}; // Resize canvas\n\n\nCRp$4.matchCanvasSize = function (container) {\n  var r = this;\n  var data = r.data;\n  var bb = r.findContainerClientCoords();\n  var width = bb[2];\n  var height = bb[3];\n  var pixelRatio = r.getPixelRatio();\n  var mbPxRatio = r.motionBlurPxRatio;\n\n  if (container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE] || container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG]) {\n    pixelRatio = mbPxRatio;\n  }\n\n  var canvasWidth = width * pixelRatio;\n  var canvasHeight = height * pixelRatio;\n  var canvas;\n\n  if (canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight) {\n    return; // save cycles if same\n  }\n\n  r.fontCaches = null; // resizing resets the style\n\n  var canvasContainer = data.canvasContainer;\n  canvasContainer.style.width = width + 'px';\n  canvasContainer.style.height = height + 'px';\n\n  for (var i = 0; i < r.CANVAS_LAYERS; i++) {\n    canvas = data.canvases[i];\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n    canvas.style.width = width + 'px';\n    canvas.style.height = height + 'px';\n  }\n\n  for (var i = 0; i < r.BUFFER_COUNT; i++) {\n    canvas = data.bufferCanvases[i];\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n    canvas.style.width = width + 'px';\n    canvas.style.height = height + 'px';\n  }\n\n  r.textureMult = 1;\n\n  if (pixelRatio <= 1) {\n    canvas = data.bufferCanvases[r.TEXTURE_BUFFER];\n    r.textureMult = 2;\n    canvas.width = canvasWidth * r.textureMult;\n    canvas.height = canvasHeight * r.textureMult;\n  }\n\n  r.canvasWidth = canvasWidth;\n  r.canvasHeight = canvasHeight;\n};\n\nCRp$4.renderTo = function (cxt, zoom, pan, pxRatio) {\n  this.render({\n    forcedContext: cxt,\n    forcedZoom: zoom,\n    forcedPan: pan,\n    drawAllLayers: true,\n    forcedPxRatio: pxRatio\n  });\n};\n\nCRp$4.render = function (options) {\n  options = options || staticEmptyObject();\n  var forcedContext = options.forcedContext;\n  var drawAllLayers = options.drawAllLayers;\n  var drawOnlyNodeLayer = options.drawOnlyNodeLayer;\n  var forcedZoom = options.forcedZoom;\n  var forcedPan = options.forcedPan;\n  var r = this;\n  var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;\n  var cy = r.cy;\n  var data = r.data;\n  var needDraw = data.canvasNeedsRedraw;\n  var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);\n  var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;\n  var mbPxRatio = r.motionBlurPxRatio;\n  var hasCompoundNodes = cy.hasCompoundNodes();\n  var inNodeDragGesture = r.hoverData.draggingEles;\n  var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;\n  motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;\n  var motionBlurFadeEffect = motionBlur;\n\n  if (!forcedContext) {\n    if (r.prevPxRatio !== pixelRatio) {\n      r.invalidateContainerClientCoordsCache();\n      r.matchCanvasSize(r.container);\n      r.redrawHint('eles', true);\n      r.redrawHint('drag', true);\n    }\n\n    r.prevPxRatio = pixelRatio;\n  }\n\n  if (!forcedContext && r.motionBlurTimeout) {\n    clearTimeout(r.motionBlurTimeout);\n  }\n\n  if (motionBlur) {\n    if (r.mbFrames == null) {\n      r.mbFrames = 0;\n    }\n\n    r.mbFrames++;\n\n    if (r.mbFrames < 3) {\n      // need several frames before even high quality motionblur\n      motionBlurFadeEffect = false;\n    } // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)\n\n\n    if (r.mbFrames > r.minMbLowQualFrames) {\n      //r.fullQualityMb = false;\n      r.motionBlurPxRatio = r.mbPxRBlurry;\n    }\n  }\n\n  if (r.clearingMotionBlur) {\n    r.motionBlurPxRatio = 1;\n  } // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame\n  // because a rogue async texture frame would clear needDraw\n\n\n  if (r.textureDrawLastFrame && !textureDraw) {\n    needDraw[r.NODE] = true;\n    needDraw[r.SELECT_BOX] = true;\n  }\n\n  var style = cy.style();\n  var zoom = cy.zoom();\n  var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;\n  var pan = cy.pan();\n  var effectivePan = {\n    x: pan.x,\n    y: pan.y\n  };\n  var vp = {\n    zoom: zoom,\n    pan: {\n      x: pan.x,\n      y: pan.y\n    }\n  };\n  var prevVp = r.prevViewport;\n  var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y; // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)\n\n  if (!viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes)) {\n    r.motionBlurPxRatio = 1;\n  }\n\n  if (forcedPan) {\n    effectivePan = forcedPan;\n  } // apply pixel ratio\n\n\n  effectiveZoom *= pixelRatio;\n  effectivePan.x *= pixelRatio;\n  effectivePan.y *= pixelRatio;\n  var eles = r.getCachedZSortedEles();\n\n  function mbclear(context, x, y, w, h) {\n    var gco = context.globalCompositeOperation;\n    context.globalCompositeOperation = 'destination-out';\n    r.colorFillStyle(context, 255, 255, 255, r.motionBlurTransparency);\n    context.fillRect(x, y, w, h);\n    context.globalCompositeOperation = gco;\n  }\n\n  function setContextTransform(context, clear) {\n    var ePan, eZoom, w, h;\n\n    if (!r.clearingMotionBlur && (context === data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] || context === data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG])) {\n      ePan = {\n        x: pan.x * mbPxRatio,\n        y: pan.y * mbPxRatio\n      };\n      eZoom = zoom * mbPxRatio;\n      w = r.canvasWidth * mbPxRatio;\n      h = r.canvasHeight * mbPxRatio;\n    } else {\n      ePan = effectivePan;\n      eZoom = effectiveZoom;\n      w = r.canvasWidth;\n      h = r.canvasHeight;\n    }\n\n    context.setTransform(1, 0, 0, 1, 0, 0);\n\n    if (clear === 'motionBlur') {\n      mbclear(context, 0, 0, w, h);\n    } else if (!forcedContext && (clear === undefined || clear)) {\n      context.clearRect(0, 0, w, h);\n    }\n\n    if (!drawAllLayers) {\n      context.translate(ePan.x, ePan.y);\n      context.scale(eZoom, eZoom);\n    }\n\n    if (forcedPan) {\n      context.translate(forcedPan.x, forcedPan.y);\n    }\n\n    if (forcedZoom) {\n      context.scale(forcedZoom, forcedZoom);\n    }\n  }\n\n  if (!textureDraw) {\n    r.textureDrawLastFrame = false;\n  }\n\n  if (textureDraw) {\n    r.textureDrawLastFrame = true;\n\n    if (!r.textureCache) {\n      r.textureCache = {};\n      r.textureCache.bb = cy.mutableElements().boundingBox();\n      r.textureCache.texture = r.data.bufferCanvases[r.TEXTURE_BUFFER];\n      var cxt = r.data.bufferContexts[r.TEXTURE_BUFFER];\n      cxt.setTransform(1, 0, 0, 1, 0, 0);\n      cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);\n      r.render({\n        forcedContext: cxt,\n        drawOnlyNodeLayer: true,\n        forcedPxRatio: pixelRatio * r.textureMult\n      });\n      var vp = r.textureCache.viewport = {\n        zoom: cy.zoom(),\n        pan: cy.pan(),\n        width: r.canvasWidth,\n        height: r.canvasHeight\n      };\n      vp.mpan = {\n        x: (0 - vp.pan.x) / vp.zoom,\n        y: (0 - vp.pan.y) / vp.zoom\n      };\n    }\n\n    needDraw[r.DRAG] = false;\n    needDraw[r.NODE] = false;\n    var context = data.contexts[r.NODE];\n    var texture = r.textureCache.texture;\n    var vp = r.textureCache.viewport;\n    context.setTransform(1, 0, 0, 1, 0, 0);\n\n    if (motionBlur) {\n      mbclear(context, 0, 0, vp.width, vp.height);\n    } else {\n      context.clearRect(0, 0, vp.width, vp.height);\n    }\n\n    var outsideBgColor = style.core('outside-texture-bg-color').value;\n    var outsideBgOpacity = style.core('outside-texture-bg-opacity').value;\n    r.colorFillStyle(context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity);\n    context.fillRect(0, 0, vp.width, vp.height);\n    var zoom = cy.zoom();\n    setContextTransform(context, false);\n    context.clearRect(vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);\n    context.drawImage(texture, vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);\n  } else if (r.textureOnViewport && !forcedContext) {\n    // clear the cache since we don't need it\n    r.textureCache = null;\n  }\n\n  var extent = cy.extent();\n  var vpManip = r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles || r.cy.animated();\n  var hideEdges = r.hideEdgesOnViewport && vpManip;\n  var needMbClear = [];\n  needMbClear[r.NODE] = !needDraw[r.NODE] && motionBlur && !r.clearedForMotionBlur[r.NODE] || r.clearingMotionBlur;\n\n  if (needMbClear[r.NODE]) {\n    r.clearedForMotionBlur[r.NODE] = true;\n  }\n\n  needMbClear[r.DRAG] = !needDraw[r.DRAG] && motionBlur && !r.clearedForMotionBlur[r.DRAG] || r.clearingMotionBlur;\n\n  if (needMbClear[r.DRAG]) {\n    r.clearedForMotionBlur[r.DRAG] = true;\n  }\n\n  if (needDraw[r.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[r.NODE]) {\n    var useBuffer = motionBlur && !needMbClear[r.NODE] && mbPxRatio !== 1;\n    var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] : data.contexts[r.NODE]);\n    var clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;\n    setContextTransform(context, clear);\n\n    if (hideEdges) {\n      r.drawCachedNodes(context, eles.nondrag, pixelRatio, extent);\n    } else {\n      r.drawLayeredElements(context, eles.nondrag, pixelRatio, extent);\n    }\n\n    if (r.debug) {\n      r.drawDebugPoints(context, eles.nondrag);\n    }\n\n    if (!drawAllLayers && !motionBlur) {\n      needDraw[r.NODE] = false;\n    }\n  }\n\n  if (!drawOnlyNodeLayer && (needDraw[r.DRAG] || drawAllLayers || needMbClear[r.DRAG])) {\n    var useBuffer = motionBlur && !needMbClear[r.DRAG] && mbPxRatio !== 1;\n    var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG] : data.contexts[r.DRAG]);\n    setContextTransform(context, motionBlur && !useBuffer ? 'motionBlur' : undefined);\n\n    if (hideEdges) {\n      r.drawCachedNodes(context, eles.drag, pixelRatio, extent);\n    } else {\n      r.drawCachedElements(context, eles.drag, pixelRatio, extent);\n    }\n\n    if (r.debug) {\n      r.drawDebugPoints(context, eles.drag);\n    }\n\n    if (!drawAllLayers && !motionBlur) {\n      needDraw[r.DRAG] = false;\n    }\n  }\n\n  if (r.showFps || !drawOnlyNodeLayer && needDraw[r.SELECT_BOX] && !drawAllLayers) {\n    var context = forcedContext || data.contexts[r.SELECT_BOX];\n    setContextTransform(context);\n\n    if (r.selection[4] == 1 && (r.hoverData.selecting || r.touchData.selecting)) {\n      var zoom = r.cy.zoom();\n      var borderWidth = style.core('selection-box-border-width').value / zoom;\n      context.lineWidth = borderWidth;\n      context.fillStyle = 'rgba(' + style.core('selection-box-color').value[0] + ',' + style.core('selection-box-color').value[1] + ',' + style.core('selection-box-color').value[2] + ',' + style.core('selection-box-opacity').value + ')';\n      context.fillRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);\n\n      if (borderWidth > 0) {\n        context.strokeStyle = 'rgba(' + style.core('selection-box-border-color').value[0] + ',' + style.core('selection-box-border-color').value[1] + ',' + style.core('selection-box-border-color').value[2] + ',' + style.core('selection-box-opacity').value + ')';\n        context.strokeRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);\n      }\n    }\n\n    if (data.bgActivePosistion && !r.hoverData.selecting) {\n      var zoom = r.cy.zoom();\n      var pos = data.bgActivePosistion;\n      context.fillStyle = 'rgba(' + style.core('active-bg-color').value[0] + ',' + style.core('active-bg-color').value[1] + ',' + style.core('active-bg-color').value[2] + ',' + style.core('active-bg-opacity').value + ')';\n      context.beginPath();\n      context.arc(pos.x, pos.y, style.core('active-bg-size').pfValue / zoom, 0, 2 * Math.PI);\n      context.fill();\n    }\n\n    var timeToRender = r.lastRedrawTime;\n\n    if (r.showFps && timeToRender) {\n      timeToRender = Math.round(timeToRender);\n      var fps = Math.round(1000 / timeToRender);\n      context.setTransform(1, 0, 0, 1, 0, 0);\n      context.fillStyle = 'rgba(255, 0, 0, 0.75)';\n      context.strokeStyle = 'rgba(255, 0, 0, 0.75)';\n      context.lineWidth = 1;\n      context.fillText('1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20);\n      var maxFps = 60;\n      context.strokeRect(0, 30, 250, 20);\n      context.fillRect(0, 30, 250 * Math.min(fps / maxFps, 1), 20);\n    }\n\n    if (!drawAllLayers) {\n      needDraw[r.SELECT_BOX] = false;\n    }\n  } // motionblur: blit rendered blurry frames\n\n\n  if (motionBlur && mbPxRatio !== 1) {\n    var cxtNode = data.contexts[r.NODE];\n    var txtNode = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE];\n    var cxtDrag = data.contexts[r.DRAG];\n    var txtDrag = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG];\n\n    var drawMotionBlur = function drawMotionBlur(cxt, txt, needClear) {\n      cxt.setTransform(1, 0, 0, 1, 0, 0);\n\n      if (needClear || !motionBlurFadeEffect) {\n        cxt.clearRect(0, 0, r.canvasWidth, r.canvasHeight);\n      } else {\n        mbclear(cxt, 0, 0, r.canvasWidth, r.canvasHeight);\n      }\n\n      var pxr = mbPxRatio;\n      cxt.drawImage(txt, // img\n      0, 0, // sx, sy\n      r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh\n      0, 0, // x, y\n      r.canvasWidth, r.canvasHeight // w, h\n      );\n    };\n\n    if (needDraw[r.NODE] || needMbClear[r.NODE]) {\n      drawMotionBlur(cxtNode, txtNode, needMbClear[r.NODE]);\n      needDraw[r.NODE] = false;\n    }\n\n    if (needDraw[r.DRAG] || needMbClear[r.DRAG]) {\n      drawMotionBlur(cxtDrag, txtDrag, needMbClear[r.DRAG]);\n      needDraw[r.DRAG] = false;\n    }\n  }\n\n  r.prevViewport = vp;\n\n  if (r.clearingMotionBlur) {\n    r.clearingMotionBlur = false;\n    r.motionBlurCleared = true;\n    r.motionBlur = true;\n  }\n\n  if (motionBlur) {\n    r.motionBlurTimeout = setTimeout(function () {\n      r.motionBlurTimeout = null;\n      r.clearedForMotionBlur[r.NODE] = false;\n      r.clearedForMotionBlur[r.DRAG] = false;\n      r.motionBlur = false;\n      r.clearingMotionBlur = !textureDraw;\n      r.mbFrames = 0;\n      needDraw[r.NODE] = true;\n      needDraw[r.DRAG] = true;\n      r.redraw();\n    }, motionBlurDelay);\n  }\n\n  if (!forcedContext) {\n    cy.emit('render');\n  }\n};\n\nvar CRp$3 = {}; // @O Polygon drawing\n\nCRp$3.drawPolygonPath = function (context, x, y, width, height, points) {\n  var halfW = width / 2;\n  var halfH = height / 2;\n\n  if (context.beginPath) {\n    context.beginPath();\n  }\n\n  context.moveTo(x + halfW * points[0], y + halfH * points[1]);\n\n  for (var i = 1; i < points.length / 2; i++) {\n    context.lineTo(x + halfW * points[i * 2], y + halfH * points[i * 2 + 1]);\n  }\n\n  context.closePath();\n};\n\nCRp$3.drawRoundPolygonPath = function (context, x, y, width, height, points) {\n  var halfW = width / 2;\n  var halfH = height / 2;\n  var cornerRadius = getRoundPolygonRadius(width, height);\n\n  if (context.beginPath) {\n    context.beginPath();\n  }\n\n  for (var _i = 0; _i < points.length / 4; _i++) {\n    var sourceUv = void 0,\n        destUv = void 0;\n\n    if (_i === 0) {\n      sourceUv = points.length - 2;\n    } else {\n      sourceUv = _i * 4 - 2;\n    }\n\n    destUv = _i * 4 + 2;\n    var px = x + halfW * points[_i * 4];\n    var py = y + halfH * points[_i * 4 + 1];\n    var cosTheta = -points[sourceUv] * points[destUv] - points[sourceUv + 1] * points[destUv + 1];\n    var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);\n    var cp0x = px - offset * points[sourceUv];\n    var cp0y = py - offset * points[sourceUv + 1];\n    var cp1x = px + offset * points[destUv];\n    var cp1y = py + offset * points[destUv + 1];\n\n    if (_i === 0) {\n      context.moveTo(cp0x, cp0y);\n    } else {\n      context.lineTo(cp0x, cp0y);\n    }\n\n    context.arcTo(px, py, cp1x, cp1y, cornerRadius);\n  }\n\n  context.closePath();\n}; // Round rectangle drawing\n\n\nCRp$3.drawRoundRectanglePath = function (context, x, y, width, height) {\n  var halfWidth = width / 2;\n  var halfHeight = height / 2;\n  var cornerRadius = getRoundRectangleRadius(width, height);\n\n  if (context.beginPath) {\n    context.beginPath();\n  } // Start at top middle\n\n\n  context.moveTo(x, y - halfHeight); // Arc from middle top to right side\n\n  context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius); // Arc from right side to bottom\n\n  context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius); // Arc from bottom to left side\n\n  context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius); // Arc from left side to topBorder\n\n  context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius); // Join line\n\n  context.lineTo(x, y - halfHeight);\n  context.closePath();\n};\n\nCRp$3.drawBottomRoundRectanglePath = function (context, x, y, width, height) {\n  var halfWidth = width / 2;\n  var halfHeight = height / 2;\n  var cornerRadius = getRoundRectangleRadius(width, height);\n\n  if (context.beginPath) {\n    context.beginPath();\n  } // Start at top middle\n\n\n  context.moveTo(x, y - halfHeight);\n  context.lineTo(x + halfWidth, y - halfHeight);\n  context.lineTo(x + halfWidth, y);\n  context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);\n  context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);\n  context.lineTo(x - halfWidth, y - halfHeight);\n  context.lineTo(x, y - halfHeight);\n  context.closePath();\n};\n\nCRp$3.drawCutRectanglePath = function (context, x, y, width, height) {\n  var halfWidth = width / 2;\n  var halfHeight = height / 2;\n  var cornerLength = getCutRectangleCornerLength();\n\n  if (context.beginPath) {\n    context.beginPath();\n  }\n\n  context.moveTo(x - halfWidth + cornerLength, y - halfHeight);\n  context.lineTo(x + halfWidth - cornerLength, y - halfHeight);\n  context.lineTo(x + halfWidth, y - halfHeight + cornerLength);\n  context.lineTo(x + halfWidth, y + halfHeight - cornerLength);\n  context.lineTo(x + halfWidth - cornerLength, y + halfHeight);\n  context.lineTo(x - halfWidth + cornerLength, y + halfHeight);\n  context.lineTo(x - halfWidth, y + halfHeight - cornerLength);\n  context.lineTo(x - halfWidth, y - halfHeight + cornerLength);\n  context.closePath();\n};\n\nCRp$3.drawBarrelPath = function (context, x, y, width, height) {\n  var halfWidth = width / 2;\n  var halfHeight = height / 2;\n  var xBegin = x - halfWidth;\n  var xEnd = x + halfWidth;\n  var yBegin = y - halfHeight;\n  var yEnd = y + halfHeight;\n  var barrelCurveConstants = getBarrelCurveConstants(width, height);\n  var wOffset = barrelCurveConstants.widthOffset;\n  var hOffset = barrelCurveConstants.heightOffset;\n  var ctrlPtXOffset = barrelCurveConstants.ctrlPtOffsetPct * wOffset;\n\n  if (context.beginPath) {\n    context.beginPath();\n  }\n\n  context.moveTo(xBegin, yBegin + hOffset);\n  context.lineTo(xBegin, yEnd - hOffset);\n  context.quadraticCurveTo(xBegin + ctrlPtXOffset, yEnd, xBegin + wOffset, yEnd);\n  context.lineTo(xEnd - wOffset, yEnd);\n  context.quadraticCurveTo(xEnd - ctrlPtXOffset, yEnd, xEnd, yEnd - hOffset);\n  context.lineTo(xEnd, yBegin + hOffset);\n  context.quadraticCurveTo(xEnd - ctrlPtXOffset, yBegin, xEnd - wOffset, yBegin);\n  context.lineTo(xBegin + wOffset, yBegin);\n  context.quadraticCurveTo(xBegin + ctrlPtXOffset, yBegin, xBegin, yBegin + hOffset);\n  context.closePath();\n};\n\nvar sin0 = Math.sin(0);\nvar cos0 = Math.cos(0);\nvar sin = {};\nvar cos = {};\nvar ellipseStepSize = Math.PI / 40;\n\nfor (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {\n  sin[i] = Math.sin(i);\n  cos[i] = Math.cos(i);\n}\n\nCRp$3.drawEllipsePath = function (context, centerX, centerY, width, height) {\n  if (context.beginPath) {\n    context.beginPath();\n  }\n\n  if (context.ellipse) {\n    context.ellipse(centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI);\n  } else {\n    var xPos, yPos;\n    var rw = width / 2;\n    var rh = height / 2;\n\n    for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {\n      xPos = centerX - rw * sin[i] * sin0 + rw * cos[i] * cos0;\n      yPos = centerY + rh * cos[i] * sin0 + rh * sin[i] * cos0;\n\n      if (i === 0) {\n        context.moveTo(xPos, yPos);\n      } else {\n        context.lineTo(xPos, yPos);\n      }\n    }\n  }\n\n  context.closePath();\n};\n\n/* global atob, ArrayBuffer, Uint8Array, Blob */\nvar CRp$2 = {};\n\nCRp$2.createBuffer = function (w, h) {\n  var buffer = document.createElement('canvas'); // eslint-disable-line no-undef\n\n  buffer.width = w;\n  buffer.height = h;\n  return [buffer, buffer.getContext('2d')];\n};\n\nCRp$2.bufferCanvasImage = function (options) {\n  var cy = this.cy;\n  var eles = cy.mutableElements();\n  var bb = eles.boundingBox();\n  var ctrRect = this.findContainerClientCoords();\n  var width = options.full ? Math.ceil(bb.w) : ctrRect[2];\n  var height = options.full ? Math.ceil(bb.h) : ctrRect[3];\n  var specdMaxDims = number$1(options.maxWidth) || number$1(options.maxHeight);\n  var pxRatio = this.getPixelRatio();\n  var scale = 1;\n\n  if (options.scale !== undefined) {\n    width *= options.scale;\n    height *= options.scale;\n    scale = options.scale;\n  } else if (specdMaxDims) {\n    var maxScaleW = Infinity;\n    var maxScaleH = Infinity;\n\n    if (number$1(options.maxWidth)) {\n      maxScaleW = scale * options.maxWidth / width;\n    }\n\n    if (number$1(options.maxHeight)) {\n      maxScaleH = scale * options.maxHeight / height;\n    }\n\n    scale = Math.min(maxScaleW, maxScaleH);\n    width *= scale;\n    height *= scale;\n  }\n\n  if (!specdMaxDims) {\n    width *= pxRatio;\n    height *= pxRatio;\n    scale *= pxRatio;\n  }\n\n  var buffCanvas = document.createElement('canvas'); // eslint-disable-line no-undef\n\n  buffCanvas.width = width;\n  buffCanvas.height = height;\n  buffCanvas.style.width = width + 'px';\n  buffCanvas.style.height = height + 'px';\n  var buffCxt = buffCanvas.getContext('2d'); // Rasterize the layers, but only if container has nonzero size\n\n  if (width > 0 && height > 0) {\n    buffCxt.clearRect(0, 0, width, height);\n    buffCxt.globalCompositeOperation = 'source-over';\n    var zsortedEles = this.getCachedZSortedEles();\n\n    if (options.full) {\n      // draw the full bounds of the graph\n      buffCxt.translate(-bb.x1 * scale, -bb.y1 * scale);\n      buffCxt.scale(scale, scale);\n      this.drawElements(buffCxt, zsortedEles);\n      buffCxt.scale(1 / scale, 1 / scale);\n      buffCxt.translate(bb.x1 * scale, bb.y1 * scale);\n    } else {\n      // draw the current view\n      var pan = cy.pan();\n      var translation = {\n        x: pan.x * scale,\n        y: pan.y * scale\n      };\n      scale *= cy.zoom();\n      buffCxt.translate(translation.x, translation.y);\n      buffCxt.scale(scale, scale);\n      this.drawElements(buffCxt, zsortedEles);\n      buffCxt.scale(1 / scale, 1 / scale);\n      buffCxt.translate(-translation.x, -translation.y);\n    } // need to fill bg at end like this in order to fill cleared transparent pixels in jpgs\n\n\n    if (options.bg) {\n      buffCxt.globalCompositeOperation = 'destination-over';\n      buffCxt.fillStyle = options.bg;\n      buffCxt.rect(0, 0, width, height);\n      buffCxt.fill();\n    }\n  }\n\n  return buffCanvas;\n};\n\nfunction b64ToBlob(b64, mimeType) {\n  var bytes = atob(b64);\n  var buff = new ArrayBuffer(bytes.length);\n  var buffUint8 = new Uint8Array(buff);\n\n  for (var i = 0; i < bytes.length; i++) {\n    buffUint8[i] = bytes.charCodeAt(i);\n  }\n\n  return new Blob([buff], {\n    type: mimeType\n  });\n}\n\nfunction b64UriToB64(b64uri) {\n  var i = b64uri.indexOf(',');\n  return b64uri.substr(i + 1);\n}\n\nfunction output(options, canvas, mimeType) {\n  var getB64Uri = function getB64Uri() {\n    return canvas.toDataURL(mimeType, options.quality);\n  };\n\n  switch (options.output) {\n    case 'blob-promise':\n      return new Promise$1(function (resolve, reject) {\n        try {\n          canvas.toBlob(function (blob) {\n            if (blob != null) {\n              resolve(blob);\n            } else {\n              reject(new Error('`canvas.toBlob()` sent a null value in its callback'));\n            }\n          }, mimeType, options.quality);\n        } catch (err) {\n          reject(err);\n        }\n      });\n\n    case 'blob':\n      return b64ToBlob(b64UriToB64(getB64Uri()), mimeType);\n\n    case 'base64':\n      return b64UriToB64(getB64Uri());\n\n    case 'base64uri':\n    default:\n      return getB64Uri();\n  }\n}\n\nCRp$2.png = function (options) {\n  return output(options, this.bufferCanvasImage(options), 'image/png');\n};\n\nCRp$2.jpg = function (options) {\n  return output(options, this.bufferCanvasImage(options), 'image/jpeg');\n};\n\nvar CRp$1 = {};\n\nCRp$1.nodeShapeImpl = function (name, context, centerX, centerY, width, height, points) {\n  switch (name) {\n    case 'ellipse':\n      return this.drawEllipsePath(context, centerX, centerY, width, height);\n\n    case 'polygon':\n      return this.drawPolygonPath(context, centerX, centerY, width, height, points);\n\n    case 'round-polygon':\n      return this.drawRoundPolygonPath(context, centerX, centerY, width, height, points);\n\n    case 'roundrectangle':\n    case 'round-rectangle':\n      return this.drawRoundRectanglePath(context, centerX, centerY, width, height);\n\n    case 'cutrectangle':\n    case 'cut-rectangle':\n      return this.drawCutRectanglePath(context, centerX, centerY, width, height);\n\n    case 'bottomroundrectangle':\n    case 'bottom-round-rectangle':\n      return this.drawBottomRoundRectanglePath(context, centerX, centerY, width, height);\n\n    case 'barrel':\n      return this.drawBarrelPath(context, centerX, centerY, width, height);\n  }\n};\n\nvar CR = CanvasRenderer;\nvar CRp = CanvasRenderer.prototype;\nCRp.CANVAS_LAYERS = 3; //\n\nCRp.SELECT_BOX = 0;\nCRp.DRAG = 1;\nCRp.NODE = 2;\nCRp.BUFFER_COUNT = 3; //\n\nCRp.TEXTURE_BUFFER = 0;\nCRp.MOTIONBLUR_BUFFER_NODE = 1;\nCRp.MOTIONBLUR_BUFFER_DRAG = 2;\n\nfunction CanvasRenderer(options) {\n  var r = this;\n  r.data = {\n    canvases: new Array(CRp.CANVAS_LAYERS),\n    contexts: new Array(CRp.CANVAS_LAYERS),\n    canvasNeedsRedraw: new Array(CRp.CANVAS_LAYERS),\n    bufferCanvases: new Array(CRp.BUFFER_COUNT),\n    bufferContexts: new Array(CRp.CANVAS_LAYERS)\n  };\n  var tapHlOffAttr = '-webkit-tap-highlight-color';\n  var tapHlOffStyle = 'rgba(0,0,0,0)';\n  r.data.canvasContainer = document.createElement('div'); // eslint-disable-line no-undef\n\n  var containerStyle = r.data.canvasContainer.style;\n  r.data.canvasContainer.style[tapHlOffAttr] = tapHlOffStyle;\n  containerStyle.position = 'relative';\n  containerStyle.zIndex = '0';\n  containerStyle.overflow = 'hidden';\n  var container = options.cy.container();\n  container.appendChild(r.data.canvasContainer);\n  container.style[tapHlOffAttr] = tapHlOffStyle;\n  var styleMap = {\n    '-webkit-user-select': 'none',\n    '-moz-user-select': '-moz-none',\n    'user-select': 'none',\n    '-webkit-tap-highlight-color': 'rgba(0,0,0,0)',\n    'outline-style': 'none'\n  };\n\n  if (ms()) {\n    styleMap['-ms-touch-action'] = 'none';\n    styleMap['touch-action'] = 'none';\n  }\n\n  for (var i = 0; i < CRp.CANVAS_LAYERS; i++) {\n    var canvas = r.data.canvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef\n\n    r.data.contexts[i] = canvas.getContext('2d');\n    Object.keys(styleMap).forEach(function (k) {\n      canvas.style[k] = styleMap[k];\n    });\n    canvas.style.position = 'absolute';\n    canvas.setAttribute('data-id', 'layer' + i);\n    canvas.style.zIndex = String(CRp.CANVAS_LAYERS - i);\n    r.data.canvasContainer.appendChild(canvas);\n    r.data.canvasNeedsRedraw[i] = false;\n  }\n\n  r.data.topCanvas = r.data.canvases[0];\n  r.data.canvases[CRp.NODE].setAttribute('data-id', 'layer' + CRp.NODE + '-node');\n  r.data.canvases[CRp.SELECT_BOX].setAttribute('data-id', 'layer' + CRp.SELECT_BOX + '-selectbox');\n  r.data.canvases[CRp.DRAG].setAttribute('data-id', 'layer' + CRp.DRAG + '-drag');\n\n  for (var i = 0; i < CRp.BUFFER_COUNT; i++) {\n    r.data.bufferCanvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef\n\n    r.data.bufferContexts[i] = r.data.bufferCanvases[i].getContext('2d');\n    r.data.bufferCanvases[i].style.position = 'absolute';\n    r.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);\n    r.data.bufferCanvases[i].style.zIndex = String(-i - 1);\n    r.data.bufferCanvases[i].style.visibility = 'hidden'; //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);\n  }\n\n  r.pathsEnabled = true;\n  var emptyBb = makeBoundingBox();\n\n  var getBoxCenter = function getBoxCenter(bb) {\n    return {\n      x: (bb.x1 + bb.x2) / 2,\n      y: (bb.y1 + bb.y2) / 2\n    };\n  };\n\n  var getCenterOffset = function getCenterOffset(bb) {\n    return {\n      x: -bb.w / 2,\n      y: -bb.h / 2\n    };\n  };\n\n  var backgroundTimestampHasChanged = function backgroundTimestampHasChanged(ele) {\n    var _p = ele[0]._private;\n    var same = _p.oldBackgroundTimestamp === _p.backgroundTimestamp;\n    return !same;\n  };\n\n  var getStyleKey = function getStyleKey(ele) {\n    return ele[0]._private.nodeKey;\n  };\n\n  var getLabelKey = function getLabelKey(ele) {\n    return ele[0]._private.labelStyleKey;\n  };\n\n  var getSourceLabelKey = function getSourceLabelKey(ele) {\n    return ele[0]._private.sourceLabelStyleKey;\n  };\n\n  var getTargetLabelKey = function getTargetLabelKey(ele) {\n    return ele[0]._private.targetLabelStyleKey;\n  };\n\n  var drawElement = function drawElement(context, ele, bb, scaledLabelShown, useEleOpacity) {\n    return r.drawElement(context, ele, bb, false, false, useEleOpacity);\n  };\n\n  var drawLabel = function drawLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {\n    return r.drawElementText(context, ele, bb, scaledLabelShown, 'main', useEleOpacity);\n  };\n\n  var drawSourceLabel = function drawSourceLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {\n    return r.drawElementText(context, ele, bb, scaledLabelShown, 'source', useEleOpacity);\n  };\n\n  var drawTargetLabel = function drawTargetLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {\n    return r.drawElementText(context, ele, bb, scaledLabelShown, 'target', useEleOpacity);\n  };\n\n  var getElementBox = function getElementBox(ele) {\n    ele.boundingBox();\n    return ele[0]._private.bodyBounds;\n  };\n\n  var getLabelBox = function getLabelBox(ele) {\n    ele.boundingBox();\n    return ele[0]._private.labelBounds.main || emptyBb;\n  };\n\n  var getSourceLabelBox = function getSourceLabelBox(ele) {\n    ele.boundingBox();\n    return ele[0]._private.labelBounds.source || emptyBb;\n  };\n\n  var getTargetLabelBox = function getTargetLabelBox(ele) {\n    ele.boundingBox();\n    return ele[0]._private.labelBounds.target || emptyBb;\n  };\n\n  var isLabelVisibleAtScale = function isLabelVisibleAtScale(ele, scaledLabelShown) {\n    return scaledLabelShown;\n  };\n\n  var getElementRotationPoint = function getElementRotationPoint(ele) {\n    return getBoxCenter(getElementBox(ele));\n  };\n\n  var addTextMargin = function addTextMargin(prefix, pt, ele) {\n    var pre = prefix ? prefix + '-' : '';\n    return {\n      x: pt.x + ele.pstyle(pre + 'text-margin-x').pfValue,\n      y: pt.y + ele.pstyle(pre + 'text-margin-y').pfValue\n    };\n  };\n\n  var getRsPt = function getRsPt(ele, x, y) {\n    var rs = ele[0]._private.rscratch;\n    return {\n      x: rs[x],\n      y: rs[y]\n    };\n  };\n\n  var getLabelRotationPoint = function getLabelRotationPoint(ele) {\n    return addTextMargin('', getRsPt(ele, 'labelX', 'labelY'), ele);\n  };\n\n  var getSourceLabelRotationPoint = function getSourceLabelRotationPoint(ele) {\n    return addTextMargin('source', getRsPt(ele, 'sourceLabelX', 'sourceLabelY'), ele);\n  };\n\n  var getTargetLabelRotationPoint = function getTargetLabelRotationPoint(ele) {\n    return addTextMargin('target', getRsPt(ele, 'targetLabelX', 'targetLabelY'), ele);\n  };\n\n  var getElementRotationOffset = function getElementRotationOffset(ele) {\n    return getCenterOffset(getElementBox(ele));\n  };\n\n  var getSourceLabelRotationOffset = function getSourceLabelRotationOffset(ele) {\n    return getCenterOffset(getSourceLabelBox(ele));\n  };\n\n  var getTargetLabelRotationOffset = function getTargetLabelRotationOffset(ele) {\n    return getCenterOffset(getTargetLabelBox(ele));\n  };\n\n  var getLabelRotationOffset = function getLabelRotationOffset(ele) {\n    var bb = getLabelBox(ele);\n    var p = getCenterOffset(getLabelBox(ele));\n\n    if (ele.isNode()) {\n      switch (ele.pstyle('text-halign').value) {\n        case 'left':\n          p.x = -bb.w;\n          break;\n\n        case 'right':\n          p.x = 0;\n          break;\n      }\n\n      switch (ele.pstyle('text-valign').value) {\n        case 'top':\n          p.y = -bb.h;\n          break;\n\n        case 'bottom':\n          p.y = 0;\n          break;\n      }\n    }\n\n    return p;\n  };\n\n  var eleTxrCache = r.data.eleTxrCache = new ElementTextureCache(r, {\n    getKey: getStyleKey,\n    doesEleInvalidateKey: backgroundTimestampHasChanged,\n    drawElement: drawElement,\n    getBoundingBox: getElementBox,\n    getRotationPoint: getElementRotationPoint,\n    getRotationOffset: getElementRotationOffset,\n    allowEdgeTxrCaching: false,\n    allowParentTxrCaching: false\n  });\n  var lblTxrCache = r.data.lblTxrCache = new ElementTextureCache(r, {\n    getKey: getLabelKey,\n    drawElement: drawLabel,\n    getBoundingBox: getLabelBox,\n    getRotationPoint: getLabelRotationPoint,\n    getRotationOffset: getLabelRotationOffset,\n    isVisible: isLabelVisibleAtScale\n  });\n  var slbTxrCache = r.data.slbTxrCache = new ElementTextureCache(r, {\n    getKey: getSourceLabelKey,\n    drawElement: drawSourceLabel,\n    getBoundingBox: getSourceLabelBox,\n    getRotationPoint: getSourceLabelRotationPoint,\n    getRotationOffset: getSourceLabelRotationOffset,\n    isVisible: isLabelVisibleAtScale\n  });\n  var tlbTxrCache = r.data.tlbTxrCache = new ElementTextureCache(r, {\n    getKey: getTargetLabelKey,\n    drawElement: drawTargetLabel,\n    getBoundingBox: getTargetLabelBox,\n    getRotationPoint: getTargetLabelRotationPoint,\n    getRotationOffset: getTargetLabelRotationOffset,\n    isVisible: isLabelVisibleAtScale\n  });\n  var lyrTxrCache = r.data.lyrTxrCache = new LayeredTextureCache(r);\n  r.onUpdateEleCalcs(function invalidateTextureCaches(willDraw, eles) {\n    // each cache should check for sub-key diff to see that the update affects that cache particularly\n    eleTxrCache.invalidateElements(eles);\n    lblTxrCache.invalidateElements(eles);\n    slbTxrCache.invalidateElements(eles);\n    tlbTxrCache.invalidateElements(eles); // any change invalidates the layers\n\n    lyrTxrCache.invalidateElements(eles); // update the old bg timestamp so diffs can be done in the ele txr caches\n\n    for (var _i = 0; _i < eles.length; _i++) {\n      var _p = eles[_i]._private;\n      _p.oldBackgroundTimestamp = _p.backgroundTimestamp;\n    }\n  });\n\n  var refineInLayers = function refineInLayers(reqs) {\n    for (var i = 0; i < reqs.length; i++) {\n      lyrTxrCache.enqueueElementRefinement(reqs[i].ele);\n    }\n  };\n\n  eleTxrCache.onDequeue(refineInLayers);\n  lblTxrCache.onDequeue(refineInLayers);\n  slbTxrCache.onDequeue(refineInLayers);\n  tlbTxrCache.onDequeue(refineInLayers);\n}\n\nCRp.redrawHint = function (group, bool) {\n  var r = this;\n\n  switch (group) {\n    case 'eles':\n      r.data.canvasNeedsRedraw[CRp.NODE] = bool;\n      break;\n\n    case 'drag':\n      r.data.canvasNeedsRedraw[CRp.DRAG] = bool;\n      break;\n\n    case 'select':\n      r.data.canvasNeedsRedraw[CRp.SELECT_BOX] = bool;\n      break;\n  }\n}; // whether to use Path2D caching for drawing\n\n\nvar pathsImpld = typeof Path2D !== 'undefined';\n\nCRp.path2dEnabled = function (on) {\n  if (on === undefined) {\n    return this.pathsEnabled;\n  }\n\n  this.pathsEnabled = on ? true : false;\n};\n\nCRp.usePaths = function () {\n  return pathsImpld && this.pathsEnabled;\n};\n\nCRp.setImgSmoothing = function (context, bool) {\n  if (context.imageSmoothingEnabled != null) {\n    context.imageSmoothingEnabled = bool;\n  } else {\n    context.webkitImageSmoothingEnabled = bool;\n    context.mozImageSmoothingEnabled = bool;\n    context.msImageSmoothingEnabled = bool;\n  }\n};\n\nCRp.getImgSmoothing = function (context) {\n  if (context.imageSmoothingEnabled != null) {\n    return context.imageSmoothingEnabled;\n  } else {\n    return context.webkitImageSmoothingEnabled || context.mozImageSmoothingEnabled || context.msImageSmoothingEnabled;\n  }\n};\n\nCRp.makeOffscreenCanvas = function (width, height) {\n  var canvas;\n\n  if ((typeof OffscreenCanvas === \"undefined\" ? \"undefined\" : _typeof(OffscreenCanvas)) !== (\"undefined\" )) {\n    canvas = new OffscreenCanvas(width, height);\n  } else {\n    canvas = document.createElement('canvas'); // eslint-disable-line no-undef\n\n    canvas.width = width;\n    canvas.height = height;\n  }\n\n  return canvas;\n};\n\n[CRp$a, CRp$9, CRp$8, CRp$7, CRp$6, CRp$5, CRp$4, CRp$3, CRp$2, CRp$1].forEach(function (props) {\n  extend(CRp, props);\n});\n\nvar renderer = [{\n  name: 'null',\n  impl: NullRenderer\n}, {\n  name: 'base',\n  impl: BR\n}, {\n  name: 'canvas',\n  impl: CR\n}];\n\nvar incExts = [{\n  type: 'layout',\n  extensions: layout\n}, {\n  type: 'renderer',\n  extensions: renderer\n}];\n\nvar extensions = {}; // registered modules for extensions, indexed by name\n\nvar modules = {};\n\nfunction setExtension(type, name, registrant) {\n  var ext = registrant;\n\n  var overrideErr = function overrideErr(field) {\n    warn('Can not register `' + name + '` for `' + type + '` since `' + field + '` already exists in the prototype and can not be overridden');\n  };\n\n  if (type === 'core') {\n    if (Core.prototype[name]) {\n      return overrideErr(name);\n    } else {\n      Core.prototype[name] = registrant;\n    }\n  } else if (type === 'collection') {\n    if (Collection.prototype[name]) {\n      return overrideErr(name);\n    } else {\n      Collection.prototype[name] = registrant;\n    }\n  } else if (type === 'layout') {\n    // fill in missing layout functions in the prototype\n    var Layout = function Layout(options) {\n      this.options = options;\n      registrant.call(this, options); // make sure layout has _private for use w/ std apis like .on()\n\n      if (!plainObject(this._private)) {\n        this._private = {};\n      }\n\n      this._private.cy = options.cy;\n      this._private.listeners = [];\n      this.createEmitter();\n    };\n\n    var layoutProto = Layout.prototype = Object.create(registrant.prototype);\n    var optLayoutFns = [];\n\n    for (var i = 0; i < optLayoutFns.length; i++) {\n      var fnName = optLayoutFns[i];\n\n      layoutProto[fnName] = layoutProto[fnName] || function () {\n        return this;\n      };\n    } // either .start() or .run() is defined, so autogen the other\n\n\n    if (layoutProto.start && !layoutProto.run) {\n      layoutProto.run = function () {\n        this.start();\n        return this;\n      };\n    } else if (!layoutProto.start && layoutProto.run) {\n      layoutProto.start = function () {\n        this.run();\n        return this;\n      };\n    }\n\n    var regStop = registrant.prototype.stop;\n\n    layoutProto.stop = function () {\n      var opts = this.options;\n\n      if (opts && opts.animate) {\n        var anis = this.animations;\n\n        if (anis) {\n          for (var _i = 0; _i < anis.length; _i++) {\n            anis[_i].stop();\n          }\n        }\n      }\n\n      if (regStop) {\n        regStop.call(this);\n      } else {\n        this.emit('layoutstop');\n      }\n\n      return this;\n    };\n\n    if (!layoutProto.destroy) {\n      layoutProto.destroy = function () {\n        return this;\n      };\n    }\n\n    layoutProto.cy = function () {\n      return this._private.cy;\n    };\n\n    var getCy = function getCy(layout) {\n      return layout._private.cy;\n    };\n\n    var emitterOpts = {\n      addEventFields: function addEventFields(layout, evt) {\n        evt.layout = layout;\n        evt.cy = getCy(layout);\n        evt.target = layout;\n      },\n      bubble: function bubble() {\n        return true;\n      },\n      parent: function parent(layout) {\n        return getCy(layout);\n      }\n    };\n    extend(layoutProto, {\n      createEmitter: function createEmitter() {\n        this._private.emitter = new Emitter(emitterOpts, this);\n        return this;\n      },\n      emitter: function emitter() {\n        return this._private.emitter;\n      },\n      on: function on(evt, cb) {\n        this.emitter().on(evt, cb);\n        return this;\n      },\n      one: function one(evt, cb) {\n        this.emitter().one(evt, cb);\n        return this;\n      },\n      once: function once(evt, cb) {\n        this.emitter().one(evt, cb);\n        return this;\n      },\n      removeListener: function removeListener(evt, cb) {\n        this.emitter().removeListener(evt, cb);\n        return this;\n      },\n      removeAllListeners: function removeAllListeners() {\n        this.emitter().removeAllListeners();\n        return this;\n      },\n      emit: function emit(evt, params) {\n        this.emitter().emit(evt, params);\n        return this;\n      }\n    });\n    define.eventAliasesOn(layoutProto);\n    ext = Layout; // replace with our wrapped layout\n  } else if (type === 'renderer' && name !== 'null' && name !== 'base') {\n    // user registered renderers inherit from base\n    var BaseRenderer = getExtension('renderer', 'base');\n    var bProto = BaseRenderer.prototype;\n    var RegistrantRenderer = registrant;\n    var rProto = registrant.prototype;\n\n    var Renderer = function Renderer() {\n      BaseRenderer.apply(this, arguments);\n      RegistrantRenderer.apply(this, arguments);\n    };\n\n    var proto = Renderer.prototype;\n\n    for (var pName in bProto) {\n      var pVal = bProto[pName];\n      var existsInR = rProto[pName] != null;\n\n      if (existsInR) {\n        return overrideErr(pName);\n      }\n\n      proto[pName] = pVal; // take impl from base\n    }\n\n    for (var _pName in rProto) {\n      proto[_pName] = rProto[_pName]; // take impl from registrant\n    }\n\n    bProto.clientFunctions.forEach(function (name) {\n      proto[name] = proto[name] || function () {\n        error('Renderer does not implement `renderer.' + name + '()` on its prototype');\n      };\n    });\n    ext = Renderer;\n  } else if (type === '__proto__' || type === 'constructor' || type === 'prototype') {\n    // to avoid potential prototype pollution\n    return error(type + ' is an illegal type to be registered, possibly lead to prototype pollutions');\n  }\n\n  return setMap({\n    map: extensions,\n    keys: [type, name],\n    value: ext\n  });\n}\n\nfunction getExtension(type, name) {\n  return getMap({\n    map: extensions,\n    keys: [type, name]\n  });\n}\n\nfunction setModule(type, name, moduleType, moduleName, registrant) {\n  return setMap({\n    map: modules,\n    keys: [type, name, moduleType, moduleName],\n    value: registrant\n  });\n}\n\nfunction getModule(type, name, moduleType, moduleName) {\n  return getMap({\n    map: modules,\n    keys: [type, name, moduleType, moduleName]\n  });\n}\n\nvar extension = function extension() {\n  // e.g. extension('renderer', 'svg')\n  if (arguments.length === 2) {\n    return getExtension.apply(null, arguments);\n  } // e.g. extension('renderer', 'svg', { ... })\n  else if (arguments.length === 3) {\n    return setExtension.apply(null, arguments);\n  } // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse')\n  else if (arguments.length === 4) {\n    return getModule.apply(null, arguments);\n  } // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })\n  else if (arguments.length === 5) {\n    return setModule.apply(null, arguments);\n  } else {\n    error('Invalid extension access syntax');\n  }\n}; // allows a core instance to access extensions internally\n\n\nCore.prototype.extension = extension; // included extensions\n\nincExts.forEach(function (group) {\n  group.extensions.forEach(function (ext) {\n    setExtension(group.type, ext.name, ext.impl);\n  });\n});\n\n// (useful for init)\n\nvar Stylesheet = function Stylesheet() {\n  if (!(this instanceof Stylesheet)) {\n    return new Stylesheet();\n  }\n\n  this.length = 0;\n};\n\nvar sheetfn = Stylesheet.prototype;\n\nsheetfn.instanceString = function () {\n  return 'stylesheet';\n}; // just store the selector to be parsed later\n\n\nsheetfn.selector = function (selector) {\n  var i = this.length++;\n  this[i] = {\n    selector: selector,\n    properties: []\n  };\n  return this; // chaining\n}; // just store the property to be parsed later\n\n\nsheetfn.css = function (name, value) {\n  var i = this.length - 1;\n\n  if (string(name)) {\n    this[i].properties.push({\n      name: name,\n      value: value\n    });\n  } else if (plainObject(name)) {\n    var map = name;\n    var propNames = Object.keys(map);\n\n    for (var j = 0; j < propNames.length; j++) {\n      var key = propNames[j];\n      var mapVal = map[key];\n\n      if (mapVal == null) {\n        continue;\n      }\n\n      var prop = Style.properties[key] || Style.properties[dash2camel(key)];\n\n      if (prop == null) {\n        continue;\n      }\n\n      var _name = prop.name;\n      var _value = mapVal;\n      this[i].properties.push({\n        name: _name,\n        value: _value\n      });\n    }\n  }\n\n  return this; // chaining\n};\n\nsheetfn.style = sheetfn.css; // generate a real style object from the dummy stylesheet\n\nsheetfn.generateStyle = function (cy) {\n  var style = new Style(cy);\n  return this.appendToStyle(style);\n}; // append a dummy stylesheet object on a real style object\n\n\nsheetfn.appendToStyle = function (style) {\n  for (var i = 0; i < this.length; i++) {\n    var context = this[i];\n    var selector = context.selector;\n    var props = context.properties;\n    style.selector(selector); // apply selector\n\n    for (var j = 0; j < props.length; j++) {\n      var prop = props[j];\n      style.css(prop.name, prop.value); // apply property\n    }\n  }\n\n  return style;\n};\n\nvar version = \"3.26.0\";\n\nvar cytoscape = function cytoscape(options) {\n  // if no options specified, use default\n  if (options === undefined) {\n    options = {};\n  } // create instance\n\n\n  if (plainObject(options)) {\n    return new Core(options);\n  } // allow for registration of extensions\n  else if (string(options)) {\n    return extension.apply(extension, arguments);\n  }\n}; // e.g. cytoscape.use( require('cytoscape-foo'), bar )\n\n\ncytoscape.use = function (ext) {\n  var args = Array.prototype.slice.call(arguments, 1); // args to pass to ext\n\n  args.unshift(cytoscape); // cytoscape is first arg to ext\n\n  ext.apply(null, args);\n  return this;\n};\n\ncytoscape.warnings = function (bool) {\n  return warnings(bool);\n}; // replaced by build system\n\n\ncytoscape.version = version; // expose public apis (mostly for extensions)\n\ncytoscape.stylesheet = cytoscape.Stylesheet = Stylesheet;\n\nmodule.exports = cytoscape;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9kaXN0L2N5dG9zY2FwZS5janMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLGVBQWUsbUJBQU8sQ0FBQywyREFBaUI7QUFDeEMsV0FBVyxtQkFBTyxDQUFDLDJDQUFNO0FBQ3pCLFVBQVUsbUJBQU8sQ0FBQyxpREFBWTtBQUM5QixVQUFVLG1CQUFPLENBQUMsaURBQVk7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLHVEQUFlOztBQUVwQyxxQ0FBcUMsNERBQTREOztBQUVqRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0QkFBNEIsK0JBQStCO0FBQzNEOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUzs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkRBQTZEOztBQUU3RDtBQUNBOztBQUVBOztBQUVBLDBCQUEwQjs7QUFFMUIscUNBQXFDOztBQUVyQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGlCQUFpQjtBQUNqQjs7QUFFQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixFQUFFO0FBQzdCLDJCQUEyQixFQUFFOztBQUU3QjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxjQUFjOztBQUVkOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTixpQkFBaUI7O0FBRWpCOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTixpQkFBaUI7O0FBRWpCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7O0FBRVIsTUFBTTtBQUNOOzs7QUFHQTtBQUNBLHVDQUF1QztBQUN2QyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFFBQVE7QUFDNUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixPQUFPO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsc0NBQXNDLE9BQU87QUFDN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDOzs7QUFHckMsb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsNEJBQTRCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixpQkFBaUI7QUFDeEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7QUFDUjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQSxJQUFJOzs7QUFHSixtQkFBbUIsYUFBYTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUEseURBQXlEOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFF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O0FBRTdCO0FBQ0Esa0JBQWtCOztBQUVsQjs7QUFFQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7O0FBRUEsY0FBYyxnQkFBZ0I7QUFDOUI7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFD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LHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7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Q0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7O0FBRXhGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUIsWUFBWTs7QUFFWjtBQUNBLCtGQUErRjtBQUMvRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNkRBQTZEO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVYsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRDs7QUFFckQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7O0FBRXpEO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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RUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7O0FBRWpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENB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O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsb0VBQW9FO0FBQy9FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBLE1BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7O0FBR1AscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7OztBQUdBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0osc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDOztBQUV0QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNB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LE1BQU07OztBQUdOOztBQUVBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1RkFBdUY7O0FBRXZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVFQUF1RTs7QUFFdkU7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCOzs7QUFHM0I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7O0FBRUEscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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Q0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtB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UTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxNQUFNOztBQUVOOztBQUVBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWLFVBQVU7O0FBRVYsWUFBWTs7QUFFWixZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKLDRCQUE0QjtBQUM1QixJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKLDRCQUE0QjtBQUM1QixJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLDZCQUE2QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxRQUFROztBQUVSLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1IseURBQXlEO0FBQ3pELE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtB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LFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTixHQUFHLFVBQVU7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxT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QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLDRCQUE0QjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0VBQWtFOztBQUVsRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTs7QUFFVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTs7QUFFVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTs7QUFFVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsbUJBQW1CO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVB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QUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSUFBa0k7O0FBRWxJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKLHFDQUFxQzs7QUFFckMsZ0ZBQWdGOztBQUVoRixpRkFBaUY7O0FBRWpGLGdGQUFnRjs7QUFFaEYsaUZBQWlGOztBQUVqRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixpQkFBaUI7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHVCQUF1QjtBQUN6Qyx3RUFBd0U7O0FBRXhFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHNCQUFzQjtBQUN4QyxpRUFBaUU7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUMsMENBQTBDOztBQUUxQyxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQscUJBQXFCOztB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QUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0EsdURBQXVEOztBQUV2RCwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0gsNkJBQTZCOztBQUU3Qjs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlL2Rpc3QvY3l0b3NjYXBlLmNqcy5qcz81MDRlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMjMsIFRoZSBDeXRvc2NhcGUgQ29uc29ydGl1bS5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSDigJxTb2Z0d2FyZeKAnSksIHRvIGRlYWwgaW5cbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIOKAnEFTIElT4oCdLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWJvdW5jZSA9IHJlcXVpcmUoJ2xvZGFzaC9kZWJvdW5jZScpO1xudmFyIEhlYXAgPSByZXF1aXJlKCdoZWFwJyk7XG52YXIgZ2V0ID0gcmVxdWlyZSgnbG9kYXNoL2dldCcpO1xudmFyIHNldCA9IHJlcXVpcmUoJ2xvZGFzaC9zZXQnKTtcbnZhciB0b1BhdGggPSByZXF1aXJlKCdsb2Rhc2gvdG9QYXRoJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdExlZ2FjeSAoZSkgeyByZXR1cm4gZSAmJiB0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiYgJ2RlZmF1bHQnIGluIGUgPyBlIDogeyAnZGVmYXVsdCc6IGUgfTsgfVxuXG52YXIgZGVib3VuY2VfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KGRlYm91bmNlKTtcbnZhciBIZWFwX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShIZWFwKTtcbnZhciBnZXRfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KGdldCk7XG52YXIgc2V0X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShzZXQpO1xudmFyIHRvUGF0aF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3kodG9QYXRoKTtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICB9IDogZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gIH0sIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcblxuICBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcblxuICB2YXIgX3MsIF9lO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG52YXIgX3dpbmRvdyA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG52YXIgbmF2aWdhdG9yID0gX3dpbmRvdyA/IF93aW5kb3cubmF2aWdhdG9yIDogbnVsbDtcbl93aW5kb3cgPyBfd2luZG93LmRvY3VtZW50IDogbnVsbDtcblxudmFyIHR5cGVvZnN0ciA9IF90eXBlb2YoJycpO1xuXG52YXIgdHlwZW9mb2JqID0gX3R5cGVvZih7fSk7XG5cbnZhciB0eXBlb2ZmbiA9IF90eXBlb2YoZnVuY3Rpb24gKCkge30pO1xuXG52YXIgdHlwZW9maHRtbGVsZSA9IHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKEhUTUxFbGVtZW50KTtcblxudmFyIGluc3RhbmNlU3RyID0gZnVuY3Rpb24gaW5zdGFuY2VTdHIob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLmluc3RhbmNlU3RyaW5nICYmIGZuJDYob2JqLmluc3RhbmNlU3RyaW5nKSA/IG9iai5pbnN0YW5jZVN0cmluZygpIDogbnVsbDtcbn07XG5cbnZhciBzdHJpbmcgPSBmdW5jdGlvbiBzdHJpbmcob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT0gdHlwZW9mc3RyO1xufTtcbnZhciBmbiQ2ID0gZnVuY3Rpb24gZm4ob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT09IHR5cGVvZmZuO1xufTtcbnZhciBhcnJheSA9IGZ1bmN0aW9uIGFycmF5KG9iaikge1xuICByZXR1cm4gIWVsZW1lbnRPckNvbGxlY3Rpb24ob2JqKSAmJiAoQXJyYXkuaXNBcnJheSA/IEFycmF5LmlzQXJyYXkob2JqKSA6IG9iaiAhPSBudWxsICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5KTtcbn07XG52YXIgcGxhaW5PYmplY3QgPSBmdW5jdGlvbiBwbGFpbk9iamVjdChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIF90eXBlb2Yob2JqKSA9PT0gdHlwZW9mb2JqICYmICFhcnJheShvYmopICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufTtcbnZhciBvYmplY3QgPSBmdW5jdGlvbiBvYmplY3Qob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT09IHR5cGVvZm9iajtcbn07XG52YXIgbnVtYmVyJDEgPSBmdW5jdGlvbiBudW1iZXIob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT09IF90eXBlb2YoMSkgJiYgIWlzTmFOKG9iaik7XG59O1xudmFyIGludGVnZXIgPSBmdW5jdGlvbiBpbnRlZ2VyKG9iaikge1xuICByZXR1cm4gbnVtYmVyJDEob2JqKSAmJiBNYXRoLmZsb29yKG9iaikgPT09IG9iajtcbn07XG52YXIgaHRtbEVsZW1lbnQgPSBmdW5jdGlvbiBodG1sRWxlbWVudChvYmopIHtcbiAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2ZodG1sZWxlKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbCAhPSBvYmogJiYgb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gIH1cbn07XG52YXIgZWxlbWVudE9yQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIGVsZW1lbnRPckNvbGxlY3Rpb24ob2JqKSB7XG4gIHJldHVybiBlbGVtZW50KG9iaikgfHwgY29sbGVjdGlvbihvYmopO1xufTtcbnZhciBlbGVtZW50ID0gZnVuY3Rpb24gZWxlbWVudChvYmopIHtcbiAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICdjb2xsZWN0aW9uJyAmJiBvYmouX3ByaXZhdGUuc2luZ2xlO1xufTtcbnZhciBjb2xsZWN0aW9uID0gZnVuY3Rpb24gY29sbGVjdGlvbihvYmopIHtcbiAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICdjb2xsZWN0aW9uJyAmJiAhb2JqLl9wcml2YXRlLnNpbmdsZTtcbn07XG52YXIgY29yZSA9IGZ1bmN0aW9uIGNvcmUob2JqKSB7XG4gIHJldHVybiBpbnN0YW5jZVN0cihvYmopID09PSAnY29yZSc7XG59O1xudmFyIHN0eWxlc2hlZXQgPSBmdW5jdGlvbiBzdHlsZXNoZWV0KG9iaikge1xuICByZXR1cm4gaW5zdGFuY2VTdHIob2JqKSA9PT0gJ3N0eWxlc2hlZXQnO1xufTtcbnZhciBldmVudCA9IGZ1bmN0aW9uIGV2ZW50KG9iaikge1xuICByZXR1cm4gaW5zdGFuY2VTdHIob2JqKSA9PT0gJ2V2ZW50Jztcbn07XG52YXIgZW1wdHlTdHJpbmcgPSBmdW5jdGlvbiBlbXB0eVN0cmluZyhvYmopIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgIC8vIG51bGwgaXMgZW1wdHlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChvYmogPT09ICcnIHx8IG9iai5tYXRjaCgvXlxccyskLykpIHtcbiAgICByZXR1cm4gdHJ1ZTsgLy8gZW1wdHkgc3RyaW5nIGlzIGVtcHR5XG4gIH1cblxuICByZXR1cm4gZmFsc2U7IC8vIG90aGVyd2lzZSwgd2UgZG9uJ3Qga25vdyB3aGF0IHdlJ3ZlIGdvdFxufTtcbnZhciBkb21FbGVtZW50ID0gZnVuY3Rpb24gZG9tRWxlbWVudChvYmopIHtcbiAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7IC8vIHdlJ3JlIG5vdCBpbiBhIGJyb3dzZXIgc28gaXQgZG9lc24ndCBtYXR0ZXJcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gIH1cbn07XG52YXIgYm91bmRpbmdCb3ggPSBmdW5jdGlvbiBib3VuZGluZ0JveChvYmopIHtcbiAgcmV0dXJuIHBsYWluT2JqZWN0KG9iaikgJiYgbnVtYmVyJDEob2JqLngxKSAmJiBudW1iZXIkMShvYmoueDIpICYmIG51bWJlciQxKG9iai55MSkgJiYgbnVtYmVyJDEob2JqLnkyKTtcbn07XG52YXIgcHJvbWlzZSA9IGZ1bmN0aW9uIHByb21pc2Uob2JqKSB7XG4gIHJldHVybiBvYmplY3Qob2JqKSAmJiBmbiQ2KG9iai50aGVuKTtcbn07XG52YXIgbXMgPSBmdW5jdGlvbiBtcygpIHtcbiAgcmV0dXJuIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9tc2llfHRyaWRlbnR8ZWRnZS9pKTtcbn07IC8vIHByb2JhYmx5IGEgYmV0dGVyIHdheSB0byBkZXRlY3QgdGhpcy4uLlxuXG52YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uIG1lbW9pemUoZm4sIGtleUZuKSB7XG4gIGlmICgha2V5Rm4pIHtcbiAgICBrZXlGbiA9IGZ1bmN0aW9uIGtleUZuKCkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gICAgICB9XG5cbiAgICAgIHZhciBhcmdzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJncy5qb2luKCckJyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBtZW1vaXplZEZuID0gZnVuY3Rpb24gbWVtb2l6ZWRGbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHJldDtcbiAgICB2YXIgayA9IGtleUZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIHZhciBjYWNoZSA9IG1lbW9pemVkRm4uY2FjaGU7XG5cbiAgICBpZiAoIShyZXQgPSBjYWNoZVtrXSkpIHtcbiAgICAgIHJldCA9IGNhY2hlW2tdID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBtZW1vaXplZEZuLmNhY2hlID0ge307XG4gIHJldHVybiBtZW1vaXplZEZuO1xufTtcblxudmFyIGNhbWVsMmRhc2ggPSBtZW1vaXplKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW0EtWl0pL2csIGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuICctJyArIHYudG9Mb3dlckNhc2UoKTtcbiAgfSk7XG59KTtcbnZhciBkYXNoMmNhbWVsID0gbWVtb2l6ZShmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKC1cXHcpL2csIGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHZbMV0udG9VcHBlckNhc2UoKTtcbiAgfSk7XG59KTtcbnZhciBwcmVwZW5kQ2FtZWwgPSBtZW1vaXplKGZ1bmN0aW9uIChwcmVmaXgsIHN0cikge1xuICByZXR1cm4gcHJlZml4ICsgc3RyWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xufSwgZnVuY3Rpb24gKHByZWZpeCwgc3RyKSB7XG4gIHJldHVybiBwcmVmaXggKyAnJCcgKyBzdHI7XG59KTtcbnZhciBjYXBpdGFsaXplID0gZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHIpIHtcbiAgaWYgKGVtcHR5U3RyaW5nKHN0cikpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG59O1xuXG52YXIgbnVtYmVyID0gJyg/OlstK10/KD86KD86XFxcXGQrfFxcXFxkKlxcXFwuXFxcXGQrKSg/OltFZV1bKy1dP1xcXFxkKyk/KSknO1xudmFyIHJnYmEgPSAncmdiW2FdP1xcXFwoKCcgKyBudW1iZXIgKyAnWyVdPylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnWyVdPylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnWyVdPykoPzpcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnKSk/XFxcXCknO1xudmFyIHJnYmFOb0JhY2tSZWZzID0gJ3JnYlthXT9cXFxcKCg/OicgKyBudW1iZXIgKyAnWyVdPylcXFxccyosXFxcXHMqKD86JyArIG51bWJlciArICdbJV0/KVxcXFxzKixcXFxccyooPzonICsgbnVtYmVyICsgJ1slXT8pKD86XFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIgKyAnKSk/XFxcXCknO1xudmFyIGhzbGEgPSAnaHNsW2FdP1xcXFwoKCcgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciArICdbJV0pXFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJ1slXSkoPzpcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnKSk/XFxcXCknO1xudmFyIGhzbGFOb0JhY2tSZWZzID0gJ2hzbFthXT9cXFxcKCg/OicgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooPzonICsgbnVtYmVyICsgJ1slXSlcXFxccyosXFxcXHMqKD86JyArIG51bWJlciArICdbJV0pKD86XFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIgKyAnKSk/XFxcXCknO1xudmFyIGhleDMgPSAnXFxcXCNbMC05YS1mQS1GXXszfSc7XG52YXIgaGV4NiA9ICdcXFxcI1swLTlhLWZBLUZdezZ9JztcblxudmFyIGFzY2VuZGluZyA9IGZ1bmN0aW9uIGFzY2VuZGluZyhhLCBiKSB7XG4gIGlmIChhIDwgYikge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmIChhID4gYikge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xudmFyIGRlc2NlbmRpbmcgPSBmdW5jdGlvbiBkZXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIC0xICogYXNjZW5kaW5nKGEsIGIpO1xufTtcblxudmFyIGV4dGVuZCA9IE9iamVjdC5hc3NpZ24gIT0gbnVsbCA/IE9iamVjdC5hc3NpZ24uYmluZChPYmplY3QpIDogZnVuY3Rpb24gKHRndCkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgb2JqID0gYXJnc1tpXTtcblxuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgayA9IGtleXNbal07XG4gICAgICB0Z3Rba10gPSBvYmpba107XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRndDtcbn07XG5cbnZhciBoZXgydHVwbGUgPSBmdW5jdGlvbiBoZXgydHVwbGUoaGV4KSB7XG4gIGlmICghKGhleC5sZW5ndGggPT09IDQgfHwgaGV4Lmxlbmd0aCA9PT0gNykgfHwgaGV4WzBdICE9PSAnIycpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2hvcnRIZXggPSBoZXgubGVuZ3RoID09PSA0O1xuICB2YXIgciwgZywgYjtcbiAgdmFyIGJhc2UgPSAxNjtcblxuICBpZiAoc2hvcnRIZXgpIHtcbiAgICByID0gcGFyc2VJbnQoaGV4WzFdICsgaGV4WzFdLCBiYXNlKTtcbiAgICBnID0gcGFyc2VJbnQoaGV4WzJdICsgaGV4WzJdLCBiYXNlKTtcbiAgICBiID0gcGFyc2VJbnQoaGV4WzNdICsgaGV4WzNdLCBiYXNlKTtcbiAgfSBlbHNlIHtcbiAgICByID0gcGFyc2VJbnQoaGV4WzFdICsgaGV4WzJdLCBiYXNlKTtcbiAgICBnID0gcGFyc2VJbnQoaGV4WzNdICsgaGV4WzRdLCBiYXNlKTtcbiAgICBiID0gcGFyc2VJbnQoaGV4WzVdICsgaGV4WzZdLCBiYXNlKTtcbiAgfVxuXG4gIHJldHVybiBbciwgZywgYl07XG59OyAvLyBnZXQgW3IsIGcsIGIsIGFdIGZyb20gaHNsKDAsIDAsIDApIG9yIGhzbGEoMCwgMCwgMCwgMClcblxudmFyIGhzbDJ0dXBsZSA9IGZ1bmN0aW9uIGhzbDJ0dXBsZShoc2wpIHtcbiAgdmFyIHJldDtcbiAgdmFyIGgsIHMsIGwsIGEsIHIsIGcsIGI7XG5cbiAgZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XG4gICAgaWYgKHQgPCAwKSB0ICs9IDE7XG4gICAgaWYgKHQgPiAxKSB0IC09IDE7XG4gICAgaWYgKHQgPCAxIC8gNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gICAgaWYgKHQgPCAxIC8gMikgcmV0dXJuIHE7XG4gICAgaWYgKHQgPCAyIC8gMykgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xuICAgIHJldHVybiBwO1xuICB9XG5cbiAgdmFyIG0gPSBuZXcgUmVnRXhwKCdeJyArIGhzbGEgKyAnJCcpLmV4ZWMoaHNsKTtcblxuICBpZiAobSkge1xuICAgIC8vIGdldCBodWVcbiAgICBoID0gcGFyc2VJbnQobVsxXSk7XG5cbiAgICBpZiAoaCA8IDApIHtcbiAgICAgIGggPSAoMzYwIC0gLTEgKiBoICUgMzYwKSAlIDM2MDtcbiAgICB9IGVsc2UgaWYgKGggPiAzNjApIHtcbiAgICAgIGggPSBoICUgMzYwO1xuICAgIH1cblxuICAgIGggLz0gMzYwOyAvLyBub3JtYWxpc2Ugb24gWzAsIDFdXG5cbiAgICBzID0gcGFyc2VGbG9hdChtWzJdKTtcblxuICAgIGlmIChzIDwgMCB8fCBzID4gMTAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBzYXR1cmF0aW9uIGlzIFswLCAxMDBdXG5cblxuICAgIHMgPSBzIC8gMTAwOyAvLyBub3JtYWxpc2Ugb24gWzAsIDFdXG5cbiAgICBsID0gcGFyc2VGbG9hdChtWzNdKTtcblxuICAgIGlmIChsIDwgMCB8fCBsID4gMTAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBsaWdodG5lc3MgaXMgWzAsIDEwMF1cblxuXG4gICAgbCA9IGwgLyAxMDA7IC8vIG5vcm1hbGlzZSBvbiBbMCwgMV1cblxuICAgIGEgPSBtWzRdO1xuXG4gICAgaWYgKGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYSA9IHBhcnNlRmxvYXQoYSk7XG5cbiAgICAgIGlmIChhIDwgMCB8fCBhID4gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGFscGhhIGlzIFswLCAxXVxuXG4gICAgfSAvLyBub3csIGNvbnZlcnQgdG8gcmdiXG4gICAgLy8gY29kZSBmcm9tIGh0dHA6Ly9tamlqYWNrc29uLmNvbS8yMDA4LzAyL3JnYi10by1oc2wtYW5kLXJnYi10by1oc3YtY29sb3ItbW9kZWwtY29udmVyc2lvbi1hbGdvcml0aG1zLWluLWphdmFzY3JpcHRcblxuXG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIHIgPSBnID0gYiA9IE1hdGgucm91bmQobCAqIDI1NSk7IC8vIGFjaHJvbWF0aWNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgdmFyIHAgPSAyICogbCAtIHE7XG4gICAgICByID0gTWF0aC5yb3VuZCgyNTUgKiBodWUycmdiKHAsIHEsIGggKyAxIC8gMykpO1xuICAgICAgZyA9IE1hdGgucm91bmQoMjU1ICogaHVlMnJnYihwLCBxLCBoKSk7XG4gICAgICBiID0gTWF0aC5yb3VuZCgyNTUgKiBodWUycmdiKHAsIHEsIGggLSAxIC8gMykpO1xuICAgIH1cblxuICAgIHJldCA9IFtyLCBnLCBiLCBhXTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59OyAvLyBnZXQgW3IsIGcsIGIsIGFdIGZyb20gcmdiKDAsIDAsIDApIG9yIHJnYmEoMCwgMCwgMCwgMClcblxudmFyIHJnYjJ0dXBsZSA9IGZ1bmN0aW9uIHJnYjJ0dXBsZShyZ2IpIHtcbiAgdmFyIHJldDtcbiAgdmFyIG0gPSBuZXcgUmVnRXhwKCdeJyArIHJnYmEgKyAnJCcpLmV4ZWMocmdiKTtcblxuICBpZiAobSkge1xuICAgIHJldCA9IFtdO1xuICAgIHZhciBpc1BjdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gMzsgaSsrKSB7XG4gICAgICB2YXIgY2hhbm5lbCA9IG1baV07XG5cbiAgICAgIGlmIChjaGFubmVsW2NoYW5uZWwubGVuZ3RoIC0gMV0gPT09ICclJykge1xuICAgICAgICBpc1BjdFtpXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNoYW5uZWwgPSBwYXJzZUZsb2F0KGNoYW5uZWwpO1xuXG4gICAgICBpZiAoaXNQY3RbaV0pIHtcbiAgICAgICAgY2hhbm5lbCA9IGNoYW5uZWwgLyAxMDAgKiAyNTU7IC8vIG5vcm1hbGlzZSB0byBbMCwgMjU1XVxuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbm5lbCA8IDAgfHwgY2hhbm5lbCA+IDI1NSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGludmFsaWQgY2hhbm5lbCB2YWx1ZVxuXG5cbiAgICAgIHJldC5wdXNoKE1hdGguZmxvb3IoY2hhbm5lbCkpO1xuICAgIH1cblxuICAgIHZhciBhdExlYXN0T25lSXNQY3QgPSBpc1BjdFsxXSB8fCBpc1BjdFsyXSB8fCBpc1BjdFszXTtcbiAgICB2YXIgYWxsQXJlUGN0ID0gaXNQY3RbMV0gJiYgaXNQY3RbMl0gJiYgaXNQY3RbM107XG5cbiAgICBpZiAoYXRMZWFzdE9uZUlzUGN0ICYmICFhbGxBcmVQY3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIG11c3QgYWxsIGJlIHBlcmNlbnQgdmFsdWVzIGlmIG9uZSBpc1xuXG5cbiAgICB2YXIgYWxwaGEgPSBtWzRdO1xuXG4gICAgaWYgKGFscGhhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFscGhhID0gcGFyc2VGbG9hdChhbHBoYSk7XG5cbiAgICAgIGlmIChhbHBoYSA8IDAgfHwgYWxwaGEgPiAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gaW52YWxpZCBhbHBoYSB2YWx1ZVxuXG5cbiAgICAgIHJldC5wdXNoKGFscGhhKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcbnZhciBjb2xvcm5hbWUydHVwbGUgPSBmdW5jdGlvbiBjb2xvcm5hbWUydHVwbGUoY29sb3IpIHtcbiAgcmV0dXJuIGNvbG9yc1tjb2xvci50b0xvd2VyQ2FzZSgpXTtcbn07XG52YXIgY29sb3IydHVwbGUgPSBmdW5jdGlvbiBjb2xvcjJ0dXBsZShjb2xvcikge1xuICByZXR1cm4gKGFycmF5KGNvbG9yKSA/IGNvbG9yIDogbnVsbCkgfHwgY29sb3JuYW1lMnR1cGxlKGNvbG9yKSB8fCBoZXgydHVwbGUoY29sb3IpIHx8IHJnYjJ0dXBsZShjb2xvcikgfHwgaHNsMnR1cGxlKGNvbG9yKTtcbn07XG52YXIgY29sb3JzID0ge1xuICAvLyBzcGVjaWFsIGNvbG91ciBuYW1lc1xuICB0cmFuc3BhcmVudDogWzAsIDAsIDAsIDBdLFxuICAvLyBOQiBhbHBoYSA9PT0gMFxuICAvLyByZWd1bGFyIGNvbG91cnNcbiAgYWxpY2VibHVlOiBbMjQwLCAyNDgsIDI1NV0sXG4gIGFudGlxdWV3aGl0ZTogWzI1MCwgMjM1LCAyMTVdLFxuICBhcXVhOiBbMCwgMjU1LCAyNTVdLFxuICBhcXVhbWFyaW5lOiBbMTI3LCAyNTUsIDIxMl0sXG4gIGF6dXJlOiBbMjQwLCAyNTUsIDI1NV0sXG4gIGJlaWdlOiBbMjQ1LCAyNDUsIDIyMF0sXG4gIGJpc3F1ZTogWzI1NSwgMjI4LCAxOTZdLFxuICBibGFjazogWzAsIDAsIDBdLFxuICBibGFuY2hlZGFsbW9uZDogWzI1NSwgMjM1LCAyMDVdLFxuICBibHVlOiBbMCwgMCwgMjU1XSxcbiAgYmx1ZXZpb2xldDogWzEzOCwgNDMsIDIyNl0sXG4gIGJyb3duOiBbMTY1LCA0MiwgNDJdLFxuICBidXJseXdvb2Q6IFsyMjIsIDE4NCwgMTM1XSxcbiAgY2FkZXRibHVlOiBbOTUsIDE1OCwgMTYwXSxcbiAgY2hhcnRyZXVzZTogWzEyNywgMjU1LCAwXSxcbiAgY2hvY29sYXRlOiBbMjEwLCAxMDUsIDMwXSxcbiAgY29yYWw6IFsyNTUsIDEyNywgODBdLFxuICBjb3JuZmxvd2VyYmx1ZTogWzEwMCwgMTQ5LCAyMzddLFxuICBjb3Juc2lsazogWzI1NSwgMjQ4LCAyMjBdLFxuICBjcmltc29uOiBbMjIwLCAyMCwgNjBdLFxuICBjeWFuOiBbMCwgMjU1LCAyNTVdLFxuICBkYXJrYmx1ZTogWzAsIDAsIDEzOV0sXG4gIGRhcmtjeWFuOiBbMCwgMTM5LCAxMzldLFxuICBkYXJrZ29sZGVucm9kOiBbMTg0LCAxMzQsIDExXSxcbiAgZGFya2dyYXk6IFsxNjksIDE2OSwgMTY5XSxcbiAgZGFya2dyZWVuOiBbMCwgMTAwLCAwXSxcbiAgZGFya2dyZXk6IFsxNjksIDE2OSwgMTY5XSxcbiAgZGFya2toYWtpOiBbMTg5LCAxODMsIDEwN10sXG4gIGRhcmttYWdlbnRhOiBbMTM5LCAwLCAxMzldLFxuICBkYXJrb2xpdmVncmVlbjogWzg1LCAxMDcsIDQ3XSxcbiAgZGFya29yYW5nZTogWzI1NSwgMTQwLCAwXSxcbiAgZGFya29yY2hpZDogWzE1MywgNTAsIDIwNF0sXG4gIGRhcmtyZWQ6IFsxMzksIDAsIDBdLFxuICBkYXJrc2FsbW9uOiBbMjMzLCAxNTAsIDEyMl0sXG4gIGRhcmtzZWFncmVlbjogWzE0MywgMTg4LCAxNDNdLFxuICBkYXJrc2xhdGVibHVlOiBbNzIsIDYxLCAxMzldLFxuICBkYXJrc2xhdGVncmF5OiBbNDcsIDc5LCA3OV0sXG4gIGRhcmtzbGF0ZWdyZXk6IFs0NywgNzksIDc5XSxcbiAgZGFya3R1cnF1b2lzZTogWzAsIDIwNiwgMjA5XSxcbiAgZGFya3Zpb2xldDogWzE0OCwgMCwgMjExXSxcbiAgZGVlcHBpbms6IFsyNTUsIDIwLCAxNDddLFxuICBkZWVwc2t5Ymx1ZTogWzAsIDE5MSwgMjU1XSxcbiAgZGltZ3JheTogWzEwNSwgMTA1LCAxMDVdLFxuICBkaW1ncmV5OiBbMTA1LCAxMDUsIDEwNV0sXG4gIGRvZGdlcmJsdWU6IFszMCwgMTQ0LCAyNTVdLFxuICBmaXJlYnJpY2s6IFsxNzgsIDM0LCAzNF0sXG4gIGZsb3JhbHdoaXRlOiBbMjU1LCAyNTAsIDI0MF0sXG4gIGZvcmVzdGdyZWVuOiBbMzQsIDEzOSwgMzRdLFxuICBmdWNoc2lhOiBbMjU1LCAwLCAyNTVdLFxuICBnYWluc2Jvcm86IFsyMjAsIDIyMCwgMjIwXSxcbiAgZ2hvc3R3aGl0ZTogWzI0OCwgMjQ4LCAyNTVdLFxuICBnb2xkOiBbMjU1LCAyMTUsIDBdLFxuICBnb2xkZW5yb2Q6IFsyMTgsIDE2NSwgMzJdLFxuICBncmF5OiBbMTI4LCAxMjgsIDEyOF0sXG4gIGdyZXk6IFsxMjgsIDEyOCwgMTI4XSxcbiAgZ3JlZW46IFswLCAxMjgsIDBdLFxuICBncmVlbnllbGxvdzogWzE3MywgMjU1LCA0N10sXG4gIGhvbmV5ZGV3OiBbMjQwLCAyNTUsIDI0MF0sXG4gIGhvdHBpbms6IFsyNTUsIDEwNSwgMTgwXSxcbiAgaW5kaWFucmVkOiBbMjA1LCA5MiwgOTJdLFxuICBpbmRpZ286IFs3NSwgMCwgMTMwXSxcbiAgaXZvcnk6IFsyNTUsIDI1NSwgMjQwXSxcbiAga2hha2k6IFsyNDAsIDIzMCwgMTQwXSxcbiAgbGF2ZW5kZXI6IFsyMzAsIDIzMCwgMjUwXSxcbiAgbGF2ZW5kZXJibHVzaDogWzI1NSwgMjQwLCAyNDVdLFxuICBsYXduZ3JlZW46IFsxMjQsIDI1MiwgMF0sXG4gIGxlbW9uY2hpZmZvbjogWzI1NSwgMjUwLCAyMDVdLFxuICBsaWdodGJsdWU6IFsxNzMsIDIxNiwgMjMwXSxcbiAgbGlnaHRjb3JhbDogWzI0MCwgMTI4LCAxMjhdLFxuICBsaWdodGN5YW46IFsyMjQsIDI1NSwgMjU1XSxcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFsyNTAsIDI1MCwgMjEwXSxcbiAgbGlnaHRncmF5OiBbMjExLCAyMTEsIDIxMV0sXG4gIGxpZ2h0Z3JlZW46IFsxNDQsIDIzOCwgMTQ0XSxcbiAgbGlnaHRncmV5OiBbMjExLCAyMTEsIDIxMV0sXG4gIGxpZ2h0cGluazogWzI1NSwgMTgyLCAxOTNdLFxuICBsaWdodHNhbG1vbjogWzI1NSwgMTYwLCAxMjJdLFxuICBsaWdodHNlYWdyZWVuOiBbMzIsIDE3OCwgMTcwXSxcbiAgbGlnaHRza3libHVlOiBbMTM1LCAyMDYsIDI1MF0sXG4gIGxpZ2h0c2xhdGVncmF5OiBbMTE5LCAxMzYsIDE1M10sXG4gIGxpZ2h0c2xhdGVncmV5OiBbMTE5LCAxMzYsIDE1M10sXG4gIGxpZ2h0c3RlZWxibHVlOiBbMTc2LCAxOTYsIDIyMl0sXG4gIGxpZ2h0eWVsbG93OiBbMjU1LCAyNTUsIDIyNF0sXG4gIGxpbWU6IFswLCAyNTUsIDBdLFxuICBsaW1lZ3JlZW46IFs1MCwgMjA1LCA1MF0sXG4gIGxpbmVuOiBbMjUwLCAyNDAsIDIzMF0sXG4gIG1hZ2VudGE6IFsyNTUsIDAsIDI1NV0sXG4gIG1hcm9vbjogWzEyOCwgMCwgMF0sXG4gIG1lZGl1bWFxdWFtYXJpbmU6IFsxMDIsIDIwNSwgMTcwXSxcbiAgbWVkaXVtYmx1ZTogWzAsIDAsIDIwNV0sXG4gIG1lZGl1bW9yY2hpZDogWzE4NiwgODUsIDIxMV0sXG4gIG1lZGl1bXB1cnBsZTogWzE0NywgMTEyLCAyMTldLFxuICBtZWRpdW1zZWFncmVlbjogWzYwLCAxNzksIDExM10sXG4gIG1lZGl1bXNsYXRlYmx1ZTogWzEyMywgMTA0LCAyMzhdLFxuICBtZWRpdW1zcHJpbmdncmVlbjogWzAsIDI1MCwgMTU0XSxcbiAgbWVkaXVtdHVycXVvaXNlOiBbNzIsIDIwOSwgMjA0XSxcbiAgbWVkaXVtdmlvbGV0cmVkOiBbMTk5LCAyMSwgMTMzXSxcbiAgbWlkbmlnaHRibHVlOiBbMjUsIDI1LCAxMTJdLFxuICBtaW50Y3JlYW06IFsyNDUsIDI1NSwgMjUwXSxcbiAgbWlzdHlyb3NlOiBbMjU1LCAyMjgsIDIyNV0sXG4gIG1vY2Nhc2luOiBbMjU1LCAyMjgsIDE4MV0sXG4gIG5hdmFqb3doaXRlOiBbMjU1LCAyMjIsIDE3M10sXG4gIG5hdnk6IFswLCAwLCAxMjhdLFxuICBvbGRsYWNlOiBbMjUzLCAyNDUsIDIzMF0sXG4gIG9saXZlOiBbMTI4LCAxMjgsIDBdLFxuICBvbGl2ZWRyYWI6IFsxMDcsIDE0MiwgMzVdLFxuICBvcmFuZ2U6IFsyNTUsIDE2NSwgMF0sXG4gIG9yYW5nZXJlZDogWzI1NSwgNjksIDBdLFxuICBvcmNoaWQ6IFsyMTgsIDExMiwgMjE0XSxcbiAgcGFsZWdvbGRlbnJvZDogWzIzOCwgMjMyLCAxNzBdLFxuICBwYWxlZ3JlZW46IFsxNTIsIDI1MSwgMTUyXSxcbiAgcGFsZXR1cnF1b2lzZTogWzE3NSwgMjM4LCAyMzhdLFxuICBwYWxldmlvbGV0cmVkOiBbMjE5LCAxMTIsIDE0N10sXG4gIHBhcGF5YXdoaXA6IFsyNTUsIDIzOSwgMjEzXSxcbiAgcGVhY2hwdWZmOiBbMjU1LCAyMTgsIDE4NV0sXG4gIHBlcnU6IFsyMDUsIDEzMywgNjNdLFxuICBwaW5rOiBbMjU1LCAxOTIsIDIwM10sXG4gIHBsdW06IFsyMjEsIDE2MCwgMjIxXSxcbiAgcG93ZGVyYmx1ZTogWzE3NiwgMjI0LCAyMzBdLFxuICBwdXJwbGU6IFsxMjgsIDAsIDEyOF0sXG4gIHJlZDogWzI1NSwgMCwgMF0sXG4gIHJvc3licm93bjogWzE4OCwgMTQzLCAxNDNdLFxuICByb3lhbGJsdWU6IFs2NSwgMTA1LCAyMjVdLFxuICBzYWRkbGVicm93bjogWzEzOSwgNjksIDE5XSxcbiAgc2FsbW9uOiBbMjUwLCAxMjgsIDExNF0sXG4gIHNhbmR5YnJvd246IFsyNDQsIDE2NCwgOTZdLFxuICBzZWFncmVlbjogWzQ2LCAxMzksIDg3XSxcbiAgc2Vhc2hlbGw6IFsyNTUsIDI0NSwgMjM4XSxcbiAgc2llbm5hOiBbMTYwLCA4MiwgNDVdLFxuICBzaWx2ZXI6IFsxOTIsIDE5MiwgMTkyXSxcbiAgc2t5Ymx1ZTogWzEzNSwgMjA2LCAyMzVdLFxuICBzbGF0ZWJsdWU6IFsxMDYsIDkwLCAyMDVdLFxuICBzbGF0ZWdyYXk6IFsxMTIsIDEyOCwgMTQ0XSxcbiAgc2xhdGVncmV5OiBbMTEyLCAxMjgsIDE0NF0sXG4gIHNub3c6IFsyNTUsIDI1MCwgMjUwXSxcbiAgc3ByaW5nZ3JlZW46IFswLCAyNTUsIDEyN10sXG4gIHN0ZWVsYmx1ZTogWzcwLCAxMzAsIDE4MF0sXG4gIHRhbjogWzIxMCwgMTgwLCAxNDBdLFxuICB0ZWFsOiBbMCwgMTI4LCAxMjhdLFxuICB0aGlzdGxlOiBbMjE2LCAxOTEsIDIxNl0sXG4gIHRvbWF0bzogWzI1NSwgOTksIDcxXSxcbiAgdHVycXVvaXNlOiBbNjQsIDIyNCwgMjA4XSxcbiAgdmlvbGV0OiBbMjM4LCAxMzAsIDIzOF0sXG4gIHdoZWF0OiBbMjQ1LCAyMjIsIDE3OV0sXG4gIHdoaXRlOiBbMjU1LCAyNTUsIDI1NV0sXG4gIHdoaXRlc21va2U6IFsyNDUsIDI0NSwgMjQ1XSxcbiAgeWVsbG93OiBbMjU1LCAyNTUsIDBdLFxuICB5ZWxsb3dncmVlbjogWzE1NCwgMjA1LCA1MF1cbn07XG5cbnZhciBzZXRNYXAgPSBmdW5jdGlvbiBzZXRNYXAob3B0aW9ucykge1xuICB2YXIgb2JqID0gb3B0aW9ucy5tYXA7XG4gIHZhciBrZXlzID0gb3B0aW9ucy5rZXlzO1xuICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICBpZiAocGxhaW5PYmplY3Qoa2V5KSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ1RyaWVkIHRvIHNldCBtYXAgd2l0aCBvYmplY3Qga2V5Jyk7XG4gICAgfVxuXG4gICAgaWYgKGkgPCBrZXlzLmxlbmd0aCAtIDEpIHtcbiAgICAgIC8vIGV4dGVuZCB0aGUgbWFwIGlmIG5lY2Vzc2FyeVxuICAgICAgaWYgKG9ialtrZXldID09IG51bGwpIHtcbiAgICAgICAgb2JqW2tleV0gPSB7fTtcbiAgICAgIH1cblxuICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNldCB0aGUgdmFsdWVcbiAgICAgIG9ialtrZXldID0gb3B0aW9ucy52YWx1ZTtcbiAgICB9XG4gIH1cbn07IC8vIGdldHMgdGhlIHZhbHVlIGluIGEgbWFwIGV2ZW4gaWYgaXQncyBub3QgYnVpbHQgaW4gcGxhY2VzXG5cbnZhciBnZXRNYXAgPSBmdW5jdGlvbiBnZXRNYXAob3B0aW9ucykge1xuICB2YXIgb2JqID0gb3B0aW9ucy5tYXA7XG4gIHZhciBrZXlzID0gb3B0aW9ucy5rZXlzO1xuICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICBpZiAocGxhaW5PYmplY3Qoa2V5KSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ1RyaWVkIHRvIGdldCBtYXAgd2l0aCBvYmplY3Qga2V5Jyk7XG4gICAgfVxuXG4gICAgb2JqID0gb2JqW2tleV07XG5cbiAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07IC8vIGRlbGV0ZXMgdGhlIGVudHJ5IGluIHRoZSBtYXBcblxudmFyIHBlcmZvcm1hbmNlID0gX3dpbmRvdyA/IF93aW5kb3cucGVyZm9ybWFuY2UgOiBudWxsO1xudmFyIHBub3cgPSBwZXJmb3JtYW5jZSAmJiBwZXJmb3JtYW5jZS5ub3cgPyBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbn0gOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBEYXRlLm5vdygpO1xufTtcblxudmFyIHJhZiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF93aW5kb3cpIHtcbiAgICBpZiAoX3dpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgX3dpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKF93aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIF93aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChfd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgICBfd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoX3dpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgICBfd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIGlmIChmbikge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZuKHBub3coKSk7XG4gICAgICB9LCAxMDAwIC8gNjApO1xuICAgIH1cbiAgfTtcbn0oKTtcblxudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIHJlcXVlc3RBbmltYXRpb25GcmFtZShmbikge1xuICByZXR1cm4gcmFmKGZuKTtcbn07XG52YXIgcGVyZm9ybWFuY2VOb3cgPSBwbm93O1xuXG52YXIgREVGQVVMVF9IQVNIX1NFRUQgPSA5MjYxO1xudmFyIEsgPSA2NTU5OTsgLy8gMzcgYWxzbyB3b3JrcyBwcmV0dHkgd2VsbFxuXG52YXIgREVGQVVMVF9IQVNIX1NFRURfQUxUID0gNTM4MTtcbnZhciBoYXNoSXRlcmFibGVJbnRzID0gZnVuY3Rpb24gaGFzaEl0ZXJhYmxlSW50cyhpdGVyYXRvcikge1xuICB2YXIgc2VlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogREVGQVVMVF9IQVNIX1NFRUQ7XG4gIC8vIHNkYm0vc3RyaW5nLWhhc2hcbiAgdmFyIGhhc2ggPSBzZWVkO1xuICB2YXIgZW50cnk7XG5cbiAgZm9yICg7Oykge1xuICAgIGVudHJ5ID0gaXRlcmF0b3IubmV4dCgpO1xuXG4gICAgaWYgKGVudHJ5LmRvbmUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGhhc2ggPSBoYXNoICogSyArIGVudHJ5LnZhbHVlIHwgMDtcbiAgfVxuXG4gIHJldHVybiBoYXNoO1xufTtcbnZhciBoYXNoSW50ID0gZnVuY3Rpb24gaGFzaEludChudW0pIHtcbiAgdmFyIHNlZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IERFRkFVTFRfSEFTSF9TRUVEO1xuICAvLyBzZGJtL3N0cmluZy1oYXNoXG4gIHJldHVybiBzZWVkICogSyArIG51bSB8IDA7XG59O1xudmFyIGhhc2hJbnRBbHQgPSBmdW5jdGlvbiBoYXNoSW50QWx0KG51bSkge1xuICB2YXIgc2VlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogREVGQVVMVF9IQVNIX1NFRURfQUxUO1xuICAvLyBkamIyL3N0cmluZy1oYXNoXG4gIHJldHVybiAoc2VlZCA8PCA1KSArIHNlZWQgKyBudW0gfCAwO1xufTtcbnZhciBjb21iaW5lSGFzaGVzID0gZnVuY3Rpb24gY29tYmluZUhhc2hlcyhoYXNoMSwgaGFzaDIpIHtcbiAgcmV0dXJuIGhhc2gxICogMHgyMDAwMDAgKyBoYXNoMjtcbn07XG52YXIgY29tYmluZUhhc2hlc0FycmF5ID0gZnVuY3Rpb24gY29tYmluZUhhc2hlc0FycmF5KGhhc2hlcykge1xuICByZXR1cm4gaGFzaGVzWzBdICogMHgyMDAwMDAgKyBoYXNoZXNbMV07XG59O1xudmFyIGhhc2hBcnJheXMgPSBmdW5jdGlvbiBoYXNoQXJyYXlzKGhhc2hlczEsIGhhc2hlczIpIHtcbiAgcmV0dXJuIFtoYXNoSW50KGhhc2hlczFbMF0sIGhhc2hlczJbMF0pLCBoYXNoSW50QWx0KGhhc2hlczFbMV0sIGhhc2hlczJbMV0pXTtcbn07XG52YXIgaGFzaEludHNBcnJheSA9IGZ1bmN0aW9uIGhhc2hJbnRzQXJyYXkoaW50cywgc2VlZCkge1xuICB2YXIgZW50cnkgPSB7XG4gICAgdmFsdWU6IDAsXG4gICAgZG9uZTogZmFsc2VcbiAgfTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbGVuZ3RoID0gaW50cy5sZW5ndGg7XG4gIHZhciBpdGVyYXRvciA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgaWYgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgZW50cnkudmFsdWUgPSBpbnRzW2krK107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnRyeS5kb25lID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhhc2hJdGVyYWJsZUludHMoaXRlcmF0b3IsIHNlZWQpO1xufTtcbnZhciBoYXNoU3RyaW5nID0gZnVuY3Rpb24gaGFzaFN0cmluZyhzdHIsIHNlZWQpIHtcbiAgdmFyIGVudHJ5ID0ge1xuICAgIHZhbHVlOiAwLFxuICAgIGRvbmU6IGZhbHNlXG4gIH07XG4gIHZhciBpID0gMDtcbiAgdmFyIGxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gIHZhciBpdGVyYXRvciA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgaWYgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgZW50cnkudmFsdWUgPSBzdHIuY2hhckNvZGVBdChpKyspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW50cnkuZG9uZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbnRyeTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBoYXNoSXRlcmFibGVJbnRzKGl0ZXJhdG9yLCBzZWVkKTtcbn07XG52YXIgaGFzaFN0cmluZ3MgPSBmdW5jdGlvbiBoYXNoU3RyaW5ncygpIHtcbiAgcmV0dXJuIGhhc2hTdHJpbmdzQXJyYXkoYXJndW1lbnRzKTtcbn07XG52YXIgaGFzaFN0cmluZ3NBcnJheSA9IGZ1bmN0aW9uIGhhc2hTdHJpbmdzQXJyYXkoc3Rycykge1xuICB2YXIgaGFzaDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3RyID0gc3Ryc1tpXTtcblxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBoYXNoID0gaGFzaFN0cmluZyhzdHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYXNoID0gaGFzaFN0cmluZyhzdHIsIGhhc2gpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoYXNoO1xufTtcblxuLypnbG9iYWwgY29uc29sZSAqL1xudmFyIHdhcm5pbmdzRW5hYmxlZCA9IHRydWU7XG52YXIgd2FyblN1cHBvcnRlZCA9IGNvbnNvbGUud2FybiAhPSBudWxsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblxudmFyIHRyYWNlU3VwcG9ydGVkID0gY29uc29sZS50cmFjZSAhPSBudWxsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblxudmFyIE1BWF9JTlQkMSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IDkwMDcxOTkyNTQ3NDA5OTE7XG52YXIgdHJ1ZWlmeSA9IGZ1bmN0aW9uIHRydWVpZnkoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBmYWxzaWZ5ID0gZnVuY3Rpb24gZmFsc2lmeSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciB6ZXJvaWZ5ID0gZnVuY3Rpb24gemVyb2lmeSgpIHtcbiAgcmV0dXJuIDA7XG59O1xudmFyIG5vb3AkMSA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcbnZhciBlcnJvciA9IGZ1bmN0aW9uIGVycm9yKG1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn07XG52YXIgd2FybmluZ3MgPSBmdW5jdGlvbiB3YXJuaW5ncyhlbmFibGVkKSB7XG4gIGlmIChlbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICB3YXJuaW5nc0VuYWJsZWQgPSAhIWVuYWJsZWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHdhcm5pbmdzRW5hYmxlZDtcbiAgfVxufTtcbnZhciB3YXJuID0gZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICBpZiAoIXdhcm5pbmdzKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAod2FyblN1cHBvcnRlZCkge1xuICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKG1zZyk7XG5cbiAgICBpZiAodHJhY2VTdXBwb3J0ZWQpIHtcbiAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICB9XG4gIH1cbn07XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cbnZhciBjbG9uZSA9IGZ1bmN0aW9uIGNsb25lKG9iaikge1xuICByZXR1cm4gZXh0ZW5kKHt9LCBvYmopO1xufTsgLy8gZ2V0cyBhIHNoYWxsb3cgY29weSBvZiB0aGUgYXJndW1lbnRcblxudmFyIGNvcHkgPSBmdW5jdGlvbiBjb3B5KG9iaikge1xuICBpZiAob2JqID09IG51bGwpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgaWYgKGFycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLnNsaWNlKCk7XG4gIH0gZWxzZSBpZiAocGxhaW5PYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBjbG9uZShvYmopO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbn07XG52YXIgY29weUFycmF5ID0gZnVuY3Rpb24gY29weUFycmF5KGFycikge1xuICByZXR1cm4gYXJyLnNsaWNlKCk7XG59O1xudmFyIHV1aWQgPSBmdW5jdGlvbiB1dWlkKGEsIGJcbi8qIHBsYWNlaG9sZGVycyAqL1xuKSB7XG4gIGZvciAoIC8vIGxvb3AgOilcbiAgYiA9IGEgPSAnJzsgLy8gYiAtIHJlc3VsdCAsIGEgLSBudW1lcmljIGxldGlhYmxlXG4gIGErKyA8IDM2OyAvL1xuICBiICs9IGEgKiA1MSAmIDUyIC8vIGlmIFwiYVwiIGlzIG5vdCA5IG9yIDE0IG9yIDE5IG9yIDI0XG4gID8gLy8gIHJldHVybiBhIHJhbmRvbSBudW1iZXIgb3IgNFxuICAoYSBeIDE1IC8vIGlmIFwiYVwiIGlzIG5vdCAxNVxuICA/IC8vIGdlbmVyYXRlIGEgcmFuZG9tIG51bWJlciBmcm9tIDAgdG8gMTVcbiAgOCBeIE1hdGgucmFuZG9tKCkgKiAoYSBeIDIwID8gMTYgOiA0KSAvLyB1bmxlc3MgXCJhXCIgaXMgMjAsIGluIHdoaWNoIGNhc2UgYSByYW5kb20gbnVtYmVyIGZyb20gOCB0byAxMVxuICA6IDQgLy8gIG90aGVyd2lzZSA0XG4gICkudG9TdHJpbmcoMTYpIDogJy0nIC8vICBpbiBvdGhlciBjYXNlcyAoaWYgXCJhXCIgaXMgOSwxNCwxOSwyNCkgaW5zZXJ0IFwiLVwiXG4gICkge1xuICB9XG5cbiAgcmV0dXJuIGI7XG59O1xudmFyIF9zdGF0aWNFbXB0eU9iamVjdCA9IHt9O1xudmFyIHN0YXRpY0VtcHR5T2JqZWN0ID0gZnVuY3Rpb24gc3RhdGljRW1wdHlPYmplY3QoKSB7XG4gIHJldHVybiBfc3RhdGljRW1wdHlPYmplY3Q7XG59O1xudmFyIGRlZmF1bHRzJGcgPSBmdW5jdGlvbiBkZWZhdWx0cyhfZGVmYXVsdHMpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhfZGVmYXVsdHMpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICB2YXIgZmlsbGVkT3B0cyA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciBvcHRWYWwgPSBvcHRzID09IG51bGwgPyB1bmRlZmluZWQgOiBvcHRzW2tleV07XG4gICAgICBmaWxsZWRPcHRzW2tleV0gPSBvcHRWYWwgPT09IHVuZGVmaW5lZCA/IF9kZWZhdWx0c1trZXldIDogb3B0VmFsO1xuICAgIH1cblxuICAgIHJldHVybiBmaWxsZWRPcHRzO1xuICB9O1xufTtcbnZhciByZW1vdmVGcm9tQXJyYXkgPSBmdW5jdGlvbiByZW1vdmVGcm9tQXJyYXkoYXJyLCBlbGUsIG9uZUNvcHkpIHtcbiAgZm9yICh2YXIgaSA9IGFyci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChhcnJbaV0gPT09IGVsZSkge1xuICAgICAgYXJyLnNwbGljZShpLCAxKTtcblxuICAgICAgaWYgKG9uZUNvcHkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIGNsZWFyQXJyYXkgPSBmdW5jdGlvbiBjbGVhckFycmF5KGFycikge1xuICBhcnIuc3BsaWNlKDAsIGFyci5sZW5ndGgpO1xufTtcbnZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChhcnIsIG90aGVyQXJyKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3RoZXJBcnIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWwgPSBvdGhlckFycltpXTtcbiAgICBhcnIucHVzaChlbCk7XG4gIH1cbn07XG52YXIgZ2V0UHJlZml4ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIGdldFByZWZpeGVkUHJvcGVydHkob2JqLCBwcm9wTmFtZSwgcHJlZml4KSB7XG4gIGlmIChwcmVmaXgpIHtcbiAgICBwcm9wTmFtZSA9IHByZXBlbmRDYW1lbChwcmVmaXgsIHByb3BOYW1lKTsgLy8gZS5nLiAobGFiZWxXaWR0aCwgc291cmNlKSA9PiBzb3VyY2VMYWJlbFdpZHRoXG4gIH1cblxuICByZXR1cm4gb2JqW3Byb3BOYW1lXTtcbn07XG52YXIgc2V0UHJlZml4ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIHNldFByZWZpeGVkUHJvcGVydHkob2JqLCBwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSkge1xuICBpZiAocHJlZml4KSB7XG4gICAgcHJvcE5hbWUgPSBwcmVwZW5kQ2FtZWwocHJlZml4LCBwcm9wTmFtZSk7IC8vIGUuZy4gKGxhYmVsV2lkdGgsIHNvdXJjZSkgPT4gc291cmNlTGFiZWxXaWR0aFxuICB9XG5cbiAgb2JqW3Byb3BOYW1lXSA9IHZhbHVlO1xufTtcblxuLyogZ2xvYmFsIE1hcCAqL1xudmFyIE9iamVjdE1hcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9iamVjdE1hcCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT2JqZWN0TWFwKTtcblxuICAgIHRoaXMuX29iaiA9IHt9O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE9iamVjdE1hcCwgW3tcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChrZXksIHZhbCkge1xuICAgICAgdGhpcy5fb2JqW2tleV0gPSB2YWw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUoa2V5KSB7XG4gICAgICB0aGlzLl9vYmpba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuX29iaiA9IHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX29ialtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2JqW2tleV07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE9iamVjdE1hcDtcbn0oKTtcblxudmFyIE1hcCQxID0gdHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgPyBNYXAgOiBPYmplY3RNYXA7XG5cbi8qIGdsb2JhbCBTZXQgKi9cbnZhciB1bmRlZiA9IFwidW5kZWZpbmVkXCIgO1xuXG52YXIgT2JqZWN0U2V0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT2JqZWN0U2V0KGFycmF5T3JPYmplY3RTZXQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT2JqZWN0U2V0KTtcblxuICAgIHRoaXMuX29iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5zaXplID0gMDtcblxuICAgIGlmIChhcnJheU9yT2JqZWN0U2V0ICE9IG51bGwpIHtcbiAgICAgIHZhciBhcnI7XG5cbiAgICAgIGlmIChhcnJheU9yT2JqZWN0U2V0Lmluc3RhbmNlU3RyaW5nICE9IG51bGwgJiYgYXJyYXlPck9iamVjdFNldC5pbnN0YW5jZVN0cmluZygpID09PSB0aGlzLmluc3RhbmNlU3RyaW5nKCkpIHtcbiAgICAgICAgYXJyID0gYXJyYXlPck9iamVjdFNldC50b0FycmF5KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnIgPSBhcnJheU9yT2JqZWN0U2V0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFkZChhcnJbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhPYmplY3RTZXQsIFt7XG4gICAga2V5OiBcImluc3RhbmNlU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc3RhbmNlU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdzZXQnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKHZhbCkge1xuICAgICAgdmFyIG8gPSB0aGlzLl9vYmo7XG5cbiAgICAgIGlmIChvW3ZhbF0gIT09IDEpIHtcbiAgICAgICAgb1t2YWxdID0gMTtcbiAgICAgICAgdGhpcy5zaXplKys7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKHZhbCkge1xuICAgICAgdmFyIG8gPSB0aGlzLl9vYmo7XG5cbiAgICAgIGlmIChvW3ZhbF0gPT09IDEpIHtcbiAgICAgICAgb1t2YWxdID0gMDtcbiAgICAgICAgdGhpcy5zaXplLS07XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5fb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhcyh2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vYmpbdmFsXSA9PT0gMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9BcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0FycmF5KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX29iaikuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmhhcyhrZXkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvckVhY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBPYmplY3RTZXQ7XG59KCk7XG5cbnZhciBTZXQkMSA9ICh0eXBlb2YgU2V0ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoU2V0KSkgIT09IHVuZGVmID8gU2V0IDogT2JqZWN0U2V0O1xuXG52YXIgRWxlbWVudCA9IGZ1bmN0aW9uIEVsZW1lbnQoY3ksIHBhcmFtcykge1xuICB2YXIgcmVzdG9yZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcblxuICBpZiAoY3kgPT09IHVuZGVmaW5lZCB8fCBwYXJhbXMgPT09IHVuZGVmaW5lZCB8fCAhY29yZShjeSkpIHtcbiAgICBlcnJvcignQW4gZWxlbWVudCBtdXN0IGhhdmUgYSBjb3JlIHJlZmVyZW5jZSBhbmQgcGFyYW1ldGVycyBzZXQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZ3JvdXAgPSBwYXJhbXMuZ3JvdXA7IC8vIHRyeSB0byBhdXRvbWF0aWNhbGx5IGluZmVyIHRoZSBncm91cCBpZiB1bnNwZWNpZmllZFxuXG4gIGlmIChncm91cCA9PSBudWxsKSB7XG4gICAgaWYgKHBhcmFtcy5kYXRhICYmIHBhcmFtcy5kYXRhLnNvdXJjZSAhPSBudWxsICYmIHBhcmFtcy5kYXRhLnRhcmdldCAhPSBudWxsKSB7XG4gICAgICBncm91cCA9ICdlZGdlcyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwID0gJ25vZGVzJztcbiAgICB9XG4gIH0gLy8gdmFsaWRhdGUgZ3JvdXBcblxuXG4gIGlmIChncm91cCAhPT0gJ25vZGVzJyAmJiBncm91cCAhPT0gJ2VkZ2VzJykge1xuICAgIGVycm9yKCdBbiBlbGVtZW50IG11c3QgYmUgb2YgdHlwZSBgbm9kZXNgIG9yIGBlZGdlc2A7IHlvdSBzcGVjaWZpZWQgYCcgKyBncm91cCArICdgJyk7XG4gICAgcmV0dXJuO1xuICB9IC8vIG1ha2UgdGhlIGVsZW1lbnQgYXJyYXktbGlrZSwganVzdCBsaWtlIGEgY29sbGVjdGlvblxuXG5cbiAgdGhpcy5sZW5ndGggPSAxO1xuICB0aGlzWzBdID0gdGhpczsgLy8gTk9URTogd2hlbiBzb21ldGhpbmcgaXMgYWRkZWQgaGVyZSwgYWRkIGFsc28gdG8gZWxlLmpzb24oKVxuXG4gIHZhciBfcCA9IHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgY3k6IGN5LFxuICAgIHNpbmdsZTogdHJ1ZSxcbiAgICAvLyBpbmRpY2F0ZXMgdGhpcyBpcyBhbiBlbGVtZW50XG4gICAgZGF0YTogcGFyYW1zLmRhdGEgfHwge30sXG4gICAgLy8gZGF0YSBvYmplY3RcbiAgICBwb3NpdGlvbjogcGFyYW1zLnBvc2l0aW9uIHx8IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfSxcbiAgICAvLyAoeCwgeSkgcG9zaXRpb24gcGFpclxuICAgIGF1dG9XaWR0aDogdW5kZWZpbmVkLFxuICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQgb2Ygbm9kZXMgY2FsY3VsYXRlZCBieSB0aGUgcmVuZGVyZXIgd2hlbiBzZXQgdG8gc3BlY2lhbCAnYXV0bycgdmFsdWVcbiAgICBhdXRvSGVpZ2h0OiB1bmRlZmluZWQsXG4gICAgYXV0b1BhZGRpbmc6IHVuZGVmaW5lZCxcbiAgICBjb21wb3VuZEJvdW5kc0NsZWFuOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHRoZSBjb21wb3VuZCBkaW1lbnNpb25zIG5lZWQgdG8gYmUgcmVjYWxjdWxhdGVkIHRoZSBuZXh0IHRpbWUgZGltZW5zaW9ucyBhcmUgcmVhZFxuICAgIGxpc3RlbmVyczogW10sXG4gICAgLy8gYXJyYXkgb2YgYm91bmQgbGlzdGVuZXJzXG4gICAgZ3JvdXA6IGdyb3VwLFxuICAgIC8vIHN0cmluZzsgJ25vZGVzJyBvciAnZWRnZXMnXG4gICAgc3R5bGU6IHt9LFxuICAgIC8vIHByb3BlcnRpZXMgYXMgc2V0IGJ5IHRoZSBzdHlsZVxuICAgIHJzdHlsZToge30sXG4gICAgLy8gcHJvcGVydGllcyBmb3Igc3R5bGUgc2VudCBmcm9tIHRoZSByZW5kZXJlciB0byB0aGUgY29yZVxuICAgIHN0eWxlQ3h0czogW10sXG4gICAgLy8gYXBwbGllZCBzdHlsZSBjb250ZXh0cyBmcm9tIHRoZSBzdHlsZXJcbiAgICBzdHlsZUtleXM6IHt9LFxuICAgIC8vIHBlci1ncm91cCBrZXlzIG9mIHN0eWxlIHByb3BlcnR5IHZhbHVlc1xuICAgIHJlbW92ZWQ6IHRydWUsXG4gICAgLy8gd2hldGhlciBpdCdzIGluc2lkZSB0aGUgdmlzOyB0cnVlIGlmIHJlbW92ZWQgKHNldCB0cnVlIGhlcmUgc2luY2Ugd2UgY2FsbCByZXN0b3JlKVxuICAgIHNlbGVjdGVkOiBwYXJhbXMuc2VsZWN0ZWQgPyB0cnVlIDogZmFsc2UsXG4gICAgLy8gd2hldGhlciBpdCdzIHNlbGVjdGVkXG4gICAgc2VsZWN0YWJsZTogcGFyYW1zLnNlbGVjdGFibGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBwYXJhbXMuc2VsZWN0YWJsZSA/IHRydWUgOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIGl0J3Mgc2VsZWN0YWJsZVxuICAgIGxvY2tlZDogcGFyYW1zLmxvY2tlZCA/IHRydWUgOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGxvY2tlZCAoY2Fubm90IGJlIG1vdmVkKVxuICAgIGdyYWJiZWQ6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZ3JhYmJlZCBieSB0aGUgbW91c2U7IHJlbmRlcmVyIHNldHMgdGhpcyBwcml2YXRlbHlcbiAgICBncmFiYmFibGU6IHBhcmFtcy5ncmFiYmFibGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBwYXJhbXMuZ3JhYmJhYmxlID8gdHJ1ZSA6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgY2FuIGJlIGdyYWJiZWRcbiAgICBwYW5uYWJsZTogcGFyYW1zLnBhbm5hYmxlID09PSB1bmRlZmluZWQgPyBncm91cCA9PT0gJ2VkZ2VzJyA/IHRydWUgOiBmYWxzZSA6IHBhcmFtcy5wYW5uYWJsZSA/IHRydWUgOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGhhcyBwYXNzdGhyb3VnaCBwYW5uaW5nIGVuYWJsZWRcbiAgICBhY3RpdmU6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgYWN0aXZlIGZyb20gdXNlciBpbnRlcmFjdGlvblxuICAgIGNsYXNzZXM6IG5ldyBTZXQkMSgpLFxuICAgIC8vIG1hcCAoIGNsYXNzTmFtZSA9PiB0cnVlIClcbiAgICBhbmltYXRpb246IHtcbiAgICAgIC8vIG9iamVjdCBmb3IgY3VycmVudGx5LXJ1bm5pbmcgYW5pbWF0aW9uc1xuICAgICAgY3VycmVudDogW10sXG4gICAgICBxdWV1ZTogW11cbiAgICB9LFxuICAgIHJzY3JhdGNoOiB7fSxcbiAgICAvLyBvYmplY3QgaW4gd2hpY2ggdGhlIHJlbmRlcmVyIGNhbiBzdG9yZSBpbmZvcm1hdGlvblxuICAgIHNjcmF0Y2g6IHBhcmFtcy5zY3JhdGNoIHx8IHt9LFxuICAgIC8vIHNjcmF0Y2ggb2JqZWN0c1xuICAgIGVkZ2VzOiBbXSxcbiAgICAvLyBhcnJheSBvZiBjb25uZWN0ZWQgZWRnZXNcbiAgICBjaGlsZHJlbjogW10sXG4gICAgLy8gYXJyYXkgb2YgY2hpbGRyZW5cbiAgICBwYXJlbnQ6IHBhcmFtcy5wYXJlbnQgJiYgcGFyYW1zLnBhcmVudC5pc05vZGUoKSA/IHBhcmFtcy5wYXJlbnQgOiBudWxsLFxuICAgIC8vIHBhcmVudCByZWZcbiAgICB0cmF2ZXJzYWxDYWNoZToge30sXG4gICAgLy8gY2FjaGUgb2Ygb3V0cHV0IG9mIHRyYXZlcnNhbCBmdW5jdGlvbnNcbiAgICBiYWNrZ3JvdW5kaW5nOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIGJhY2tncm91bmQgaW1hZ2VzIGFyZSBsb2FkaW5nXG4gICAgYmJDYWNoZTogbnVsbCxcbiAgICAvLyBjYWNoZSBvZiB0aGUgY3VycmVudCBib3VuZGluZyBib3hcbiAgICBiYkNhY2hlU2hpZnQ6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfSxcbiAgICAvLyBzaGlmdCBhcHBsaWVkIHRvIGNhY2hlZCBiYiB0byBiZSBhcHBsaWVkIG9uIG5leHQgZ2V0XG4gICAgYm9keUJvdW5kczogbnVsbCxcbiAgICAvLyBib3VuZHMgY2FjaGUgb2YgZWxlbWVudCBib2R5LCB3L28gb3ZlcmxheVxuICAgIG92ZXJsYXlCb3VuZHM6IG51bGwsXG4gICAgLy8gYm91bmRzIGNhY2hlIG9mIGVsZW1lbnQgYm9keSwgaW5jbHVkaW5nIG92ZXJsYXlcbiAgICBsYWJlbEJvdW5kczoge1xuICAgICAgLy8gYm91bmRzIGNhY2hlIG9mIGxhYmVsc1xuICAgICAgYWxsOiBudWxsLFxuICAgICAgc291cmNlOiBudWxsLFxuICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgbWFpbjogbnVsbFxuICAgIH0sXG4gICAgYXJyb3dCb3VuZHM6IHtcbiAgICAgIC8vIGJvdW5kcyBjYWNoZSBvZiBlZGdlIGFycm93c1xuICAgICAgc291cmNlOiBudWxsLFxuICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgJ21pZC1zb3VyY2UnOiBudWxsLFxuICAgICAgJ21pZC10YXJnZXQnOiBudWxsXG4gICAgfVxuICB9O1xuXG4gIGlmIChfcC5wb3NpdGlvbi54ID09IG51bGwpIHtcbiAgICBfcC5wb3NpdGlvbi54ID0gMDtcbiAgfVxuXG4gIGlmIChfcC5wb3NpdGlvbi55ID09IG51bGwpIHtcbiAgICBfcC5wb3NpdGlvbi55ID0gMDtcbiAgfSAvLyByZW5kZXJlZFBvc2l0aW9uIG92ZXJyaWRlcyBpZiBzcGVjaWZpZWRcblxuXG4gIGlmIChwYXJhbXMucmVuZGVyZWRQb3NpdGlvbikge1xuICAgIHZhciBycG9zID0gcGFyYW1zLnJlbmRlcmVkUG9zaXRpb247XG4gICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgIF9wLnBvc2l0aW9uID0ge1xuICAgICAgeDogKHJwb3MueCAtIHBhbi54KSAvIHpvb20sXG4gICAgICB5OiAocnBvcy55IC0gcGFuLnkpIC8gem9vbVxuICAgIH07XG4gIH1cblxuICB2YXIgY2xhc3NlcyA9IFtdO1xuXG4gIGlmIChhcnJheShwYXJhbXMuY2xhc3NlcykpIHtcbiAgICBjbGFzc2VzID0gcGFyYW1zLmNsYXNzZXM7XG4gIH0gZWxzZSBpZiAoc3RyaW5nKHBhcmFtcy5jbGFzc2VzKSkge1xuICAgIGNsYXNzZXMgPSBwYXJhbXMuY2xhc3Nlcy5zcGxpdCgvXFxzKy8pO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjbHMgPSBjbGFzc2VzW2ldO1xuXG4gICAgaWYgKCFjbHMgfHwgY2xzID09PSAnJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgX3AuY2xhc3Nlcy5hZGQoY2xzKTtcbiAgfVxuXG4gIHRoaXMuY3JlYXRlRW1pdHRlcigpO1xuICB2YXIgYnlwYXNzID0gcGFyYW1zLnN0eWxlIHx8IHBhcmFtcy5jc3M7XG5cbiAgaWYgKGJ5cGFzcykge1xuICAgIHdhcm4oJ1NldHRpbmcgYSBgc3R5bGVgIGJ5cGFzcyBhdCBlbGVtZW50IGNyZWF0aW9uIHNob3VsZCBiZSBkb25lIG9ubHkgd2hlbiBhYnNvbHV0ZWx5IG5lY2Vzc2FyeS4gIFRyeSB0byB1c2UgdGhlIHN0eWxlc2hlZXQgaW5zdGVhZC4nKTtcbiAgICB0aGlzLnN0eWxlKGJ5cGFzcyk7XG4gIH1cblxuICBpZiAocmVzdG9yZSA9PT0gdW5kZWZpbmVkIHx8IHJlc3RvcmUpIHtcbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgfVxufTtcblxudmFyIGRlZmluZVNlYXJjaCA9IGZ1bmN0aW9uIGRlZmluZVNlYXJjaChwYXJhbXMpIHtcbiAgcGFyYW1zID0ge1xuICAgIGJmczogcGFyYW1zLmJmcyB8fCAhcGFyYW1zLmRmcyxcbiAgICBkZnM6IHBhcmFtcy5kZnMgfHwgIXBhcmFtcy5iZnNcbiAgfTsgLy8gZnJvbSBwc2V1ZG9jb2RlIG9uIHdpa2lwZWRpYVxuXG4gIHJldHVybiBmdW5jdGlvbiBzZWFyY2hGbihyb290cywgZm4sIGRpcmVjdGVkKSB7XG4gICAgdmFyIG9wdGlvbnM7XG5cbiAgICBpZiAocGxhaW5PYmplY3Qocm9vdHMpICYmICFlbGVtZW50T3JDb2xsZWN0aW9uKHJvb3RzKSkge1xuICAgICAgb3B0aW9ucyA9IHJvb3RzO1xuICAgICAgcm9vdHMgPSBvcHRpb25zLnJvb3RzIHx8IG9wdGlvbnMucm9vdDtcbiAgICAgIGZuID0gb3B0aW9ucy52aXNpdDtcbiAgICAgIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICB9XG5cbiAgICBkaXJlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgIWZuJDYoZm4pID8gZm4gOiBkaXJlY3RlZDtcbiAgICBmbiA9IGZuJDYoZm4pID8gZm4gOiBmdW5jdGlvbiAoKSB7fTtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciB2ID0gcm9vdHMgPSBzdHJpbmcocm9vdHMpID8gdGhpcy5maWx0ZXIocm9vdHMpIDogcm9vdHM7XG4gICAgdmFyIFEgPSBbXTtcbiAgICB2YXIgY29ubmVjdGVkTm9kZXMgPSBbXTtcbiAgICB2YXIgY29ubmVjdGVkQnkgPSB7fTtcbiAgICB2YXIgaWQyZGVwdGggPSB7fTtcbiAgICB2YXIgViA9IHt9O1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIgZm91bmQ7XG5cbiAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXMsXG4gICAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlczsgLy8gZW5xdWV1ZSB2XG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZpID0gdltpXTtcbiAgICAgIHZhciB2aUlkID0gdmkuaWQoKTtcblxuICAgICAgaWYgKHZpLmlzTm9kZSgpKSB7XG4gICAgICAgIFEudW5zaGlmdCh2aSk7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5iZnMpIHtcbiAgICAgICAgICBWW3ZpSWRdID0gdHJ1ZTtcbiAgICAgICAgICBjb25uZWN0ZWROb2Rlcy5wdXNoKHZpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlkMmRlcHRoW3ZpSWRdID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIHZhciB2ID0gcGFyYW1zLmJmcyA/IFEuc2hpZnQoKSA6IFEucG9wKCk7XG4gICAgICB2YXIgdklkID0gdi5pZCgpO1xuXG4gICAgICBpZiAocGFyYW1zLmRmcykge1xuICAgICAgICBpZiAoVlt2SWRdKSB7XG4gICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIFZbdklkXSA9IHRydWU7XG4gICAgICAgIGNvbm5lY3RlZE5vZGVzLnB1c2godik7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZXB0aCA9IGlkMmRlcHRoW3ZJZF07XG4gICAgICB2YXIgcHJldkVkZ2UgPSBjb25uZWN0ZWRCeVt2SWRdO1xuICAgICAgdmFyIHNyYyA9IHByZXZFZGdlICE9IG51bGwgPyBwcmV2RWRnZS5zb3VyY2UoKSA6IG51bGw7XG4gICAgICB2YXIgdGd0ID0gcHJldkVkZ2UgIT0gbnVsbCA/IHByZXZFZGdlLnRhcmdldCgpIDogbnVsbDtcbiAgICAgIHZhciBwcmV2Tm9kZSA9IHByZXZFZGdlID09IG51bGwgPyB1bmRlZmluZWQgOiB2LnNhbWUoc3JjKSA/IHRndFswXSA6IHNyY1swXTtcbiAgICAgIHZhciByZXQgPSB2b2lkIDA7XG4gICAgICByZXQgPSBmbih2LCBwcmV2RWRnZSwgcHJldk5vZGUsIGorKywgZGVwdGgpO1xuXG4gICAgICBpZiAocmV0ID09PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kID0gdjtcbiAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHZ3RWRnZXMgPSB2LmNvbm5lY3RlZEVkZ2VzKCkuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiAoIWRpcmVjdGVkIHx8IGUuc291cmNlKCkuc2FtZSh2KSkgJiYgZWRnZXMuaGFzKGUpO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHZ3RWRnZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgZSA9IHZ3RWRnZXNbX2kyXTtcbiAgICAgICAgdmFyIHcgPSBlLmNvbm5lY3RlZE5vZGVzKCkuZmlsdGVyKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgcmV0dXJuICFuLnNhbWUodikgJiYgbm9kZXMuaGFzKG4pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHdJZCA9IHcuaWQoKTtcblxuICAgICAgICBpZiAody5sZW5ndGggIT09IDAgJiYgIVZbd0lkXSkge1xuICAgICAgICAgIHcgPSB3WzBdO1xuICAgICAgICAgIFEucHVzaCh3KTtcblxuICAgICAgICAgIGlmIChwYXJhbXMuYmZzKSB7XG4gICAgICAgICAgICBWW3dJZF0gPSB0cnVlO1xuICAgICAgICAgICAgY29ubmVjdGVkTm9kZXMucHVzaCh3KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25uZWN0ZWRCeVt3SWRdID0gZTtcbiAgICAgICAgICBpZDJkZXB0aFt3SWRdID0gaWQyZGVwdGhbdklkXSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2hpbGUgKFEubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgX3JldCA9IF9sb29wKCk7XG5cbiAgICAgIGlmIChfcmV0ID09PSBcImNvbnRpbnVlXCIpIGNvbnRpbnVlO1xuICAgICAgaWYgKF9yZXQgPT09IFwiYnJlYWtcIikgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGNvbm5lY3RlZEVsZXMgPSBjeS5jb2xsZWN0aW9uKCk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgY29ubmVjdGVkTm9kZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgbm9kZSA9IGNvbm5lY3RlZE5vZGVzW19pXTtcbiAgICAgIHZhciBlZGdlID0gY29ubmVjdGVkQnlbbm9kZS5pZCgpXTtcblxuICAgICAgaWYgKGVkZ2UgIT0gbnVsbCkge1xuICAgICAgICBjb25uZWN0ZWRFbGVzLnB1c2goZWRnZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbm5lY3RlZEVsZXMucHVzaChub2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogY3kuY29sbGVjdGlvbihjb25uZWN0ZWRFbGVzKSxcbiAgICAgIGZvdW5kOiBjeS5jb2xsZWN0aW9uKGZvdW5kKVxuICAgIH07XG4gIH07XG59OyAvLyBzZWFyY2gsIHNwYW5uaW5nIHRyZWVzLCBldGNcblxuXG52YXIgZWxlc2ZuJHYgPSB7XG4gIGJyZWFkdGhGaXJzdFNlYXJjaDogZGVmaW5lU2VhcmNoKHtcbiAgICBiZnM6IHRydWVcbiAgfSksXG4gIGRlcHRoRmlyc3RTZWFyY2g6IGRlZmluZVNlYXJjaCh7XG4gICAgZGZzOiB0cnVlXG4gIH0pXG59OyAvLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGljYWwgYWxpYXNcblxuZWxlc2ZuJHYuYmZzID0gZWxlc2ZuJHYuYnJlYWR0aEZpcnN0U2VhcmNoO1xuZWxlc2ZuJHYuZGZzID0gZWxlc2ZuJHYuZGVwdGhGaXJzdFNlYXJjaDtcblxudmFyIGRpamtzdHJhRGVmYXVsdHMgPSBkZWZhdWx0cyRnKHtcbiAgcm9vdDogbnVsbCxcbiAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoZWRnZSkge1xuICAgIHJldHVybiAxO1xuICB9LFxuICBkaXJlY3RlZDogZmFsc2Vcbn0pO1xudmFyIGVsZXNmbiR1ID0ge1xuICBkaWprc3RyYTogZnVuY3Rpb24gZGlqa3N0cmEob3B0aW9ucykge1xuICAgIGlmICghcGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgcm9vdDogYXJnc1swXSxcbiAgICAgICAgd2VpZ2h0OiBhcmdzWzFdLFxuICAgICAgICBkaXJlY3RlZDogYXJnc1syXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgX2RpamtzdHJhRGVmYXVsdHMgPSBkaWprc3RyYURlZmF1bHRzKG9wdGlvbnMpLFxuICAgICAgICByb290ID0gX2RpamtzdHJhRGVmYXVsdHMucm9vdCxcbiAgICAgICAgd2VpZ2h0ID0gX2RpamtzdHJhRGVmYXVsdHMud2VpZ2h0LFxuICAgICAgICBkaXJlY3RlZCA9IF9kaWprc3RyYURlZmF1bHRzLmRpcmVjdGVkO1xuXG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciB3ZWlnaHRGbiA9IHdlaWdodDtcbiAgICB2YXIgc291cmNlID0gc3RyaW5nKHJvb3QpID8gdGhpcy5maWx0ZXIocm9vdClbMF0gOiByb290WzBdO1xuICAgIHZhciBkaXN0ID0ge307XG4gICAgdmFyIHByZXYgPSB7fTtcbiAgICB2YXIga25vd25EaXN0ID0ge307XG5cbiAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXMsXG4gICAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcztcblxuICAgIGVkZ2VzLnVubWVyZ2VCeShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzTG9vcCgpO1xuICAgIH0pO1xuXG4gICAgdmFyIGdldERpc3QgPSBmdW5jdGlvbiBnZXREaXN0KG5vZGUpIHtcbiAgICAgIHJldHVybiBkaXN0W25vZGUuaWQoKV07XG4gICAgfTtcblxuICAgIHZhciBzZXREaXN0ID0gZnVuY3Rpb24gc2V0RGlzdChub2RlLCBkKSB7XG4gICAgICBkaXN0W25vZGUuaWQoKV0gPSBkO1xuICAgICAgUS51cGRhdGVJdGVtKG5vZGUpO1xuICAgIH07XG5cbiAgICB2YXIgUSA9IG5ldyBIZWFwX19kZWZhdWx0W1wiZGVmYXVsdFwiXShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGdldERpc3QoYSkgLSBnZXREaXN0KGIpO1xuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGRpc3Rbbm9kZS5pZCgpXSA9IG5vZGUuc2FtZShzb3VyY2UpID8gMCA6IEluZmluaXR5O1xuICAgICAgUS5wdXNoKG5vZGUpO1xuICAgIH1cblxuICAgIHZhciBkaXN0QmV0d2VlbiA9IGZ1bmN0aW9uIGRpc3RCZXR3ZWVuKHUsIHYpIHtcbiAgICAgIHZhciB1dnMgPSAoZGlyZWN0ZWQgPyB1LmVkZ2VzVG8odikgOiB1LmVkZ2VzV2l0aCh2KSkuaW50ZXJzZWN0KGVkZ2VzKTtcbiAgICAgIHZhciBzbWFsbGVzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICB2YXIgc21hbGxlc3RFZGdlO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdXZzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgZWRnZSA9IHV2c1tfaV07XG5cbiAgICAgICAgdmFyIF93ZWlnaHQgPSB3ZWlnaHRGbihlZGdlKTtcblxuICAgICAgICBpZiAoX3dlaWdodCA8IHNtYWxsZXN0RGlzdGFuY2UgfHwgIXNtYWxsZXN0RWRnZSkge1xuICAgICAgICAgIHNtYWxsZXN0RGlzdGFuY2UgPSBfd2VpZ2h0O1xuICAgICAgICAgIHNtYWxsZXN0RWRnZSA9IGVkZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWRnZTogc21hbGxlc3RFZGdlLFxuICAgICAgICBkaXN0OiBzbWFsbGVzdERpc3RhbmNlXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB3aGlsZSAoUS5zaXplKCkgPiAwKSB7XG4gICAgICB2YXIgdSA9IFEucG9wKCk7XG4gICAgICB2YXIgc21hbGxldHNEaXN0ID0gZ2V0RGlzdCh1KTtcbiAgICAgIHZhciB1aWQgPSB1LmlkKCk7XG4gICAgICBrbm93bkRpc3RbdWlkXSA9IHNtYWxsZXRzRGlzdDtcblxuICAgICAgaWYgKHNtYWxsZXRzRGlzdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZWlnaGJvcnMgPSB1Lm5laWdoYm9yaG9vZCgpLmludGVyc2VjdChub2Rlcyk7XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5laWdoYm9ycy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciB2ID0gbmVpZ2hib3JzW19pMl07XG4gICAgICAgIHZhciB2aWQgPSB2LmlkKCk7XG4gICAgICAgIHZhciB2RGlzdCA9IGRpc3RCZXR3ZWVuKHUsIHYpO1xuICAgICAgICB2YXIgYWx0ID0gc21hbGxldHNEaXN0ICsgdkRpc3QuZGlzdDtcblxuICAgICAgICBpZiAoYWx0IDwgZ2V0RGlzdCh2KSkge1xuICAgICAgICAgIHNldERpc3QodiwgYWx0KTtcbiAgICAgICAgICBwcmV2W3ZpZF0gPSB7XG4gICAgICAgICAgICBub2RlOiB1LFxuICAgICAgICAgICAgZWRnZTogdkRpc3QuZWRnZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZm9yXG5cbiAgICB9IC8vIHdoaWxlXG5cblxuICAgIHJldHVybiB7XG4gICAgICBkaXN0YW5jZVRvOiBmdW5jdGlvbiBkaXN0YW5jZVRvKG5vZGUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHN0cmluZyhub2RlKSA/IG5vZGVzLmZpbHRlcihub2RlKVswXSA6IG5vZGVbMF07XG4gICAgICAgIHJldHVybiBrbm93bkRpc3RbdGFyZ2V0LmlkKCldO1xuICAgICAgfSxcbiAgICAgIHBhdGhUbzogZnVuY3Rpb24gcGF0aFRvKG5vZGUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHN0cmluZyhub2RlKSA/IG5vZGVzLmZpbHRlcihub2RlKVswXSA6IG5vZGVbMF07XG4gICAgICAgIHZhciBTID0gW107XG4gICAgICAgIHZhciB1ID0gdGFyZ2V0O1xuICAgICAgICB2YXIgdWlkID0gdS5pZCgpO1xuXG4gICAgICAgIGlmICh0YXJnZXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIFMudW5zaGlmdCh0YXJnZXQpO1xuXG4gICAgICAgICAgd2hpbGUgKHByZXZbdWlkXSkge1xuICAgICAgICAgICAgdmFyIHAgPSBwcmV2W3VpZF07XG4gICAgICAgICAgICBTLnVuc2hpZnQocC5lZGdlKTtcbiAgICAgICAgICAgIFMudW5zaGlmdChwLm5vZGUpO1xuICAgICAgICAgICAgdSA9IHAubm9kZTtcbiAgICAgICAgICAgIHVpZCA9IHUuaWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlcy5zcGF3bihTKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG52YXIgZWxlc2ZuJHQgPSB7XG4gIC8vIGtydXNrYWwncyBhbGdvcml0aG0gKGZpbmRzIG1pbiBzcGFubmluZyB0cmVlLCBhc3N1bWluZyB1bmRpcmVjdGVkIGdyYXBoKVxuICAvLyBpbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAga3J1c2thbDogZnVuY3Rpb24ga3J1c2thbCh3ZWlnaHRGbikge1xuICAgIHdlaWdodEZuID0gd2VpZ2h0Rm4gfHwgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH07XG5cbiAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXMsXG4gICAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcztcblxuICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICB2YXIgZm9yZXN0ID0gbmV3IEFycmF5KG51bU5vZGVzKTtcbiAgICB2YXIgQSA9IG5vZGVzOyAvLyBhc3N1bWVzIGJ5R3JvdXAoKSBjcmVhdGVzIG5ldyBjb2xsZWN0aW9ucyB0aGF0IGNhbiBiZSBzYWZlbHkgbXV0YXRlZFxuXG4gICAgdmFyIGZpbmRTZXRJbmRleCA9IGZ1bmN0aW9uIGZpbmRTZXRJbmRleChlbGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9yZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGVzID0gZm9yZXN0W2ldO1xuXG4gICAgICAgIGlmIChlbGVzLmhhcyhlbGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9OyAvLyBzdGFydCB3aXRoIG9uZSBmb3Jlc3QgcGVyIG5vZGVcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICBmb3Jlc3RbaV0gPSB0aGlzLnNwYXduKG5vZGVzW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgUyA9IGVkZ2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiB3ZWlnaHRGbihhKSAtIHdlaWdodEZuKGIpO1xuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IFMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgZWRnZSA9IFNbX2ldO1xuICAgICAgdmFyIHUgPSBlZGdlLnNvdXJjZSgpWzBdO1xuICAgICAgdmFyIHYgPSBlZGdlLnRhcmdldCgpWzBdO1xuICAgICAgdmFyIHNldFVJbmRleCA9IGZpbmRTZXRJbmRleCh1KTtcbiAgICAgIHZhciBzZXRWSW5kZXggPSBmaW5kU2V0SW5kZXgodik7XG4gICAgICB2YXIgc2V0VSA9IGZvcmVzdFtzZXRVSW5kZXhdO1xuICAgICAgdmFyIHNldFYgPSBmb3Jlc3Rbc2V0VkluZGV4XTtcblxuICAgICAgaWYgKHNldFVJbmRleCAhPT0gc2V0VkluZGV4KSB7XG4gICAgICAgIEEubWVyZ2UoZWRnZSk7IC8vIGNvbWJpbmUgZm9yZXN0cyBmb3IgdSBhbmQgdlxuXG4gICAgICAgIHNldFUubWVyZ2Uoc2V0Vik7XG4gICAgICAgIGZvcmVzdC5zcGxpY2Uoc2V0VkluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQTtcbiAgfVxufTtcblxudmFyIGFTdGFyRGVmYXVsdHMgPSBkZWZhdWx0cyRnKHtcbiAgcm9vdDogbnVsbCxcbiAgZ29hbDogbnVsbCxcbiAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoZWRnZSkge1xuICAgIHJldHVybiAxO1xuICB9LFxuICBoZXVyaXN0aWM6IGZ1bmN0aW9uIGhldXJpc3RpYyhlZGdlKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIGRpcmVjdGVkOiBmYWxzZVxufSk7XG52YXIgZWxlc2ZuJHMgPSB7XG4gIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICBhU3RhcjogZnVuY3Rpb24gYVN0YXIob3B0aW9ucykge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIHZhciBfYVN0YXJEZWZhdWx0cyA9IGFTdGFyRGVmYXVsdHMob3B0aW9ucyksXG4gICAgICAgIHJvb3QgPSBfYVN0YXJEZWZhdWx0cy5yb290LFxuICAgICAgICBnb2FsID0gX2FTdGFyRGVmYXVsdHMuZ29hbCxcbiAgICAgICAgaGV1cmlzdGljID0gX2FTdGFyRGVmYXVsdHMuaGV1cmlzdGljLFxuICAgICAgICBkaXJlY3RlZCA9IF9hU3RhckRlZmF1bHRzLmRpcmVjdGVkLFxuICAgICAgICB3ZWlnaHQgPSBfYVN0YXJEZWZhdWx0cy53ZWlnaHQ7XG5cbiAgICByb290ID0gY3kuY29sbGVjdGlvbihyb290KVswXTtcbiAgICBnb2FsID0gY3kuY29sbGVjdGlvbihnb2FsKVswXTtcbiAgICB2YXIgc2lkID0gcm9vdC5pZCgpO1xuICAgIHZhciB0aWQgPSBnb2FsLmlkKCk7XG4gICAgdmFyIGdTY29yZSA9IHt9O1xuICAgIHZhciBmU2NvcmUgPSB7fTtcbiAgICB2YXIgY2xvc2VkU2V0SWRzID0ge307XG4gICAgdmFyIG9wZW5TZXQgPSBuZXcgSGVhcF9fZGVmYXVsdFtcImRlZmF1bHRcIl0oZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmU2NvcmVbYS5pZCgpXSAtIGZTY29yZVtiLmlkKCldO1xuICAgIH0pO1xuICAgIHZhciBvcGVuU2V0SWRzID0gbmV3IFNldCQxKCk7XG4gICAgdmFyIGNhbWVGcm9tID0ge307XG4gICAgdmFyIGNhbWVGcm9tRWRnZSA9IHt9O1xuXG4gICAgdmFyIGFkZFRvT3BlblNldCA9IGZ1bmN0aW9uIGFkZFRvT3BlblNldChlbGUsIGlkKSB7XG4gICAgICBvcGVuU2V0LnB1c2goZWxlKTtcbiAgICAgIG9wZW5TZXRJZHMuYWRkKGlkKTtcbiAgICB9O1xuXG4gICAgdmFyIGNNaW4sIGNNaW5JZDtcblxuICAgIHZhciBwb3BGcm9tT3BlblNldCA9IGZ1bmN0aW9uIHBvcEZyb21PcGVuU2V0KCkge1xuICAgICAgY01pbiA9IG9wZW5TZXQucG9wKCk7XG4gICAgICBjTWluSWQgPSBjTWluLmlkKCk7XG4gICAgICBvcGVuU2V0SWRzW1wiZGVsZXRlXCJdKGNNaW5JZCk7XG4gICAgfTtcblxuICAgIHZhciBpc0luT3BlblNldCA9IGZ1bmN0aW9uIGlzSW5PcGVuU2V0KGlkKSB7XG4gICAgICByZXR1cm4gb3BlblNldElkcy5oYXMoaWQpO1xuICAgIH07XG5cbiAgICBhZGRUb09wZW5TZXQocm9vdCwgc2lkKTtcbiAgICBnU2NvcmVbc2lkXSA9IDA7XG4gICAgZlNjb3JlW3NpZF0gPSBoZXVyaXN0aWMocm9vdCk7IC8vIENvdW50ZXJcblxuICAgIHZhciBzdGVwcyA9IDA7IC8vIE1haW4gbG9vcFxuXG4gICAgd2hpbGUgKG9wZW5TZXQuc2l6ZSgpID4gMCkge1xuICAgICAgcG9wRnJvbU9wZW5TZXQoKTtcbiAgICAgIHN0ZXBzKys7IC8vIElmIHdlJ3ZlIGZvdW5kIG91ciBnb2FsLCB0aGVuIHdlIGFyZSBkb25lXG5cbiAgICAgIGlmIChjTWluSWQgPT09IHRpZCkge1xuICAgICAgICB2YXIgcGF0aCA9IFtdO1xuICAgICAgICB2YXIgcGF0aE5vZGUgPSBnb2FsO1xuICAgICAgICB2YXIgcGF0aE5vZGVJZCA9IHRpZDtcbiAgICAgICAgdmFyIHBhdGhFZGdlID0gY2FtZUZyb21FZGdlW3BhdGhOb2RlSWRdO1xuXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBwYXRoLnVuc2hpZnQocGF0aE5vZGUpO1xuXG4gICAgICAgICAgaWYgKHBhdGhFZGdlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBhdGgudW5zaGlmdChwYXRoRWRnZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aE5vZGUgPSBjYW1lRnJvbVtwYXRoTm9kZUlkXTtcblxuICAgICAgICAgIGlmIChwYXRoTm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoTm9kZUlkID0gcGF0aE5vZGUuaWQoKTtcbiAgICAgICAgICBwYXRoRWRnZSA9IGNhbWVGcm9tRWRnZVtwYXRoTm9kZUlkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZm91bmQ6IHRydWUsXG4gICAgICAgICAgZGlzdGFuY2U6IGdTY29yZVtjTWluSWRdLFxuICAgICAgICAgIHBhdGg6IHRoaXMuc3Bhd24ocGF0aCksXG4gICAgICAgICAgc3RlcHM6IHN0ZXBzXG4gICAgICAgIH07XG4gICAgICB9IC8vIEFkZCBjTWluIHRvIHByb2Nlc3NlZCBub2Rlc1xuXG5cbiAgICAgIGNsb3NlZFNldElkc1tjTWluSWRdID0gdHJ1ZTsgLy8gVXBkYXRlIHNjb3JlcyBmb3IgbmVpZ2hib3JzIG9mIGNNaW5cbiAgICAgIC8vIFRha2UgaW50byBhY2NvdW50IGlmIGdyYXBoIGlzIGRpcmVjdGVkIG9yIG5vdFxuXG4gICAgICB2YXIgdndFZGdlcyA9IGNNaW4uX3ByaXZhdGUuZWRnZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdndFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZSA9IHZ3RWRnZXNbaV07IC8vIGVkZ2UgbXVzdCBiZSBpbiBzZXQgb2YgY2FsbGluZyBlbGVzXG5cbiAgICAgICAgaWYgKCF0aGlzLmhhc0VsZW1lbnRXaXRoSWQoZS5pZCgpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGNNaW4gbXVzdCBiZSB0aGUgc291cmNlIG9mIGVkZ2UgaWYgZGlyZWN0ZWRcblxuXG4gICAgICAgIGlmIChkaXJlY3RlZCAmJiBlLmRhdGEoJ3NvdXJjZScpICE9PSBjTWluSWQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3U3JjID0gZS5zb3VyY2UoKTtcbiAgICAgICAgdmFyIHdUZ3QgPSBlLnRhcmdldCgpO1xuICAgICAgICB2YXIgdyA9IHdTcmMuaWQoKSAhPT0gY01pbklkID8gd1NyYyA6IHdUZ3Q7XG4gICAgICAgIHZhciB3aWQgPSB3LmlkKCk7IC8vIG5vZGUgbXVzdCBiZSBpbiBzZXQgb2YgY2FsbGluZyBlbGVzXG5cbiAgICAgICAgaWYgKCF0aGlzLmhhc0VsZW1lbnRXaXRoSWQod2lkKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGlmIG5vZGUgaXMgaW4gY2xvc2VkU2V0LCBpZ25vcmUgaXRcblxuXG4gICAgICAgIGlmIChjbG9zZWRTZXRJZHNbd2lkXSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIE5ldyB0ZW50YXRpdmUgc2NvcmUgZm9yIG5vZGUgd1xuXG5cbiAgICAgICAgdmFyIHRlbXBTY29yZSA9IGdTY29yZVtjTWluSWRdICsgd2VpZ2h0KGUpOyAvLyBVcGRhdGUgZ1Njb3JlIGZvciBub2RlIHcgaWY6XG4gICAgICAgIC8vICAgdyBub3QgcHJlc2VudCBpbiBvcGVuU2V0XG4gICAgICAgIC8vIE9SXG4gICAgICAgIC8vICAgdGVudGF0aXZlIGdTY29yZSBpcyBsZXNzIHRoYW4gcHJldmlvdXMgdmFsdWVcbiAgICAgICAgLy8gdyBub3QgaW4gb3BlblNldFxuXG4gICAgICAgIGlmICghaXNJbk9wZW5TZXQod2lkKSkge1xuICAgICAgICAgIGdTY29yZVt3aWRdID0gdGVtcFNjb3JlO1xuICAgICAgICAgIGZTY29yZVt3aWRdID0gdGVtcFNjb3JlICsgaGV1cmlzdGljKHcpO1xuICAgICAgICAgIGFkZFRvT3BlblNldCh3LCB3aWQpO1xuICAgICAgICAgIGNhbWVGcm9tW3dpZF0gPSBjTWluO1xuICAgICAgICAgIGNhbWVGcm9tRWRnZVt3aWRdID0gZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyB3IGFscmVhZHkgaW4gb3BlblNldCwgYnV0IHdpdGggZ3JlYXRlciBnU2NvcmVcblxuXG4gICAgICAgIGlmICh0ZW1wU2NvcmUgPCBnU2NvcmVbd2lkXSkge1xuICAgICAgICAgIGdTY29yZVt3aWRdID0gdGVtcFNjb3JlO1xuICAgICAgICAgIGZTY29yZVt3aWRdID0gdGVtcFNjb3JlICsgaGV1cmlzdGljKHcpO1xuICAgICAgICAgIGNhbWVGcm9tW3dpZF0gPSBjTWluO1xuICAgICAgICAgIGNhbWVGcm9tRWRnZVt3aWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBFbmQgb2YgbmVpZ2hib3JzIHVwZGF0ZVxuXG4gICAgfSAvLyBFbmQgb2YgbWFpbiBsb29wXG4gICAgLy8gSWYgd2UndmUgcmVhY2hlZCBoZXJlLCB0aGVuIHdlJ3ZlIG5vdCByZWFjaGVkIG91ciBnb2FsXG5cblxuICAgIHJldHVybiB7XG4gICAgICBmb3VuZDogZmFsc2UsXG4gICAgICBkaXN0YW5jZTogdW5kZWZpbmVkLFxuICAgICAgcGF0aDogdW5kZWZpbmVkLFxuICAgICAgc3RlcHM6IHN0ZXBzXG4gICAgfTtcbiAgfVxufTsgLy8gZWxlc2ZuXG5cbnZhciBmbG95ZFdhcnNoYWxsRGVmYXVsdHMgPSBkZWZhdWx0cyRnKHtcbiAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoZWRnZSkge1xuICAgIHJldHVybiAxO1xuICB9LFxuICBkaXJlY3RlZDogZmFsc2Vcbn0pO1xudmFyIGVsZXNmbiRyID0ge1xuICAvLyBJbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAgZmxveWRXYXJzaGFsbDogZnVuY3Rpb24gZmxveWRXYXJzaGFsbChvcHRpb25zKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgdmFyIF9mbG95ZFdhcnNoYWxsRGVmYXVsdCA9IGZsb3lkV2Fyc2hhbGxEZWZhdWx0cyhvcHRpb25zKSxcbiAgICAgICAgd2VpZ2h0ID0gX2Zsb3lkV2Fyc2hhbGxEZWZhdWx0LndlaWdodCxcbiAgICAgICAgZGlyZWN0ZWQgPSBfZmxveWRXYXJzaGFsbERlZmF1bHQuZGlyZWN0ZWQ7XG5cbiAgICB2YXIgd2VpZ2h0Rm4gPSB3ZWlnaHQ7XG5cbiAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXMsXG4gICAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcztcblxuICAgIHZhciBOID0gbm9kZXMubGVuZ3RoO1xuICAgIHZhciBOc3EgPSBOICogTjtcblxuICAgIHZhciBpbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZihub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZXMuaW5kZXhPZihub2RlKTtcbiAgICB9O1xuXG4gICAgdmFyIGF0SW5kZXggPSBmdW5jdGlvbiBhdEluZGV4KGkpIHtcbiAgICAgIHJldHVybiBub2Rlc1tpXTtcbiAgICB9OyAvLyBJbml0aWFsaXplIGRpc3RhbmNlIG1hdHJpeFxuXG5cbiAgICB2YXIgZGlzdCA9IG5ldyBBcnJheShOc3EpO1xuXG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBOc3E7IG4rKykge1xuICAgICAgdmFyIGogPSBuICUgTjtcbiAgICAgIHZhciBpID0gKG4gLSBqKSAvIE47XG5cbiAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgIGRpc3Rbbl0gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlzdFtuXSA9IEluZmluaXR5O1xuICAgICAgfVxuICAgIH0gLy8gSW5pdGlhbGl6ZSBtYXRyaXggdXNlZCBmb3IgcGF0aCByZWNvbnN0cnVjdGlvblxuICAgIC8vIEluaXRpYWxpemUgZGlzdGFuY2UgbWF0cml4XG5cblxuICAgIHZhciBuZXh0ID0gbmV3IEFycmF5KE5zcSk7XG4gICAgdmFyIGVkZ2VOZXh0ID0gbmV3IEFycmF5KE5zcSk7IC8vIFByb2Nlc3MgZWRnZXNcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBlZGdlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBlZGdlID0gZWRnZXNbX2ldO1xuICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKClbMF07XG4gICAgICB2YXIgdGd0ID0gZWRnZS50YXJnZXQoKVswXTtcblxuICAgICAgaWYgKHNyYyA9PT0gdGd0KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBleGNsdWRlIGxvb3BzXG5cblxuICAgICAgdmFyIHMgPSBpbmRleE9mKHNyYyk7XG4gICAgICB2YXIgdCA9IGluZGV4T2YodGd0KTtcbiAgICAgIHZhciBzdCA9IHMgKiBOICsgdDsgLy8gc291cmNlIHRvIHRhcmdldCBpbmRleFxuXG4gICAgICB2YXIgX3dlaWdodCA9IHdlaWdodEZuKGVkZ2UpOyAvLyBDaGVjayBpZiBhbHJlYWR5IHByb2Nlc3MgYW5vdGhlciBlZGdlIGJldHdlZW4gc2FtZSAyIG5vZGVzXG5cblxuICAgICAgaWYgKGRpc3Rbc3RdID4gX3dlaWdodCkge1xuICAgICAgICBkaXN0W3N0XSA9IF93ZWlnaHQ7XG4gICAgICAgIG5leHRbc3RdID0gdDtcbiAgICAgICAgZWRnZU5leHRbc3RdID0gZWRnZTtcbiAgICAgIH0gLy8gSWYgdW5kaXJlY3RlZCBncmFwaCwgcHJvY2VzcyAncmV2ZXJzZWQnIGVkZ2VcblxuXG4gICAgICBpZiAoIWRpcmVjdGVkKSB7XG4gICAgICAgIHZhciB0cyA9IHQgKiBOICsgczsgLy8gdGFyZ2V0IHRvIHNvdXJjZSBpbmRleFxuXG4gICAgICAgIGlmICghZGlyZWN0ZWQgJiYgZGlzdFt0c10gPiBfd2VpZ2h0KSB7XG4gICAgICAgICAgZGlzdFt0c10gPSBfd2VpZ2h0O1xuICAgICAgICAgIG5leHRbdHNdID0gcztcbiAgICAgICAgICBlZGdlTmV4dFt0c10gPSBlZGdlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBNYWluIGxvb3BcblxuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBOOyBrKyspIHtcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IE47IF9pMisrKSB7XG4gICAgICAgIHZhciBpayA9IF9pMiAqIE4gKyBrO1xuXG4gICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBOOyBfaisrKSB7XG4gICAgICAgICAgdmFyIGlqID0gX2kyICogTiArIF9qO1xuICAgICAgICAgIHZhciBraiA9IGsgKiBOICsgX2o7XG5cbiAgICAgICAgICBpZiAoZGlzdFtpa10gKyBkaXN0W2tqXSA8IGRpc3RbaWpdKSB7XG4gICAgICAgICAgICBkaXN0W2lqXSA9IGRpc3RbaWtdICsgZGlzdFtral07XG4gICAgICAgICAgICBuZXh0W2lqXSA9IG5leHRbaWtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBnZXRBcmdFbGUgPSBmdW5jdGlvbiBnZXRBcmdFbGUoZWxlKSB7XG4gICAgICByZXR1cm4gKHN0cmluZyhlbGUpID8gY3kuZmlsdGVyKGVsZSkgOiBlbGUpWzBdO1xuICAgIH07XG5cbiAgICB2YXIgaW5kZXhPZkFyZ0VsZSA9IGZ1bmN0aW9uIGluZGV4T2ZBcmdFbGUoZWxlKSB7XG4gICAgICByZXR1cm4gaW5kZXhPZihnZXRBcmdFbGUoZWxlKSk7XG4gICAgfTtcblxuICAgIHZhciByZXMgPSB7XG4gICAgICBkaXN0YW5jZTogZnVuY3Rpb24gZGlzdGFuY2UoZnJvbSwgdG8pIHtcbiAgICAgICAgdmFyIGkgPSBpbmRleE9mQXJnRWxlKGZyb20pO1xuICAgICAgICB2YXIgaiA9IGluZGV4T2ZBcmdFbGUodG8pO1xuICAgICAgICByZXR1cm4gZGlzdFtpICogTiArIGpdO1xuICAgICAgfSxcbiAgICAgIHBhdGg6IGZ1bmN0aW9uIHBhdGgoZnJvbSwgdG8pIHtcbiAgICAgICAgdmFyIGkgPSBpbmRleE9mQXJnRWxlKGZyb20pO1xuICAgICAgICB2YXIgaiA9IGluZGV4T2ZBcmdFbGUodG8pO1xuICAgICAgICB2YXIgZnJvbU5vZGUgPSBhdEluZGV4KGkpO1xuXG4gICAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgcmV0dXJuIGZyb21Ob2RlLmNvbGxlY3Rpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0W2kgKiBOICsgal0gPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGF0aCA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgdmFyIHByZXYgPSBpO1xuICAgICAgICB2YXIgZWRnZTtcbiAgICAgICAgcGF0aC5tZXJnZShmcm9tTm9kZSk7XG5cbiAgICAgICAgd2hpbGUgKGkgIT09IGopIHtcbiAgICAgICAgICBwcmV2ID0gaTtcbiAgICAgICAgICBpID0gbmV4dFtpICogTiArIGpdO1xuICAgICAgICAgIGVkZ2UgPSBlZGdlTmV4dFtwcmV2ICogTiArIGldO1xuICAgICAgICAgIHBhdGgubWVyZ2UoZWRnZSk7XG4gICAgICAgICAgcGF0aC5tZXJnZShhdEluZGV4KGkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJlcztcbiAgfSAvLyBmbG95ZFdhcnNoYWxsXG5cbn07IC8vIGVsZXNmblxuXG52YXIgYmVsbG1hbkZvcmREZWZhdWx0cyA9IGRlZmF1bHRzJGcoe1xuICB3ZWlnaHQ6IGZ1bmN0aW9uIHdlaWdodChlZGdlKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0sXG4gIGRpcmVjdGVkOiBmYWxzZSxcbiAgcm9vdDogbnVsbFxufSk7XG52YXIgZWxlc2ZuJHEgPSB7XG4gIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICBiZWxsbWFuRm9yZDogZnVuY3Rpb24gYmVsbG1hbkZvcmQob3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgX2JlbGxtYW5Gb3JkRGVmYXVsdHMgPSBiZWxsbWFuRm9yZERlZmF1bHRzKG9wdGlvbnMpLFxuICAgICAgICB3ZWlnaHQgPSBfYmVsbG1hbkZvcmREZWZhdWx0cy53ZWlnaHQsXG4gICAgICAgIGRpcmVjdGVkID0gX2JlbGxtYW5Gb3JkRGVmYXVsdHMuZGlyZWN0ZWQsXG4gICAgICAgIHJvb3QgPSBfYmVsbG1hbkZvcmREZWZhdWx0cy5yb290O1xuXG4gICAgdmFyIHdlaWdodEZuID0gd2VpZ2h0O1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgICBlZGdlcyA9IF90aGlzJGJ5R3JvdXAuZWRnZXMsXG4gICAgICAgIG5vZGVzID0gX3RoaXMkYnlHcm91cC5ub2RlcztcblxuICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICB2YXIgaW5mb01hcCA9IG5ldyBNYXAkMSgpO1xuICAgIHZhciBoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlID0gZmFsc2U7XG4gICAgdmFyIG5lZ2F0aXZlV2VpZ2h0Q3ljbGVzID0gW107XG4gICAgcm9vdCA9IGN5LmNvbGxlY3Rpb24ocm9vdClbMF07IC8vIGluIGNhc2Ugc2VsZWN0b3IgcGFzc2VkXG5cbiAgICBlZGdlcy51bm1lcmdlQnkoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLmlzTG9vcCgpO1xuICAgIH0pO1xuICAgIHZhciBudW1FZGdlcyA9IGVkZ2VzLmxlbmd0aDtcblxuICAgIHZhciBnZXRJbmZvID0gZnVuY3Rpb24gZ2V0SW5mbyhub2RlKSB7XG4gICAgICB2YXIgb2JqID0gaW5mb01hcC5nZXQobm9kZS5pZCgpKTtcblxuICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgb2JqID0ge307XG4gICAgICAgIGluZm9NYXAuc2V0KG5vZGUuaWQoKSwgb2JqKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuXG4gICAgdmFyIGdldE5vZGVGcm9tVG8gPSBmdW5jdGlvbiBnZXROb2RlRnJvbVRvKHRvKSB7XG4gICAgICByZXR1cm4gKHN0cmluZyh0bykgPyBjeS4kKHRvKSA6IHRvKVswXTtcbiAgICB9O1xuXG4gICAgdmFyIGRpc3RhbmNlVG8gPSBmdW5jdGlvbiBkaXN0YW5jZVRvKHRvKSB7XG4gICAgICByZXR1cm4gZ2V0SW5mbyhnZXROb2RlRnJvbVRvKHRvKSkuZGlzdDtcbiAgICB9O1xuXG4gICAgdmFyIHBhdGhUbyA9IGZ1bmN0aW9uIHBhdGhUbyh0bykge1xuICAgICAgdmFyIHRoaXNTdGFydCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogcm9vdDtcbiAgICAgIHZhciBlbmQgPSBnZXROb2RlRnJvbVRvKHRvKTtcbiAgICAgIHZhciBwYXRoID0gW107XG4gICAgICB2YXIgbm9kZSA9IGVuZDtcblxuICAgICAgZm9yICg7Oykge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnNwYXduKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2dldEluZm8gPSBnZXRJbmZvKG5vZGUpLFxuICAgICAgICAgICAgZWRnZSA9IF9nZXRJbmZvLmVkZ2UsXG4gICAgICAgICAgICBwcmVkID0gX2dldEluZm8ucHJlZDtcblxuICAgICAgICBwYXRoLnVuc2hpZnQobm9kZVswXSk7XG5cbiAgICAgICAgaWYgKG5vZGUuc2FtZSh0aGlzU3RhcnQpICYmIHBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVkZ2UgIT0gbnVsbCkge1xuICAgICAgICAgIHBhdGgudW5zaGlmdChlZGdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBwcmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxlcy5zcGF3bihwYXRoKTtcbiAgICB9OyAvLyBJbml0aWFsaXphdGlvbnMgeyBkaXN0LCBwcmVkLCBlZGdlIH1cblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgdmFyIGluZm8gPSBnZXRJbmZvKG5vZGUpO1xuXG4gICAgICBpZiAobm9kZS5zYW1lKHJvb3QpKSB7XG4gICAgICAgIGluZm8uZGlzdCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvLmRpc3QgPSBJbmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgaW5mby5wcmVkID0gbnVsbDtcbiAgICAgIGluZm8uZWRnZSA9IG51bGw7XG4gICAgfSAvLyBFZGdlcyByZWxheGF0aW9uXG5cblxuICAgIHZhciByZXBsYWNlZEVkZ2UgPSBmYWxzZTtcblxuICAgIHZhciBjaGVja0ZvckVkZ2VSZXBsYWNlbWVudCA9IGZ1bmN0aW9uIGNoZWNrRm9yRWRnZVJlcGxhY2VtZW50KG5vZGUxLCBub2RlMiwgZWRnZSwgaW5mbzEsIGluZm8yLCB3ZWlnaHQpIHtcbiAgICAgIHZhciBkaXN0ID0gaW5mbzEuZGlzdCArIHdlaWdodDtcblxuICAgICAgaWYgKGRpc3QgPCBpbmZvMi5kaXN0ICYmICFlZGdlLnNhbWUoaW5mbzEuZWRnZSkpIHtcbiAgICAgICAgaW5mbzIuZGlzdCA9IGRpc3Q7XG4gICAgICAgIGluZm8yLnByZWQgPSBub2RlMTtcbiAgICAgICAgaW5mbzIuZWRnZSA9IGVkZ2U7XG4gICAgICAgIHJlcGxhY2VkRWRnZSA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBudW1Ob2RlczsgX2krKykge1xuICAgICAgcmVwbGFjZWRFZGdlID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgbnVtRWRnZXM7IGUrKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2VdO1xuICAgICAgICB2YXIgc3JjID0gZWRnZS5zb3VyY2UoKTtcbiAgICAgICAgdmFyIHRndCA9IGVkZ2UudGFyZ2V0KCk7XG5cbiAgICAgICAgdmFyIF93ZWlnaHQgPSB3ZWlnaHRGbihlZGdlKTtcblxuICAgICAgICB2YXIgc3JjSW5mbyA9IGdldEluZm8oc3JjKTtcbiAgICAgICAgdmFyIHRndEluZm8gPSBnZXRJbmZvKHRndCk7XG4gICAgICAgIGNoZWNrRm9yRWRnZVJlcGxhY2VtZW50KHNyYywgdGd0LCBlZGdlLCBzcmNJbmZvLCB0Z3RJbmZvLCBfd2VpZ2h0KTsgLy8gSWYgdW5kaXJlY3RlZCBncmFwaCwgd2UgbmVlZCB0byB0YWtlIGludG8gYWNjb3VudCB0aGUgJ3JldmVyc2UnIGVkZ2VcblxuICAgICAgICBpZiAoIWRpcmVjdGVkKSB7XG4gICAgICAgICAgY2hlY2tGb3JFZGdlUmVwbGFjZW1lbnQodGd0LCBzcmMsIGVkZ2UsIHRndEluZm8sIHNyY0luZm8sIF93ZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVwbGFjZWRFZGdlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXBsYWNlZEVkZ2UpIHtcbiAgICAgIC8vIENoZWNrIGZvciBuZWdhdGl2ZSB3ZWlnaHQgY3ljbGVzXG4gICAgICB2YXIgbmVnYXRpdmVXZWlnaHRDeWNsZUlkcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBfZSA9IDA7IF9lIDwgbnVtRWRnZXM7IF9lKyspIHtcbiAgICAgICAgdmFyIF9lZGdlID0gZWRnZXNbX2VdO1xuXG4gICAgICAgIHZhciBfc3JjID0gX2VkZ2Uuc291cmNlKCk7XG5cbiAgICAgICAgdmFyIF90Z3QgPSBfZWRnZS50YXJnZXQoKTtcblxuICAgICAgICB2YXIgX3dlaWdodDIgPSB3ZWlnaHRGbihfZWRnZSk7XG5cbiAgICAgICAgdmFyIHNyY0Rpc3QgPSBnZXRJbmZvKF9zcmMpLmRpc3Q7XG4gICAgICAgIHZhciB0Z3REaXN0ID0gZ2V0SW5mbyhfdGd0KS5kaXN0O1xuXG4gICAgICAgIGlmIChzcmNEaXN0ICsgX3dlaWdodDIgPCB0Z3REaXN0IHx8ICFkaXJlY3RlZCAmJiB0Z3REaXN0ICsgX3dlaWdodDIgPCBzcmNEaXN0KSB7XG4gICAgICAgICAgaWYgKCFoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlKSB7XG4gICAgICAgICAgICB3YXJuKCdHcmFwaCBjb250YWlucyBhIG5lZ2F0aXZlIHdlaWdodCBjeWNsZSBmb3IgQmVsbG1hbi1Gb3JkJyk7XG4gICAgICAgICAgICBoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5maW5kTmVnYXRpdmVXZWlnaHRDeWNsZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YXIgbmVnYXRpdmVOb2RlcyA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoc3JjRGlzdCArIF93ZWlnaHQyIDwgdGd0RGlzdCkge1xuICAgICAgICAgICAgICBuZWdhdGl2ZU5vZGVzLnB1c2goX3NyYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZGlyZWN0ZWQgJiYgdGd0RGlzdCArIF93ZWlnaHQyIDwgc3JjRGlzdCkge1xuICAgICAgICAgICAgICBuZWdhdGl2ZU5vZGVzLnB1c2goX3RndCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBudW1OZWdhdGl2ZU5vZGVzID0gbmVnYXRpdmVOb2Rlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbnVtTmVnYXRpdmVOb2RlczsgbisrKSB7XG4gICAgICAgICAgICAgIHZhciBzdGFydCA9IG5lZ2F0aXZlTm9kZXNbbl07XG4gICAgICAgICAgICAgIHZhciBjeWNsZSA9IFtzdGFydF07XG4gICAgICAgICAgICAgIGN5Y2xlLnB1c2goZ2V0SW5mbyhzdGFydCkuZWRnZSk7XG4gICAgICAgICAgICAgIHZhciBfbm9kZSA9IGdldEluZm8oc3RhcnQpLnByZWQ7XG5cbiAgICAgICAgICAgICAgd2hpbGUgKGN5Y2xlLmluZGV4T2YoX25vZGUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGN5Y2xlLnB1c2goX25vZGUpO1xuICAgICAgICAgICAgICAgIGN5Y2xlLnB1c2goZ2V0SW5mbyhfbm9kZSkuZWRnZSk7XG4gICAgICAgICAgICAgICAgX25vZGUgPSBnZXRJbmZvKF9ub2RlKS5wcmVkO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY3ljbGUgPSBjeWNsZS5zbGljZShjeWNsZS5pbmRleE9mKF9ub2RlKSk7XG4gICAgICAgICAgICAgIHZhciBzbWFsbGVzdElkID0gY3ljbGVbMF0uaWQoKTtcbiAgICAgICAgICAgICAgdmFyIHNtYWxsZXN0SW5kZXggPSAwO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIGMgPSAyOyBjIDwgY3ljbGUubGVuZ3RoOyBjICs9IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3ljbGVbY10uaWQoKSA8IHNtYWxsZXN0SWQpIHtcbiAgICAgICAgICAgICAgICAgIHNtYWxsZXN0SWQgPSBjeWNsZVtjXS5pZCgpO1xuICAgICAgICAgICAgICAgICAgc21hbGxlc3RJbmRleCA9IGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY3ljbGUgPSBjeWNsZS5zbGljZShzbWFsbGVzdEluZGV4KS5jb25jYXQoY3ljbGUuc2xpY2UoMCwgc21hbGxlc3RJbmRleCkpO1xuICAgICAgICAgICAgICBjeWNsZS5wdXNoKGN5Y2xlWzBdKTtcbiAgICAgICAgICAgICAgdmFyIGN5Y2xlSWQgPSBjeWNsZS5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsLmlkKCk7XG4gICAgICAgICAgICAgIH0pLmpvaW4oXCIsXCIpO1xuXG4gICAgICAgICAgICAgIGlmIChuZWdhdGl2ZVdlaWdodEN5Y2xlSWRzLmluZGV4T2YoY3ljbGVJZCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbmVnYXRpdmVXZWlnaHRDeWNsZXMucHVzaChlbGVzLnNwYXduKGN5Y2xlKSk7XG4gICAgICAgICAgICAgICAgbmVnYXRpdmVXZWlnaHRDeWNsZUlkcy5wdXNoKGN5Y2xlSWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkaXN0YW5jZVRvOiBkaXN0YW5jZVRvLFxuICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICBoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlOiBoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlLFxuICAgICAgbmVnYXRpdmVXZWlnaHRDeWNsZXM6IG5lZ2F0aXZlV2VpZ2h0Q3ljbGVzXG4gICAgfTtcbiAgfSAvLyBiZWxsbWFuRm9yZFxuXG59OyAvLyBlbGVzZm5cblxudmFyIHNxcnQyID0gTWF0aC5zcXJ0KDIpOyAvLyBGdW5jdGlvbiB3aGljaCBjb2xhcHNlcyAyIChtZXRhKSBub2RlcyBpbnRvIG9uZVxuLy8gVXBkYXRlcyB0aGUgcmVtYWluaW5nIGVkZ2UgbGlzdHNcbi8vIFJlY2VpdmVzIGFzIGEgcGFyYW1hdGVyIHRoZSBlZGdlIHdoaWNoIGNhdXNlcyB0aGUgY29sbGFwc2VcblxudmFyIGNvbGxhcHNlID0gZnVuY3Rpb24gY29sbGFwc2UoZWRnZUluZGV4LCBub2RlTWFwLCByZW1haW5pbmdFZGdlcykge1xuICBpZiAocmVtYWluaW5nRWRnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgZXJyb3IoXCJLYXJnZXItU3RlaW4gbXVzdCBiZSBydW4gb24gYSBjb25uZWN0ZWQgKHN1YilncmFwaFwiKTtcbiAgfVxuXG4gIHZhciBlZGdlSW5mbyA9IHJlbWFpbmluZ0VkZ2VzW2VkZ2VJbmRleF07XG4gIHZhciBzb3VyY2VJbiA9IGVkZ2VJbmZvWzFdO1xuICB2YXIgdGFyZ2V0SW4gPSBlZGdlSW5mb1syXTtcbiAgdmFyIHBhcnRpdGlvbjEgPSBub2RlTWFwW3NvdXJjZUluXTtcbiAgdmFyIHBhcnRpdGlvbjIgPSBub2RlTWFwW3RhcmdldEluXTtcbiAgdmFyIG5ld0VkZ2VzID0gcmVtYWluaW5nRWRnZXM7IC8vIHJlLXVzZSBhcnJheVxuICAvLyBEZWxldGUgYWxsIGVkZ2VzIGJldHdlZW4gcGFydGl0aW9uMSBhbmQgcGFydGl0aW9uMlxuXG4gIGZvciAodmFyIGkgPSBuZXdFZGdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBlZGdlID0gbmV3RWRnZXNbaV07XG4gICAgdmFyIHNyYyA9IGVkZ2VbMV07XG4gICAgdmFyIHRndCA9IGVkZ2VbMl07XG5cbiAgICBpZiAobm9kZU1hcFtzcmNdID09PSBwYXJ0aXRpb24xICYmIG5vZGVNYXBbdGd0XSA9PT0gcGFydGl0aW9uMiB8fCBub2RlTWFwW3NyY10gPT09IHBhcnRpdGlvbjIgJiYgbm9kZU1hcFt0Z3RdID09PSBwYXJ0aXRpb24xKSB7XG4gICAgICBuZXdFZGdlcy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9IC8vIEFsbCBlZGdlcyBwb2ludGluZyB0byBwYXJ0aXRpb24yIHNob3VsZCBub3cgcG9pbnQgdG8gcGFydGl0aW9uMVxuXG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5ld0VkZ2VzLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBfZWRnZSA9IG5ld0VkZ2VzW19pXTtcblxuICAgIGlmIChfZWRnZVsxXSA9PT0gcGFydGl0aW9uMikge1xuICAgICAgLy8gQ2hlY2sgc291cmNlXG4gICAgICBuZXdFZGdlc1tfaV0gPSBfZWRnZS5zbGljZSgpOyAvLyBjb3B5XG5cbiAgICAgIG5ld0VkZ2VzW19pXVsxXSA9IHBhcnRpdGlvbjE7XG4gICAgfSBlbHNlIGlmIChfZWRnZVsyXSA9PT0gcGFydGl0aW9uMikge1xuICAgICAgLy8gQ2hlY2sgdGFyZ2V0XG4gICAgICBuZXdFZGdlc1tfaV0gPSBfZWRnZS5zbGljZSgpOyAvLyBjb3B5XG5cbiAgICAgIG5ld0VkZ2VzW19pXVsyXSA9IHBhcnRpdGlvbjE7XG4gICAgfVxuICB9IC8vIE1vdmUgYWxsIG5vZGVzIGZyb20gcGFydGl0aW9uMiB0byBwYXJ0aXRpb24xXG5cblxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBub2RlTWFwLmxlbmd0aDsgX2kyKyspIHtcbiAgICBpZiAobm9kZU1hcFtfaTJdID09PSBwYXJ0aXRpb24yKSB7XG4gICAgICBub2RlTWFwW19pMl0gPSBwYXJ0aXRpb24xO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdFZGdlcztcbn07IC8vIENvbnRyYWN0cyBhIGdyYXBoIHVudGlsIHdlIHJlYWNoIGEgY2VydGFpbiBudW1iZXIgb2YgbWV0YSBub2Rlc1xuXG5cbnZhciBjb250cmFjdFVudGlsID0gZnVuY3Rpb24gY29udHJhY3RVbnRpbChtZXRhTm9kZU1hcCwgcmVtYWluaW5nRWRnZXMsIHNpemUsIHNpemVMaW1pdCkge1xuICB3aGlsZSAoc2l6ZSA+IHNpemVMaW1pdCkge1xuICAgIC8vIENob29zZSBhbiBlZGdlIHJhbmRvbWx5XG4gICAgdmFyIGVkZ2VJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHJlbWFpbmluZ0VkZ2VzLmxlbmd0aCk7IC8vIENvbGxhcHNlIGdyYXBoIGJhc2VkIG9uIGVkZ2VcblxuICAgIHJlbWFpbmluZ0VkZ2VzID0gY29sbGFwc2UoZWRnZUluZGV4LCBtZXRhTm9kZU1hcCwgcmVtYWluaW5nRWRnZXMpO1xuICAgIHNpemUtLTtcbiAgfVxuXG4gIHJldHVybiByZW1haW5pbmdFZGdlcztcbn07XG5cbnZhciBlbGVzZm4kcCA9IHtcbiAgLy8gQ29tcHV0ZXMgdGhlIG1pbmltdW0gY3V0IG9mIGFuIHVuZGlyZWN0ZWQgZ3JhcGhcbiAgLy8gUmV0dXJucyB0aGUgY29ycmVjdCBhbnN3ZXIgd2l0aCBoaWdoIHByb2JhYmlsaXR5XG4gIGthcmdlclN0ZWluOiBmdW5jdGlvbiBrYXJnZXJTdGVpbigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIF90aGlzJGJ5R3JvdXAgPSB0aGlzLmJ5R3JvdXAoKSxcbiAgICAgICAgbm9kZXMgPSBfdGhpcyRieUdyb3VwLm5vZGVzLFxuICAgICAgICBlZGdlcyA9IF90aGlzJGJ5R3JvdXAuZWRnZXM7XG5cbiAgICBlZGdlcy51bm1lcmdlQnkoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLmlzTG9vcCgpO1xuICAgIH0pO1xuICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICB2YXIgbnVtRWRnZXMgPSBlZGdlcy5sZW5ndGg7XG4gICAgdmFyIG51bUl0ZXIgPSBNYXRoLmNlaWwoTWF0aC5wb3coTWF0aC5sb2cobnVtTm9kZXMpIC8gTWF0aC5MTjIsIDIpKTtcbiAgICB2YXIgc3RvcFNpemUgPSBNYXRoLmZsb29yKG51bU5vZGVzIC8gc3FydDIpO1xuXG4gICAgaWYgKG51bU5vZGVzIDwgMikge1xuICAgICAgZXJyb3IoJ0F0IGxlYXN0IDIgbm9kZXMgYXJlIHJlcXVpcmVkIGZvciBLYXJnZXItU3RlaW4gYWxnb3JpdGhtJyk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gLy8gTm93IHN0b3JlIGVkZ2UgZGVzdGluYXRpb24gYXMgaW5kZXhlc1xuICAgIC8vIEZvcm1hdCBmb3IgZWFjaCBlZGdlIChlZGdlIGluZGV4LCBzb3VyY2Ugbm9kZSBpbmRleCwgdGFyZ2V0IG5vZGUgaW5kZXgpXG5cblxuICAgIHZhciBlZGdlSW5kZXhlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1FZGdlczsgaSsrKSB7XG4gICAgICB2YXIgZSA9IGVkZ2VzW2ldO1xuICAgICAgZWRnZUluZGV4ZXMucHVzaChbaSwgbm9kZXMuaW5kZXhPZihlLnNvdXJjZSgpKSwgbm9kZXMuaW5kZXhPZihlLnRhcmdldCgpKV0pO1xuICAgIH0gLy8gV2Ugd2lsbCBzdG9yZSB0aGUgYmVzdCBjdXQgZm91bmQgaGVyZVxuXG5cbiAgICB2YXIgbWluQ3V0U2l6ZSA9IEluZmluaXR5O1xuICAgIHZhciBtaW5DdXRFZGdlSW5kZXhlcyA9IFtdO1xuICAgIHZhciBtaW5DdXROb2RlTWFwID0gbmV3IEFycmF5KG51bU5vZGVzKTsgLy8gSW5pdGlhbCBtZXRhIG5vZGUgcGFydGl0aW9uXG5cbiAgICB2YXIgbWV0YU5vZGVNYXAgPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuICAgIHZhciBtZXRhTm9kZU1hcDIgPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuXG4gICAgdmFyIGNvcHlOb2Rlc01hcCA9IGZ1bmN0aW9uIGNvcHlOb2Rlc01hcChmcm9tLCB0bykge1xuICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbnVtTm9kZXM7IF9pMysrKSB7XG4gICAgICAgIHRvW19pM10gPSBmcm9tW19pM107XG4gICAgICB9XG4gICAgfTsgLy8gTWFpbiBsb29wXG5cblxuICAgIGZvciAodmFyIGl0ZXIgPSAwOyBpdGVyIDw9IG51bUl0ZXI7IGl0ZXIrKykge1xuICAgICAgLy8gUmVzZXQgbWV0YSBub2RlIHBhcnRpdGlvblxuICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbnVtTm9kZXM7IF9pNCsrKSB7XG4gICAgICAgIG1ldGFOb2RlTWFwW19pNF0gPSBfaTQ7XG4gICAgICB9IC8vIENvbnRyYWN0IHVudGlsIHN0b3AgcG9pbnQgKHN0b3BTaXplIG5vZGVzKVxuXG5cbiAgICAgIHZhciBlZGdlc1N0YXRlID0gY29udHJhY3RVbnRpbChtZXRhTm9kZU1hcCwgZWRnZUluZGV4ZXMuc2xpY2UoKSwgbnVtTm9kZXMsIHN0b3BTaXplKTtcbiAgICAgIHZhciBlZGdlc1N0YXRlMiA9IGVkZ2VzU3RhdGUuc2xpY2UoKTsgLy8gY29weVxuICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgY29sYXBzZWQgbm9kZXMgc3RhdGVcblxuICAgICAgY29weU5vZGVzTWFwKG1ldGFOb2RlTWFwLCBtZXRhTm9kZU1hcDIpOyAvLyBSdW4gMiBpdGVyYXRpb25zIHN0YXJ0aW5nIGluIHRoZSBzdG9wIHN0YXRlXG5cbiAgICAgIHZhciByZXMxID0gY29udHJhY3RVbnRpbChtZXRhTm9kZU1hcCwgZWRnZXNTdGF0ZSwgc3RvcFNpemUsIDIpO1xuICAgICAgdmFyIHJlczIgPSBjb250cmFjdFVudGlsKG1ldGFOb2RlTWFwMiwgZWRnZXNTdGF0ZTIsIHN0b3BTaXplLCAyKTsgLy8gSXMgYW55IG9mIHRoZSAyIHJlc3VsdHMgdGhlIGJlc3QgY3V0IHNvIGZhcj9cblxuICAgICAgaWYgKHJlczEubGVuZ3RoIDw9IHJlczIubGVuZ3RoICYmIHJlczEubGVuZ3RoIDwgbWluQ3V0U2l6ZSkge1xuICAgICAgICBtaW5DdXRTaXplID0gcmVzMS5sZW5ndGg7XG4gICAgICAgIG1pbkN1dEVkZ2VJbmRleGVzID0gcmVzMTtcbiAgICAgICAgY29weU5vZGVzTWFwKG1ldGFOb2RlTWFwLCBtaW5DdXROb2RlTWFwKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzMi5sZW5ndGggPD0gcmVzMS5sZW5ndGggJiYgcmVzMi5sZW5ndGggPCBtaW5DdXRTaXplKSB7XG4gICAgICAgIG1pbkN1dFNpemUgPSByZXMyLmxlbmd0aDtcbiAgICAgICAgbWluQ3V0RWRnZUluZGV4ZXMgPSByZXMyO1xuICAgICAgICBjb3B5Tm9kZXNNYXAobWV0YU5vZGVNYXAyLCBtaW5DdXROb2RlTWFwKTtcbiAgICAgIH1cbiAgICB9IC8vIGVuZCBvZiBtYWluIGxvb3BcbiAgICAvLyBDb25zdHJ1Y3QgcmVzdWx0XG5cblxuICAgIHZhciBjdXQgPSB0aGlzLnNwYXduKG1pbkN1dEVkZ2VJbmRleGVzLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIGVkZ2VzW2VbMF1dO1xuICAgIH0pKTtcbiAgICB2YXIgcGFydGl0aW9uMSA9IHRoaXMuc3Bhd24oKTtcbiAgICB2YXIgcGFydGl0aW9uMiA9IHRoaXMuc3Bhd24oKTsgLy8gdHJhdmVyc2UgbWV0YU5vZGVNYXAgZm9yIGJlc3QgY3V0XG5cbiAgICB2YXIgd2l0bmVzc05vZGVQYXJ0aXRpb24gPSBtaW5DdXROb2RlTWFwWzBdO1xuXG4gICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgbWluQ3V0Tm9kZU1hcC5sZW5ndGg7IF9pNSsrKSB7XG4gICAgICB2YXIgcGFydGl0aW9uSWQgPSBtaW5DdXROb2RlTWFwW19pNV07XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW19pNV07XG5cbiAgICAgIGlmIChwYXJ0aXRpb25JZCA9PT0gd2l0bmVzc05vZGVQYXJ0aXRpb24pIHtcbiAgICAgICAgcGFydGl0aW9uMS5tZXJnZShub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRpdGlvbjIubWVyZ2Uobm9kZSk7XG4gICAgICB9XG4gICAgfSAvLyBjb25zdHJ1Y3QgY29tcG9uZW50cyBjb3JyZXNwb25kaW5nIHRvIGVhY2ggZGlzam9pbnQgc3Vic2V0IG9mIG5vZGVzXG5cblxuICAgIHZhciBjb25zdHJ1Y3RDb21wb25lbnQgPSBmdW5jdGlvbiBjb25zdHJ1Y3RDb21wb25lbnQoc3Vic2V0KSB7XG4gICAgICB2YXIgY29tcG9uZW50ID0gX3RoaXMuc3Bhd24oKTtcblxuICAgICAgc3Vic2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgY29tcG9uZW50Lm1lcmdlKG5vZGUpO1xuICAgICAgICBub2RlLmNvbm5lY3RlZEVkZ2VzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBlZGdlIGlzIHdpdGhpbiBjYWxsaW5nIGNvbGxlY3Rpb24gYW5kIGVkZ2UgaXMgbm90IGluIGN1dFxuICAgICAgICAgIGlmIChfdGhpcy5jb250YWlucyhlZGdlKSAmJiAhY3V0LmNvbnRhaW5zKGVkZ2UpKSB7XG4gICAgICAgICAgICBjb21wb25lbnQubWVyZ2UoZWRnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgICB9O1xuXG4gICAgdmFyIGNvbXBvbmVudHMgPSBbY29uc3RydWN0Q29tcG9uZW50KHBhcnRpdGlvbjEpLCBjb25zdHJ1Y3RDb21wb25lbnQocGFydGl0aW9uMildO1xuICAgIHZhciByZXQgPSB7XG4gICAgICBjdXQ6IGN1dCxcbiAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHMsXG4gICAgICAvLyBuLmIuIHBhcnRpdGlvbnMgYXJlIGluY2x1ZGVkIHRvIGJlIGNvbXBhdGlibGUgd2l0aCB0aGUgb2xkIGFwaSBzcGVjXG4gICAgICAvLyAoY291bGQgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciB2ZXJzaW9uKVxuICAgICAgcGFydGl0aW9uMTogcGFydGl0aW9uMSxcbiAgICAgIHBhcnRpdGlvbjI6IHBhcnRpdGlvbjJcbiAgICB9O1xuICAgIHJldHVybiByZXQ7XG4gIH1cbn07IC8vIGVsZXNmblxuXG52YXIgY29weVBvc2l0aW9uID0gZnVuY3Rpb24gY29weVBvc2l0aW9uKHApIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBwLngsXG4gICAgeTogcC55XG4gIH07XG59O1xudmFyIG1vZGVsVG9SZW5kZXJlZFBvc2l0aW9uID0gZnVuY3Rpb24gbW9kZWxUb1JlbmRlcmVkUG9zaXRpb24ocCwgem9vbSwgcGFuKSB7XG4gIHJldHVybiB7XG4gICAgeDogcC54ICogem9vbSArIHBhbi54LFxuICAgIHk6IHAueSAqIHpvb20gKyBwYW4ueVxuICB9O1xufTtcbnZhciByZW5kZXJlZFRvTW9kZWxQb3NpdGlvbiA9IGZ1bmN0aW9uIHJlbmRlcmVkVG9Nb2RlbFBvc2l0aW9uKHAsIHpvb20sIHBhbikge1xuICByZXR1cm4ge1xuICAgIHg6IChwLnggLSBwYW4ueCkgLyB6b29tLFxuICAgIHk6IChwLnkgLSBwYW4ueSkgLyB6b29tXG4gIH07XG59O1xudmFyIGFycmF5MnBvaW50ID0gZnVuY3Rpb24gYXJyYXkycG9pbnQoYXJyKSB7XG4gIHJldHVybiB7XG4gICAgeDogYXJyWzBdLFxuICAgIHk6IGFyclsxXVxuICB9O1xufTtcbnZhciBtaW4gPSBmdW5jdGlvbiBtaW4oYXJyKSB7XG4gIHZhciBiZWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogYXJyLmxlbmd0aDtcbiAgdmFyIG1pbiA9IEluZmluaXR5O1xuXG4gIGZvciAodmFyIGkgPSBiZWdpbjsgaSA8IGVuZDsgaSsrKSB7XG4gICAgdmFyIHZhbCA9IGFycltpXTtcblxuICAgIGlmIChpc0Zpbml0ZSh2YWwpKSB7XG4gICAgICBtaW4gPSBNYXRoLm1pbih2YWwsIG1pbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1pbjtcbn07XG52YXIgbWF4ID0gZnVuY3Rpb24gbWF4KGFycikge1xuICB2YXIgYmVnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGFyci5sZW5ndGg7XG4gIHZhciBtYXggPSAtSW5maW5pdHk7XG5cbiAgZm9yICh2YXIgaSA9IGJlZ2luOyBpIDwgZW5kOyBpKyspIHtcbiAgICB2YXIgdmFsID0gYXJyW2ldO1xuXG4gICAgaWYgKGlzRmluaXRlKHZhbCkpIHtcbiAgICAgIG1heCA9IE1hdGgubWF4KHZhbCwgbWF4KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF4O1xufTtcbnZhciBtZWFuID0gZnVuY3Rpb24gbWVhbihhcnIpIHtcbiAgdmFyIGJlZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBhcnIubGVuZ3RoO1xuICB2YXIgdG90YWwgPSAwO1xuICB2YXIgbiA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IGJlZ2luOyBpIDwgZW5kOyBpKyspIHtcbiAgICB2YXIgdmFsID0gYXJyW2ldO1xuXG4gICAgaWYgKGlzRmluaXRlKHZhbCkpIHtcbiAgICAgIHRvdGFsICs9IHZhbDtcbiAgICAgIG4rKztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG90YWwgLyBuO1xufTtcbnZhciBtZWRpYW4gPSBmdW5jdGlvbiBtZWRpYW4oYXJyKSB7XG4gIHZhciBiZWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogYXJyLmxlbmd0aDtcbiAgdmFyIGNvcHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHRydWU7XG4gIHZhciBzb3J0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0cnVlO1xuICB2YXIgaW5jbHVkZUhvbGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB0cnVlO1xuXG4gIGlmIChjb3B5KSB7XG4gICAgYXJyID0gYXJyLnNsaWNlKGJlZ2luLCBlbmQpO1xuICB9IGVsc2Uge1xuICAgIGlmIChlbmQgPCBhcnIubGVuZ3RoKSB7XG4gICAgICBhcnIuc3BsaWNlKGVuZCwgYXJyLmxlbmd0aCAtIGVuZCk7XG4gICAgfVxuXG4gICAgaWYgKGJlZ2luID4gMCkge1xuICAgICAgYXJyLnNwbGljZSgwLCBiZWdpbik7XG4gICAgfVxuICB9IC8vIGFsbCBub24gZmluaXRlIChlLmcuIEluZmluaXR5LCBOYU4pIGVsZW1lbnRzIG11c3QgYmUgLUluZmluaXR5IHNvIHRoZXkgZ28gdG8gdGhlIHN0YXJ0XG5cblxuICB2YXIgb2ZmID0gMDsgLy8gb2Zmc2V0IGZyb20gbm9uLWZpbml0ZSB2YWx1ZXNcblxuICBmb3IgKHZhciBpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHYgPSBhcnJbaV07XG5cbiAgICBpZiAoaW5jbHVkZUhvbGVzKSB7XG4gICAgICBpZiAoIWlzRmluaXRlKHYpKSB7XG4gICAgICAgIGFycltpXSA9IC1JbmZpbml0eTtcbiAgICAgICAgb2ZmKys7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGp1c3QgcmVtb3ZlIGl0IGlmIHdlIGRvbid0IHdhbnQgdG8gY29uc2lkZXIgaG9sZXNcbiAgICAgIGFyci5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNvcnQpIHtcbiAgICBhcnIuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEgLSBiO1xuICAgIH0pOyAvLyByZXF1aXJlcyBjb3B5ID0gdHJ1ZSBpZiB5b3UgZG9uJ3Qgd2FudCB0byBjaGFuZ2UgdGhlIG9yaWdcbiAgfVxuXG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgbWlkID0gTWF0aC5mbG9vcihsZW4gLyAyKTtcblxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHJldHVybiBhcnJbbWlkICsgMSArIG9mZl07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChhcnJbbWlkIC0gMSArIG9mZl0gKyBhcnJbbWlkICsgb2ZmXSkgLyAyO1xuICB9XG59O1xudmFyIGRlZzJyYWQgPSBmdW5jdGlvbiBkZWcycmFkKGRlZykge1xuICByZXR1cm4gTWF0aC5QSSAqIGRlZyAvIDE4MDtcbn07XG52YXIgZ2V0QW5nbGVGcm9tRGlzcCA9IGZ1bmN0aW9uIGdldEFuZ2xlRnJvbURpc3AoZGlzcFgsIGRpc3BZKSB7XG4gIHJldHVybiBNYXRoLmF0YW4yKGRpc3BZLCBkaXNwWCkgLSBNYXRoLlBJIC8gMjtcbn07XG52YXIgbG9nMiA9IE1hdGgubG9nMiB8fCBmdW5jdGlvbiAobikge1xuICByZXR1cm4gTWF0aC5sb2cobikgLyBNYXRoLmxvZygyKTtcbn07XG52YXIgc2lnbnVtID0gZnVuY3Rpb24gc2lnbnVtKHgpIHtcbiAgaWYgKHggPiAwKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAoeCA8IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG52YXIgZGlzdCA9IGZ1bmN0aW9uIGRpc3QocDEsIHAyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoc3FkaXN0KHAxLCBwMikpO1xufTtcbnZhciBzcWRpc3QgPSBmdW5jdGlvbiBzcWRpc3QocDEsIHAyKSB7XG4gIHZhciBkeCA9IHAyLnggLSBwMS54O1xuICB2YXIgZHkgPSBwMi55IC0gcDEueTtcbiAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufTtcbnZhciBpblBsYWNlU3VtTm9ybWFsaXplID0gZnVuY3Rpb24gaW5QbGFjZVN1bU5vcm1hbGl6ZSh2KSB7XG4gIHZhciBsZW5ndGggPSB2Lmxlbmd0aDsgLy8gRmlyc3QsIGdldCBzdW0gb2YgYWxsIGVsZW1lbnRzXG5cbiAgdmFyIHRvdGFsID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdG90YWwgKz0gdltpXTtcbiAgfSAvLyBOb3csIGRpdmlkZSBlYWNoIGJ5IHRoZSBzdW0gb2YgYWxsIGVsZW1lbnRzXG5cblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGVuZ3RoOyBfaSsrKSB7XG4gICAgdltfaV0gPSB2W19pXSAvIHRvdGFsO1xuICB9XG5cbiAgcmV0dXJuIHY7XG59O1xuXG52YXIgcWJlemllckF0ID0gZnVuY3Rpb24gcWJlemllckF0KHAwLCBwMSwgcDIsIHQpIHtcbiAgcmV0dXJuICgxIC0gdCkgKiAoMSAtIHQpICogcDAgKyAyICogKDEgLSB0KSAqIHQgKiBwMSArIHQgKiB0ICogcDI7XG59O1xudmFyIHFiZXppZXJQdEF0ID0gZnVuY3Rpb24gcWJlemllclB0QXQocDAsIHAxLCBwMiwgdCkge1xuICByZXR1cm4ge1xuICAgIHg6IHFiZXppZXJBdChwMC54LCBwMS54LCBwMi54LCB0KSxcbiAgICB5OiBxYmV6aWVyQXQocDAueSwgcDEueSwgcDIueSwgdClcbiAgfTtcbn07XG52YXIgbGluZUF0ID0gZnVuY3Rpb24gbGluZUF0KHAwLCBwMSwgdCwgZCkge1xuICB2YXIgdmVjID0ge1xuICAgIHg6IHAxLnggLSBwMC54LFxuICAgIHk6IHAxLnkgLSBwMC55XG4gIH07XG4gIHZhciB2ZWNEaXN0ID0gZGlzdChwMCwgcDEpO1xuICB2YXIgbm9ybVZlYyA9IHtcbiAgICB4OiB2ZWMueCAvIHZlY0Rpc3QsXG4gICAgeTogdmVjLnkgLyB2ZWNEaXN0XG4gIH07XG4gIHQgPSB0ID09IG51bGwgPyAwIDogdDtcbiAgZCA9IGQgIT0gbnVsbCA/IGQgOiB0ICogdmVjRGlzdDtcbiAgcmV0dXJuIHtcbiAgICB4OiBwMC54ICsgbm9ybVZlYy54ICogZCxcbiAgICB5OiBwMC55ICsgbm9ybVZlYy55ICogZFxuICB9O1xufTtcbnZhciBib3VuZCA9IGZ1bmN0aW9uIGJvdW5kKG1pbiwgdmFsLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB2YWwpKTtcbn07IC8vIG1ha2VzIGEgZnVsbCBiYiAoeDEsIHkxLCB4MiwgeTIsIHcsIGgpIGZyb20gaW1wbGljaXQgcGFyYW1zXG5cbnZhciBtYWtlQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBtYWtlQm91bmRpbmdCb3goYmIpIHtcbiAgaWYgKGJiID09IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDE6IEluZmluaXR5LFxuICAgICAgeTE6IEluZmluaXR5LFxuICAgICAgeDI6IC1JbmZpbml0eSxcbiAgICAgIHkyOiAtSW5maW5pdHksXG4gICAgICB3OiAwLFxuICAgICAgaDogMFxuICAgIH07XG4gIH0gZWxzZSBpZiAoYmIueDEgIT0gbnVsbCAmJiBiYi55MSAhPSBudWxsKSB7XG4gICAgaWYgKGJiLngyICE9IG51bGwgJiYgYmIueTIgIT0gbnVsbCAmJiBiYi54MiA+PSBiYi54MSAmJiBiYi55MiA+PSBiYi55MSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IGJiLngxLFxuICAgICAgICB5MTogYmIueTEsXG4gICAgICAgIHgyOiBiYi54MixcbiAgICAgICAgeTI6IGJiLnkyLFxuICAgICAgICB3OiBiYi54MiAtIGJiLngxLFxuICAgICAgICBoOiBiYi55MiAtIGJiLnkxXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoYmIudyAhPSBudWxsICYmIGJiLmggIT0gbnVsbCAmJiBiYi53ID49IDAgJiYgYmIuaCA+PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogYmIueDEsXG4gICAgICAgIHkxOiBiYi55MSxcbiAgICAgICAgeDI6IGJiLngxICsgYmIudyxcbiAgICAgICAgeTI6IGJiLnkxICsgYmIuaCxcbiAgICAgICAgdzogYmIudyxcbiAgICAgICAgaDogYmIuaFxuICAgICAgfTtcbiAgICB9XG4gIH1cbn07XG52YXIgY29weUJvdW5kaW5nQm94ID0gZnVuY3Rpb24gY29weUJvdW5kaW5nQm94KGJiKSB7XG4gIHJldHVybiB7XG4gICAgeDE6IGJiLngxLFxuICAgIHgyOiBiYi54MixcbiAgICB3OiBiYi53LFxuICAgIHkxOiBiYi55MSxcbiAgICB5MjogYmIueTIsXG4gICAgaDogYmIuaFxuICB9O1xufTtcbnZhciBjbGVhckJvdW5kaW5nQm94ID0gZnVuY3Rpb24gY2xlYXJCb3VuZGluZ0JveChiYikge1xuICBiYi54MSA9IEluZmluaXR5O1xuICBiYi55MSA9IEluZmluaXR5O1xuICBiYi54MiA9IC1JbmZpbml0eTtcbiAgYmIueTIgPSAtSW5maW5pdHk7XG4gIGJiLncgPSAwO1xuICBiYi5oID0gMDtcbn07XG52YXIgdXBkYXRlQm91bmRpbmdCb3ggPSBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveChiYjEsIGJiMikge1xuICAvLyB1cGRhdGUgYmIxIHdpdGggYmIyIGJvdW5kc1xuICBiYjEueDEgPSBNYXRoLm1pbihiYjEueDEsIGJiMi54MSk7XG4gIGJiMS54MiA9IE1hdGgubWF4KGJiMS54MiwgYmIyLngyKTtcbiAgYmIxLncgPSBiYjEueDIgLSBiYjEueDE7XG4gIGJiMS55MSA9IE1hdGgubWluKGJiMS55MSwgYmIyLnkxKTtcbiAgYmIxLnkyID0gTWF0aC5tYXgoYmIxLnkyLCBiYjIueTIpO1xuICBiYjEuaCA9IGJiMS55MiAtIGJiMS55MTtcbn07XG52YXIgZXhwYW5kQm91bmRpbmdCb3hCeVBvaW50ID0gZnVuY3Rpb24gZXhwYW5kQm91bmRpbmdCb3hCeVBvaW50KGJiLCB4LCB5KSB7XG4gIGJiLngxID0gTWF0aC5taW4oYmIueDEsIHgpO1xuICBiYi54MiA9IE1hdGgubWF4KGJiLngyLCB4KTtcbiAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gIGJiLnkxID0gTWF0aC5taW4oYmIueTEsIHkpO1xuICBiYi55MiA9IE1hdGgubWF4KGJiLnkyLCB5KTtcbiAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG59O1xudmFyIGV4cGFuZEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gZXhwYW5kQm91bmRpbmdCb3goYmIpIHtcbiAgdmFyIHBhZGRpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIGJiLngxIC09IHBhZGRpbmc7XG4gIGJiLngyICs9IHBhZGRpbmc7XG4gIGJiLnkxIC09IHBhZGRpbmc7XG4gIGJiLnkyICs9IHBhZGRpbmc7XG4gIGJiLncgPSBiYi54MiAtIGJiLngxO1xuICBiYi5oID0gYmIueTIgLSBiYi55MTtcbiAgcmV0dXJuIGJiO1xufTtcbnZhciBleHBhbmRCb3VuZGluZ0JveFNpZGVzID0gZnVuY3Rpb24gZXhwYW5kQm91bmRpbmdCb3hTaWRlcyhiYikge1xuICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogWzBdO1xuICB2YXIgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0O1xuXG4gIGlmIChwYWRkaW5nLmxlbmd0aCA9PT0gMSkge1xuICAgIHRvcCA9IHJpZ2h0ID0gYm90dG9tID0gbGVmdCA9IHBhZGRpbmdbMF07XG4gIH0gZWxzZSBpZiAocGFkZGluZy5sZW5ndGggPT09IDIpIHtcbiAgICB0b3AgPSBib3R0b20gPSBwYWRkaW5nWzBdO1xuICAgIGxlZnQgPSByaWdodCA9IHBhZGRpbmdbMV07XG4gIH0gZWxzZSBpZiAocGFkZGluZy5sZW5ndGggPT09IDQpIHtcbiAgICB2YXIgX3BhZGRpbmcgPSBfc2xpY2VkVG9BcnJheShwYWRkaW5nLCA0KTtcblxuICAgIHRvcCA9IF9wYWRkaW5nWzBdO1xuICAgIHJpZ2h0ID0gX3BhZGRpbmdbMV07XG4gICAgYm90dG9tID0gX3BhZGRpbmdbMl07XG4gICAgbGVmdCA9IF9wYWRkaW5nWzNdO1xuICB9XG5cbiAgYmIueDEgLT0gbGVmdDtcbiAgYmIueDIgKz0gcmlnaHQ7XG4gIGJiLnkxIC09IHRvcDtcbiAgYmIueTIgKz0gYm90dG9tO1xuICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG4gIHJldHVybiBiYjtcbn07XG5cbnZhciBhc3NpZ25Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uIGFzc2lnbkJvdW5kaW5nQm94KGJiMSwgYmIyKSB7XG4gIGJiMS54MSA9IGJiMi54MTtcbiAgYmIxLnkxID0gYmIyLnkxO1xuICBiYjEueDIgPSBiYjIueDI7XG4gIGJiMS55MiA9IGJiMi55MjtcbiAgYmIxLncgPSBiYjEueDIgLSBiYjEueDE7XG4gIGJiMS5oID0gYmIxLnkyIC0gYmIxLnkxO1xufTtcbnZhciBib3VuZGluZ0JveGVzSW50ZXJzZWN0ID0gZnVuY3Rpb24gYm91bmRpbmdCb3hlc0ludGVyc2VjdChiYjEsIGJiMikge1xuICAvLyBjYXNlOiBvbmUgYmIgdG8gcmlnaHQgb2Ygb3RoZXJcbiAgaWYgKGJiMS54MSA+IGJiMi54Mikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChiYjIueDEgPiBiYjEueDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gY2FzZTogb25lIGJiIHRvIGxlZnQgb2Ygb3RoZXJcblxuXG4gIGlmIChiYjEueDIgPCBiYjIueDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYmIyLngyIDwgYmIxLngxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIGNhc2U6IG9uZSBiYiBhYm92ZSBvdGhlclxuXG5cbiAgaWYgKGJiMS55MiA8IGJiMi55MSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChiYjIueTIgPCBiYjEueTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gY2FzZTogb25lIGJiIGJlbG93IG90aGVyXG5cblxuICBpZiAoYmIxLnkxID4gYmIyLnkyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGJiMi55MSA+IGJiMS55Mikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBvdGhlcndpc2UsIG11c3QgaGF2ZSBzb21lIG92ZXJsYXBcblxuXG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBpbkJvdW5kaW5nQm94ID0gZnVuY3Rpb24gaW5Cb3VuZGluZ0JveChiYiwgeCwgeSkge1xuICByZXR1cm4gYmIueDEgPD0geCAmJiB4IDw9IGJiLngyICYmIGJiLnkxIDw9IHkgJiYgeSA8PSBiYi55Mjtcbn07XG52YXIgcG9pbnRJbkJvdW5kaW5nQm94ID0gZnVuY3Rpb24gcG9pbnRJbkJvdW5kaW5nQm94KGJiLCBwdCkge1xuICByZXR1cm4gaW5Cb3VuZGluZ0JveChiYiwgcHQueCwgcHQueSk7XG59O1xudmFyIGJvdW5kaW5nQm94SW5Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uIGJvdW5kaW5nQm94SW5Cb3VuZGluZ0JveChiYjEsIGJiMikge1xuICByZXR1cm4gaW5Cb3VuZGluZ0JveChiYjEsIGJiMi54MSwgYmIyLnkxKSAmJiBpbkJvdW5kaW5nQm94KGJiMSwgYmIyLngyLCBiYjIueTIpO1xufTtcbnZhciByb3VuZFJlY3RhbmdsZUludGVyc2VjdExpbmUgPSBmdW5jdGlvbiByb3VuZFJlY3RhbmdsZUludGVyc2VjdExpbmUoeCwgeSwgbm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKSB7XG4gIHZhciBjb3JuZXJSYWRpdXMgPSBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcbiAgdmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcbiAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyOyAvLyBDaGVjayBpbnRlcnNlY3Rpb25zIHdpdGggc3RyYWlnaHQgbGluZSBzZWdtZW50c1xuXG4gIHZhciBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zOyAvLyBUb3Agc2VnbWVudCwgbGVmdCB0byByaWdodFxuXG4gIHtcbiAgICB2YXIgdG9wU3RhcnRYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgIHZhciB0b3BTdGFydFkgPSBub2RlWSAtIGhhbGZIZWlnaHQgLSBwYWRkaW5nO1xuICAgIHZhciB0b3BFbmRYID0gbm9kZVggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuICAgIHZhciB0b3BFbmRZID0gdG9wU3RhcnRZO1xuICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSBmaW5pdGVMaW5lc0ludGVyc2VjdCh4LCB5LCBub2RlWCwgbm9kZVksIHRvcFN0YXJ0WCwgdG9wU3RhcnRZLCB0b3BFbmRYLCB0b3BFbmRZLCBmYWxzZSk7XG5cbiAgICBpZiAoc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICB9XG4gIH0gLy8gUmlnaHQgc2VnbWVudCwgdG9wIHRvIGJvdHRvbVxuXG4gIHtcbiAgICB2YXIgcmlnaHRTdGFydFggPSBub2RlWCArIGhhbGZXaWR0aCArIHBhZGRpbmc7XG4gICAgdmFyIHJpZ2h0U3RhcnRZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICB2YXIgcmlnaHRFbmRYID0gcmlnaHRTdGFydFg7XG4gICAgdmFyIHJpZ2h0RW5kWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG4gICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIG5vZGVYLCBub2RlWSwgcmlnaHRTdGFydFgsIHJpZ2h0U3RhcnRZLCByaWdodEVuZFgsIHJpZ2h0RW5kWSwgZmFsc2UpO1xuXG4gICAgaWYgKHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgfVxuICB9IC8vIEJvdHRvbSBzZWdtZW50LCBsZWZ0IHRvIHJpZ2h0XG5cbiAge1xuICAgIHZhciBib3R0b21TdGFydFggPSBub2RlWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgdmFyIGJvdHRvbVN0YXJ0WSA9IG5vZGVZICsgaGFsZkhlaWdodCArIHBhZGRpbmc7XG4gICAgdmFyIGJvdHRvbUVuZFggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG4gICAgdmFyIGJvdHRvbUVuZFkgPSBib3R0b21TdGFydFk7XG4gICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIG5vZGVYLCBub2RlWSwgYm90dG9tU3RhcnRYLCBib3R0b21TdGFydFksIGJvdHRvbUVuZFgsIGJvdHRvbUVuZFksIGZhbHNlKTtcblxuICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgIH1cbiAgfSAvLyBMZWZ0IHNlZ21lbnQsIHRvcCB0byBib3R0b21cblxuICB7XG4gICAgdmFyIGxlZnRTdGFydFggPSBub2RlWCAtIGhhbGZXaWR0aCAtIHBhZGRpbmc7XG4gICAgdmFyIGxlZnRTdGFydFkgPSBub2RlWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgIHZhciBsZWZ0RW5kWCA9IGxlZnRTdGFydFg7XG4gICAgdmFyIGxlZnRFbmRZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zID0gZmluaXRlTGluZXNJbnRlcnNlY3QoeCwgeSwgbm9kZVgsIG5vZGVZLCBsZWZ0U3RhcnRYLCBsZWZ0U3RhcnRZLCBsZWZ0RW5kWCwgbGVmdEVuZFksIGZhbHNlKTtcblxuICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgIH1cbiAgfSAvLyBDaGVjayBpbnRlcnNlY3Rpb25zIHdpdGggYXJjIHNlZ21lbnRzXG5cbiAgdmFyIGFyY0ludGVyc2VjdGlvbnM7IC8vIFRvcCBMZWZ0XG5cbiAge1xuICAgIHZhciB0b3BMZWZ0Q2VudGVyWCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzO1xuICAgIHZhciB0b3BMZWZ0Q2VudGVyWSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cztcbiAgICBhcmNJbnRlcnNlY3Rpb25zID0gaW50ZXJzZWN0TGluZUNpcmNsZSh4LCB5LCBub2RlWCwgbm9kZVksIHRvcExlZnRDZW50ZXJYLCB0b3BMZWZ0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyk7IC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuXG4gICAgaWYgKGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMCAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdIDw9IHRvcExlZnRDZW50ZXJYICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPD0gdG9wTGVmdENlbnRlclkpIHtcbiAgICAgIHJldHVybiBbYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXV07XG4gICAgfVxuICB9IC8vIFRvcCBSaWdodFxuXG4gIHtcbiAgICB2YXIgdG9wUmlnaHRDZW50ZXJYID0gbm9kZVggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXM7XG4gICAgdmFyIHRvcFJpZ2h0Q2VudGVyWSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cztcbiAgICBhcmNJbnRlcnNlY3Rpb25zID0gaW50ZXJzZWN0TGluZUNpcmNsZSh4LCB5LCBub2RlWCwgbm9kZVksIHRvcFJpZ2h0Q2VudGVyWCwgdG9wUmlnaHRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nKTsgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG5cbiAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPj0gdG9wUmlnaHRDZW50ZXJYICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPD0gdG9wUmlnaHRDZW50ZXJZKSB7XG4gICAgICByZXR1cm4gW2FyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV1dO1xuICAgIH1cbiAgfSAvLyBCb3R0b20gUmlnaHRcblxuICB7XG4gICAgdmFyIGJvdHRvbVJpZ2h0Q2VudGVyWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzO1xuICAgIHZhciBib3R0b21SaWdodENlbnRlclkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXM7XG4gICAgYXJjSW50ZXJzZWN0aW9ucyA9IGludGVyc2VjdExpbmVDaXJjbGUoeCwgeSwgbm9kZVgsIG5vZGVZLCBib3R0b21SaWdodENlbnRlclgsIGJvdHRvbVJpZ2h0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyk7IC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuXG4gICAgaWYgKGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMCAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdID49IGJvdHRvbVJpZ2h0Q2VudGVyWCAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdID49IGJvdHRvbVJpZ2h0Q2VudGVyWSkge1xuICAgICAgcmV0dXJuIFthcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdXTtcbiAgICB9XG4gIH0gLy8gQm90dG9tIExlZnRcblxuICB7XG4gICAgdmFyIGJvdHRvbUxlZnRDZW50ZXJYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXM7XG4gICAgdmFyIGJvdHRvbUxlZnRDZW50ZXJZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzO1xuICAgIGFyY0ludGVyc2VjdGlvbnMgPSBpbnRlcnNlY3RMaW5lQ2lyY2xlKHgsIHksIG5vZGVYLCBub2RlWSwgYm90dG9tTGVmdENlbnRlclgsIGJvdHRvbUxlZnRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nKTsgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG5cbiAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPD0gYm90dG9tTGVmdENlbnRlclggJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA+PSBib3R0b21MZWZ0Q2VudGVyWSkge1xuICAgICAgcmV0dXJuIFthcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtdOyAvLyBpZiBub3RoaW5nXG59O1xudmFyIGluTGluZVZpY2luaXR5ID0gZnVuY3Rpb24gaW5MaW5lVmljaW5pdHkoeCwgeSwgbHgxLCBseTEsIGx4MiwgbHkyLCB0b2xlcmFuY2UpIHtcbiAgdmFyIHQgPSB0b2xlcmFuY2U7XG4gIHZhciB4MSA9IE1hdGgubWluKGx4MSwgbHgyKTtcbiAgdmFyIHgyID0gTWF0aC5tYXgobHgxLCBseDIpO1xuICB2YXIgeTEgPSBNYXRoLm1pbihseTEsIGx5Mik7XG4gIHZhciB5MiA9IE1hdGgubWF4KGx5MSwgbHkyKTtcbiAgcmV0dXJuIHgxIC0gdCA8PSB4ICYmIHggPD0geDIgKyB0ICYmIHkxIC0gdCA8PSB5ICYmIHkgPD0geTIgKyB0O1xufTtcbnZhciBpbkJlemllclZpY2luaXR5ID0gZnVuY3Rpb24gaW5CZXppZXJWaWNpbml0eSh4LCB5LCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB0b2xlcmFuY2UpIHtcbiAgdmFyIGJiID0ge1xuICAgIHgxOiBNYXRoLm1pbih4MSwgeDMsIHgyKSAtIHRvbGVyYW5jZSxcbiAgICB4MjogTWF0aC5tYXgoeDEsIHgzLCB4MikgKyB0b2xlcmFuY2UsXG4gICAgeTE6IE1hdGgubWluKHkxLCB5MywgeTIpIC0gdG9sZXJhbmNlLFxuICAgIHkyOiBNYXRoLm1heCh5MSwgeTMsIHkyKSArIHRvbGVyYW5jZVxuICB9OyAvLyBpZiBvdXRzaWRlIHRoZSByb3VnaCBib3VuZGluZyBib3ggZm9yIHRoZSBiZXppZXIsIHRoZW4gaXQgY2FuJ3QgYmUgYSBoaXRcblxuICBpZiAoeCA8IGJiLngxIHx8IHggPiBiYi54MiB8fCB5IDwgYmIueTEgfHwgeSA+IGJiLnkyKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ2JlemllciBvdXQgb2Ygcm91Z2ggYmInKVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBjb25zb2xlLmxvZygnZG8gbW9yZSBleHBlbnNpdmUgY2hlY2snKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbnZhciBzb2x2ZVF1YWRyYXRpYyA9IGZ1bmN0aW9uIHNvbHZlUXVhZHJhdGljKGEsIGIsIGMsIHZhbCkge1xuICBjIC09IHZhbDtcbiAgdmFyIHIgPSBiICogYiAtIDQgKiBhICogYztcblxuICBpZiAociA8IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgc3FydFIgPSBNYXRoLnNxcnQocik7XG4gIHZhciBkZW5vbSA9IDIgKiBhO1xuICB2YXIgcm9vdDEgPSAoLWIgKyBzcXJ0UikgLyBkZW5vbTtcbiAgdmFyIHJvb3QyID0gKC1iIC0gc3FydFIpIC8gZGVub207XG4gIHJldHVybiBbcm9vdDEsIHJvb3QyXTtcbn07XG52YXIgc29sdmVDdWJpYyA9IGZ1bmN0aW9uIHNvbHZlQ3ViaWMoYSwgYiwgYywgZCwgcmVzdWx0KSB7XG4gIC8vIFNvbHZlcyBhIGN1YmljIGZ1bmN0aW9uLCByZXR1cm5zIHJvb3QgaW4gZm9ybSBbcjEsIGkxLCByMiwgaTIsIHIzLCBpM10sIHdoZXJlXG4gIC8vIHIgaXMgdGhlIHJlYWwgY29tcG9uZW50LCBpIGlzIHRoZSBpbWFnaW5hcnkgY29tcG9uZW50XG4gIC8vIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBDYXJkYW5vIG1ldGhvZCBmcm9tIHRoZSB5ZWFyIDE1NDVcbiAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DdWJpY19mdW5jdGlvbiNUaGVfbmF0dXJlX29mX3RoZV9yb290c1xuICB2YXIgZXBzaWxvbiA9IDAuMDAwMDE7IC8vIGF2b2lkIGRpdmlzaW9uIGJ5IHplcm8gd2hpbGUga2VlcGluZyB0aGUgb3ZlcmFsbCBleHByZXNzaW9uIGNsb3NlIGluIHZhbHVlXG5cbiAgaWYgKGEgPT09IDApIHtcbiAgICBhID0gZXBzaWxvbjtcbiAgfVxuXG4gIGIgLz0gYTtcbiAgYyAvPSBhO1xuICBkIC89IGE7XG4gIHZhciBkaXNjcmltaW5hbnQsIHEsIHIsIGR1bTEsIHMsIHQsIHRlcm0xLCByMTM7XG4gIHEgPSAoMy4wICogYyAtIGIgKiBiKSAvIDkuMDtcbiAgciA9IC0oMjcuMCAqIGQpICsgYiAqICg5LjAgKiBjIC0gMi4wICogKGIgKiBiKSk7XG4gIHIgLz0gNTQuMDtcbiAgZGlzY3JpbWluYW50ID0gcSAqIHEgKiBxICsgciAqIHI7XG4gIHJlc3VsdFsxXSA9IDA7XG4gIHRlcm0xID0gYiAvIDMuMDtcblxuICBpZiAoZGlzY3JpbWluYW50ID4gMCkge1xuICAgIHMgPSByICsgTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCk7XG4gICAgcyA9IHMgPCAwID8gLU1hdGgucG93KC1zLCAxLjAgLyAzLjApIDogTWF0aC5wb3cocywgMS4wIC8gMy4wKTtcbiAgICB0ID0gciAtIE1hdGguc3FydChkaXNjcmltaW5hbnQpO1xuICAgIHQgPSB0IDwgMCA/IC1NYXRoLnBvdygtdCwgMS4wIC8gMy4wKSA6IE1hdGgucG93KHQsIDEuMCAvIDMuMCk7XG4gICAgcmVzdWx0WzBdID0gLXRlcm0xICsgcyArIHQ7XG4gICAgdGVybTEgKz0gKHMgKyB0KSAvIDIuMDtcbiAgICByZXN1bHRbNF0gPSByZXN1bHRbMl0gPSAtdGVybTE7XG4gICAgdGVybTEgPSBNYXRoLnNxcnQoMy4wKSAqICgtdCArIHMpIC8gMjtcbiAgICByZXN1bHRbM10gPSB0ZXJtMTtcbiAgICByZXN1bHRbNV0gPSAtdGVybTE7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmVzdWx0WzVdID0gcmVzdWx0WzNdID0gMDtcblxuICBpZiAoZGlzY3JpbWluYW50ID09PSAwKSB7XG4gICAgcjEzID0gciA8IDAgPyAtTWF0aC5wb3coLXIsIDEuMCAvIDMuMCkgOiBNYXRoLnBvdyhyLCAxLjAgLyAzLjApO1xuICAgIHJlc3VsdFswXSA9IC10ZXJtMSArIDIuMCAqIHIxMztcbiAgICByZXN1bHRbNF0gPSByZXN1bHRbMl0gPSAtKHIxMyArIHRlcm0xKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBxID0gLXE7XG4gIGR1bTEgPSBxICogcSAqIHE7XG4gIGR1bTEgPSBNYXRoLmFjb3MociAvIE1hdGguc3FydChkdW0xKSk7XG4gIHIxMyA9IDIuMCAqIE1hdGguc3FydChxKTtcbiAgcmVzdWx0WzBdID0gLXRlcm0xICsgcjEzICogTWF0aC5jb3MoZHVtMSAvIDMuMCk7XG4gIHJlc3VsdFsyXSA9IC10ZXJtMSArIHIxMyAqIE1hdGguY29zKChkdW0xICsgMi4wICogTWF0aC5QSSkgLyAzLjApO1xuICByZXN1bHRbNF0gPSAtdGVybTEgKyByMTMgKiBNYXRoLmNvcygoZHVtMSArIDQuMCAqIE1hdGguUEkpIC8gMy4wKTtcbiAgcmV0dXJuO1xufTtcbnZhciBzcWRpc3RUb1F1YWRyYXRpY0JlemllciA9IGZ1bmN0aW9uIHNxZGlzdFRvUXVhZHJhdGljQmV6aWVyKHgsIHksIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgLy8gRmluZCBtaW5pbXVtIGRpc3RhbmNlIGJ5IHVzaW5nIHRoZSBtaW5pbXVtIG9mIHRoZSBkaXN0YW5jZVxuICAvLyBmdW5jdGlvbiBiZXR3ZWVuIHRoZSBnaXZlbiBwb2ludCBhbmQgdGhlIGN1cnZlXG4gIC8vIFRoaXMgZ2l2ZXMgdGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgcmVzdWx0aW5nIGN1YmljIGVxdWF0aW9uXG4gIC8vIHdob3NlIHJvb3RzIHRlbGwgdXMgd2hlcmUgYSBwb3NzaWJsZSBtaW5pbXVtIGlzXG4gIC8vIChDb2VmZmljaWVudHMgYXJlIGRpdmlkZWQgYnkgNClcbiAgdmFyIGEgPSAxLjAgKiB4MSAqIHgxIC0gNCAqIHgxICogeDIgKyAyICogeDEgKiB4MyArIDQgKiB4MiAqIHgyIC0gNCAqIHgyICogeDMgKyB4MyAqIHgzICsgeTEgKiB5MSAtIDQgKiB5MSAqIHkyICsgMiAqIHkxICogeTMgKyA0ICogeTIgKiB5MiAtIDQgKiB5MiAqIHkzICsgeTMgKiB5MztcbiAgdmFyIGIgPSAxLjAgKiA5ICogeDEgKiB4MiAtIDMgKiB4MSAqIHgxIC0gMyAqIHgxICogeDMgLSA2ICogeDIgKiB4MiArIDMgKiB4MiAqIHgzICsgOSAqIHkxICogeTIgLSAzICogeTEgKiB5MSAtIDMgKiB5MSAqIHkzIC0gNiAqIHkyICogeTIgKyAzICogeTIgKiB5MztcbiAgdmFyIGMgPSAxLjAgKiAzICogeDEgKiB4MSAtIDYgKiB4MSAqIHgyICsgeDEgKiB4MyAtIHgxICogeCArIDIgKiB4MiAqIHgyICsgMiAqIHgyICogeCAtIHgzICogeCArIDMgKiB5MSAqIHkxIC0gNiAqIHkxICogeTIgKyB5MSAqIHkzIC0geTEgKiB5ICsgMiAqIHkyICogeTIgKyAyICogeTIgKiB5IC0geTMgKiB5O1xuICB2YXIgZCA9IDEuMCAqIHgxICogeDIgLSB4MSAqIHgxICsgeDEgKiB4IC0geDIgKiB4ICsgeTEgKiB5MiAtIHkxICogeTEgKyB5MSAqIHkgLSB5MiAqIHk7IC8vIGRlYnVnKFwiY29lZmZpY2llbnRzOiBcIiArIGEgLyBhICsgXCIsIFwiICsgYiAvIGEgKyBcIiwgXCIgKyBjIC8gYSArIFwiLCBcIiArIGQgLyBhKTtcblxuICB2YXIgcm9vdHMgPSBbXTsgLy8gVXNlIHRoZSBjdWJpYyBzb2x2aW5nIGFsZ29yaXRobVxuXG4gIHNvbHZlQ3ViaWMoYSwgYiwgYywgZCwgcm9vdHMpO1xuICB2YXIgemVyb1RocmVzaG9sZCA9IDAuMDAwMDAwMTtcbiAgdmFyIHBhcmFtcyA9IFtdO1xuXG4gIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCA2OyBpbmRleCArPSAyKSB7XG4gICAgaWYgKE1hdGguYWJzKHJvb3RzW2luZGV4ICsgMV0pIDwgemVyb1RocmVzaG9sZCAmJiByb290c1tpbmRleF0gPj0gMCAmJiByb290c1tpbmRleF0gPD0gMS4wKSB7XG4gICAgICBwYXJhbXMucHVzaChyb290c1tpbmRleF0pO1xuICAgIH1cbiAgfVxuXG4gIHBhcmFtcy5wdXNoKDEuMCk7XG4gIHBhcmFtcy5wdXNoKDAuMCk7XG4gIHZhciBtaW5EaXN0YW5jZVNxdWFyZWQgPSAtMTtcbiAgdmFyIGN1clgsIGN1clksIGRpc3RTcXVhcmVkO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgY3VyWCA9IE1hdGgucG93KDEuMCAtIHBhcmFtc1tpXSwgMi4wKSAqIHgxICsgMi4wICogKDEgLSBwYXJhbXNbaV0pICogcGFyYW1zW2ldICogeDIgKyBwYXJhbXNbaV0gKiBwYXJhbXNbaV0gKiB4MztcbiAgICBjdXJZID0gTWF0aC5wb3coMSAtIHBhcmFtc1tpXSwgMi4wKSAqIHkxICsgMiAqICgxLjAgLSBwYXJhbXNbaV0pICogcGFyYW1zW2ldICogeTIgKyBwYXJhbXNbaV0gKiBwYXJhbXNbaV0gKiB5MztcbiAgICBkaXN0U3F1YXJlZCA9IE1hdGgucG93KGN1clggLSB4LCAyKSArIE1hdGgucG93KGN1clkgLSB5LCAyKTsgLy8gZGVidWcoJ2Rpc3RhbmNlIGZvciBwYXJhbSAnICsgcGFyYW1zW2ldICsgXCI6IFwiICsgTWF0aC5zcXJ0KGRpc3RTcXVhcmVkKSk7XG5cbiAgICBpZiAobWluRGlzdGFuY2VTcXVhcmVkID49IDApIHtcbiAgICAgIGlmIChkaXN0U3F1YXJlZCA8IG1pbkRpc3RhbmNlU3F1YXJlZCkge1xuICAgICAgICBtaW5EaXN0YW5jZVNxdWFyZWQgPSBkaXN0U3F1YXJlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWluRGlzdGFuY2VTcXVhcmVkID0gZGlzdFNxdWFyZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1pbkRpc3RhbmNlU3F1YXJlZDtcbn07XG52YXIgc3FkaXN0VG9GaW5pdGVMaW5lID0gZnVuY3Rpb24gc3FkaXN0VG9GaW5pdGVMaW5lKHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG4gIHZhciBvZmZzZXQgPSBbeCAtIHgxLCB5IC0geTFdO1xuICB2YXIgbGluZSA9IFt4MiAtIHgxLCB5MiAtIHkxXTtcbiAgdmFyIGxpbmVTcSA9IGxpbmVbMF0gKiBsaW5lWzBdICsgbGluZVsxXSAqIGxpbmVbMV07XG4gIHZhciBoeXBTcSA9IG9mZnNldFswXSAqIG9mZnNldFswXSArIG9mZnNldFsxXSAqIG9mZnNldFsxXTtcbiAgdmFyIGRvdFByb2R1Y3QgPSBvZmZzZXRbMF0gKiBsaW5lWzBdICsgb2Zmc2V0WzFdICogbGluZVsxXTtcbiAgdmFyIGFkalNxID0gZG90UHJvZHVjdCAqIGRvdFByb2R1Y3QgLyBsaW5lU3E7XG5cbiAgaWYgKGRvdFByb2R1Y3QgPCAwKSB7XG4gICAgcmV0dXJuIGh5cFNxO1xuICB9XG5cbiAgaWYgKGFkalNxID4gbGluZVNxKSB7XG4gICAgcmV0dXJuICh4IC0geDIpICogKHggLSB4MikgKyAoeSAtIHkyKSAqICh5IC0geTIpO1xuICB9XG5cbiAgcmV0dXJuIGh5cFNxIC0gYWRqU3E7XG59O1xudmFyIHBvaW50SW5zaWRlUG9seWdvblBvaW50cyA9IGZ1bmN0aW9uIHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBwb2ludHMpIHtcbiAgdmFyIHgxLCB5MSwgeDIsIHkyO1xuICB2YXIgeTM7IC8vIEludGVyc2VjdCB3aXRoIHZlcnRpY2FsIGxpbmUgdGhyb3VnaCAoeCwgeSlcblxuICB2YXIgdXAgPSAwOyAvLyBsZXQgZG93biA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgeDEgPSBwb2ludHNbaSAqIDJdO1xuICAgIHkxID0gcG9pbnRzW2kgKiAyICsgMV07XG5cbiAgICBpZiAoaSArIDEgPCBwb2ludHMubGVuZ3RoIC8gMikge1xuICAgICAgeDIgPSBwb2ludHNbKGkgKyAxKSAqIDJdO1xuICAgICAgeTIgPSBwb2ludHNbKGkgKyAxKSAqIDIgKyAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgeDIgPSBwb2ludHNbKGkgKyAxIC0gcG9pbnRzLmxlbmd0aCAvIDIpICogMl07XG4gICAgICB5MiA9IHBvaW50c1soaSArIDEgLSBwb2ludHMubGVuZ3RoIC8gMikgKiAyICsgMV07XG4gICAgfVxuXG4gICAgaWYgKHgxID09IHggJiYgeDIgPT0geCkgOyBlbHNlIGlmICh4MSA+PSB4ICYmIHggPj0geDIgfHwgeDEgPD0geCAmJiB4IDw9IHgyKSB7XG4gICAgICB5MyA9ICh4IC0geDEpIC8gKHgyIC0geDEpICogKHkyIC0geTEpICsgeTE7XG5cbiAgICAgIGlmICh5MyA+IHkpIHtcbiAgICAgICAgdXArKztcbiAgICAgIH0gLy8gaWYoIHkzIDwgeSApe1xuICAgICAgLy8gZG93bisrO1xuICAgICAgLy8gfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICh1cCAlIDIgPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG52YXIgcG9pbnRJbnNpZGVQb2x5Z29uID0gZnVuY3Rpb24gcG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZykge1xuICB2YXIgdHJhbnNmb3JtZWRQb2ludHMgPSBuZXcgQXJyYXkoYmFzZVBvaW50cy5sZW5ndGgpOyAvLyBHaXZlcyBuZWdhdGl2ZSBhbmdsZVxuXG4gIHZhciBhbmdsZTtcblxuICBpZiAoZGlyZWN0aW9uWzBdICE9IG51bGwpIHtcbiAgICBhbmdsZSA9IE1hdGguYXRhbihkaXJlY3Rpb25bMV0gLyBkaXJlY3Rpb25bMF0pO1xuXG4gICAgaWYgKGRpcmVjdGlvblswXSA8IDApIHtcbiAgICAgIGFuZ2xlID0gYW5nbGUgKyBNYXRoLlBJIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5nbGUgPSAtYW5nbGUgLSBNYXRoLlBJIC8gMjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYW5nbGUgPSBkaXJlY3Rpb247XG4gIH1cblxuICB2YXIgY29zID0gTWF0aC5jb3MoLWFuZ2xlKTtcbiAgdmFyIHNpbiA9IE1hdGguc2luKC1hbmdsZSk7IC8vICAgIGNvbnNvbGUubG9nKFwiYmFzZTogXCIgKyBiYXNlUG9pbnRzKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybWVkUG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSA9IHdpZHRoIC8gMiAqIChiYXNlUG9pbnRzW2kgKiAyXSAqIGNvcyAtIGJhc2VQb2ludHNbaSAqIDIgKyAxXSAqIHNpbik7XG4gICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSA9IGhlaWdodCAvIDIgKiAoYmFzZVBvaW50c1tpICogMiArIDFdICogY29zICsgYmFzZVBvaW50c1tpICogMl0gKiBzaW4pO1xuICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSArPSBjZW50ZXJYO1xuICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV0gKz0gY2VudGVyWTtcbiAgfVxuXG4gIHZhciBwb2ludHM7XG5cbiAgaWYgKHBhZGRpbmcgPiAwKSB7XG4gICAgdmFyIGV4cGFuZGVkTGluZVNldCA9IGV4cGFuZFBvbHlnb24odHJhbnNmb3JtZWRQb2ludHMsIC1wYWRkaW5nKTtcbiAgICBwb2ludHMgPSBqb2luTGluZXMoZXhwYW5kZWRMaW5lU2V0KTtcbiAgfSBlbHNlIHtcbiAgICBwb2ludHMgPSB0cmFuc2Zvcm1lZFBvaW50cztcbiAgfVxuXG4gIHJldHVybiBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgcG9pbnRzKTtcbn07XG52YXIgcG9pbnRJbnNpZGVSb3VuZFBvbHlnb24gPSBmdW5jdGlvbiBwb2ludEluc2lkZVJvdW5kUG9seWdvbih4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciBjdXRQb2x5Z29uUG9pbnRzID0gbmV3IEFycmF5KGJhc2VQb2ludHMubGVuZ3RoKTtcbiAgdmFyIGhhbGZXID0gd2lkdGggLyAyO1xuICB2YXIgaGFsZkggPSBoZWlnaHQgLyAyO1xuICB2YXIgY29ybmVyUmFkaXVzID0gZ2V0Um91bmRQb2x5Z29uUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuICB2YXIgc3F1YXJlZENvcm5lclJhZGl1cyA9IGNvcm5lclJhZGl1cyAqIGNvcm5lclJhZGl1cztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJhc2VQb2ludHMubGVuZ3RoIC8gNDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZVV2ID0gdm9pZCAwLFxuICAgICAgICBkZXN0VXYgPSB2b2lkIDA7XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgc291cmNlVXYgPSBiYXNlUG9pbnRzLmxlbmd0aCAtIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvdXJjZVV2ID0gaSAqIDQgLSAyO1xuICAgIH1cblxuICAgIGRlc3RVdiA9IGkgKiA0ICsgMjtcbiAgICB2YXIgcHggPSBjZW50ZXJYICsgaGFsZlcgKiBiYXNlUG9pbnRzW2kgKiA0XTtcbiAgICB2YXIgcHkgPSBjZW50ZXJZICsgaGFsZkggKiBiYXNlUG9pbnRzW2kgKiA0ICsgMV07XG4gICAgdmFyIGNvc1RoZXRhID0gLWJhc2VQb2ludHNbc291cmNlVXZdICogYmFzZVBvaW50c1tkZXN0VXZdIC0gYmFzZVBvaW50c1tzb3VyY2VVdiArIDFdICogYmFzZVBvaW50c1tkZXN0VXYgKyAxXTtcbiAgICB2YXIgb2Zmc2V0ID0gY29ybmVyUmFkaXVzIC8gTWF0aC50YW4oTWF0aC5hY29zKGNvc1RoZXRhKSAvIDIpO1xuICAgIHZhciBjcDB4ID0gcHggLSBvZmZzZXQgKiBiYXNlUG9pbnRzW3NvdXJjZVV2XTtcbiAgICB2YXIgY3AweSA9IHB5IC0gb2Zmc2V0ICogYmFzZVBvaW50c1tzb3VyY2VVdiArIDFdO1xuICAgIHZhciBjcDF4ID0gcHggKyBvZmZzZXQgKiBiYXNlUG9pbnRzW2Rlc3RVdl07XG4gICAgdmFyIGNwMXkgPSBweSArIG9mZnNldCAqIGJhc2VQb2ludHNbZGVzdFV2ICsgMV07XG4gICAgY3V0UG9seWdvblBvaW50c1tpICogNF0gPSBjcDB4O1xuICAgIGN1dFBvbHlnb25Qb2ludHNbaSAqIDQgKyAxXSA9IGNwMHk7XG4gICAgY3V0UG9seWdvblBvaW50c1tpICogNCArIDJdID0gY3AxeDtcbiAgICBjdXRQb2x5Z29uUG9pbnRzW2kgKiA0ICsgM10gPSBjcDF5O1xuICAgIHZhciBvcnRoeCA9IGJhc2VQb2ludHNbc291cmNlVXYgKyAxXTtcbiAgICB2YXIgb3J0aHkgPSAtYmFzZVBvaW50c1tzb3VyY2VVdl07XG4gICAgdmFyIGNvc0FscGhhID0gb3J0aHggKiBiYXNlUG9pbnRzW2Rlc3RVdl0gKyBvcnRoeSAqIGJhc2VQb2ludHNbZGVzdFV2ICsgMV07XG5cbiAgICBpZiAoY29zQWxwaGEgPCAwKSB7XG4gICAgICBvcnRoeCAqPSAtMTtcbiAgICAgIG9ydGh5ICo9IC0xO1xuICAgIH1cblxuICAgIHZhciBjeCA9IGNwMHggKyBvcnRoeCAqIGNvcm5lclJhZGl1cztcbiAgICB2YXIgY3kgPSBjcDB5ICsgb3J0aHkgKiBjb3JuZXJSYWRpdXM7XG4gICAgdmFyIHNxdWFyZWREaXN0YW5jZSA9IE1hdGgucG93KGN4IC0geCwgMikgKyBNYXRoLnBvdyhjeSAtIHksIDIpO1xuXG4gICAgaWYgKHNxdWFyZWREaXN0YW5jZSA8PSBzcXVhcmVkQ29ybmVyUmFkaXVzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIGN1dFBvbHlnb25Qb2ludHMpO1xufTtcbnZhciBqb2luTGluZXMgPSBmdW5jdGlvbiBqb2luTGluZXMobGluZVNldCkge1xuICB2YXIgdmVydGljZXMgPSBuZXcgQXJyYXkobGluZVNldC5sZW5ndGggLyAyKTtcbiAgdmFyIGN1cnJlbnRMaW5lU3RhcnRYLCBjdXJyZW50TGluZVN0YXJ0WSwgY3VycmVudExpbmVFbmRYLCBjdXJyZW50TGluZUVuZFk7XG4gIHZhciBuZXh0TGluZVN0YXJ0WCwgbmV4dExpbmVTdGFydFksIG5leHRMaW5lRW5kWCwgbmV4dExpbmVFbmRZO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVNldC5sZW5ndGggLyA0OyBpKyspIHtcbiAgICBjdXJyZW50TGluZVN0YXJ0WCA9IGxpbmVTZXRbaSAqIDRdO1xuICAgIGN1cnJlbnRMaW5lU3RhcnRZID0gbGluZVNldFtpICogNCArIDFdO1xuICAgIGN1cnJlbnRMaW5lRW5kWCA9IGxpbmVTZXRbaSAqIDQgKyAyXTtcbiAgICBjdXJyZW50TGluZUVuZFkgPSBsaW5lU2V0W2kgKiA0ICsgM107XG5cbiAgICBpZiAoaSA8IGxpbmVTZXQubGVuZ3RoIC8gNCAtIDEpIHtcbiAgICAgIG5leHRMaW5lU3RhcnRYID0gbGluZVNldFsoaSArIDEpICogNF07XG4gICAgICBuZXh0TGluZVN0YXJ0WSA9IGxpbmVTZXRbKGkgKyAxKSAqIDQgKyAxXTtcbiAgICAgIG5leHRMaW5lRW5kWCA9IGxpbmVTZXRbKGkgKyAxKSAqIDQgKyAyXTtcbiAgICAgIG5leHRMaW5lRW5kWSA9IGxpbmVTZXRbKGkgKyAxKSAqIDQgKyAzXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dExpbmVTdGFydFggPSBsaW5lU2V0WzBdO1xuICAgICAgbmV4dExpbmVTdGFydFkgPSBsaW5lU2V0WzFdO1xuICAgICAgbmV4dExpbmVFbmRYID0gbGluZVNldFsyXTtcbiAgICAgIG5leHRMaW5lRW5kWSA9IGxpbmVTZXRbM107XG4gICAgfVxuXG4gICAgdmFyIGludGVyc2VjdGlvbiA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KGN1cnJlbnRMaW5lU3RhcnRYLCBjdXJyZW50TGluZVN0YXJ0WSwgY3VycmVudExpbmVFbmRYLCBjdXJyZW50TGluZUVuZFksIG5leHRMaW5lU3RhcnRYLCBuZXh0TGluZVN0YXJ0WSwgbmV4dExpbmVFbmRYLCBuZXh0TGluZUVuZFksIHRydWUpO1xuICAgIHZlcnRpY2VzW2kgKiAyXSA9IGludGVyc2VjdGlvblswXTtcbiAgICB2ZXJ0aWNlc1tpICogMiArIDFdID0gaW50ZXJzZWN0aW9uWzFdO1xuICB9XG5cbiAgcmV0dXJuIHZlcnRpY2VzO1xufTtcbnZhciBleHBhbmRQb2x5Z29uID0gZnVuY3Rpb24gZXhwYW5kUG9seWdvbihwb2ludHMsIHBhZCkge1xuICB2YXIgZXhwYW5kZWRMaW5lU2V0ID0gbmV3IEFycmF5KHBvaW50cy5sZW5ndGggKiAyKTtcbiAgdmFyIGN1cnJlbnRQb2ludFgsIGN1cnJlbnRQb2ludFksIG5leHRQb2ludFgsIG5leHRQb2ludFk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgY3VycmVudFBvaW50WCA9IHBvaW50c1tpICogMl07XG4gICAgY3VycmVudFBvaW50WSA9IHBvaW50c1tpICogMiArIDFdO1xuXG4gICAgaWYgKGkgPCBwb2ludHMubGVuZ3RoIC8gMiAtIDEpIHtcbiAgICAgIG5leHRQb2ludFggPSBwb2ludHNbKGkgKyAxKSAqIDJdO1xuICAgICAgbmV4dFBvaW50WSA9IHBvaW50c1soaSArIDEpICogMiArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0UG9pbnRYID0gcG9pbnRzWzBdO1xuICAgICAgbmV4dFBvaW50WSA9IHBvaW50c1sxXTtcbiAgICB9IC8vIEN1cnJlbnQgbGluZTogW2N1cnJlbnRQb2ludFgsIGN1cnJlbnRQb2ludFldIHRvIFtuZXh0UG9pbnRYLCBuZXh0UG9pbnRZXVxuICAgIC8vIEFzc3VtZSBDQ1cgcG9seWdvbiB3aW5kaW5nXG5cblxuICAgIHZhciBvZmZzZXRYID0gbmV4dFBvaW50WSAtIGN1cnJlbnRQb2ludFk7XG4gICAgdmFyIG9mZnNldFkgPSAtKG5leHRQb2ludFggLSBjdXJyZW50UG9pbnRYKTsgLy8gTm9ybWFsaXplXG5cbiAgICB2YXIgb2Zmc2V0TGVuZ3RoID0gTWF0aC5zcXJ0KG9mZnNldFggKiBvZmZzZXRYICsgb2Zmc2V0WSAqIG9mZnNldFkpO1xuICAgIHZhciBub3JtYWxpemVkT2Zmc2V0WCA9IG9mZnNldFggLyBvZmZzZXRMZW5ndGg7XG4gICAgdmFyIG5vcm1hbGl6ZWRPZmZzZXRZID0gb2Zmc2V0WSAvIG9mZnNldExlbmd0aDtcbiAgICBleHBhbmRlZExpbmVTZXRbaSAqIDRdID0gY3VycmVudFBvaW50WCArIG5vcm1hbGl6ZWRPZmZzZXRYICogcGFkO1xuICAgIGV4cGFuZGVkTGluZVNldFtpICogNCArIDFdID0gY3VycmVudFBvaW50WSArIG5vcm1hbGl6ZWRPZmZzZXRZICogcGFkO1xuICAgIGV4cGFuZGVkTGluZVNldFtpICogNCArIDJdID0gbmV4dFBvaW50WCArIG5vcm1hbGl6ZWRPZmZzZXRYICogcGFkO1xuICAgIGV4cGFuZGVkTGluZVNldFtpICogNCArIDNdID0gbmV4dFBvaW50WSArIG5vcm1hbGl6ZWRPZmZzZXRZICogcGFkO1xuICB9XG5cbiAgcmV0dXJuIGV4cGFuZGVkTGluZVNldDtcbn07XG52YXIgaW50ZXJzZWN0TGluZUVsbGlwc2UgPSBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lRWxsaXBzZSh4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCBlbGxpcHNlV3JhZGl1cywgZWxsaXBzZUhyYWRpdXMpIHtcbiAgdmFyIGRpc3BYID0gY2VudGVyWCAtIHg7XG4gIHZhciBkaXNwWSA9IGNlbnRlclkgLSB5O1xuICBkaXNwWCAvPSBlbGxpcHNlV3JhZGl1cztcbiAgZGlzcFkgLz0gZWxsaXBzZUhyYWRpdXM7XG4gIHZhciBsZW4gPSBNYXRoLnNxcnQoZGlzcFggKiBkaXNwWCArIGRpc3BZICogZGlzcFkpO1xuICB2YXIgbmV3TGVuZ3RoID0gbGVuIC0gMTtcblxuICBpZiAobmV3TGVuZ3RoIDwgMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBsZW5Qcm9wb3J0aW9uID0gbmV3TGVuZ3RoIC8gbGVuO1xuICByZXR1cm4gWyhjZW50ZXJYIC0geCkgKiBsZW5Qcm9wb3J0aW9uICsgeCwgKGNlbnRlclkgLSB5KSAqIGxlblByb3BvcnRpb24gKyB5XTtcbn07XG52YXIgY2hlY2tJbkVsbGlwc2UgPSBmdW5jdGlvbiBjaGVja0luRWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBwYWRkaW5nKSB7XG4gIHggLT0gY2VudGVyWDtcbiAgeSAtPSBjZW50ZXJZO1xuICB4IC89IHdpZHRoIC8gMiArIHBhZGRpbmc7XG4gIHkgLz0gaGVpZ2h0IC8gMiArIHBhZGRpbmc7XG4gIHJldHVybiB4ICogeCArIHkgKiB5IDw9IDE7XG59OyAvLyBSZXR1cm5zIGludGVyc2VjdGlvbnMgb2YgaW5jcmVhc2luZyBkaXN0YW5jZSBmcm9tIGxpbmUncyBzdGFydCBwb2ludFxuXG52YXIgaW50ZXJzZWN0TGluZUNpcmNsZSA9IGZ1bmN0aW9uIGludGVyc2VjdExpbmVDaXJjbGUoeDEsIHkxLCB4MiwgeTIsIGNlbnRlclgsIGNlbnRlclksIHJhZGl1cykge1xuICAvLyBDYWxjdWxhdGUgZCwgZGlyZWN0aW9uIHZlY3RvciBvZiBsaW5lXG4gIHZhciBkID0gW3gyIC0geDEsIHkyIC0geTFdOyAvLyBEaXJlY3Rpb24gdmVjdG9yIG9mIGxpbmVcblxuICB2YXIgZiA9IFt4MSAtIGNlbnRlclgsIHkxIC0gY2VudGVyWV07XG4gIHZhciBhID0gZFswXSAqIGRbMF0gKyBkWzFdICogZFsxXTtcbiAgdmFyIGIgPSAyICogKGZbMF0gKiBkWzBdICsgZlsxXSAqIGRbMV0pO1xuICB2YXIgYyA9IGZbMF0gKiBmWzBdICsgZlsxXSAqIGZbMV0gLSByYWRpdXMgKiByYWRpdXM7XG4gIHZhciBkaXNjcmltaW5hbnQgPSBiICogYiAtIDQgKiBhICogYztcblxuICBpZiAoZGlzY3JpbWluYW50IDwgMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciB0MSA9ICgtYiArIE1hdGguc3FydChkaXNjcmltaW5hbnQpKSAvICgyICogYSk7XG4gIHZhciB0MiA9ICgtYiAtIE1hdGguc3FydChkaXNjcmltaW5hbnQpKSAvICgyICogYSk7XG4gIHZhciB0TWluID0gTWF0aC5taW4odDEsIHQyKTtcbiAgdmFyIHRNYXggPSBNYXRoLm1heCh0MSwgdDIpO1xuICB2YXIgaW5SYW5nZVBhcmFtcyA9IFtdO1xuXG4gIGlmICh0TWluID49IDAgJiYgdE1pbiA8PSAxKSB7XG4gICAgaW5SYW5nZVBhcmFtcy5wdXNoKHRNaW4pO1xuICB9XG5cbiAgaWYgKHRNYXggPj0gMCAmJiB0TWF4IDw9IDEpIHtcbiAgICBpblJhbmdlUGFyYW1zLnB1c2godE1heCk7XG4gIH1cblxuICBpZiAoaW5SYW5nZVBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgbmVhckludGVyc2VjdGlvblggPSBpblJhbmdlUGFyYW1zWzBdICogZFswXSArIHgxO1xuICB2YXIgbmVhckludGVyc2VjdGlvblkgPSBpblJhbmdlUGFyYW1zWzBdICogZFsxXSArIHkxO1xuXG4gIGlmIChpblJhbmdlUGFyYW1zLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoaW5SYW5nZVBhcmFtc1swXSA9PSBpblJhbmdlUGFyYW1zWzFdKSB7XG4gICAgICByZXR1cm4gW25lYXJJbnRlcnNlY3Rpb25YLCBuZWFySW50ZXJzZWN0aW9uWV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmYXJJbnRlcnNlY3Rpb25YID0gaW5SYW5nZVBhcmFtc1sxXSAqIGRbMF0gKyB4MTtcbiAgICAgIHZhciBmYXJJbnRlcnNlY3Rpb25ZID0gaW5SYW5nZVBhcmFtc1sxXSAqIGRbMV0gKyB5MTtcbiAgICAgIHJldHVybiBbbmVhckludGVyc2VjdGlvblgsIG5lYXJJbnRlcnNlY3Rpb25ZLCBmYXJJbnRlcnNlY3Rpb25YLCBmYXJJbnRlcnNlY3Rpb25ZXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtuZWFySW50ZXJzZWN0aW9uWCwgbmVhckludGVyc2VjdGlvblldO1xuICB9XG59O1xudmFyIG1pZE9mVGhyZWUgPSBmdW5jdGlvbiBtaWRPZlRocmVlKGEsIGIsIGMpIHtcbiAgaWYgKGIgPD0gYSAmJiBhIDw9IGMgfHwgYyA8PSBhICYmIGEgPD0gYikge1xuICAgIHJldHVybiBhO1xuICB9IGVsc2UgaWYgKGEgPD0gYiAmJiBiIDw9IGMgfHwgYyA8PSBiICYmIGIgPD0gYSkge1xuICAgIHJldHVybiBiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjO1xuICB9XG59OyAvLyAoeDEseTEpPT4oeDIseTIpIGludGVyc2VjdCB3aXRoICh4Myx5Myk9Pih4NCx5NClcblxudmFyIGZpbml0ZUxpbmVzSW50ZXJzZWN0ID0gZnVuY3Rpb24gZmluaXRlTGluZXNJbnRlcnNlY3QoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCBpbmZpbml0ZUxpbmVzKSB7XG4gIHZhciBkeDEzID0geDEgLSB4MztcbiAgdmFyIGR4MjEgPSB4MiAtIHgxO1xuICB2YXIgZHg0MyA9IHg0IC0geDM7XG4gIHZhciBkeTEzID0geTEgLSB5MztcbiAgdmFyIGR5MjEgPSB5MiAtIHkxO1xuICB2YXIgZHk0MyA9IHk0IC0geTM7XG4gIHZhciB1YV90ID0gZHg0MyAqIGR5MTMgLSBkeTQzICogZHgxMztcbiAgdmFyIHViX3QgPSBkeDIxICogZHkxMyAtIGR5MjEgKiBkeDEzO1xuICB2YXIgdV9iID0gZHk0MyAqIGR4MjEgLSBkeDQzICogZHkyMTtcblxuICBpZiAodV9iICE9PSAwKSB7XG4gICAgdmFyIHVhID0gdWFfdCAvIHVfYjtcbiAgICB2YXIgdWIgPSB1Yl90IC8gdV9iO1xuICAgIHZhciBmbHB0VGhyZXNob2xkID0gMC4wMDE7XG5cbiAgICB2YXIgX21pbiA9IDAgLSBmbHB0VGhyZXNob2xkO1xuXG4gICAgdmFyIF9tYXggPSAxICsgZmxwdFRocmVzaG9sZDtcblxuICAgIGlmIChfbWluIDw9IHVhICYmIHVhIDw9IF9tYXggJiYgX21pbiA8PSB1YiAmJiB1YiA8PSBfbWF4KSB7XG4gICAgICByZXR1cm4gW3gxICsgdWEgKiBkeDIxLCB5MSArIHVhICogZHkyMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghaW5maW5pdGVMaW5lcykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW3gxICsgdWEgKiBkeDIxLCB5MSArIHVhICogZHkyMV07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh1YV90ID09PSAwIHx8IHViX3QgPT09IDApIHtcbiAgICAgIC8vIFBhcmFsbGVsLCBjb2luY2lkZW50IGxpbmVzLiBDaGVjayBpZiBvdmVybGFwXG4gICAgICAvLyBDaGVjayBlbmRwb2ludCBvZiBzZWNvbmQgbGluZVxuICAgICAgaWYgKG1pZE9mVGhyZWUoeDEsIHgyLCB4NCkgPT09IHg0KSB7XG4gICAgICAgIHJldHVybiBbeDQsIHk0XTtcbiAgICAgIH0gLy8gQ2hlY2sgc3RhcnQgcG9pbnQgb2Ygc2Vjb25kIGxpbmVcblxuXG4gICAgICBpZiAobWlkT2ZUaHJlZSh4MSwgeDIsIHgzKSA9PT0geDMpIHtcbiAgICAgICAgcmV0dXJuIFt4MywgeTNdO1xuICAgICAgfSAvLyBFbmRwb2ludCBvZiBmaXJzdCBsaW5lXG5cblxuICAgICAgaWYgKG1pZE9mVGhyZWUoeDMsIHg0LCB4MikgPT09IHgyKSB7XG4gICAgICAgIHJldHVybiBbeDIsIHkyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQYXJhbGxlbCwgbm9uLWNvaW5jaWRlbnRcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbn07IC8vIG1hdGgucG9seWdvbkludGVyc2VjdExpbmUoIHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcgKVxuLy8gaW50ZXJzZWN0IGEgbm9kZSBwb2x5Z29uIChwdHMgdHJhbnNmb3JtZWQpXG4vL1xuLy8gbWF0aC5wb2x5Z29uSW50ZXJzZWN0TGluZSggeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSApXG4vLyBpbnRlcnNlY3QgdGhlIHBvaW50cyAobm8gdHJhbnNmb3JtKVxuXG52YXIgcG9seWdvbkludGVyc2VjdExpbmUgPSBmdW5jdGlvbiBwb2x5Z29uSW50ZXJzZWN0TGluZSh4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKSB7XG4gIHZhciBpbnRlcnNlY3Rpb25zID0gW107XG4gIHZhciBpbnRlcnNlY3Rpb247XG4gIHZhciB0cmFuc2Zvcm1lZFBvaW50cyA9IG5ldyBBcnJheShiYXNlUG9pbnRzLmxlbmd0aCk7XG4gIHZhciBkb1RyYW5zZm9ybSA9IHRydWU7XG5cbiAgaWYgKHdpZHRoID09IG51bGwpIHtcbiAgICBkb1RyYW5zZm9ybSA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIHBvaW50cztcblxuICBpZiAoZG9UcmFuc2Zvcm0pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybWVkUG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdID0gYmFzZVBvaW50c1tpICogMl0gKiB3aWR0aCArIGNlbnRlclg7XG4gICAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdID0gYmFzZVBvaW50c1tpICogMiArIDFdICogaGVpZ2h0ICsgY2VudGVyWTtcbiAgICB9XG5cbiAgICBpZiAocGFkZGluZyA+IDApIHtcbiAgICAgIHZhciBleHBhbmRlZExpbmVTZXQgPSBleHBhbmRQb2x5Z29uKHRyYW5zZm9ybWVkUG9pbnRzLCAtcGFkZGluZyk7XG4gICAgICBwb2ludHMgPSBqb2luTGluZXMoZXhwYW5kZWRMaW5lU2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRzID0gdHJhbnNmb3JtZWRQb2ludHM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBvaW50cyA9IGJhc2VQb2ludHM7XG4gIH1cblxuICB2YXIgY3VycmVudFgsIGN1cnJlbnRZLCBuZXh0WCwgbmV4dFk7XG5cbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcG9pbnRzLmxlbmd0aCAvIDI7IF9pMisrKSB7XG4gICAgY3VycmVudFggPSBwb2ludHNbX2kyICogMl07XG4gICAgY3VycmVudFkgPSBwb2ludHNbX2kyICogMiArIDFdO1xuXG4gICAgaWYgKF9pMiA8IHBvaW50cy5sZW5ndGggLyAyIC0gMSkge1xuICAgICAgbmV4dFggPSBwb2ludHNbKF9pMiArIDEpICogMl07XG4gICAgICBuZXh0WSA9IHBvaW50c1soX2kyICsgMSkgKiAyICsgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRYID0gcG9pbnRzWzBdO1xuICAgICAgbmV4dFkgPSBwb2ludHNbMV07XG4gICAgfVxuXG4gICAgaW50ZXJzZWN0aW9uID0gZmluaXRlTGluZXNJbnRlcnNlY3QoeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgY3VycmVudFgsIGN1cnJlbnRZLCBuZXh0WCwgbmV4dFkpO1xuXG4gICAgaWYgKGludGVyc2VjdGlvbi5sZW5ndGggIT09IDApIHtcbiAgICAgIGludGVyc2VjdGlvbnMucHVzaChpbnRlcnNlY3Rpb25bMF0sIGludGVyc2VjdGlvblsxXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG59O1xudmFyIHJvdW5kUG9seWdvbkludGVyc2VjdExpbmUgPSBmdW5jdGlvbiByb3VuZFBvbHlnb25JbnRlcnNlY3RMaW5lKHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpIHtcbiAgdmFyIGludGVyc2VjdGlvbnMgPSBbXTtcbiAgdmFyIGludGVyc2VjdGlvbjtcbiAgdmFyIGxpbmVzID0gbmV3IEFycmF5KGJhc2VQb2ludHMubGVuZ3RoKTtcbiAgdmFyIGhhbGZXID0gd2lkdGggLyAyO1xuICB2YXIgaGFsZkggPSBoZWlnaHQgLyAyO1xuICB2YXIgY29ybmVyUmFkaXVzID0gZ2V0Um91bmRQb2x5Z29uUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmFzZVBvaW50cy5sZW5ndGggLyA0OyBpKyspIHtcbiAgICB2YXIgc291cmNlVXYgPSB2b2lkIDAsXG4gICAgICAgIGRlc3RVdiA9IHZvaWQgMDtcblxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBzb3VyY2VVdiA9IGJhc2VQb2ludHMubGVuZ3RoIC0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlVXYgPSBpICogNCAtIDI7XG4gICAgfVxuXG4gICAgZGVzdFV2ID0gaSAqIDQgKyAyO1xuICAgIHZhciBweCA9IGNlbnRlclggKyBoYWxmVyAqIGJhc2VQb2ludHNbaSAqIDRdO1xuICAgIHZhciBweSA9IGNlbnRlclkgKyBoYWxmSCAqIGJhc2VQb2ludHNbaSAqIDQgKyAxXTtcbiAgICB2YXIgY29zVGhldGEgPSAtYmFzZVBvaW50c1tzb3VyY2VVdl0gKiBiYXNlUG9pbnRzW2Rlc3RVdl0gLSBiYXNlUG9pbnRzW3NvdXJjZVV2ICsgMV0gKiBiYXNlUG9pbnRzW2Rlc3RVdiArIDFdO1xuICAgIHZhciBvZmZzZXQgPSBjb3JuZXJSYWRpdXMgLyBNYXRoLnRhbihNYXRoLmFjb3MoY29zVGhldGEpIC8gMik7XG4gICAgdmFyIGNwMHggPSBweCAtIG9mZnNldCAqIGJhc2VQb2ludHNbc291cmNlVXZdO1xuICAgIHZhciBjcDB5ID0gcHkgLSBvZmZzZXQgKiBiYXNlUG9pbnRzW3NvdXJjZVV2ICsgMV07XG4gICAgdmFyIGNwMXggPSBweCArIG9mZnNldCAqIGJhc2VQb2ludHNbZGVzdFV2XTtcbiAgICB2YXIgY3AxeSA9IHB5ICsgb2Zmc2V0ICogYmFzZVBvaW50c1tkZXN0VXYgKyAxXTtcblxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBsaW5lc1tiYXNlUG9pbnRzLmxlbmd0aCAtIDJdID0gY3AweDtcbiAgICAgIGxpbmVzW2Jhc2VQb2ludHMubGVuZ3RoIC0gMV0gPSBjcDB5O1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lc1tpICogNCAtIDJdID0gY3AweDtcbiAgICAgIGxpbmVzW2kgKiA0IC0gMV0gPSBjcDB5O1xuICAgIH1cblxuICAgIGxpbmVzW2kgKiA0XSA9IGNwMXg7XG4gICAgbGluZXNbaSAqIDQgKyAxXSA9IGNwMXk7XG4gICAgdmFyIG9ydGh4ID0gYmFzZVBvaW50c1tzb3VyY2VVdiArIDFdO1xuICAgIHZhciBvcnRoeSA9IC1iYXNlUG9pbnRzW3NvdXJjZVV2XTtcbiAgICB2YXIgY29zQWxwaGEgPSBvcnRoeCAqIGJhc2VQb2ludHNbZGVzdFV2XSArIG9ydGh5ICogYmFzZVBvaW50c1tkZXN0VXYgKyAxXTtcblxuICAgIGlmIChjb3NBbHBoYSA8IDApIHtcbiAgICAgIG9ydGh4ICo9IC0xO1xuICAgICAgb3J0aHkgKj0gLTE7XG4gICAgfVxuXG4gICAgdmFyIGN4ID0gY3AweCArIG9ydGh4ICogY29ybmVyUmFkaXVzO1xuICAgIHZhciBjeSA9IGNwMHkgKyBvcnRoeSAqIGNvcm5lclJhZGl1cztcbiAgICBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RMaW5lQ2lyY2xlKHgsIHksIGNlbnRlclgsIGNlbnRlclksIGN4LCBjeSwgY29ybmVyUmFkaXVzKTtcblxuICAgIGlmIChpbnRlcnNlY3Rpb24ubGVuZ3RoICE9PSAwKSB7XG4gICAgICBpbnRlcnNlY3Rpb25zLnB1c2goaW50ZXJzZWN0aW9uWzBdLCBpbnRlcnNlY3Rpb25bMV0pO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGxpbmVzLmxlbmd0aCAvIDQ7IF9pMysrKSB7XG4gICAgaW50ZXJzZWN0aW9uID0gZmluaXRlTGluZXNJbnRlcnNlY3QoeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgbGluZXNbX2kzICogNF0sIGxpbmVzW19pMyAqIDQgKyAxXSwgbGluZXNbX2kzICogNCArIDJdLCBsaW5lc1tfaTMgKiA0ICsgM10sIGZhbHNlKTtcblxuICAgIGlmIChpbnRlcnNlY3Rpb24ubGVuZ3RoICE9PSAwKSB7XG4gICAgICBpbnRlcnNlY3Rpb25zLnB1c2goaW50ZXJzZWN0aW9uWzBdLCBpbnRlcnNlY3Rpb25bMV0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDIpIHtcbiAgICB2YXIgbG93ZXN0SW50ZXJzZWN0aW9uID0gW2ludGVyc2VjdGlvbnNbMF0sIGludGVyc2VjdGlvbnNbMV1dO1xuICAgIHZhciBsb3dlc3RTcXVhcmVkRGlzdGFuY2UgPSBNYXRoLnBvdyhsb3dlc3RJbnRlcnNlY3Rpb25bMF0gLSB4LCAyKSArIE1hdGgucG93KGxvd2VzdEludGVyc2VjdGlvblsxXSAtIHksIDIpO1xuXG4gICAgZm9yICh2YXIgX2k0ID0gMTsgX2k0IDwgaW50ZXJzZWN0aW9ucy5sZW5ndGggLyAyOyBfaTQrKykge1xuICAgICAgdmFyIHNxdWFyZWREaXN0YW5jZSA9IE1hdGgucG93KGludGVyc2VjdGlvbnNbX2k0ICogMl0gLSB4LCAyKSArIE1hdGgucG93KGludGVyc2VjdGlvbnNbX2k0ICogMiArIDFdIC0geSwgMik7XG5cbiAgICAgIGlmIChzcXVhcmVkRGlzdGFuY2UgPD0gbG93ZXN0U3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICAgIGxvd2VzdEludGVyc2VjdGlvblswXSA9IGludGVyc2VjdGlvbnNbX2k0ICogMl07XG4gICAgICAgIGxvd2VzdEludGVyc2VjdGlvblsxXSA9IGludGVyc2VjdGlvbnNbX2k0ICogMiArIDFdO1xuICAgICAgICBsb3dlc3RTcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRGlzdGFuY2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxvd2VzdEludGVyc2VjdGlvbjtcbiAgfVxuXG4gIHJldHVybiBpbnRlcnNlY3Rpb25zO1xufTtcbnZhciBzaG9ydGVuSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3Rpb24sIG9mZnNldCwgYW1vdW50KSB7XG4gIHZhciBkaXNwID0gW2ludGVyc2VjdGlvblswXSAtIG9mZnNldFswXSwgaW50ZXJzZWN0aW9uWzFdIC0gb2Zmc2V0WzFdXTtcbiAgdmFyIGxlbmd0aCA9IE1hdGguc3FydChkaXNwWzBdICogZGlzcFswXSArIGRpc3BbMV0gKiBkaXNwWzFdKTtcbiAgdmFyIGxlblJhdGlvID0gKGxlbmd0aCAtIGFtb3VudCkgLyBsZW5ndGg7XG5cbiAgaWYgKGxlblJhdGlvIDwgMCkge1xuICAgIGxlblJhdGlvID0gMC4wMDAwMTtcbiAgfVxuXG4gIHJldHVybiBbb2Zmc2V0WzBdICsgbGVuUmF0aW8gKiBkaXNwWzBdLCBvZmZzZXRbMV0gKyBsZW5SYXRpbyAqIGRpc3BbMV1dO1xufTtcbnZhciBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUgPSBmdW5jdGlvbiBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoc2lkZXMsIHJvdGF0aW9uUmFkaWFucykge1xuICB2YXIgcG9pbnRzID0gZ2VuZXJhdGVVbml0TmdvblBvaW50cyhzaWRlcywgcm90YXRpb25SYWRpYW5zKTtcbiAgcG9pbnRzID0gZml0UG9seWdvblRvU3F1YXJlKHBvaW50cyk7XG4gIHJldHVybiBwb2ludHM7XG59O1xudmFyIGZpdFBvbHlnb25Ub1NxdWFyZSA9IGZ1bmN0aW9uIGZpdFBvbHlnb25Ub1NxdWFyZShwb2ludHMpIHtcbiAgdmFyIHgsIHk7XG4gIHZhciBzaWRlcyA9IHBvaW50cy5sZW5ndGggLyAyO1xuICB2YXIgbWluWCA9IEluZmluaXR5LFxuICAgICAgbWluWSA9IEluZmluaXR5LFxuICAgICAgbWF4WCA9IC1JbmZpbml0eSxcbiAgICAgIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrKSB7XG4gICAgeCA9IHBvaW50c1syICogaV07XG4gICAgeSA9IHBvaW50c1syICogaSArIDFdO1xuICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4KTtcbiAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeCk7XG4gICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpO1xuICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5KTtcbiAgfSAvLyBzdHJldGNoIGZhY3RvcnNcblxuXG4gIHZhciBzeCA9IDIgLyAobWF4WCAtIG1pblgpO1xuICB2YXIgc3kgPSAyIC8gKG1heFkgLSBtaW5ZKTtcblxuICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBzaWRlczsgX2k1KyspIHtcbiAgICB4ID0gcG9pbnRzWzIgKiBfaTVdID0gcG9pbnRzWzIgKiBfaTVdICogc3g7XG4gICAgeSA9IHBvaW50c1syICogX2k1ICsgMV0gPSBwb2ludHNbMiAqIF9pNSArIDFdICogc3k7XG4gICAgbWluWCA9IE1hdGgubWluKG1pblgsIHgpO1xuICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB4KTtcbiAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgeSk7XG4gICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHkpO1xuICB9XG5cbiAgaWYgKG1pblkgPCAtMSkge1xuICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IHNpZGVzOyBfaTYrKykge1xuICAgICAgeSA9IHBvaW50c1syICogX2k2ICsgMV0gPSBwb2ludHNbMiAqIF9pNiArIDFdICsgKC0xIC0gbWluWSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn07XG52YXIgZ2VuZXJhdGVVbml0TmdvblBvaW50cyA9IGZ1bmN0aW9uIGdlbmVyYXRlVW5pdE5nb25Qb2ludHMoc2lkZXMsIHJvdGF0aW9uUmFkaWFucykge1xuICB2YXIgaW5jcmVtZW50ID0gMS4wIC8gc2lkZXMgKiAyICogTWF0aC5QSTtcbiAgdmFyIHN0YXJ0QW5nbGUgPSBzaWRlcyAlIDIgPT09IDAgPyBNYXRoLlBJIC8gMi4wICsgaW5jcmVtZW50IC8gMi4wIDogTWF0aC5QSSAvIDIuMDtcbiAgc3RhcnRBbmdsZSArPSByb3RhdGlvblJhZGlhbnM7XG4gIHZhciBwb2ludHMgPSBuZXcgQXJyYXkoc2lkZXMgKiAyKTtcbiAgdmFyIGN1cnJlbnRBbmdsZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKyspIHtcbiAgICBjdXJyZW50QW5nbGUgPSBpICogaW5jcmVtZW50ICsgc3RhcnRBbmdsZTtcbiAgICBwb2ludHNbMiAqIGldID0gTWF0aC5jb3MoY3VycmVudEFuZ2xlKTsgLy8geFxuXG4gICAgcG9pbnRzWzIgKiBpICsgMV0gPSBNYXRoLnNpbigtY3VycmVudEFuZ2xlKTsgLy8geVxuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn07IC8vIFNldCB0aGUgZGVmYXVsdCByYWRpdXMsIHVubGVzcyBoYWxmIG9mIHdpZHRoIG9yIGhlaWdodCBpcyBzbWFsbGVyIHRoYW4gZGVmYXVsdFxuXG52YXIgZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMgPSBmdW5jdGlvbiBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KSB7XG4gIHJldHVybiBNYXRoLm1pbih3aWR0aCAvIDQsIGhlaWdodCAvIDQsIDgpO1xufTsgLy8gU2V0IHRoZSBkZWZhdWx0IHJhZGl1c1xuXG52YXIgZ2V0Um91bmRQb2x5Z29uUmFkaXVzID0gZnVuY3Rpb24gZ2V0Um91bmRQb2x5Z29uUmFkaXVzKHdpZHRoLCBoZWlnaHQpIHtcbiAgcmV0dXJuIE1hdGgubWluKHdpZHRoIC8gMTAsIGhlaWdodCAvIDEwLCA4KTtcbn07XG52YXIgZ2V0Q3V0UmVjdGFuZ2xlQ29ybmVyTGVuZ3RoID0gZnVuY3Rpb24gZ2V0Q3V0UmVjdGFuZ2xlQ29ybmVyTGVuZ3RoKCkge1xuICByZXR1cm4gODtcbn07XG52YXIgYmV6aWVyUHRzVG9RdWFkQ29lZmYgPSBmdW5jdGlvbiBiZXppZXJQdHNUb1F1YWRDb2VmZihwMCwgcDEsIHAyKSB7XG4gIHJldHVybiBbcDAgLSAyICogcDEgKyBwMiwgMiAqIChwMSAtIHAwKSwgcDBdO1xufTsgLy8gZ2V0IGN1cnZlIHdpZHRoLCBoZWlnaHQsIGFuZCBjb250cm9sIHBvaW50IHBvc2l0aW9uIG9mZnNldHMgYXMgYSBwZXJjZW50YWdlIG9mIG5vZGUgaGVpZ2h0IC8gd2lkdGhcblxudmFyIGdldEJhcnJlbEN1cnZlQ29uc3RhbnRzID0gZnVuY3Rpb24gZ2V0QmFycmVsQ3VydmVDb25zdGFudHMod2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4ge1xuICAgIGhlaWdodE9mZnNldDogTWF0aC5taW4oMTUsIDAuMDUgKiBoZWlnaHQpLFxuICAgIHdpZHRoT2Zmc2V0OiBNYXRoLm1pbigxMDAsIDAuMjUgKiB3aWR0aCksXG4gICAgY3RybFB0T2Zmc2V0UGN0OiAwLjA1XG4gIH07XG59O1xuXG52YXIgcGFnZVJhbmtEZWZhdWx0cyA9IGRlZmF1bHRzJGcoe1xuICBkYW1waW5nRmFjdG9yOiAwLjgsXG4gIHByZWNpc2lvbjogMC4wMDAwMDEsXG4gIGl0ZXJhdGlvbnM6IDIwMCxcbiAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoZWRnZSkge1xuICAgIHJldHVybiAxO1xuICB9XG59KTtcbnZhciBlbGVzZm4kbyA9IHtcbiAgcGFnZVJhbms6IGZ1bmN0aW9uIHBhZ2VSYW5rKG9wdGlvbnMpIHtcbiAgICB2YXIgX3BhZ2VSYW5rRGVmYXVsdHMgPSBwYWdlUmFua0RlZmF1bHRzKG9wdGlvbnMpLFxuICAgICAgICBkYW1waW5nRmFjdG9yID0gX3BhZ2VSYW5rRGVmYXVsdHMuZGFtcGluZ0ZhY3RvcixcbiAgICAgICAgcHJlY2lzaW9uID0gX3BhZ2VSYW5rRGVmYXVsdHMucHJlY2lzaW9uLFxuICAgICAgICBpdGVyYXRpb25zID0gX3BhZ2VSYW5rRGVmYXVsdHMuaXRlcmF0aW9ucyxcbiAgICAgICAgd2VpZ2h0ID0gX3BhZ2VSYW5rRGVmYXVsdHMud2VpZ2h0O1xuXG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgIHZhciBfdGhpcyRieUdyb3VwID0gdGhpcy5ieUdyb3VwKCksXG4gICAgICAgIG5vZGVzID0gX3RoaXMkYnlHcm91cC5ub2RlcyxcbiAgICAgICAgZWRnZXMgPSBfdGhpcyRieUdyb3VwLmVkZ2VzO1xuXG4gICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgIHZhciBudW1Ob2Rlc1NxZCA9IG51bU5vZGVzICogbnVtTm9kZXM7XG4gICAgdmFyIG51bUVkZ2VzID0gZWRnZXMubGVuZ3RoOyAvLyBDb25zdHJ1Y3QgdHJhbnNwb3NlZCBhZGphY2VuY3kgbWF0cml4XG4gICAgLy8gRmlyc3QgbGV0cyBoYXZlIGEgemVyb2VkIG1hdHJpeCBvZiB0aGUgcmlnaHQgc2l6ZVxuICAgIC8vIFdlJ2xsIGFsc28ga2VlcCB0cmFjayBvZiB0aGUgc3VtIG9mIGVhY2ggY29sdW1uXG5cbiAgICB2YXIgbWF0cml4ID0gbmV3IEFycmF5KG51bU5vZGVzU3FkKTtcbiAgICB2YXIgY29sdW1uU3VtID0gbmV3IEFycmF5KG51bU5vZGVzKTtcbiAgICB2YXIgYWRkaXRpb25hbFByb2IgPSAoMSAtIGRhbXBpbmdGYWN0b3IpIC8gbnVtTm9kZXM7IC8vIENyZWF0ZSBudWxsIG1hdHJpeFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgICAgdmFyIG4gPSBpICogbnVtTm9kZXMgKyBqO1xuICAgICAgICBtYXRyaXhbbl0gPSAwO1xuICAgICAgfVxuXG4gICAgICBjb2x1bW5TdW1baV0gPSAwO1xuICAgIH0gLy8gTm93LCBwcm9jZXNzIGVkZ2VzXG5cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBudW1FZGdlczsgX2krKykge1xuICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tfaV07XG4gICAgICB2YXIgc3JjSWQgPSBlZGdlLmRhdGEoJ3NvdXJjZScpO1xuICAgICAgdmFyIHRndElkID0gZWRnZS5kYXRhKCd0YXJnZXQnKTsgLy8gRG9uJ3QgaW5jbHVkZSBsb29wcyBpbiB0aGUgbWF0cml4XG5cbiAgICAgIGlmIChzcmNJZCA9PT0gdGd0SWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBzID0gbm9kZXMuaW5kZXhPZklkKHNyY0lkKTtcbiAgICAgIHZhciB0ID0gbm9kZXMuaW5kZXhPZklkKHRndElkKTtcbiAgICAgIHZhciB3ID0gd2VpZ2h0KGVkZ2UpO1xuXG4gICAgICB2YXIgX24gPSB0ICogbnVtTm9kZXMgKyBzOyAvLyBVcGRhdGUgbWF0cml4XG5cblxuICAgICAgbWF0cml4W19uXSArPSB3OyAvLyBVcGRhdGUgY29sdW1uIHN1bVxuXG4gICAgICBjb2x1bW5TdW1bc10gKz0gdztcbiAgICB9IC8vIEFkZCBhZGRpdGlvbmFsIHByb2JhYmlsaXR5IGJhc2VkIG9uIGRhbXBpbmcgZmFjdG9yXG4gICAgLy8gQWxzbywgdGFrZSBpbnRvIGFjY291bnQgY29sdW1ucyB0aGF0IGhhdmUgc3VtID0gMFxuXG5cbiAgICB2YXIgcCA9IDEuMCAvIG51bU5vZGVzICsgYWRkaXRpb25hbFByb2I7IC8vIFNob3J0aGFuZFxuICAgIC8vIFRyYXZlcnNlIG1hdHJpeCwgY29sdW1uIGJ5IGNvbHVtblxuXG4gICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IG51bU5vZGVzOyBfaisrKSB7XG4gICAgICBpZiAoY29sdW1uU3VtW19qXSA9PT0gMCkge1xuICAgICAgICAvLyBObyAnbGlua3MnIG91dCBmcm9tIG5vZGUganRoLCBhc3N1bWUgZXF1YWwgcHJvYmFiaWxpdHkgZm9yIGVhY2ggcG9zc2libGUgbm9kZVxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBudW1Ob2RlczsgX2kyKyspIHtcbiAgICAgICAgICB2YXIgX24yID0gX2kyICogbnVtTm9kZXMgKyBfajtcblxuICAgICAgICAgIG1hdHJpeFtfbjJdID0gcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm9kZSBqdGggaGFzIG91dGdvaW5nIGxpbmssIGNvbXB1dGUgbm9ybWFsaXplZCBwcm9iYWJpbGl0aWVzXG4gICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG51bU5vZGVzOyBfaTMrKykge1xuICAgICAgICAgIHZhciBfbjMgPSBfaTMgKiBudW1Ob2RlcyArIF9qO1xuXG4gICAgICAgICAgbWF0cml4W19uM10gPSBtYXRyaXhbX24zXSAvIGNvbHVtblN1bVtfal0gKyBhZGRpdGlvbmFsUHJvYjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gQ29tcHV0ZSBkb21pbmFudCBlaWdlbnZlY3RvciB1c2luZyBwb3dlciBtZXRob2RcblxuXG4gICAgdmFyIGVpZ2VudmVjdG9yID0gbmV3IEFycmF5KG51bU5vZGVzKTtcbiAgICB2YXIgdGVtcCA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG4gICAgdmFyIHByZXZpb3VzOyAvLyBTdGFydCB3aXRoIGEgdmVjdG9yIG9mIGFsbCAxJ3NcbiAgICAvLyBBbHNvLCBpbml0aWFsaXplIGEgbnVsbCB2ZWN0b3Igd2hpY2ggd2lsbCBiZSB1c2VkIGFzIHNob3J0aGFuZFxuXG4gICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbnVtTm9kZXM7IF9pNCsrKSB7XG4gICAgICBlaWdlbnZlY3RvcltfaTRdID0gMTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpdGVyID0gMDsgaXRlciA8IGl0ZXJhdGlvbnM7IGl0ZXIrKykge1xuICAgICAgLy8gVGVtcCBhcnJheSB3aXRoIGFsbCAwJ3NcbiAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IG51bU5vZGVzOyBfaTUrKykge1xuICAgICAgICB0ZW1wW19pNV0gPSAwO1xuICAgICAgfSAvLyBNdWx0aXBseSBtYXRyaXggd2l0aCBwcmV2aW91cyByZXN1bHRcblxuXG4gICAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBudW1Ob2RlczsgX2k2KyspIHtcbiAgICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgbnVtTm9kZXM7IF9qMisrKSB7XG4gICAgICAgICAgdmFyIF9uNCA9IF9pNiAqIG51bU5vZGVzICsgX2oyO1xuXG4gICAgICAgICAgdGVtcFtfaTZdICs9IG1hdHJpeFtfbjRdICogZWlnZW52ZWN0b3JbX2oyXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpblBsYWNlU3VtTm9ybWFsaXplKHRlbXApO1xuICAgICAgcHJldmlvdXMgPSBlaWdlbnZlY3RvcjtcbiAgICAgIGVpZ2VudmVjdG9yID0gdGVtcDtcbiAgICAgIHRlbXAgPSBwcmV2aW91cztcbiAgICAgIHZhciBkaWZmID0gMDsgLy8gQ29tcHV0ZSBkaWZmZXJlbmNlIChzcXVhcmVkIG1vZHVsZSkgb2YgYm90aCB2ZWN0b3JzXG5cbiAgICAgIGZvciAodmFyIF9pNyA9IDA7IF9pNyA8IG51bU5vZGVzOyBfaTcrKykge1xuICAgICAgICB2YXIgZGVsdGEgPSBwcmV2aW91c1tfaTddIC0gZWlnZW52ZWN0b3JbX2k3XTtcbiAgICAgICAgZGlmZiArPSBkZWx0YSAqIGRlbHRhO1xuICAgICAgfSAvLyBJZiBkaWZmZXJlbmNlIGlzIGxlc3MgdGhhbiB0aGUgZGVzaXJlZCB0aHJlc2hvbGQsIHN0b3AgaXRlcmF0aW5nXG5cblxuICAgICAgaWYgKGRpZmYgPCBwcmVjaXNpb24pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSAvLyBDb25zdHJ1Y3QgcmVzdWx0XG5cblxuICAgIHZhciByZXMgPSB7XG4gICAgICByYW5rOiBmdW5jdGlvbiByYW5rKG5vZGUpIHtcbiAgICAgICAgbm9kZSA9IGN5LmNvbGxlY3Rpb24obm9kZSlbMF07XG4gICAgICAgIHJldHVybiBlaWdlbnZlY3Rvcltub2Rlcy5pbmRleE9mKG5vZGUpXTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiByZXM7XG4gIH0gLy8gcGFnZVJhbmtcblxufTsgLy8gZWxlc2ZuXG5cbnZhciBkZWZhdWx0cyRmID0gZGVmYXVsdHMkZyh7XG4gIHJvb3Q6IG51bGwsXG4gIHdlaWdodDogZnVuY3Rpb24gd2VpZ2h0KGVkZ2UpIHtcbiAgICByZXR1cm4gMTtcbiAgfSxcbiAgZGlyZWN0ZWQ6IGZhbHNlLFxuICBhbHBoYTogMFxufSk7XG52YXIgZWxlc2ZuJG4gPSB7XG4gIGRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkOiBmdW5jdGlvbiBkZWdyZWVDZW50cmFsaXR5Tm9ybWFsaXplZChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRzJGYob3B0aW9ucyk7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgICBpZiAoIW9wdGlvbnMuZGlyZWN0ZWQpIHtcbiAgICAgIHZhciBkZWdyZWVzID0ge307XG4gICAgICB2YXIgbWF4RGVncmVlID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07IC8vIGFkZCBjdXJyZW50IG5vZGUgdG8gdGhlIGN1cnJlbnQgb3B0aW9ucyBvYmplY3QgYW5kIGNhbGwgZGVncmVlQ2VudHJhbGl0eVxuXG4gICAgICAgIG9wdGlvbnMucm9vdCA9IG5vZGU7XG4gICAgICAgIHZhciBjdXJyRGVncmVlID0gdGhpcy5kZWdyZWVDZW50cmFsaXR5KG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChtYXhEZWdyZWUgPCBjdXJyRGVncmVlLmRlZ3JlZSkge1xuICAgICAgICAgIG1heERlZ3JlZSA9IGN1cnJEZWdyZWUuZGVncmVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVncmVlc1tub2RlLmlkKCldID0gY3VyckRlZ3JlZS5kZWdyZWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlZ3JlZTogZnVuY3Rpb24gZGVncmVlKG5vZGUpIHtcbiAgICAgICAgICBpZiAobWF4RGVncmVlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICBub2RlID0gY3kuZmlsdGVyKG5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBkZWdyZWVzW25vZGUuaWQoKV0gLyBtYXhEZWdyZWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpbmRlZ3JlZXMgPSB7fTtcbiAgICAgIHZhciBvdXRkZWdyZWVzID0ge307XG4gICAgICB2YXIgbWF4SW5kZWdyZWUgPSAwO1xuICAgICAgdmFyIG1heE91dGRlZ3JlZSA9IDA7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBudW1Ob2RlczsgX2krKykge1xuICAgICAgICB2YXIgX25vZGUgPSBub2Rlc1tfaV07XG5cbiAgICAgICAgdmFyIGlkID0gX25vZGUuaWQoKTsgLy8gYWRkIGN1cnJlbnQgbm9kZSB0byB0aGUgY3VycmVudCBvcHRpb25zIG9iamVjdCBhbmQgY2FsbCBkZWdyZWVDZW50cmFsaXR5XG5cblxuICAgICAgICBvcHRpb25zLnJvb3QgPSBfbm9kZTtcblxuICAgICAgICB2YXIgX2N1cnJEZWdyZWUgPSB0aGlzLmRlZ3JlZUNlbnRyYWxpdHkob3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKG1heEluZGVncmVlIDwgX2N1cnJEZWdyZWUuaW5kZWdyZWUpIG1heEluZGVncmVlID0gX2N1cnJEZWdyZWUuaW5kZWdyZWU7XG4gICAgICAgIGlmIChtYXhPdXRkZWdyZWUgPCBfY3VyckRlZ3JlZS5vdXRkZWdyZWUpIG1heE91dGRlZ3JlZSA9IF9jdXJyRGVncmVlLm91dGRlZ3JlZTtcbiAgICAgICAgaW5kZWdyZWVzW2lkXSA9IF9jdXJyRGVncmVlLmluZGVncmVlO1xuICAgICAgICBvdXRkZWdyZWVzW2lkXSA9IF9jdXJyRGVncmVlLm91dGRlZ3JlZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZWdyZWU6IGZ1bmN0aW9uIGluZGVncmVlKG5vZGUpIHtcbiAgICAgICAgICBpZiAobWF4SW5kZWdyZWUgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0cmluZyhub2RlKSkge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgbm9kZSA9IGN5LmZpbHRlcihub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaW5kZWdyZWVzW25vZGUuaWQoKV0gLyBtYXhJbmRlZ3JlZTtcbiAgICAgICAgfSxcbiAgICAgICAgb3V0ZGVncmVlOiBmdW5jdGlvbiBvdXRkZWdyZWUobm9kZSkge1xuICAgICAgICAgIGlmIChtYXhPdXRkZWdyZWUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgIG5vZGUgPSBjeS5maWx0ZXIobm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG91dGRlZ3JlZXNbbm9kZS5pZCgpXSAvIG1heE91dGRlZ3JlZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIC8vIGRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkXG4gIC8vIEltcGxlbWVudGVkIGZyb20gdGhlIGFsZ29yaXRobSBpbiBPcHNhaGwncyBwYXBlclxuICAvLyBcIk5vZGUgY2VudHJhbGl0eSBpbiB3ZWlnaHRlZCBuZXR3b3JrczogR2VuZXJhbGl6aW5nIGRlZ3JlZSBhbmQgc2hvcnRlc3QgcGF0aHNcIlxuICAvLyBjaGVjayB0aGUgaGVhZGluZyAyIFwiRGVncmVlXCJcbiAgZGVncmVlQ2VudHJhbGl0eTogZnVuY3Rpb24gZGVncmVlQ2VudHJhbGl0eShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRzJGYob3B0aW9ucyk7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBjYWxsaW5nRWxlcyA9IHRoaXM7XG4gICAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgICAgcm9vdCA9IF9vcHRpb25zLnJvb3QsXG4gICAgICAgIHdlaWdodCA9IF9vcHRpb25zLndlaWdodCxcbiAgICAgICAgZGlyZWN0ZWQgPSBfb3B0aW9ucy5kaXJlY3RlZCxcbiAgICAgICAgYWxwaGEgPSBfb3B0aW9ucy5hbHBoYTtcbiAgICByb290ID0gY3kuY29sbGVjdGlvbihyb290KVswXTtcblxuICAgIGlmICghZGlyZWN0ZWQpIHtcbiAgICAgIHZhciBjb25uRWRnZXMgPSByb290LmNvbm5lY3RlZEVkZ2VzKCkuaW50ZXJzZWN0aW9uKGNhbGxpbmdFbGVzKTtcbiAgICAgIHZhciBrID0gY29ubkVkZ2VzLmxlbmd0aDtcbiAgICAgIHZhciBzID0gMDsgLy8gTm93LCBzdW0gZWRnZSB3ZWlnaHRzXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29ubkVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHMgKz0gd2VpZ2h0KGNvbm5FZGdlc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlZ3JlZTogTWF0aC5wb3coaywgMSAtIGFscGhhKSAqIE1hdGgucG93KHMsIGFscGhhKVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVkZ2VzID0gcm9vdC5jb25uZWN0ZWRFZGdlcygpO1xuICAgICAgdmFyIGluY29taW5nID0gZWRnZXMuZmlsdGVyKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIHJldHVybiBlZGdlLnRhcmdldCgpLnNhbWUocm9vdCkgJiYgY2FsbGluZ0VsZXMuaGFzKGVkZ2UpO1xuICAgICAgfSk7XG4gICAgICB2YXIgb3V0Z29pbmcgPSBlZGdlcy5maWx0ZXIoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2Uuc291cmNlKCkuc2FtZShyb290KSAmJiBjYWxsaW5nRWxlcy5oYXMoZWRnZSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBrX2luID0gaW5jb21pbmcubGVuZ3RoO1xuICAgICAgdmFyIGtfb3V0ID0gb3V0Z29pbmcubGVuZ3RoO1xuICAgICAgdmFyIHNfaW4gPSAwO1xuICAgICAgdmFyIHNfb3V0ID0gMDsgLy8gTm93LCBzdW0gaW5jb21pbmcgZWRnZSB3ZWlnaHRzXG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGluY29taW5nLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgc19pbiArPSB3ZWlnaHQoaW5jb21pbmdbX2kyXSk7XG4gICAgICB9IC8vIE5vdywgc3VtIG91dGdvaW5nIGVkZ2Ugd2VpZ2h0c1xuXG5cbiAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG91dGdvaW5nLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgc19vdXQgKz0gd2VpZ2h0KG91dGdvaW5nW19pM10pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmRlZ3JlZTogTWF0aC5wb3coa19pbiwgMSAtIGFscGhhKSAqIE1hdGgucG93KHNfaW4sIGFscGhhKSxcbiAgICAgICAgb3V0ZGVncmVlOiBNYXRoLnBvdyhrX291dCwgMSAtIGFscGhhKSAqIE1hdGgucG93KHNfb3V0LCBhbHBoYSlcbiAgICAgIH07XG4gICAgfVxuICB9IC8vIGRlZ3JlZUNlbnRyYWxpdHlcblxufTsgLy8gZWxlc2ZuXG4vLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGljYWwgYWxpYXNcblxuZWxlc2ZuJG4uZGMgPSBlbGVzZm4kbi5kZWdyZWVDZW50cmFsaXR5O1xuZWxlc2ZuJG4uZGNuID0gZWxlc2ZuJG4uZGVncmVlQ2VudHJhbGl0eU5vcm1hbGlzZWQgPSBlbGVzZm4kbi5kZWdyZWVDZW50cmFsaXR5Tm9ybWFsaXplZDtcblxudmFyIGRlZmF1bHRzJGUgPSBkZWZhdWx0cyRnKHtcbiAgaGFybW9uaWM6IHRydWUsXG4gIHdlaWdodDogZnVuY3Rpb24gd2VpZ2h0KCkge1xuICAgIHJldHVybiAxO1xuICB9LFxuICBkaXJlY3RlZDogZmFsc2UsXG4gIHJvb3Q6IG51bGxcbn0pO1xudmFyIGVsZXNmbiRtID0ge1xuICBjbG9zZW5lc3NDZW50cmFsaXR5Tm9ybWFsaXplZDogZnVuY3Rpb24gY2xvc2VuZXNzQ2VudHJhbGl0eU5vcm1hbGl6ZWQob3B0aW9ucykge1xuICAgIHZhciBfZGVmYXVsdHMgPSBkZWZhdWx0cyRlKG9wdGlvbnMpLFxuICAgICAgICBoYXJtb25pYyA9IF9kZWZhdWx0cy5oYXJtb25pYyxcbiAgICAgICAgd2VpZ2h0ID0gX2RlZmF1bHRzLndlaWdodCxcbiAgICAgICAgZGlyZWN0ZWQgPSBfZGVmYXVsdHMuZGlyZWN0ZWQ7XG5cbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIGNsb3NlbmVzc2VzID0ge307XG4gICAgdmFyIG1heENsb3NlbmVzcyA9IDA7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBmdyA9IHRoaXMuZmxveWRXYXJzaGFsbCh7XG4gICAgICB3ZWlnaHQ6IHdlaWdodCxcbiAgICAgIGRpcmVjdGVkOiBkaXJlY3RlZFxuICAgIH0pOyAvLyBDb21wdXRlIGNsb3NlbmVzcyBmb3IgZXZlcnkgbm9kZSBhbmQgZmluZCB0aGUgbWF4aW11bSBjbG9zZW5lc3NcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjdXJyQ2xvc2VuZXNzID0gMDtcbiAgICAgIHZhciBub2RlX2kgPSBub2Rlc1tpXTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoaSAhPT0gaikge1xuICAgICAgICAgIHZhciBkID0gZncuZGlzdGFuY2Uobm9kZV9pLCBub2Rlc1tqXSk7XG5cbiAgICAgICAgICBpZiAoaGFybW9uaWMpIHtcbiAgICAgICAgICAgIGN1cnJDbG9zZW5lc3MgKz0gMSAvIGQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJDbG9zZW5lc3MgKz0gZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFoYXJtb25pYykge1xuICAgICAgICBjdXJyQ2xvc2VuZXNzID0gMSAvIGN1cnJDbG9zZW5lc3M7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXhDbG9zZW5lc3MgPCBjdXJyQ2xvc2VuZXNzKSB7XG4gICAgICAgIG1heENsb3NlbmVzcyA9IGN1cnJDbG9zZW5lc3M7XG4gICAgICB9XG5cbiAgICAgIGNsb3NlbmVzc2VzW25vZGVfaS5pZCgpXSA9IGN1cnJDbG9zZW5lc3M7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNsb3NlbmVzczogZnVuY3Rpb24gY2xvc2VuZXNzKG5vZGUpIHtcbiAgICAgICAgaWYgKG1heENsb3NlbmVzcyA9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgIG5vZGUgPSBjeS5maWx0ZXIobm9kZSlbMF0uaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmcm9tIGlzIGEgbm9kZVxuICAgICAgICAgIG5vZGUgPSBub2RlLmlkKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xvc2VuZXNzZXNbbm9kZV0gLyBtYXhDbG9zZW5lc3M7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gIGNsb3NlbmVzc0NlbnRyYWxpdHk6IGZ1bmN0aW9uIGNsb3NlbmVzc0NlbnRyYWxpdHkob3B0aW9ucykge1xuICAgIHZhciBfZGVmYXVsdHMyID0gZGVmYXVsdHMkZShvcHRpb25zKSxcbiAgICAgICAgcm9vdCA9IF9kZWZhdWx0czIucm9vdCxcbiAgICAgICAgd2VpZ2h0ID0gX2RlZmF1bHRzMi53ZWlnaHQsXG4gICAgICAgIGRpcmVjdGVkID0gX2RlZmF1bHRzMi5kaXJlY3RlZCxcbiAgICAgICAgaGFybW9uaWMgPSBfZGVmYXVsdHMyLmhhcm1vbmljO1xuXG4gICAgcm9vdCA9IHRoaXMuZmlsdGVyKHJvb3QpWzBdOyAvLyB3ZSBuZWVkIGRpc3RhbmNlIGZyb20gdGhpcyBub2RlIHRvIGV2ZXJ5IG90aGVyIG5vZGVcblxuICAgIHZhciBkaWprc3RyYSA9IHRoaXMuZGlqa3N0cmEoe1xuICAgICAgcm9vdDogcm9vdCxcbiAgICAgIHdlaWdodDogd2VpZ2h0LFxuICAgICAgZGlyZWN0ZWQ6IGRpcmVjdGVkXG4gICAgfSk7XG4gICAgdmFyIHRvdGFsRGlzdGFuY2UgPSAwO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuID0gbm9kZXNbaV07XG5cbiAgICAgIGlmICghbi5zYW1lKHJvb3QpKSB7XG4gICAgICAgIHZhciBkID0gZGlqa3N0cmEuZGlzdGFuY2VUbyhuKTtcblxuICAgICAgICBpZiAoaGFybW9uaWMpIHtcbiAgICAgICAgICB0b3RhbERpc3RhbmNlICs9IDEgLyBkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvdGFsRGlzdGFuY2UgKz0gZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoYXJtb25pYyA/IHRvdGFsRGlzdGFuY2UgOiAxIC8gdG90YWxEaXN0YW5jZTtcbiAgfSAvLyBjbG9zZW5lc3NDZW50cmFsaXR5XG5cbn07IC8vIGVsZXNmblxuLy8gbmljZSwgc2hvcnQgbWF0aGVtYXRpY2FsIGFsaWFzXG5cbmVsZXNmbiRtLmNjID0gZWxlc2ZuJG0uY2xvc2VuZXNzQ2VudHJhbGl0eTtcbmVsZXNmbiRtLmNjbiA9IGVsZXNmbiRtLmNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpc2VkID0gZWxlc2ZuJG0uY2xvc2VuZXNzQ2VudHJhbGl0eU5vcm1hbGl6ZWQ7XG5cbnZhciBkZWZhdWx0cyRkID0gZGVmYXVsdHMkZyh7XG4gIHdlaWdodDogbnVsbCxcbiAgZGlyZWN0ZWQ6IGZhbHNlXG59KTtcbnZhciBlbGVzZm4kbCA9IHtcbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSB0aGUgYWxnb3JpdGhtIGluIHRoZSBwYXBlciBcIk9uIFZhcmlhbnRzIG9mIFNob3J0ZXN0LVBhdGggQmV0d2Vlbm5lc3MgQ2VudHJhbGl0eSBhbmQgdGhlaXIgR2VuZXJpYyBDb21wdXRhdGlvblwiIGJ5IFVscmlrIEJyYW5kZXNcbiAgYmV0d2Vlbm5lc3NDZW50cmFsaXR5OiBmdW5jdGlvbiBiZXR3ZWVubmVzc0NlbnRyYWxpdHkob3B0aW9ucykge1xuICAgIHZhciBfZGVmYXVsdHMgPSBkZWZhdWx0cyRkKG9wdGlvbnMpLFxuICAgICAgICBkaXJlY3RlZCA9IF9kZWZhdWx0cy5kaXJlY3RlZCxcbiAgICAgICAgd2VpZ2h0ID0gX2RlZmF1bHRzLndlaWdodDtcblxuICAgIHZhciB3ZWlnaHRlZCA9IHdlaWdodCAhPSBudWxsO1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTsgLy8gc3RhcnRpbmdcblxuICAgIHZhciBWID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBBID0ge307XG4gICAgdmFyIF9DID0ge307XG4gICAgdmFyIG1heCA9IDA7XG4gICAgdmFyIEMgPSB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbCkge1xuICAgICAgICBfQ1trZXldID0gdmFsO1xuXG4gICAgICAgIGlmICh2YWwgPiBtYXgpIHtcbiAgICAgICAgICBtYXggPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9DW2tleV07XG4gICAgICB9XG4gICAgfTsgLy8gQSBjb250YWlucyB0aGUgbmVpZ2hib3Job29kcyBvZiBldmVyeSBub2RlXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IFYubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2ID0gVltpXTtcbiAgICAgIHZhciB2aWQgPSB2LmlkKCk7XG5cbiAgICAgIGlmIChkaXJlY3RlZCkge1xuICAgICAgICBBW3ZpZF0gPSB2Lm91dGdvZXJzKCkubm9kZXMoKTsgLy8gZ2V0IG91dGdvZXJzIG9mIGV2ZXJ5IG5vZGVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEFbdmlkXSA9IHYub3Blbk5laWdoYm9yaG9vZCgpLm5vZGVzKCk7IC8vIGdldCBuZWlnaGJvcnMgb2YgZXZlcnkgbm9kZVxuICAgICAgfVxuXG4gICAgICBDLnNldCh2aWQsIDApO1xuICAgIH1cblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKHMpIHtcbiAgICAgIHZhciBzaWQgPSBWW3NdLmlkKCk7XG4gICAgICB2YXIgUyA9IFtdOyAvLyBzdGFja1xuXG4gICAgICB2YXIgUCA9IHt9O1xuICAgICAgdmFyIGcgPSB7fTtcbiAgICAgIHZhciBkID0ge307XG4gICAgICB2YXIgUSA9IG5ldyBIZWFwX19kZWZhdWx0W1wiZGVmYXVsdFwiXShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gZFthXSAtIGRbYl07XG4gICAgICB9KTsgLy8gcXVldWVcbiAgICAgIC8vIGluaXQgZGljdGlvbmFyaWVzXG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBWLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgX3ZpZCA9IFZbX2ldLmlkKCk7XG5cbiAgICAgICAgUFtfdmlkXSA9IFtdO1xuICAgICAgICBnW192aWRdID0gMDtcbiAgICAgICAgZFtfdmlkXSA9IEluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICBnW3NpZF0gPSAxOyAvLyBzaWdtYVxuXG4gICAgICBkW3NpZF0gPSAwOyAvLyBkaXN0YW5jZSB0byBzXG5cbiAgICAgIFEucHVzaChzaWQpO1xuXG4gICAgICB3aGlsZSAoIVEuZW1wdHkoKSkge1xuICAgICAgICB2YXIgX3YgPSBRLnBvcCgpO1xuXG4gICAgICAgIFMucHVzaChfdik7XG5cbiAgICAgICAgaWYgKHdlaWdodGVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBBW192XS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHcgPSBBW192XVtqXTtcbiAgICAgICAgICAgIHZhciB2RWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQoX3YpO1xuICAgICAgICAgICAgdmFyIGVkZ2UgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmICh2RWxlLmVkZ2VzVG8odykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBlZGdlID0gdkVsZS5lZGdlc1RvKHcpWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWRnZSA9IHcuZWRnZXNUbyh2RWxlKVswXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVkZ2VXZWlnaHQgPSB3ZWlnaHQoZWRnZSk7XG4gICAgICAgICAgICB3ID0gdy5pZCgpO1xuXG4gICAgICAgICAgICBpZiAoZFt3XSA+IGRbX3ZdICsgZWRnZVdlaWdodCkge1xuICAgICAgICAgICAgICBkW3ddID0gZFtfdl0gKyBlZGdlV2VpZ2h0O1xuXG4gICAgICAgICAgICAgIGlmIChRLm5vZGVzLmluZGV4T2YodykgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy9pZiB3IGlzIG5vdCBpbiBRXG4gICAgICAgICAgICAgICAgUS5wdXNoKHcpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvbiBpZiB3IGlzIGluIFFcbiAgICAgICAgICAgICAgICBRLnVwZGF0ZUl0ZW0odyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBnW3ddID0gMDtcbiAgICAgICAgICAgICAgUFt3XSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZFt3XSA9PSBkW192XSArIGVkZ2VXZWlnaHQpIHtcbiAgICAgICAgICAgICAgZ1t3XSA9IGdbd10gKyBnW192XTtcbiAgICAgICAgICAgICAgUFt3XS5wdXNoKF92KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IEFbX3ZdLmxlbmd0aDsgX2orKykge1xuICAgICAgICAgICAgdmFyIF93ID0gQVtfdl1bX2pdLmlkKCk7XG5cbiAgICAgICAgICAgIGlmIChkW193XSA9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICBRLnB1c2goX3cpO1xuICAgICAgICAgICAgICBkW193XSA9IGRbX3ZdICsgMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRbX3ddID09IGRbX3ZdICsgMSkge1xuICAgICAgICAgICAgICBnW193XSA9IGdbX3ddICsgZ1tfdl07XG5cbiAgICAgICAgICAgICAgUFtfd10ucHVzaChfdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBlID0ge307XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IFYubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICBlW1ZbX2kyXS5pZCgpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChTLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIF93MiA9IFMucG9wKCk7XG5cbiAgICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgUFtfdzJdLmxlbmd0aDsgX2oyKyspIHtcbiAgICAgICAgICB2YXIgX3YyID0gUFtfdzJdW19qMl07XG4gICAgICAgICAgZVtfdjJdID0gZVtfdjJdICsgZ1tfdjJdIC8gZ1tfdzJdICogKDEgKyBlW193Ml0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF93MiAhPSBWW3NdLmlkKCkpIHtcbiAgICAgICAgICBDLnNldChfdzIsIEMuZ2V0KF93MikgKyBlW193Ml0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIHMgPSAwOyBzIDwgVi5sZW5ndGg7IHMrKykge1xuICAgICAgX2xvb3Aocyk7XG4gICAgfVxuXG4gICAgdmFyIHJldCA9IHtcbiAgICAgIGJldHdlZW5uZXNzOiBmdW5jdGlvbiBiZXR3ZWVubmVzcyhub2RlKSB7XG4gICAgICAgIHZhciBpZCA9IGN5LmNvbGxlY3Rpb24obm9kZSkuaWQoKTtcbiAgICAgICAgcmV0dXJuIEMuZ2V0KGlkKTtcbiAgICAgIH0sXG4gICAgICBiZXR3ZWVubmVzc05vcm1hbGl6ZWQ6IGZ1bmN0aW9uIGJldHdlZW5uZXNzTm9ybWFsaXplZChub2RlKSB7XG4gICAgICAgIGlmIChtYXggPT0gMCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlkID0gY3kuY29sbGVjdGlvbihub2RlKS5pZCgpO1xuICAgICAgICByZXR1cm4gQy5nZXQoaWQpIC8gbWF4O1xuICAgICAgfVxuICAgIH07IC8vIGFsaWFzXG5cbiAgICByZXQuYmV0d2Vlbm5lc3NOb3JtYWxpc2VkID0gcmV0LmJldHdlZW5uZXNzTm9ybWFsaXplZDtcbiAgICByZXR1cm4gcmV0O1xuICB9IC8vIGJldHdlZW5uZXNzQ2VudHJhbGl0eVxuXG59OyAvLyBlbGVzZm5cbi8vIG5pY2UsIHNob3J0IG1hdGhlbWF0aWNhbCBhbGlhc1xuXG5lbGVzZm4kbC5iYyA9IGVsZXNmbiRsLmJldHdlZW5uZXNzQ2VudHJhbGl0eTtcblxuLy8gSW1wbGVtZW50ZWQgYnkgWm9lIFhpIEB6b2V4aSBmb3IgR1NPQyAyMDE2XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG52YXIgZGVmYXVsdHMkYyA9IGRlZmF1bHRzJGcoe1xuICBleHBhbmRGYWN0b3I6IDIsXG4gIC8vIGFmZmVjdHMgdGltZSBvZiBjb21wdXRhdGlvbiBhbmQgY2x1c3RlciBncmFudWxhcml0eSB0byBzb21lIGV4dGVudDogTSAqIE1cbiAgaW5mbGF0ZUZhY3RvcjogMixcbiAgLy8gYWZmZWN0cyBjbHVzdGVyIGdyYW51bGFyaXR5ICh0aGUgZ3JlYXRlciB0aGUgdmFsdWUsIHRoZSBtb3JlIGNsdXN0ZXJzKTogTShpLGopIC8gRShqKVxuICBtdWx0RmFjdG9yOiAxLFxuICAvLyBvcHRpb25hbCBzZWxmIGxvb3BzIGZvciBlYWNoIG5vZGUuIFVzZSBhIG5ldXRyYWwgdmFsdWUgdG8gaW1wcm92ZSBjbHVzdGVyIGNvbXB1dGF0aW9ucy5cbiAgbWF4SXRlcmF0aW9uczogMjAsXG4gIC8vIG1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgb2YgdGhlIE1DTCBhbGdvcml0aG0gaW4gYSBzaW5nbGUgcnVuXG4gIGF0dHJpYnV0ZXM6IFsvLyBhdHRyaWJ1dGVzL2ZlYXR1cmVzIHVzZWQgdG8gZ3JvdXAgbm9kZXMsIGllLiBzaW1pbGFyaXR5IHZhbHVlcyBiZXR3ZWVuIG5vZGVzXG4gIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1dXG59KTtcbi8qIGVzbGludC1lbmFibGUgKi9cblxudmFyIHNldE9wdGlvbnMkMyA9IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4gZGVmYXVsdHMkYyhvcHRpb25zKTtcbn07XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cblxudmFyIGdldFNpbWlsYXJpdHkkMSA9IGZ1bmN0aW9uIGdldFNpbWlsYXJpdHkoZWRnZSwgYXR0cmlidXRlcykge1xuICB2YXIgdG90YWwgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgIHRvdGFsICs9IGF0dHJpYnV0ZXNbaV0oZWRnZSk7XG4gIH1cblxuICByZXR1cm4gdG90YWw7XG59O1xuXG52YXIgYWRkTG9vcHMgPSBmdW5jdGlvbiBhZGRMb29wcyhNLCBuLCB2YWwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBNW2kgKiBuICsgaV0gPSB2YWw7XG4gIH1cbn07XG5cbnZhciBub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUoTSwgbikge1xuICB2YXIgc3VtO1xuXG4gIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG47IGNvbCsrKSB7XG4gICAgc3VtID0gMDtcblxuICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG47IHJvdysrKSB7XG4gICAgICBzdW0gKz0gTVtyb3cgKiBuICsgY29sXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfcm93ID0gMDsgX3JvdyA8IG47IF9yb3crKykge1xuICAgICAgTVtfcm93ICogbiArIGNvbF0gPSBNW19yb3cgKiBuICsgY29sXSAvIHN1bTtcbiAgICB9XG4gIH1cbn07IC8vIFRPRE86IGJsb2NrZWQgbWF0cml4IG11bHRpcGxpY2F0aW9uP1xuXG5cbnZhciBtbXVsdCA9IGZ1bmN0aW9uIG1tdWx0KEEsIEIsIG4pIHtcbiAgdmFyIEMgPSBuZXcgQXJyYXkobiAqIG4pO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgIENbaSAqIG4gKyBqXSA9IDA7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBuOyBrKyspIHtcbiAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBuOyBfaisrKSB7XG4gICAgICAgIENbaSAqIG4gKyBfal0gKz0gQVtpICogbiArIGtdICogQltrICogbiArIF9qXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gQztcbn07XG5cbnZhciBleHBhbmQgPSBmdW5jdGlvbiBleHBhbmQoTSwgbiwgZXhwYW5kRmFjdG9yXG4vKiogcG93ZXIgKiovXG4pIHtcbiAgdmFyIF9NID0gTS5zbGljZSgwKTtcblxuICBmb3IgKHZhciBwID0gMTsgcCA8IGV4cGFuZEZhY3RvcjsgcCsrKSB7XG4gICAgTSA9IG1tdWx0KE0sIF9NLCBuKTtcbiAgfVxuXG4gIHJldHVybiBNO1xufTtcblxudmFyIGluZmxhdGUgPSBmdW5jdGlvbiBpbmZsYXRlKE0sIG4sIGluZmxhdGVGYWN0b3Jcbi8qKiByICoqL1xuKSB7XG4gIHZhciBfTSA9IG5ldyBBcnJheShuICogbik7IC8vIE0oaSxqKSBeIGluZmxhdGVQb3dlclxuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuICogbjsgaSsrKSB7XG4gICAgX01baV0gPSBNYXRoLnBvdyhNW2ldLCBpbmZsYXRlRmFjdG9yKTtcbiAgfVxuXG4gIG5vcm1hbGl6ZShfTSwgbik7XG4gIHJldHVybiBfTTtcbn07XG5cbnZhciBoYXNDb252ZXJnZWQgPSBmdW5jdGlvbiBoYXNDb252ZXJnZWQoTSwgX00sIG4yLCByb3VuZEZhY3Rvcikge1xuICAvLyBDaGVjayB0aGF0IGJvdGggbWF0cmljZXMgaGF2ZSB0aGUgc2FtZSBlbGVtZW50cyAoaSxqKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG4yOyBpKyspIHtcbiAgICB2YXIgdjEgPSBNYXRoLnJvdW5kKE1baV0gKiBNYXRoLnBvdygxMCwgcm91bmRGYWN0b3IpKSAvIE1hdGgucG93KDEwLCByb3VuZEZhY3Rvcik7IC8vIHRydW5jYXRlIHRvICdyb3VuZEZhY3RvcicgZGVjaW1hbCBwbGFjZXNcblxuICAgIHZhciB2MiA9IE1hdGgucm91bmQoX01baV0gKiBNYXRoLnBvdygxMCwgcm91bmRGYWN0b3IpKSAvIE1hdGgucG93KDEwLCByb3VuZEZhY3Rvcik7XG5cbiAgICBpZiAodjEgIT09IHYyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgYXNzaWduJDIgPSBmdW5jdGlvbiBhc3NpZ24oTSwgbiwgbm9kZXMsIGN5KSB7XG4gIHZhciBjbHVzdGVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgdmFyIGNsdXN0ZXIgPSBbXTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAvLyBSb3ctd2lzZSBhdHRyYWN0b3JzIGFuZCBlbGVtZW50cyB0aGF0IHRoZXkgYXR0cmFjdCBiZWxvbmcgaW4gc2FtZSBjbHVzdGVyXG4gICAgICBpZiAoTWF0aC5yb3VuZChNW2kgKiBuICsgal0gKiAxMDAwKSAvIDEwMDAgPiAwKSB7XG4gICAgICAgIGNsdXN0ZXIucHVzaChub2Rlc1tqXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNsdXN0ZXIubGVuZ3RoICE9PSAwKSB7XG4gICAgICBjbHVzdGVycy5wdXNoKGN5LmNvbGxlY3Rpb24oY2x1c3RlcikpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjbHVzdGVycztcbn07XG5cbnZhciBpc0R1cGxpY2F0ZSA9IGZ1bmN0aW9uIGlzRHVwbGljYXRlKGMxLCBjMikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGMxLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFjMltpXSB8fCBjMVtpXS5pZCgpICE9PSBjMltpXS5pZCgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgcmVtb3ZlRHVwbGljYXRlcyA9IGZ1bmN0aW9uIHJlbW92ZUR1cGxpY2F0ZXMoY2x1c3RlcnMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbHVzdGVycy5sZW5ndGg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2x1c3RlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChpICE9IGogJiYgaXNEdXBsaWNhdGUoY2x1c3RlcnNbaV0sIGNsdXN0ZXJzW2pdKSkge1xuICAgICAgICBjbHVzdGVycy5zcGxpY2UoaiwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNsdXN0ZXJzO1xufTtcblxudmFyIG1hcmtvdkNsdXN0ZXJpbmcgPSBmdW5jdGlvbiBtYXJrb3ZDbHVzdGVyaW5nKG9wdGlvbnMpIHtcbiAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCk7XG4gIHZhciBjeSA9IHRoaXMuY3koKTsgLy8gU2V0IHBhcmFtZXRlcnMgb2YgYWxnb3JpdGhtOlxuXG4gIHZhciBvcHRzID0gc2V0T3B0aW9ucyQzKG9wdGlvbnMpOyAvLyBNYXAgZWFjaCBub2RlIHRvIGl0cyBwb3NpdGlvbiBpbiBub2RlIGFycmF5XG5cbiAgdmFyIGlkMnBvc2l0aW9uID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlkMnBvc2l0aW9uW25vZGVzW2ldLmlkKCldID0gaTtcbiAgfSAvLyBHZW5lcmF0ZSBzdG9jaGFzdGljIG1hdHJpeCBNIGZyb20gaW5wdXQgZ3JhcGggRyAoc2hvdWxkIGJlIHN5bW1ldHJpYy91bmRpcmVjdGVkKVxuXG5cbiAgdmFyIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICBuMiA9IG4gKiBuO1xuXG4gIHZhciBNID0gbmV3IEFycmF5KG4yKSxcbiAgICAgIF9NO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBuMjsgX2krKykge1xuICAgIE1bX2ldID0gMDtcbiAgfVxuXG4gIGZvciAodmFyIGUgPSAwOyBlIDwgZWRnZXMubGVuZ3RoOyBlKyspIHtcbiAgICB2YXIgZWRnZSA9IGVkZ2VzW2VdO1xuICAgIHZhciBfaTIgPSBpZDJwb3NpdGlvbltlZGdlLnNvdXJjZSgpLmlkKCldO1xuICAgIHZhciBqID0gaWQycG9zaXRpb25bZWRnZS50YXJnZXQoKS5pZCgpXTtcbiAgICB2YXIgc2ltID0gZ2V0U2ltaWxhcml0eSQxKGVkZ2UsIG9wdHMuYXR0cmlidXRlcyk7XG4gICAgTVtfaTIgKiBuICsgal0gKz0gc2ltOyAvLyBHIHNob3VsZCBiZSBzeW1tZXRyaWMgYW5kIHVuZGlyZWN0ZWRcblxuICAgIE1baiAqIG4gKyBfaTJdICs9IHNpbTtcbiAgfSAvLyBCZWdpbiBNYXJrb3YgY2x1c3RlciBhbGdvcml0aG1cbiAgLy8gU3RlcCAxOiBBZGQgc2VsZiBsb29wcyB0byBlYWNoIG5vZGUsIGllLiBhZGQgbXVsdEZhY3RvciB0byBtYXRyaXggZGlhZ29uYWxcblxuXG4gIGFkZExvb3BzKE0sIG4sIG9wdHMubXVsdEZhY3Rvcik7IC8vIFN0ZXAgMjogTSA9IG5vcm1hbGl6ZSggTSApO1xuXG4gIG5vcm1hbGl6ZShNLCBuKTtcbiAgdmFyIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICB2YXIgaXRlcmF0aW9ucyA9IDA7XG5cbiAgd2hpbGUgKGlzU3RpbGxNb3ZpbmcgJiYgaXRlcmF0aW9ucyA8IG9wdHMubWF4SXRlcmF0aW9ucykge1xuICAgIGlzU3RpbGxNb3ZpbmcgPSBmYWxzZTsgLy8gU3RlcCAzOlxuXG4gICAgX00gPSBleHBhbmQoTSwgbiwgb3B0cy5leHBhbmRGYWN0b3IpOyAvLyBTdGVwIDQ6XG5cbiAgICBNID0gaW5mbGF0ZShfTSwgbiwgb3B0cy5pbmZsYXRlRmFjdG9yKTsgLy8gU3RlcCA1OiBjaGVjayB0byBzZWUgaWYgfnN0ZWFkeSBzdGF0ZSBoYXMgYmVlbiByZWFjaGVkXG5cbiAgICBpZiAoIWhhc0NvbnZlcmdlZChNLCBfTSwgbjIsIDQpKSB7XG4gICAgICBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpdGVyYXRpb25zKys7XG4gIH0gLy8gQnVpbGQgY2x1c3RlcnMgZnJvbSBtYXRyaXhcblxuXG4gIHZhciBjbHVzdGVycyA9IGFzc2lnbiQyKE0sIG4sIG5vZGVzLCBjeSk7IC8vIFJlbW92ZSBkdXBsaWNhdGUgY2x1c3RlcnMgZHVlIHRvIHN5bW1ldHJ5IG9mIGdyYXBoIGFuZCBNIG1hdHJpeFxuXG4gIGNsdXN0ZXJzID0gcmVtb3ZlRHVwbGljYXRlcyhjbHVzdGVycyk7XG4gIHJldHVybiBjbHVzdGVycztcbn07XG5cbnZhciBtYXJrb3ZDbHVzdGVyaW5nJDEgPSB7XG4gIG1hcmtvdkNsdXN0ZXJpbmc6IG1hcmtvdkNsdXN0ZXJpbmcsXG4gIG1jbDogbWFya292Q2x1c3RlcmluZ1xufTtcblxuLy8gQ29tbW9uIGRpc3RhbmNlIG1ldHJpY3MgZm9yIGNsdXN0ZXJpbmcgYWxnb3JpdGhtc1xuXG52YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gIHJldHVybiB4O1xufTtcblxudmFyIGFic0RpZmYgPSBmdW5jdGlvbiBhYnNEaWZmKHAsIHEpIHtcbiAgcmV0dXJuIE1hdGguYWJzKHEgLSBwKTtcbn07XG5cbnZhciBhZGRBYnNEaWZmID0gZnVuY3Rpb24gYWRkQWJzRGlmZih0b3RhbCwgcCwgcSkge1xuICByZXR1cm4gdG90YWwgKyBhYnNEaWZmKHAsIHEpO1xufTtcblxudmFyIGFkZFNxdWFyZWREaWZmID0gZnVuY3Rpb24gYWRkU3F1YXJlZERpZmYodG90YWwsIHAsIHEpIHtcbiAgcmV0dXJuIHRvdGFsICsgTWF0aC5wb3cocSAtIHAsIDIpO1xufTtcblxudmFyIHNxcnQgPSBmdW5jdGlvbiBzcXJ0KHgpIHtcbiAgcmV0dXJuIE1hdGguc3FydCh4KTtcbn07XG5cbnZhciBtYXhBYnNEaWZmID0gZnVuY3Rpb24gbWF4QWJzRGlmZihjdXJyZW50TWF4LCBwLCBxKSB7XG4gIHJldHVybiBNYXRoLm1heChjdXJyZW50TWF4LCBhYnNEaWZmKHAsIHEpKTtcbn07XG5cbnZhciBnZXREaXN0YW5jZSA9IGZ1bmN0aW9uIGdldERpc3RhbmNlKGxlbmd0aCwgZ2V0UCwgZ2V0USwgaW5pdCwgdmlzaXQpIHtcbiAgdmFyIHBvc3QgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IGlkZW50aXR5O1xuICB2YXIgcmV0ID0gaW5pdDtcbiAgdmFyIHAsIHE7XG5cbiAgZm9yICh2YXIgZGltID0gMDsgZGltIDwgbGVuZ3RoOyBkaW0rKykge1xuICAgIHAgPSBnZXRQKGRpbSk7XG4gICAgcSA9IGdldFEoZGltKTtcbiAgICByZXQgPSB2aXNpdChyZXQsIHAsIHEpO1xuICB9XG5cbiAgcmV0dXJuIHBvc3QocmV0KTtcbn07XG5cbnZhciBkaXN0YW5jZXMgPSB7XG4gIGV1Y2xpZGVhbjogZnVuY3Rpb24gZXVjbGlkZWFuKGxlbmd0aCwgZ2V0UCwgZ2V0USkge1xuICAgIGlmIChsZW5ndGggPj0gMikge1xuICAgICAgcmV0dXJuIGdldERpc3RhbmNlKGxlbmd0aCwgZ2V0UCwgZ2V0USwgMCwgYWRkU3F1YXJlZERpZmYsIHNxcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmb3Igc2luZ2xlIGF0dHIgY2FzZSwgbW9yZSBlZmZpY2llbnQgdG8gYXZvaWQgc3FydFxuICAgICAgcmV0dXJuIGdldERpc3RhbmNlKGxlbmd0aCwgZ2V0UCwgZ2V0USwgMCwgYWRkQWJzRGlmZik7XG4gICAgfVxuICB9LFxuICBzcXVhcmVkRXVjbGlkZWFuOiBmdW5jdGlvbiBzcXVhcmVkRXVjbGlkZWFuKGxlbmd0aCwgZ2V0UCwgZ2V0USkge1xuICAgIHJldHVybiBnZXREaXN0YW5jZShsZW5ndGgsIGdldFAsIGdldFEsIDAsIGFkZFNxdWFyZWREaWZmKTtcbiAgfSxcbiAgbWFuaGF0dGFuOiBmdW5jdGlvbiBtYW5oYXR0YW4obGVuZ3RoLCBnZXRQLCBnZXRRKSB7XG4gICAgcmV0dXJuIGdldERpc3RhbmNlKGxlbmd0aCwgZ2V0UCwgZ2V0USwgMCwgYWRkQWJzRGlmZik7XG4gIH0sXG4gIG1heDogZnVuY3Rpb24gbWF4KGxlbmd0aCwgZ2V0UCwgZ2V0USkge1xuICAgIHJldHVybiBnZXREaXN0YW5jZShsZW5ndGgsIGdldFAsIGdldFEsIC1JbmZpbml0eSwgbWF4QWJzRGlmZik7XG4gIH1cbn07IC8vIGluIGNhc2UgdGhlIHVzZXIgYWNjaWRlbnRhbGx5IGRvZXNuJ3QgdXNlIGNhbWVsIGNhc2VcblxuZGlzdGFuY2VzWydzcXVhcmVkLWV1Y2xpZGVhbiddID0gZGlzdGFuY2VzWydzcXVhcmVkRXVjbGlkZWFuJ107XG5kaXN0YW5jZXNbJ3NxdWFyZWRldWNsaWRlYW4nXSA9IGRpc3RhbmNlc1snc3F1YXJlZEV1Y2xpZGVhbiddO1xuZnVuY3Rpb24gY2x1c3RlcmluZ0Rpc3RhbmNlIChtZXRob2QsIGxlbmd0aCwgZ2V0UCwgZ2V0USwgbm9kZVAsIG5vZGVRKSB7XG4gIHZhciBpbXBsO1xuXG4gIGlmIChmbiQ2KG1ldGhvZCkpIHtcbiAgICBpbXBsID0gbWV0aG9kO1xuICB9IGVsc2Uge1xuICAgIGltcGwgPSBkaXN0YW5jZXNbbWV0aG9kXSB8fCBkaXN0YW5jZXMuZXVjbGlkZWFuO1xuICB9XG5cbiAgaWYgKGxlbmd0aCA9PT0gMCAmJiBmbiQ2KG1ldGhvZCkpIHtcbiAgICByZXR1cm4gaW1wbChub2RlUCwgbm9kZVEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpbXBsKGxlbmd0aCwgZ2V0UCwgZ2V0USwgbm9kZVAsIG5vZGVRKTtcbiAgfVxufVxuXG52YXIgZGVmYXVsdHMkYiA9IGRlZmF1bHRzJGcoe1xuICBrOiAyLFxuICBtOiAyLFxuICBzZW5zaXRpdml0eVRocmVzaG9sZDogMC4wMDAxLFxuICBkaXN0YW5jZTogJ2V1Y2xpZGVhbicsXG4gIG1heEl0ZXJhdGlvbnM6IDEwLFxuICBhdHRyaWJ1dGVzOiBbXSxcbiAgdGVzdE1vZGU6IGZhbHNlLFxuICB0ZXN0Q2VudHJvaWRzOiBudWxsXG59KTtcblxudmFyIHNldE9wdGlvbnMkMiA9IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4gZGVmYXVsdHMkYihvcHRpb25zKTtcbn07XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cblxudmFyIGdldERpc3QgPSBmdW5jdGlvbiBnZXREaXN0KHR5cGUsIG5vZGUsIGNlbnRyb2lkLCBhdHRyaWJ1dGVzLCBtb2RlKSB7XG4gIHZhciBub05vZGVQID0gbW9kZSAhPT0gJ2tNZWRvaWRzJztcbiAgdmFyIGdldFAgPSBub05vZGVQID8gZnVuY3Rpb24gKGkpIHtcbiAgICByZXR1cm4gY2VudHJvaWRbaV07XG4gIH0gOiBmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBhdHRyaWJ1dGVzW2ldKGNlbnRyb2lkKTtcbiAgfTtcblxuICB2YXIgZ2V0USA9IGZ1bmN0aW9uIGdldFEoaSkge1xuICAgIHJldHVybiBhdHRyaWJ1dGVzW2ldKG5vZGUpO1xuICB9O1xuXG4gIHZhciBub2RlUCA9IGNlbnRyb2lkO1xuICB2YXIgbm9kZVEgPSBub2RlO1xuICByZXR1cm4gY2x1c3RlcmluZ0Rpc3RhbmNlKHR5cGUsIGF0dHJpYnV0ZXMubGVuZ3RoLCBnZXRQLCBnZXRRLCBub2RlUCwgbm9kZVEpO1xufTtcblxudmFyIHJhbmRvbUNlbnRyb2lkcyA9IGZ1bmN0aW9uIHJhbmRvbUNlbnRyb2lkcyhub2RlcywgaywgYXR0cmlidXRlcykge1xuICB2YXIgbmRpbSA9IGF0dHJpYnV0ZXMubGVuZ3RoO1xuICB2YXIgbWluID0gbmV3IEFycmF5KG5kaW0pO1xuICB2YXIgbWF4ID0gbmV3IEFycmF5KG5kaW0pO1xuICB2YXIgY2VudHJvaWRzID0gbmV3IEFycmF5KGspO1xuICB2YXIgY2VudHJvaWQgPSBudWxsOyAvLyBGaW5kIG1pbiwgbWF4IHZhbHVlcyBmb3IgZWFjaCBhdHRyaWJ1dGUgZGltZW5zaW9uXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZGltOyBpKyspIHtcbiAgICBtaW5baV0gPSBub2Rlcy5taW4oYXR0cmlidXRlc1tpXSkudmFsdWU7XG4gICAgbWF4W2ldID0gbm9kZXMubWF4KGF0dHJpYnV0ZXNbaV0pLnZhbHVlO1xuICB9IC8vIEJ1aWxkIGsgY2VudHJvaWRzLCBlYWNoIHJlcHJlc2VudGVkIGFzIGFuIG4tZGltIGZlYXR1cmUgdmVjdG9yXG5cblxuICBmb3IgKHZhciBjID0gMDsgYyA8IGs7IGMrKykge1xuICAgIGNlbnRyb2lkID0gW107XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbmRpbTsgX2krKykge1xuICAgICAgY2VudHJvaWRbX2ldID0gTWF0aC5yYW5kb20oKSAqIChtYXhbX2ldIC0gbWluW19pXSkgKyBtaW5bX2ldOyAvLyByYW5kb20gaW5pdGlhbCB2YWx1ZVxuICAgIH1cblxuICAgIGNlbnRyb2lkc1tjXSA9IGNlbnRyb2lkO1xuICB9XG5cbiAgcmV0dXJuIGNlbnRyb2lkcztcbn07XG5cbnZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIGNsYXNzaWZ5KG5vZGUsIGNlbnRyb2lkcywgZGlzdGFuY2UsIGF0dHJpYnV0ZXMsIHR5cGUpIHtcbiAgdmFyIG1pbiA9IEluZmluaXR5O1xuICB2YXIgaW5kZXggPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2VudHJvaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRpc3QgPSBnZXREaXN0KGRpc3RhbmNlLCBub2RlLCBjZW50cm9pZHNbaV0sIGF0dHJpYnV0ZXMsIHR5cGUpO1xuXG4gICAgaWYgKGRpc3QgPCBtaW4pIHtcbiAgICAgIG1pbiA9IGRpc3Q7XG4gICAgICBpbmRleCA9IGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluZGV4O1xufTtcblxudmFyIGJ1aWxkQ2x1c3RlciA9IGZ1bmN0aW9uIGJ1aWxkQ2x1c3RlcihjZW50cm9pZCwgbm9kZXMsIGFzc2lnbm1lbnQpIHtcbiAgdmFyIGNsdXN0ZXIgPSBbXTtcbiAgdmFyIG5vZGUgPSBudWxsO1xuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgbm9kZXMubGVuZ3RoOyBuKyspIHtcbiAgICBub2RlID0gbm9kZXNbbl07XG5cbiAgICBpZiAoYXNzaWdubWVudFtub2RlLmlkKCldID09PSBjZW50cm9pZCkge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIk5vZGUgXCIgKyBub2RlLmlkKCkgKyBcIiBpcyBhc3NvY2lhdGVkIHdpdGggbWVkb2lkICM6IFwiICsgbSk7XG4gICAgICBjbHVzdGVyLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNsdXN0ZXI7XG59O1xuXG52YXIgaGF2ZVZhbHVlc0NvbnZlcmdlZCA9IGZ1bmN0aW9uIGhhdmVWYWx1ZXNDb252ZXJnZWQodjEsIHYyLCBzZW5zaXRpdml0eVRocmVzaG9sZCkge1xuICByZXR1cm4gTWF0aC5hYnModjIgLSB2MSkgPD0gc2Vuc2l0aXZpdHlUaHJlc2hvbGQ7XG59O1xuXG52YXIgaGF2ZU1hdHJpY2VzQ29udmVyZ2VkID0gZnVuY3Rpb24gaGF2ZU1hdHJpY2VzQ29udmVyZ2VkKHYxLCB2Miwgc2Vuc2l0aXZpdHlUaHJlc2hvbGQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2MS5sZW5ndGg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdjFbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBkaWZmID0gTWF0aC5hYnModjFbaV1bal0gLSB2MltpXVtqXSk7XG5cbiAgICAgIGlmIChkaWZmID4gc2Vuc2l0aXZpdHlUaHJlc2hvbGQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIHNlZW5CZWZvcmUgPSBmdW5jdGlvbiBzZWVuQmVmb3JlKG5vZGUsIG1lZG9pZHMsIG4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBpZiAobm9kZSA9PT0gbWVkb2lkc1tpXSkgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgcmFuZG9tTWVkb2lkcyA9IGZ1bmN0aW9uIHJhbmRvbU1lZG9pZHMobm9kZXMsIGspIHtcbiAgdmFyIG1lZG9pZHMgPSBuZXcgQXJyYXkoayk7IC8vIEZvciBzbWFsbCBkYXRhIHNldHMsIHRoZSBwcm9iYWJpbGl0eSBvZiBtZWRvaWQgY29uZmxpY3QgaXMgZ3JlYXRlcixcbiAgLy8gc28gd2UgbmVlZCB0byBjaGVjayB0byBzZWUgaWYgd2UndmUgYWxyZWFkeSBzZWVuIG9yIGNob3NlIHRoaXMgbm9kZSBiZWZvcmUuXG5cbiAgaWYgKG5vZGVzLmxlbmd0aCA8IDUwKSB7XG4gICAgLy8gUmFuZG9tbHkgc2VsZWN0IGsgbWVkb2lkcyBmcm9tIHRoZSBuIG5vZGVzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbm9kZXMubGVuZ3RoKV07IC8vIElmIHdlJ3ZlIGFscmVhZHkgY2hvc2VuIHRoaXMgbm9kZSB0byBiZSBhIG1lZG9pZCwgZG9uJ3QgY2hvb3NlIGl0IGFnYWluIChmb3Igc21hbGwgZGF0YSBzZXRzKS5cbiAgICAgIC8vIEluc3RlYWQgY2hvb3NlIGEgZGlmZmVyZW50IHJhbmRvbSBub2RlLlxuXG4gICAgICB3aGlsZSAoc2VlbkJlZm9yZShub2RlLCBtZWRvaWRzLCBpKSkge1xuICAgICAgICBub2RlID0gbm9kZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbm9kZXMubGVuZ3RoKV07XG4gICAgICB9XG5cbiAgICAgIG1lZG9pZHNbaV0gPSBub2RlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBSZWxhdGl2ZWx5IGxhcmdlIGRhdGEgc2V0LCBzbyBwcmV0dHkgc2FmZSB0byBub3QgY2hlY2sgYW5kIGp1c3Qgc2VsZWN0IHJhbmRvbSBub2Rlc1xuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGs7IF9pMisrKSB7XG4gICAgICBtZWRvaWRzW19pMl0gPSBub2Rlc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBub2Rlcy5sZW5ndGgpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWVkb2lkcztcbn07XG5cbnZhciBmaW5kQ29zdCA9IGZ1bmN0aW9uIGZpbmRDb3N0KHBvdGVudGlhbE5ld01lZG9pZCwgY2x1c3RlciwgYXR0cmlidXRlcykge1xuICB2YXIgY29zdCA9IDA7XG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBjbHVzdGVyLmxlbmd0aDsgbisrKSB7XG4gICAgY29zdCArPSBnZXREaXN0KCdtYW5oYXR0YW4nLCBjbHVzdGVyW25dLCBwb3RlbnRpYWxOZXdNZWRvaWQsIGF0dHJpYnV0ZXMsICdrTWVkb2lkcycpO1xuICB9XG5cbiAgcmV0dXJuIGNvc3Q7XG59O1xuXG52YXIga01lYW5zID0gZnVuY3Rpb24ga01lYW5zKG9wdGlvbnMpIHtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gIHZhciBub2RlID0gbnVsbDsgLy8gU2V0IHBhcmFtZXRlcnMgb2YgYWxnb3JpdGhtOiAjIG9mIGNsdXN0ZXJzLCBkaXN0YW5jZSBtZXRyaWMsIGV0Yy5cblxuICB2YXIgb3B0cyA9IHNldE9wdGlvbnMkMihvcHRpb25zKTsgLy8gQmVnaW4gay1tZWFucyBhbGdvcml0aG1cblxuICB2YXIgY2x1c3RlcnMgPSBuZXcgQXJyYXkob3B0cy5rKTtcbiAgdmFyIGFzc2lnbm1lbnQgPSB7fTtcbiAgdmFyIGNlbnRyb2lkczsgLy8gU3RlcCAxOiBJbml0aWFsaXplIGNlbnRyb2lkIHBvc2l0aW9uc1xuXG4gIGlmIChvcHRzLnRlc3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzLnRlc3RDZW50cm9pZHMgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgYSBzZWVkZWQgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuXG4gICAgICBvcHRzLnRlc3RDZW50cm9pZHM7XG4gICAgICBjZW50cm9pZHMgPSByYW5kb21DZW50cm9pZHMobm9kZXMsIG9wdHMuaywgb3B0cy5hdHRyaWJ1dGVzKTtcbiAgICB9IGVsc2UgaWYgKF90eXBlb2Yob3B0cy50ZXN0Q2VudHJvaWRzKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNlbnRyb2lkcyA9IG9wdHMudGVzdENlbnRyb2lkcztcbiAgICB9IGVsc2Uge1xuICAgICAgY2VudHJvaWRzID0gcmFuZG9tQ2VudHJvaWRzKG5vZGVzLCBvcHRzLmssIG9wdHMuYXR0cmlidXRlcyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNlbnRyb2lkcyA9IHJhbmRvbUNlbnRyb2lkcyhub2Rlcywgb3B0cy5rLCBvcHRzLmF0dHJpYnV0ZXMpO1xuICB9XG5cbiAgdmFyIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICB2YXIgaXRlcmF0aW9ucyA9IDA7XG5cbiAgd2hpbGUgKGlzU3RpbGxNb3ZpbmcgJiYgaXRlcmF0aW9ucyA8IG9wdHMubWF4SXRlcmF0aW9ucykge1xuICAgIC8vIFN0ZXAgMjogQXNzaWduIG5vZGVzIHRvIHRoZSBuZWFyZXN0IGNlbnRyb2lkXG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBub2Rlcy5sZW5ndGg7IG4rKykge1xuICAgICAgbm9kZSA9IG5vZGVzW25dOyAvLyBEZXRlcm1pbmUgd2hpY2ggY2x1c3RlciB0aGlzIG5vZGUgYmVsb25ncyB0bzogbm9kZSBpZCA9PiBjbHVzdGVyICNcblxuICAgICAgYXNzaWdubWVudFtub2RlLmlkKCldID0gY2xhc3NpZnkobm9kZSwgY2VudHJvaWRzLCBvcHRzLmRpc3RhbmNlLCBvcHRzLmF0dHJpYnV0ZXMsICdrTWVhbnMnKTtcbiAgICB9IC8vIFN0ZXAgMzogRm9yIGVhY2ggb2YgdGhlIGsgY2x1c3RlcnMsIHVwZGF0ZSBpdHMgY2VudHJvaWRcblxuXG4gICAgaXNTdGlsbE1vdmluZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBvcHRzLms7IGMrKykge1xuICAgICAgLy8gR2V0IGFsbCBub2RlcyB0aGF0IGJlbG9uZyB0byB0aGlzIGNsdXN0ZXJcbiAgICAgIHZhciBjbHVzdGVyID0gYnVpbGRDbHVzdGVyKGMsIG5vZGVzLCBhc3NpZ25tZW50KTtcblxuICAgICAgaWYgKGNsdXN0ZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIElmIGNsdXN0ZXIgaXMgZW1wdHksIGJyZWFrIG91dCBlYXJseSAmIG1vdmUgdG8gbmV4dCBjbHVzdGVyXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBVcGRhdGUgY2VudHJvaWRzIGJ5IGNhbGN1bGF0aW5nIGF2ZyBvZiBhbGwgbm9kZXMgd2l0aGluIHRoZSBjbHVzdGVyLlxuXG5cbiAgICAgIHZhciBuZGltID0gb3B0cy5hdHRyaWJ1dGVzLmxlbmd0aDtcbiAgICAgIHZhciBjZW50cm9pZCA9IGNlbnRyb2lkc1tjXTsgLy8gWyBkaW1fMSwgZGltXzIsIGRpbV8zLCAuLi4gLCBkaW1fbiBdXG5cbiAgICAgIHZhciBuZXdDZW50cm9pZCA9IG5ldyBBcnJheShuZGltKTtcbiAgICAgIHZhciBzdW0gPSBuZXcgQXJyYXkobmRpbSk7XG5cbiAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgbmRpbTsgZCsrKSB7XG4gICAgICAgIHN1bVtkXSA9IDAuMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsdXN0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlID0gY2x1c3RlcltpXTtcbiAgICAgICAgICBzdW1bZF0gKz0gb3B0cy5hdHRyaWJ1dGVzW2RdKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3Q2VudHJvaWRbZF0gPSBzdW1bZF0gLyBjbHVzdGVyLmxlbmd0aDsgLy8gQ2hlY2sgdG8gc2VlIGlmIGFsZ29yaXRobSBoYXMgY29udmVyZ2VkLCBpLmUuIHdoZW4gY2VudHJvaWRzIG5vIGxvbmdlciBjaGFuZ2VcblxuICAgICAgICBpZiAoIWhhdmVWYWx1ZXNDb252ZXJnZWQobmV3Q2VudHJvaWRbZF0sIGNlbnRyb2lkW2RdLCBvcHRzLnNlbnNpdGl2aXR5VGhyZXNob2xkKSkge1xuICAgICAgICAgIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNlbnRyb2lkc1tjXSA9IG5ld0NlbnRyb2lkO1xuICAgICAgY2x1c3RlcnNbY10gPSBjeS5jb2xsZWN0aW9uKGNsdXN0ZXIpO1xuICAgIH1cblxuICAgIGl0ZXJhdGlvbnMrKztcbiAgfVxuXG4gIHJldHVybiBjbHVzdGVycztcbn07XG5cbnZhciBrTWVkb2lkcyA9IGZ1bmN0aW9uIGtNZWRvaWRzKG9wdGlvbnMpIHtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gIHZhciBub2RlID0gbnVsbDtcbiAgdmFyIG9wdHMgPSBzZXRPcHRpb25zJDIob3B0aW9ucyk7IC8vIEJlZ2luIGstbWVkb2lkcyBhbGdvcml0aG1cblxuICB2YXIgY2x1c3RlcnMgPSBuZXcgQXJyYXkob3B0cy5rKTtcbiAgdmFyIG1lZG9pZHM7XG4gIHZhciBhc3NpZ25tZW50ID0ge307XG4gIHZhciBjdXJDb3N0O1xuICB2YXIgbWluQ29zdHMgPSBuZXcgQXJyYXkob3B0cy5rKTsgLy8gbWluaW11bSBjb3N0IGNvbmZpZ3VyYXRpb24gZm9yIGVhY2ggY2x1c3RlclxuICAvLyBTdGVwIDE6IEluaXRpYWxpemUgayBtZWRvaWRzXG5cbiAgaWYgKG9wdHMudGVzdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMudGVzdENlbnRyb2lkcyA9PT0gJ251bWJlcicpIDsgZWxzZSBpZiAoX3R5cGVvZihvcHRzLnRlc3RDZW50cm9pZHMpID09PSAnb2JqZWN0Jykge1xuICAgICAgbWVkb2lkcyA9IG9wdHMudGVzdENlbnRyb2lkcztcbiAgICB9IGVsc2Uge1xuICAgICAgbWVkb2lkcyA9IHJhbmRvbU1lZG9pZHMobm9kZXMsIG9wdHMuayk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1lZG9pZHMgPSByYW5kb21NZWRvaWRzKG5vZGVzLCBvcHRzLmspO1xuICB9XG5cbiAgdmFyIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICB2YXIgaXRlcmF0aW9ucyA9IDA7XG5cbiAgd2hpbGUgKGlzU3RpbGxNb3ZpbmcgJiYgaXRlcmF0aW9ucyA8IG9wdHMubWF4SXRlcmF0aW9ucykge1xuICAgIC8vIFN0ZXAgMjogQXNzaWduIG5vZGVzIHRvIHRoZSBuZWFyZXN0IG1lZG9pZFxuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbm9kZXMubGVuZ3RoOyBuKyspIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tuXTsgLy8gRGV0ZXJtaW5lIHdoaWNoIGNsdXN0ZXIgdGhpcyBub2RlIGJlbG9uZ3MgdG86IG5vZGUgaWQgPT4gY2x1c3RlciAjXG5cbiAgICAgIGFzc2lnbm1lbnRbbm9kZS5pZCgpXSA9IGNsYXNzaWZ5KG5vZGUsIG1lZG9pZHMsIG9wdHMuZGlzdGFuY2UsIG9wdHMuYXR0cmlidXRlcywgJ2tNZWRvaWRzJyk7XG4gICAgfVxuXG4gICAgaXNTdGlsbE1vdmluZyA9IGZhbHNlOyAvLyBTdGVwIDM6IEZvciBlYWNoIG1lZG9pZCBtLCBhbmQgZm9yIGVhY2ggbm9kZSBhc3NvY2lhdGVkIHdpdGggbWVkaW9kIG0sXG4gICAgLy8gc2VsZWN0IHRoZSBub2RlIHdpdGggdGhlIGxvd2VzdCBjb25maWd1cmF0aW9uIGNvc3QgYXMgbmV3IG1lZG9pZC5cblxuICAgIGZvciAodmFyIG0gPSAwOyBtIDwgbWVkb2lkcy5sZW5ndGg7IG0rKykge1xuICAgICAgLy8gR2V0IGFsbCBub2RlcyB0aGF0IGJlbG9uZyB0byB0aGlzIG1lZG9pZFxuICAgICAgdmFyIGNsdXN0ZXIgPSBidWlsZENsdXN0ZXIobSwgbm9kZXMsIGFzc2lnbm1lbnQpO1xuXG4gICAgICBpZiAoY2x1c3Rlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gSWYgY2x1c3RlciBpcyBlbXB0eSwgYnJlYWsgb3V0IGVhcmx5ICYgbW92ZSB0byBuZXh0IGNsdXN0ZXJcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIG1pbkNvc3RzW21dID0gZmluZENvc3QobWVkb2lkc1ttXSwgY2x1c3Rlciwgb3B0cy5hdHRyaWJ1dGVzKTsgLy8gb3JpZ2luYWwgY29zdFxuICAgICAgLy8gU2VsZWN0IGRpZmZlcmVudCBtZWRvaWQgaWYgaXRzIGNvbmZpZ3VyYXRpb24gaGFzIHRoZSBsb3dlc3QgY29zdFxuXG4gICAgICBmb3IgKHZhciBfbiA9IDA7IF9uIDwgY2x1c3Rlci5sZW5ndGg7IF9uKyspIHtcbiAgICAgICAgY3VyQ29zdCA9IGZpbmRDb3N0KGNsdXN0ZXJbX25dLCBjbHVzdGVyLCBvcHRzLmF0dHJpYnV0ZXMpO1xuXG4gICAgICAgIGlmIChjdXJDb3N0IDwgbWluQ29zdHNbbV0pIHtcbiAgICAgICAgICBtaW5Db3N0c1ttXSA9IGN1ckNvc3Q7XG4gICAgICAgICAgbWVkb2lkc1ttXSA9IGNsdXN0ZXJbX25dO1xuICAgICAgICAgIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNsdXN0ZXJzW21dID0gY3kuY29sbGVjdGlvbihjbHVzdGVyKTtcbiAgICB9XG5cbiAgICBpdGVyYXRpb25zKys7XG4gIH1cblxuICByZXR1cm4gY2x1c3RlcnM7XG59O1xuXG52YXIgdXBkYXRlQ2VudHJvaWRzID0gZnVuY3Rpb24gdXBkYXRlQ2VudHJvaWRzKGNlbnRyb2lkcywgbm9kZXMsIFUsIHdlaWdodCwgb3B0cykge1xuICB2YXIgbnVtZXJhdG9yLCBkZW5vbWluYXRvcjtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IG5vZGVzLmxlbmd0aDsgbisrKSB7XG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjZW50cm9pZHMubGVuZ3RoOyBjKyspIHtcbiAgICAgIHdlaWdodFtuXVtjXSA9IE1hdGgucG93KFVbbl1bY10sIG9wdHMubSk7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX2MgPSAwOyBfYyA8IGNlbnRyb2lkcy5sZW5ndGg7IF9jKyspIHtcbiAgICBmb3IgKHZhciBkaW0gPSAwOyBkaW0gPCBvcHRzLmF0dHJpYnV0ZXMubGVuZ3RoOyBkaW0rKykge1xuICAgICAgbnVtZXJhdG9yID0gMDtcbiAgICAgIGRlbm9taW5hdG9yID0gMDtcblxuICAgICAgZm9yICh2YXIgX24yID0gMDsgX24yIDwgbm9kZXMubGVuZ3RoOyBfbjIrKykge1xuICAgICAgICBudW1lcmF0b3IgKz0gd2VpZ2h0W19uMl1bX2NdICogb3B0cy5hdHRyaWJ1dGVzW2RpbV0obm9kZXNbX24yXSk7XG4gICAgICAgIGRlbm9taW5hdG9yICs9IHdlaWdodFtfbjJdW19jXTtcbiAgICAgIH1cblxuICAgICAgY2VudHJvaWRzW19jXVtkaW1dID0gbnVtZXJhdG9yIC8gZGVub21pbmF0b3I7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdXBkYXRlTWVtYmVyc2hpcCA9IGZ1bmN0aW9uIHVwZGF0ZU1lbWJlcnNoaXAoVSwgX1UsIGNlbnRyb2lkcywgbm9kZXMsIG9wdHMpIHtcbiAgLy8gU2F2ZSBwcmV2aW91cyBzdGVwXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgVS5sZW5ndGg7IGkrKykge1xuICAgIF9VW2ldID0gVVtpXS5zbGljZSgpO1xuICB9XG5cbiAgdmFyIHN1bSwgbnVtZXJhdG9yLCBkZW5vbWluYXRvcjtcbiAgdmFyIHBvdyA9IDIgLyAob3B0cy5tIC0gMSk7XG5cbiAgZm9yICh2YXIgYyA9IDA7IGMgPCBjZW50cm9pZHMubGVuZ3RoOyBjKyspIHtcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IG5vZGVzLmxlbmd0aDsgbisrKSB7XG4gICAgICBzdW0gPSAwO1xuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGNlbnRyb2lkcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAvLyBhZ2FpbnN0IGFsbCBvdGhlciBjZW50cm9pZHNcbiAgICAgICAgbnVtZXJhdG9yID0gZ2V0RGlzdChvcHRzLmRpc3RhbmNlLCBub2Rlc1tuXSwgY2VudHJvaWRzW2NdLCBvcHRzLmF0dHJpYnV0ZXMsICdjbWVhbnMnKTtcbiAgICAgICAgZGVub21pbmF0b3IgPSBnZXREaXN0KG9wdHMuZGlzdGFuY2UsIG5vZGVzW25dLCBjZW50cm9pZHNba10sIG9wdHMuYXR0cmlidXRlcywgJ2NtZWFucycpO1xuICAgICAgICBzdW0gKz0gTWF0aC5wb3cobnVtZXJhdG9yIC8gZGVub21pbmF0b3IsIHBvdyk7XG4gICAgICB9XG5cbiAgICAgIFVbbl1bY10gPSAxIC8gc3VtO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGFzc2lnbiQxID0gZnVuY3Rpb24gYXNzaWduKG5vZGVzLCBVLCBvcHRzLCBjeSkge1xuICB2YXIgY2x1c3RlcnMgPSBuZXcgQXJyYXkob3B0cy5rKTtcblxuICBmb3IgKHZhciBjID0gMDsgYyA8IGNsdXN0ZXJzLmxlbmd0aDsgYysrKSB7XG4gICAgY2x1c3RlcnNbY10gPSBbXTtcbiAgfVxuXG4gIHZhciBtYXg7XG4gIHZhciBpbmRleDtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IFUubGVuZ3RoOyBuKyspIHtcbiAgICAvLyBmb3IgZWFjaCBub2RlIChVIGlzIE4geCBDIG1hdHJpeClcbiAgICBtYXggPSAtSW5maW5pdHk7XG4gICAgaW5kZXggPSAtMTsgLy8gRGV0ZXJtaW5lIHdoaWNoIGNsdXN0ZXIgdGhlIG5vZGUgaXMgbW9zdCBsaWtlbHkgdG8gYmVsb25nIGluXG5cbiAgICBmb3IgKHZhciBfYzIgPSAwOyBfYzIgPCBVWzBdLmxlbmd0aDsgX2MyKyspIHtcbiAgICAgIGlmIChVW25dW19jMl0gPiBtYXgpIHtcbiAgICAgICAgbWF4ID0gVVtuXVtfYzJdO1xuICAgICAgICBpbmRleCA9IF9jMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjbHVzdGVyc1tpbmRleF0ucHVzaChub2Rlc1tuXSk7XG4gIH0gLy8gVHVybiBldmVyeSBhcnJheSBpbnRvIGEgY29sbGVjdGlvbiBvZiBub2Rlc1xuXG5cbiAgZm9yICh2YXIgX2MzID0gMDsgX2MzIDwgY2x1c3RlcnMubGVuZ3RoOyBfYzMrKykge1xuICAgIGNsdXN0ZXJzW19jM10gPSBjeS5jb2xsZWN0aW9uKGNsdXN0ZXJzW19jM10pO1xuICB9XG5cbiAgcmV0dXJuIGNsdXN0ZXJzO1xufTtcblxudmFyIGZ1enp5Q01lYW5zID0gZnVuY3Rpb24gZnV6enlDTWVhbnMob3B0aW9ucykge1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgdmFyIG9wdHMgPSBzZXRPcHRpb25zJDIob3B0aW9ucyk7IC8vIEJlZ2luIGZ1enp5IGMtbWVhbnMgYWxnb3JpdGhtXG5cbiAgdmFyIGNsdXN0ZXJzO1xuICB2YXIgY2VudHJvaWRzO1xuICB2YXIgVTtcblxuICB2YXIgX1U7XG5cbiAgdmFyIHdlaWdodDsgLy8gU3RlcCAxOiBJbml0aWFsaXplIGxldGlhYmxlcy5cblxuICBfVSA9IG5ldyBBcnJheShub2Rlcy5sZW5ndGgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOIHggQyBtYXRyaXhcbiAgICBfVVtpXSA9IG5ldyBBcnJheShvcHRzLmspO1xuICB9XG5cbiAgVSA9IG5ldyBBcnJheShub2Rlcy5sZW5ndGgpO1xuXG4gIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG5vZGVzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAvLyBOIHggQyBtYXRyaXhcbiAgICBVW19pM10gPSBuZXcgQXJyYXkob3B0cy5rKTtcbiAgfVxuXG4gIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG5vZGVzLmxlbmd0aDsgX2k0KyspIHtcbiAgICB2YXIgdG90YWwgPSAwO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBvcHRzLms7IGorKykge1xuICAgICAgVVtfaTRdW2pdID0gTWF0aC5yYW5kb20oKTtcbiAgICAgIHRvdGFsICs9IFVbX2k0XVtqXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgb3B0cy5rOyBfaisrKSB7XG4gICAgICBVW19pNF1bX2pdID0gVVtfaTRdW19qXSAvIHRvdGFsO1xuICAgIH1cbiAgfVxuXG4gIGNlbnRyb2lkcyA9IG5ldyBBcnJheShvcHRzLmspO1xuXG4gIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IG9wdHMuazsgX2k1KyspIHtcbiAgICBjZW50cm9pZHNbX2k1XSA9IG5ldyBBcnJheShvcHRzLmF0dHJpYnV0ZXMubGVuZ3RoKTtcbiAgfVxuXG4gIHdlaWdodCA9IG5ldyBBcnJheShub2Rlcy5sZW5ndGgpO1xuXG4gIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IG5vZGVzLmxlbmd0aDsgX2k2KyspIHtcbiAgICAvLyBOIHggQyBtYXRyaXhcbiAgICB3ZWlnaHRbX2k2XSA9IG5ldyBBcnJheShvcHRzLmspO1xuICB9IC8vIGVuZCBpbml0IEZDTVxuXG5cbiAgdmFyIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICB2YXIgaXRlcmF0aW9ucyA9IDA7XG5cbiAgd2hpbGUgKGlzU3RpbGxNb3ZpbmcgJiYgaXRlcmF0aW9ucyA8IG9wdHMubWF4SXRlcmF0aW9ucykge1xuICAgIGlzU3RpbGxNb3ZpbmcgPSBmYWxzZTsgLy8gU3RlcCAyOiBDYWxjdWxhdGUgdGhlIGNlbnRyb2lkcyBmb3IgZWFjaCBzdGVwLlxuXG4gICAgdXBkYXRlQ2VudHJvaWRzKGNlbnRyb2lkcywgbm9kZXMsIFUsIHdlaWdodCwgb3B0cyk7IC8vIFN0ZXAgMzogVXBkYXRlIHRoZSBwYXJ0aXRpb24gbWF0cml4IFUuXG5cbiAgICB1cGRhdGVNZW1iZXJzaGlwKFUsIF9VLCBjZW50cm9pZHMsIG5vZGVzLCBvcHRzKTsgLy8gU3RlcCA0OiBDaGVjayBmb3IgY29udmVyZ2VuY2UuXG5cbiAgICBpZiAoIWhhdmVNYXRyaWNlc0NvbnZlcmdlZChVLCBfVSwgb3B0cy5zZW5zaXRpdml0eVRocmVzaG9sZCkpIHtcbiAgICAgIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICAgIH1cblxuICAgIGl0ZXJhdGlvbnMrKztcbiAgfSAvLyBBc3NpZ24gbm9kZXMgdG8gY2x1c3RlcnMgd2l0aCBoaWdoZXN0IHByb2JhYmlsaXR5LlxuXG5cbiAgY2x1c3RlcnMgPSBhc3NpZ24kMShub2RlcywgVSwgb3B0cywgY3kpO1xuICByZXR1cm4ge1xuICAgIGNsdXN0ZXJzOiBjbHVzdGVycyxcbiAgICBkZWdyZWVPZk1lbWJlcnNoaXA6IFVcbiAgfTtcbn07XG5cbnZhciBrQ2x1c3RlcmluZyA9IHtcbiAga01lYW5zOiBrTWVhbnMsXG4gIGtNZWRvaWRzOiBrTWVkb2lkcyxcbiAgZnV6enlDTWVhbnM6IGZ1enp5Q01lYW5zLFxuICBmY206IGZ1enp5Q01lYW5zXG59O1xuXG4vLyBJbXBsZW1lbnRlZCBieSBab2UgWGkgQHpvZXhpIGZvciBHU09DIDIwMTZcbnZhciBkZWZhdWx0cyRhID0gZGVmYXVsdHMkZyh7XG4gIGRpc3RhbmNlOiAnZXVjbGlkZWFuJyxcbiAgLy8gZGlzdGFuY2UgbWV0cmljIHRvIGNvbXBhcmUgbm9kZXNcbiAgbGlua2FnZTogJ21pbicsXG4gIC8vIGxpbmthZ2UgY3JpdGVyaW9uIDogaG93IHRvIGRldGVybWluZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiBjbHVzdGVycyBvZiBub2Rlc1xuICBtb2RlOiAndGhyZXNob2xkJyxcbiAgLy8gbW9kZTondGhyZXNob2xkJyA9PiBjbHVzdGVycyBtdXN0IGJlIHRocmVzaG9sZCBkaXN0YW5jZSBhcGFydFxuICB0aHJlc2hvbGQ6IEluZmluaXR5LFxuICAvLyB0aGUgZGlzdGFuY2UgdGhyZXNob2xkXG4gIC8vIG1vZGU6J2RlbmRyb2dyYW0nID0+IHRoZSBub2RlcyBhcmUgb3JnYW5pc2VkIGFzIGxlYXZlcyBpbiBhIHRyZWUgKHNpYmxpbmdzIGFyZSBjbG9zZSksIG1lcmdpbmcgbWFrZXMgY2x1c3RlcnNcbiAgYWRkRGVuZHJvZ3JhbTogZmFsc2UsXG4gIC8vIHdoZXRoZXIgdG8gYWRkIHRoZSBkZW5kcm9ncmFtIHRvIHRoZSBncmFwaCBmb3Igdml6XG4gIGRlbmRyb2dyYW1EZXB0aDogMCxcbiAgLy8gZGVwdGggYXQgd2hpY2ggZGVuZHJvZ3JhbSBicmFuY2hlcyBhcmUgbWVyZ2VkIGludG8gdGhlIHJldHVybmVkIGNsdXN0ZXJzXG4gIGF0dHJpYnV0ZXM6IFtdIC8vIGFycmF5IG9mIGF0dHIgZnVuY3Rpb25zXG5cbn0pO1xudmFyIGxpbmthZ2VBbGlhc2VzID0ge1xuICAnc2luZ2xlJzogJ21pbicsXG4gICdjb21wbGV0ZSc6ICdtYXgnXG59O1xuXG52YXIgc2V0T3B0aW9ucyQxID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gZGVmYXVsdHMkYShvcHRpb25zKTtcbiAgdmFyIHByZWZlcnJlZEFsaWFzID0gbGlua2FnZUFsaWFzZXNbb3B0cy5saW5rYWdlXTtcblxuICBpZiAocHJlZmVycmVkQWxpYXMgIT0gbnVsbCkge1xuICAgIG9wdHMubGlua2FnZSA9IHByZWZlcnJlZEFsaWFzO1xuICB9XG5cbiAgcmV0dXJuIG9wdHM7XG59O1xuXG52YXIgbWVyZ2VDbG9zZXN0ID0gZnVuY3Rpb24gbWVyZ2VDbG9zZXN0KGNsdXN0ZXJzLCBpbmRleCwgZGlzdHMsIG1pbnMsIG9wdHMpIHtcbiAgLy8gRmluZCB0d28gY2xvc2VzdCBjbHVzdGVycyBmcm9tIGNhY2hlZCBtaW5zXG4gIHZhciBtaW5LZXkgPSAwO1xuICB2YXIgbWluID0gSW5maW5pdHk7XG4gIHZhciBkaXN0O1xuICB2YXIgYXR0cnMgPSBvcHRzLmF0dHJpYnV0ZXM7XG5cbiAgdmFyIGdldERpc3QgPSBmdW5jdGlvbiBnZXREaXN0KG4xLCBuMikge1xuICAgIHJldHVybiBjbHVzdGVyaW5nRGlzdGFuY2Uob3B0cy5kaXN0YW5jZSwgYXR0cnMubGVuZ3RoLCBmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGF0dHJzW2ldKG4xKTtcbiAgICB9LCBmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGF0dHJzW2ldKG4yKTtcbiAgICB9LCBuMSwgbjIpO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gY2x1c3RlcnNbaV0ua2V5O1xuICAgIHZhciBfZGlzdCA9IGRpc3RzW2tleV1bbWluc1trZXldXTtcblxuICAgIGlmIChfZGlzdCA8IG1pbikge1xuICAgICAgbWluS2V5ID0ga2V5O1xuICAgICAgbWluID0gX2Rpc3Q7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMubW9kZSA9PT0gJ3RocmVzaG9sZCcgJiYgbWluID49IG9wdHMudGhyZXNob2xkIHx8IG9wdHMubW9kZSA9PT0gJ2RlbmRyb2dyYW0nICYmIGNsdXN0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBjMSA9IGluZGV4W21pbktleV07XG4gIHZhciBjMiA9IGluZGV4W21pbnNbbWluS2V5XV07XG4gIHZhciBtZXJnZWQ7IC8vIE1lcmdlIHR3byBjbG9zZXN0IGNsdXN0ZXJzXG5cbiAgaWYgKG9wdHMubW9kZSA9PT0gJ2RlbmRyb2dyYW0nKSB7XG4gICAgbWVyZ2VkID0ge1xuICAgICAgbGVmdDogYzEsXG4gICAgICByaWdodDogYzIsXG4gICAgICBrZXk6IGMxLmtleVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbWVyZ2VkID0ge1xuICAgICAgdmFsdWU6IGMxLnZhbHVlLmNvbmNhdChjMi52YWx1ZSksXG4gICAgICBrZXk6IGMxLmtleVxuICAgIH07XG4gIH1cblxuICBjbHVzdGVyc1tjMS5pbmRleF0gPSBtZXJnZWQ7XG4gIGNsdXN0ZXJzLnNwbGljZShjMi5pbmRleCwgMSk7XG4gIGluZGV4W2MxLmtleV0gPSBtZXJnZWQ7IC8vIFVwZGF0ZSBkaXN0YW5jZXMgd2l0aCBuZXcgbWVyZ2VkIGNsdXN0ZXJcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgY2x1c3RlcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIGN1ciA9IGNsdXN0ZXJzW19pXTtcblxuICAgIGlmIChjMS5rZXkgPT09IGN1ci5rZXkpIHtcbiAgICAgIGRpc3QgPSBJbmZpbml0eTtcbiAgICB9IGVsc2UgaWYgKG9wdHMubGlua2FnZSA9PT0gJ21pbicpIHtcbiAgICAgIGRpc3QgPSBkaXN0c1tjMS5rZXldW2N1ci5rZXldO1xuXG4gICAgICBpZiAoZGlzdHNbYzEua2V5XVtjdXIua2V5XSA+IGRpc3RzW2MyLmtleV1bY3VyLmtleV0pIHtcbiAgICAgICAgZGlzdCA9IGRpc3RzW2MyLmtleV1bY3VyLmtleV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRzLmxpbmthZ2UgPT09ICdtYXgnKSB7XG4gICAgICBkaXN0ID0gZGlzdHNbYzEua2V5XVtjdXIua2V5XTtcblxuICAgICAgaWYgKGRpc3RzW2MxLmtleV1bY3VyLmtleV0gPCBkaXN0c1tjMi5rZXldW2N1ci5rZXldKSB7XG4gICAgICAgIGRpc3QgPSBkaXN0c1tjMi5rZXldW2N1ci5rZXldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0cy5saW5rYWdlID09PSAnbWVhbicpIHtcbiAgICAgIGRpc3QgPSAoZGlzdHNbYzEua2V5XVtjdXIua2V5XSAqIGMxLnNpemUgKyBkaXN0c1tjMi5rZXldW2N1ci5rZXldICogYzIuc2l6ZSkgLyAoYzEuc2l6ZSArIGMyLnNpemUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0cy5tb2RlID09PSAnZGVuZHJvZ3JhbScpIGRpc3QgPSBnZXREaXN0KGN1ci52YWx1ZSwgYzEudmFsdWUpO2Vsc2UgZGlzdCA9IGdldERpc3QoY3VyLnZhbHVlWzBdLCBjMS52YWx1ZVswXSk7XG4gICAgfVxuXG4gICAgZGlzdHNbYzEua2V5XVtjdXIua2V5XSA9IGRpc3RzW2N1ci5rZXldW2MxLmtleV0gPSBkaXN0OyAvLyBkaXN0YW5jZSBtYXRyaXggaXMgc3ltbWV0cmljXG4gIH0gLy8gVXBkYXRlIGNhY2hlZCBtaW5zXG5cblxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBjbHVzdGVycy5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIGtleTEgPSBjbHVzdGVyc1tfaTJdLmtleTtcblxuICAgIGlmIChtaW5zW2tleTFdID09PSBjMS5rZXkgfHwgbWluc1trZXkxXSA9PT0gYzIua2V5KSB7XG4gICAgICB2YXIgX21pbiA9IGtleTE7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2x1c3RlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGtleTIgPSBjbHVzdGVyc1tqXS5rZXk7XG5cbiAgICAgICAgaWYgKGRpc3RzW2tleTFdW2tleTJdIDwgZGlzdHNba2V5MV1bX21pbl0pIHtcbiAgICAgICAgICBfbWluID0ga2V5MjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtaW5zW2tleTFdID0gX21pbjtcbiAgICB9XG5cbiAgICBjbHVzdGVyc1tfaTJdLmluZGV4ID0gX2kyO1xuICB9IC8vIENsZWFuIHVwIG1ldGEgZGF0YSB1c2VkIGZvciBjbHVzdGVyaW5nXG5cblxuICBjMS5rZXkgPSBjMi5rZXkgPSBjMS5pbmRleCA9IGMyLmluZGV4ID0gbnVsbDtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgZ2V0QWxsQ2hpbGRyZW4gPSBmdW5jdGlvbiBnZXRBbGxDaGlsZHJlbihyb290LCBhcnIsIGN5KSB7XG4gIGlmICghcm9vdCkgcmV0dXJuO1xuXG4gIGlmIChyb290LnZhbHVlKSB7XG4gICAgYXJyLnB1c2gocm9vdC52YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHJvb3QubGVmdCkgZ2V0QWxsQ2hpbGRyZW4ocm9vdC5sZWZ0LCBhcnIpO1xuICAgIGlmIChyb290LnJpZ2h0KSBnZXRBbGxDaGlsZHJlbihyb290LnJpZ2h0LCBhcnIpO1xuICB9XG59O1xuXG52YXIgYnVpbGREZW5kcm9ncmFtID0gZnVuY3Rpb24gYnVpbGREZW5kcm9ncmFtKHJvb3QsIGN5KSB7XG4gIGlmICghcm9vdCkgcmV0dXJuICcnO1xuXG4gIGlmIChyb290LmxlZnQgJiYgcm9vdC5yaWdodCkge1xuICAgIHZhciBsZWZ0U3RyID0gYnVpbGREZW5kcm9ncmFtKHJvb3QubGVmdCwgY3kpO1xuICAgIHZhciByaWdodFN0ciA9IGJ1aWxkRGVuZHJvZ3JhbShyb290LnJpZ2h0LCBjeSk7XG4gICAgdmFyIG5vZGUgPSBjeS5hZGQoe1xuICAgICAgZ3JvdXA6ICdub2RlcycsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGlkOiBsZWZ0U3RyICsgJywnICsgcmlnaHRTdHJcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjeS5hZGQoe1xuICAgICAgZ3JvdXA6ICdlZGdlcycsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHNvdXJjZTogbGVmdFN0cixcbiAgICAgICAgdGFyZ2V0OiBub2RlLmlkKClcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjeS5hZGQoe1xuICAgICAgZ3JvdXA6ICdlZGdlcycsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHNvdXJjZTogcmlnaHRTdHIsXG4gICAgICAgIHRhcmdldDogbm9kZS5pZCgpXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGUuaWQoKTtcbiAgfSBlbHNlIGlmIChyb290LnZhbHVlKSB7XG4gICAgcmV0dXJuIHJvb3QudmFsdWUuaWQoKTtcbiAgfVxufTtcblxudmFyIGJ1aWxkQ2x1c3RlcnNGcm9tVHJlZSA9IGZ1bmN0aW9uIGJ1aWxkQ2x1c3RlcnNGcm9tVHJlZShyb290LCBrLCBjeSkge1xuICBpZiAoIXJvb3QpIHJldHVybiBbXTtcbiAgdmFyIGxlZnQgPSBbXSxcbiAgICAgIHJpZ2h0ID0gW10sXG4gICAgICBsZWF2ZXMgPSBbXTtcblxuICBpZiAoayA9PT0gMCkge1xuICAgIC8vIGRvbid0IGN1dCB0cmVlLCBzaW1wbHkgcmV0dXJuIGFsbCBub2RlcyBhcyAxIHNpbmdsZSBjbHVzdGVyXG4gICAgaWYgKHJvb3QubGVmdCkgZ2V0QWxsQ2hpbGRyZW4ocm9vdC5sZWZ0LCBsZWZ0KTtcbiAgICBpZiAocm9vdC5yaWdodCkgZ2V0QWxsQ2hpbGRyZW4ocm9vdC5yaWdodCwgcmlnaHQpO1xuICAgIGxlYXZlcyA9IGxlZnQuY29uY2F0KHJpZ2h0KTtcbiAgICByZXR1cm4gW2N5LmNvbGxlY3Rpb24obGVhdmVzKV07XG4gIH0gZWxzZSBpZiAoayA9PT0gMSkge1xuICAgIC8vIGN1dCBhdCByb290XG4gICAgaWYgKHJvb3QudmFsdWUpIHtcbiAgICAgIC8vIGxlYWYgbm9kZVxuICAgICAgcmV0dXJuIFtjeS5jb2xsZWN0aW9uKHJvb3QudmFsdWUpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJvb3QubGVmdCkgZ2V0QWxsQ2hpbGRyZW4ocm9vdC5sZWZ0LCBsZWZ0KTtcbiAgICAgIGlmIChyb290LnJpZ2h0KSBnZXRBbGxDaGlsZHJlbihyb290LnJpZ2h0LCByaWdodCk7XG4gICAgICByZXR1cm4gW2N5LmNvbGxlY3Rpb24obGVmdCksIGN5LmNvbGxlY3Rpb24ocmlnaHQpXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHJvb3QudmFsdWUpIHtcbiAgICAgIHJldHVybiBbY3kuY29sbGVjdGlvbihyb290LnZhbHVlKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyb290LmxlZnQpIGxlZnQgPSBidWlsZENsdXN0ZXJzRnJvbVRyZWUocm9vdC5sZWZ0LCBrIC0gMSwgY3kpO1xuICAgICAgaWYgKHJvb3QucmlnaHQpIHJpZ2h0ID0gYnVpbGRDbHVzdGVyc0Zyb21UcmVlKHJvb3QucmlnaHQsIGsgLSAxLCBjeSk7XG4gICAgICByZXR1cm4gbGVmdC5jb25jYXQocmlnaHQpO1xuICAgIH1cbiAgfVxufTtcbi8qIGVzbGludC1lbmFibGUgKi9cblxuXG52YXIgaGllcmFyY2hpY2FsQ2x1c3RlcmluZyA9IGZ1bmN0aW9uIGhpZXJhcmNoaWNhbENsdXN0ZXJpbmcob3B0aW9ucykge1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTsgLy8gU2V0IHBhcmFtZXRlcnMgb2YgYWxnb3JpdGhtOiBsaW5rYWdlIHR5cGUsIGRpc3RhbmNlIG1ldHJpYywgZXRjLlxuXG4gIHZhciBvcHRzID0gc2V0T3B0aW9ucyQxKG9wdGlvbnMpO1xuICB2YXIgYXR0cnMgPSBvcHRzLmF0dHJpYnV0ZXM7XG5cbiAgdmFyIGdldERpc3QgPSBmdW5jdGlvbiBnZXREaXN0KG4xLCBuMikge1xuICAgIHJldHVybiBjbHVzdGVyaW5nRGlzdGFuY2Uob3B0cy5kaXN0YW5jZSwgYXR0cnMubGVuZ3RoLCBmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGF0dHJzW2ldKG4xKTtcbiAgICB9LCBmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGF0dHJzW2ldKG4yKTtcbiAgICB9LCBuMSwgbjIpO1xuICB9OyAvLyBCZWdpbiBoaWVyYXJjaGljYWwgYWxnb3JpdGhtXG5cblxuICB2YXIgY2x1c3RlcnMgPSBbXTtcbiAgdmFyIGRpc3RzID0gW107IC8vIGRpc3RhbmNlcyBiZXR3ZWVuIGVhY2ggcGFpciBvZiBjbHVzdGVyc1xuXG4gIHZhciBtaW5zID0gW107IC8vIGNsb3Nlc3QgY2x1c3RlciBmb3IgZWFjaCBjbHVzdGVyXG5cbiAgdmFyIGluZGV4ID0gW107IC8vIGhhc2ggb2YgYWxsIGNsdXN0ZXJzIGJ5IGtleVxuICAvLyBJbiBhZ2dsb21lcmF0aXZlIChib3R0b20tdXApIGNsdXN0ZXJpbmcsIGVhY2ggbm9kZSBzdGFydHMgYXMgaXRzIG93biBjbHVzdGVyXG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBub2Rlcy5sZW5ndGg7IG4rKykge1xuICAgIHZhciBjbHVzdGVyID0ge1xuICAgICAgdmFsdWU6IG9wdHMubW9kZSA9PT0gJ2RlbmRyb2dyYW0nID8gbm9kZXNbbl0gOiBbbm9kZXNbbl1dLFxuICAgICAga2V5OiBuLFxuICAgICAgaW5kZXg6IG5cbiAgICB9O1xuICAgIGNsdXN0ZXJzW25dID0gY2x1c3RlcjtcbiAgICBpbmRleFtuXSA9IGNsdXN0ZXI7XG4gICAgZGlzdHNbbl0gPSBbXTtcbiAgICBtaW5zW25dID0gMDtcbiAgfSAvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gZWFjaCBwYWlyIG9mIGNsdXN0ZXJzXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNsdXN0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPD0gaTsgaisrKSB7XG4gICAgICB2YXIgZGlzdCA9IHZvaWQgMDtcblxuICAgICAgaWYgKG9wdHMubW9kZSA9PT0gJ2RlbmRyb2dyYW0nKSB7XG4gICAgICAgIC8vIG1vZGVzIHN0b3JlIGNsdXN0ZXIgdmFsdWVzIGRpZmZlcmVudGx5XG4gICAgICAgIGRpc3QgPSBpID09PSBqID8gSW5maW5pdHkgOiBnZXREaXN0KGNsdXN0ZXJzW2ldLnZhbHVlLCBjbHVzdGVyc1tqXS52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXN0ID0gaSA9PT0gaiA/IEluZmluaXR5IDogZ2V0RGlzdChjbHVzdGVyc1tpXS52YWx1ZVswXSwgY2x1c3RlcnNbal0udmFsdWVbMF0pO1xuICAgICAgfVxuXG4gICAgICBkaXN0c1tpXVtqXSA9IGRpc3Q7XG4gICAgICBkaXN0c1tqXVtpXSA9IGRpc3Q7XG5cbiAgICAgIGlmIChkaXN0IDwgZGlzdHNbaV1bbWluc1tpXV0pIHtcbiAgICAgICAgbWluc1tpXSA9IGo7IC8vIENhY2hlIG1pbnM6IGNsb3Nlc3QgY2x1c3RlciB0byBjbHVzdGVyIGkgaXMgY2x1c3RlciBqXG4gICAgICB9XG4gICAgfVxuICB9IC8vIEZpbmQgdGhlIGNsb3Nlc3QgcGFpciBvZiBjbHVzdGVycyBhbmQgbWVyZ2UgdGhlbSBpbnRvIGEgc2luZ2xlIGNsdXN0ZXIuXG4gIC8vIFVwZGF0ZSBkaXN0YW5jZXMgYmV0d2VlbiBuZXcgY2x1c3RlciBhbmQgZWFjaCBvZiB0aGUgb2xkIGNsdXN0ZXJzLCBhbmQgbG9vcCB1bnRpbCB0aHJlc2hvbGQgcmVhY2hlZC5cblxuXG4gIHZhciBtZXJnZWQgPSBtZXJnZUNsb3Nlc3QoY2x1c3RlcnMsIGluZGV4LCBkaXN0cywgbWlucywgb3B0cyk7XG5cbiAgd2hpbGUgKG1lcmdlZCkge1xuICAgIG1lcmdlZCA9IG1lcmdlQ2xvc2VzdChjbHVzdGVycywgaW5kZXgsIGRpc3RzLCBtaW5zLCBvcHRzKTtcbiAgfVxuXG4gIHZhciByZXRDbHVzdGVyczsgLy8gRGVuZHJvZ3JhbSBtb2RlIGJ1aWxkcyB0aGUgaGllcmFyY2h5IGFuZCBhZGRzIGludGVybWVkaWFyeSBub2RlcyArIGVkZ2VzXG4gIC8vIGluIGFkZGl0aW9uIHRvIHJldHVybmluZyB0aGUgY2x1c3RlcnMuXG5cbiAgaWYgKG9wdHMubW9kZSA9PT0gJ2RlbmRyb2dyYW0nKSB7XG4gICAgcmV0Q2x1c3RlcnMgPSBidWlsZENsdXN0ZXJzRnJvbVRyZWUoY2x1c3RlcnNbMF0sIG9wdHMuZGVuZHJvZ3JhbURlcHRoLCBjeSk7XG4gICAgaWYgKG9wdHMuYWRkRGVuZHJvZ3JhbSkgYnVpbGREZW5kcm9ncmFtKGNsdXN0ZXJzWzBdLCBjeSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUmVndWxhciBtb2RlIHNpbXBseSByZXR1cm5zIHRoZSBjbHVzdGVyc1xuICAgIHJldENsdXN0ZXJzID0gbmV3IEFycmF5KGNsdXN0ZXJzLmxlbmd0aCk7XG4gICAgY2x1c3RlcnMuZm9yRWFjaChmdW5jdGlvbiAoY2x1c3RlciwgaSkge1xuICAgICAgLy8gQ2xlYW4gdXAgbWV0YSBkYXRhIHVzZWQgZm9yIGNsdXN0ZXJpbmdcbiAgICAgIGNsdXN0ZXIua2V5ID0gY2x1c3Rlci5pbmRleCA9IG51bGw7XG4gICAgICByZXRDbHVzdGVyc1tpXSA9IGN5LmNvbGxlY3Rpb24oY2x1c3Rlci52YWx1ZSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmV0Q2x1c3RlcnM7XG59O1xuXG52YXIgaGllcmFyY2hpY2FsQ2x1c3RlcmluZyQxID0ge1xuICBoaWVyYXJjaGljYWxDbHVzdGVyaW5nOiBoaWVyYXJjaGljYWxDbHVzdGVyaW5nLFxuICBoY2E6IGhpZXJhcmNoaWNhbENsdXN0ZXJpbmdcbn07XG5cbi8vIEltcGxlbWVudGVkIGJ5IFpvZSBYaSBAem9leGkgZm9yIEdTT0MgMjAxNlxudmFyIGRlZmF1bHRzJDkgPSBkZWZhdWx0cyRnKHtcbiAgZGlzdGFuY2U6ICdldWNsaWRlYW4nLFxuICAvLyBkaXN0YW5jZSBtZXRyaWMgdG8gY29tcGFyZSBhdHRyaWJ1dGVzIGJldHdlZW4gdHdvIG5vZGVzXG4gIHByZWZlcmVuY2U6ICdtZWRpYW4nLFxuICAvLyBzdWl0YWJpbGl0eSBvZiBhIGRhdGEgcG9pbnQgdG8gc2VydmUgYXMgYW4gZXhlbXBsYXJcbiAgZGFtcGluZzogMC44LFxuICAvLyBkYW1waW5nIGZhY3RvciBiZXR3ZWVuIFswLjUsIDEpXG4gIG1heEl0ZXJhdGlvbnM6IDEwMDAsXG4gIC8vIG1heCBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBydW5cbiAgbWluSXRlcmF0aW9uczogMTAwLFxuICAvLyBtaW4gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcnVuIGluIG9yZGVyIGZvciBjbHVzdGVyaW5nIHRvIHN0b3BcbiAgYXR0cmlidXRlczogWy8vIGZ1bmN0aW9ucyB0byBxdWFudGlmeSB0aGUgc2ltaWxhcml0eSBiZXR3ZWVuIGFueSB0d28gcG9pbnRzXG4gICAgLy8gZS5nLiBub2RlID0+IG5vZGUuZGF0YSgnd2VpZ2h0JylcbiAgXVxufSk7XG5cbnZhciBzZXRPcHRpb25zID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gIHZhciBkbXAgPSBvcHRpb25zLmRhbXBpbmc7XG4gIHZhciBwcmVmID0gb3B0aW9ucy5wcmVmZXJlbmNlO1xuXG4gIGlmICghKDAuNSA8PSBkbXAgJiYgZG1wIDwgMSkpIHtcbiAgICBlcnJvcihcIkRhbXBpbmcgbXVzdCByYW5nZSBvbiBbMC41LCAxKS4gIEdvdDogXCIuY29uY2F0KGRtcCkpO1xuICB9XG5cbiAgdmFyIHZhbGlkUHJlZnMgPSBbJ21lZGlhbicsICdtZWFuJywgJ21pbicsICdtYXgnXTtcblxuICBpZiAoISh2YWxpZFByZWZzLnNvbWUoZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gdiA9PT0gcHJlZjtcbiAgfSkgfHwgbnVtYmVyJDEocHJlZikpKSB7XG4gICAgZXJyb3IoXCJQcmVmZXJlbmNlIG11c3QgYmUgb25lIG9mIFtcIi5jb25jYXQodmFsaWRQcmVmcy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBcIidcIi5jb25jYXQocCwgXCInXCIpO1xuICAgIH0pLmpvaW4oJywgJyksIFwiXSBvciBhIG51bWJlci4gIEdvdDogXCIpLmNvbmNhdChwcmVmKSk7XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdHMkOShvcHRpb25zKTtcbn07XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cblxudmFyIGdldFNpbWlsYXJpdHkgPSBmdW5jdGlvbiBnZXRTaW1pbGFyaXR5KHR5cGUsIG4xLCBuMiwgYXR0cmlidXRlcykge1xuICB2YXIgYXR0ciA9IGZ1bmN0aW9uIGF0dHIobiwgaSkge1xuICAgIHJldHVybiBhdHRyaWJ1dGVzW2ldKG4pO1xuICB9OyAvLyBuYiBuZWdhdGl2ZSBiZWNhdXNlIHNpbWlsYXJpdHkgc2hvdWxkIGhhdmUgYW4gaW52ZXJzZSByZWxhdGlvbnNoaXAgdG8gZGlzdGFuY2VcblxuXG4gIHJldHVybiAtY2x1c3RlcmluZ0Rpc3RhbmNlKHR5cGUsIGF0dHJpYnV0ZXMubGVuZ3RoLCBmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBhdHRyKG4xLCBpKTtcbiAgfSwgZnVuY3Rpb24gKGkpIHtcbiAgICByZXR1cm4gYXR0cihuMiwgaSk7XG4gIH0sIG4xLCBuMik7XG59O1xuXG52YXIgZ2V0UHJlZmVyZW5jZSA9IGZ1bmN0aW9uIGdldFByZWZlcmVuY2UoUywgcHJlZmVyZW5jZSkge1xuICAvLyBsYXJnZXIgcHJlZmVyZW5jZSA9IGdyZWF0ZXIgIyBvZiBjbHVzdGVyc1xuICB2YXIgcCA9IG51bGw7XG5cbiAgaWYgKHByZWZlcmVuY2UgPT09ICdtZWRpYW4nKSB7XG4gICAgcCA9IG1lZGlhbihTKTtcbiAgfSBlbHNlIGlmIChwcmVmZXJlbmNlID09PSAnbWVhbicpIHtcbiAgICBwID0gbWVhbihTKTtcbiAgfSBlbHNlIGlmIChwcmVmZXJlbmNlID09PSAnbWluJykge1xuICAgIHAgPSBtaW4oUyk7XG4gIH0gZWxzZSBpZiAocHJlZmVyZW5jZSA9PT0gJ21heCcpIHtcbiAgICBwID0gbWF4KFMpO1xuICB9IGVsc2Uge1xuICAgIC8vIEN1c3RvbSBwcmVmZXJlbmNlIG51bWJlciwgYXMgc2V0IGJ5IHVzZXJcbiAgICBwID0gcHJlZmVyZW5jZTtcbiAgfVxuXG4gIHJldHVybiBwO1xufTtcblxudmFyIGZpbmRFeGVtcGxhcnMgPSBmdW5jdGlvbiBmaW5kRXhlbXBsYXJzKG4sIFIsIEEpIHtcbiAgdmFyIGluZGljZXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIGlmIChSW2kgKiBuICsgaV0gKyBBW2kgKiBuICsgaV0gPiAwKSB7XG4gICAgICBpbmRpY2VzLnB1c2goaSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluZGljZXM7XG59O1xuXG52YXIgYXNzaWduQ2x1c3RlcnMgPSBmdW5jdGlvbiBhc3NpZ25DbHVzdGVycyhuLCBTLCBleGVtcGxhcnMpIHtcbiAgdmFyIGNsdXN0ZXJzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICB2YXIgaW5kZXggPSAtMTtcbiAgICB2YXIgbWF4ID0gLUluZmluaXR5O1xuXG4gICAgZm9yICh2YXIgZWkgPSAwOyBlaSA8IGV4ZW1wbGFycy5sZW5ndGg7IGVpKyspIHtcbiAgICAgIHZhciBlID0gZXhlbXBsYXJzW2VpXTtcblxuICAgICAgaWYgKFNbaSAqIG4gKyBlXSA+IG1heCkge1xuICAgICAgICBpbmRleCA9IGU7XG4gICAgICAgIG1heCA9IFNbaSAqIG4gKyBlXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICBjbHVzdGVycy5wdXNoKGluZGV4KTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfZWkgPSAwOyBfZWkgPCBleGVtcGxhcnMubGVuZ3RoOyBfZWkrKykge1xuICAgIGNsdXN0ZXJzW2V4ZW1wbGFyc1tfZWldXSA9IGV4ZW1wbGFyc1tfZWldO1xuICB9XG5cbiAgcmV0dXJuIGNsdXN0ZXJzO1xufTtcblxudmFyIGFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnbihuLCBTLCBleGVtcGxhcnMpIHtcbiAgdmFyIGNsdXN0ZXJzID0gYXNzaWduQ2x1c3RlcnMobiwgUywgZXhlbXBsYXJzKTtcblxuICBmb3IgKHZhciBlaSA9IDA7IGVpIDwgZXhlbXBsYXJzLmxlbmd0aDsgZWkrKykge1xuICAgIHZhciBpaSA9IFtdO1xuXG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjbHVzdGVycy5sZW5ndGg7IGMrKykge1xuICAgICAgaWYgKGNsdXN0ZXJzW2NdID09PSBleGVtcGxhcnNbZWldKSB7XG4gICAgICAgIGlpLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1heEkgPSAtMTtcbiAgICB2YXIgbWF4U3VtID0gLUluZmluaXR5O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpaS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHN1bSA9IDA7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaWkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc3VtICs9IFNbaWlbal0gKiBuICsgaWlbaV1dO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3VtID4gbWF4U3VtKSB7XG4gICAgICAgIG1heEkgPSBpO1xuICAgICAgICBtYXhTdW0gPSBzdW07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXhlbXBsYXJzW2VpXSA9IGlpW21heEldO1xuICB9XG5cbiAgY2x1c3RlcnMgPSBhc3NpZ25DbHVzdGVycyhuLCBTLCBleGVtcGxhcnMpO1xuICByZXR1cm4gY2x1c3RlcnM7XG59O1xuXG52YXIgYWZmaW5pdHlQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uIGFmZmluaXR5UHJvcGFnYXRpb24ob3B0aW9ucykge1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgdmFyIG9wdHMgPSBzZXRPcHRpb25zKG9wdGlvbnMpOyAvLyBNYXAgZWFjaCBub2RlIHRvIGl0cyBwb3NpdGlvbiBpbiBub2RlIGFycmF5XG5cbiAgdmFyIGlkMnBvc2l0aW9uID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlkMnBvc2l0aW9uW25vZGVzW2ldLmlkKCldID0gaTtcbiAgfSAvLyBCZWdpbiBhZmZpbml0eSBwcm9wYWdhdGlvbiBhbGdvcml0aG1cblxuXG4gIHZhciBuOyAvLyBudW1iZXIgb2YgZGF0YSBwb2ludHNcblxuICB2YXIgbjI7IC8vIHNpemUgb2YgbWF0cmljZXNcblxuICB2YXIgUzsgLy8gc2ltaWxhcml0eSBtYXRyaXggKDFEIGFycmF5KVxuXG4gIHZhciBwOyAvLyBwcmVmZXJlbmNlL3N1aXRhYmlsaXR5IG9mIGEgZGF0YSBwb2ludCB0byBzZXJ2ZSBhcyBhbiBleGVtcGxhclxuXG4gIHZhciBSOyAvLyByZXNwb25zaWJpbGl0eSBtYXRyaXggKDFEIGFycmF5KVxuXG4gIHZhciBBOyAvLyBhdmFpbGFiaWxpdHkgbWF0cml4ICgxRCBhcnJheSlcblxuICBuID0gbm9kZXMubGVuZ3RoO1xuICBuMiA9IG4gKiBuOyAvLyBJbml0aWFsaXplIGFuZCBidWlsZCBTIHNpbWlsYXJpdHkgbWF0cml4XG5cbiAgUyA9IG5ldyBBcnJheShuMik7XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG4yOyBfaSsrKSB7XG4gICAgU1tfaV0gPSAtSW5maW5pdHk7IC8vIGZvciBjYXNlcyB3aGVyZSB0d28gZGF0YSBwb2ludHMgc2hvdWxkbid0IGJlIGxpbmtlZCB0b2dldGhlclxuICB9XG5cbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbjsgX2kyKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgaWYgKF9pMiAhPT0gaikge1xuICAgICAgICBTW19pMiAqIG4gKyBqXSA9IGdldFNpbWlsYXJpdHkob3B0cy5kaXN0YW5jZSwgbm9kZXNbX2kyXSwgbm9kZXNbal0sIG9wdHMuYXR0cmlidXRlcyk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFBsYWNlIHByZWZlcmVuY2VzIG9uIHRoZSBkaWFnb25hbCBvZiBTXG5cblxuICBwID0gZ2V0UHJlZmVyZW5jZShTLCBvcHRzLnByZWZlcmVuY2UpO1xuXG4gIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG47IF9pMysrKSB7XG4gICAgU1tfaTMgKiBuICsgX2kzXSA9IHA7XG4gIH0gLy8gSW5pdGlhbGl6ZSBSIHJlc3BvbnNpYmlsaXR5IG1hdHJpeFxuXG5cbiAgUiA9IG5ldyBBcnJheShuMik7XG5cbiAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbjI7IF9pNCsrKSB7XG4gICAgUltfaTRdID0gMC4wO1xuICB9IC8vIEluaXRpYWxpemUgQSBhdmFpbGFiaWxpdHkgbWF0cml4XG5cblxuICBBID0gbmV3IEFycmF5KG4yKTtcblxuICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBuMjsgX2k1KyspIHtcbiAgICBBW19pNV0gPSAwLjA7XG4gIH1cblxuICB2YXIgb2xkID0gbmV3IEFycmF5KG4pO1xuICB2YXIgUnAgPSBuZXcgQXJyYXkobik7XG4gIHZhciBzZSA9IG5ldyBBcnJheShuKTtcblxuICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBuOyBfaTYrKykge1xuICAgIG9sZFtfaTZdID0gMC4wO1xuICAgIFJwW19pNl0gPSAwLjA7XG4gICAgc2VbX2k2XSA9IDA7XG4gIH1cblxuICB2YXIgZSA9IG5ldyBBcnJheShuICogb3B0cy5taW5JdGVyYXRpb25zKTtcblxuICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCBlLmxlbmd0aDsgX2k3KyspIHtcbiAgICBlW19pN10gPSAwO1xuICB9XG5cbiAgdmFyIGl0ZXI7XG5cbiAgZm9yIChpdGVyID0gMDsgaXRlciA8IG9wdHMubWF4SXRlcmF0aW9uczsgaXRlcisrKSB7XG4gICAgLy8gbWFpbiBhbGdvcml0aG1pYyBsb29wXG4gICAgLy8gVXBkYXRlIFIgcmVzcG9uc2liaWxpdHkgbWF0cml4XG4gICAgZm9yICh2YXIgX2k4ID0gMDsgX2k4IDwgbjsgX2k4KyspIHtcbiAgICAgIHZhciBtYXggPSAtSW5maW5pdHksXG4gICAgICAgICAgbWF4MiA9IC1JbmZpbml0eSxcbiAgICAgICAgICBtYXhJID0gLTEsXG4gICAgICAgICAgQVMgPSAwLjA7XG5cbiAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBuOyBfaisrKSB7XG4gICAgICAgIG9sZFtfal0gPSBSW19pOCAqIG4gKyBfal07XG4gICAgICAgIEFTID0gQVtfaTggKiBuICsgX2pdICsgU1tfaTggKiBuICsgX2pdO1xuXG4gICAgICAgIGlmIChBUyA+PSBtYXgpIHtcbiAgICAgICAgICBtYXgyID0gbWF4O1xuICAgICAgICAgIG1heCA9IEFTO1xuICAgICAgICAgIG1heEkgPSBfajtcbiAgICAgICAgfSBlbHNlIGlmIChBUyA+IG1heDIpIHtcbiAgICAgICAgICBtYXgyID0gQVM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgbjsgX2oyKyspIHtcbiAgICAgICAgUltfaTggKiBuICsgX2oyXSA9ICgxIC0gb3B0cy5kYW1waW5nKSAqIChTW19pOCAqIG4gKyBfajJdIC0gbWF4KSArIG9wdHMuZGFtcGluZyAqIG9sZFtfajJdO1xuICAgICAgfVxuXG4gICAgICBSW19pOCAqIG4gKyBtYXhJXSA9ICgxIC0gb3B0cy5kYW1waW5nKSAqIChTW19pOCAqIG4gKyBtYXhJXSAtIG1heDIpICsgb3B0cy5kYW1waW5nICogb2xkW21heEldO1xuICAgIH0gLy8gVXBkYXRlIEEgYXZhaWxhYmlsaXR5IG1hdHJpeFxuXG5cbiAgICBmb3IgKHZhciBfaTkgPSAwOyBfaTkgPCBuOyBfaTkrKykge1xuICAgICAgdmFyIHN1bSA9IDA7XG5cbiAgICAgIGZvciAodmFyIF9qMyA9IDA7IF9qMyA8IG47IF9qMysrKSB7XG4gICAgICAgIG9sZFtfajNdID0gQVtfajMgKiBuICsgX2k5XTtcbiAgICAgICAgUnBbX2ozXSA9IE1hdGgubWF4KDAsIFJbX2ozICogbiArIF9pOV0pO1xuICAgICAgICBzdW0gKz0gUnBbX2ozXTtcbiAgICAgIH1cblxuICAgICAgc3VtIC09IFJwW19pOV07XG4gICAgICBScFtfaTldID0gUltfaTkgKiBuICsgX2k5XTtcbiAgICAgIHN1bSArPSBScFtfaTldO1xuXG4gICAgICBmb3IgKHZhciBfajQgPSAwOyBfajQgPCBuOyBfajQrKykge1xuICAgICAgICBBW19qNCAqIG4gKyBfaTldID0gKDEgLSBvcHRzLmRhbXBpbmcpICogTWF0aC5taW4oMCwgc3VtIC0gUnBbX2o0XSkgKyBvcHRzLmRhbXBpbmcgKiBvbGRbX2o0XTtcbiAgICAgIH1cblxuICAgICAgQVtfaTkgKiBuICsgX2k5XSA9ICgxIC0gb3B0cy5kYW1waW5nKSAqIChzdW0gLSBScFtfaTldKSArIG9wdHMuZGFtcGluZyAqIG9sZFtfaTldO1xuICAgIH0gLy8gQ2hlY2sgZm9yIGNvbnZlcmdlbmNlXG5cblxuICAgIHZhciBLID0gMDtcblxuICAgIGZvciAodmFyIF9pMTAgPSAwOyBfaTEwIDwgbjsgX2kxMCsrKSB7XG4gICAgICB2YXIgRSA9IEFbX2kxMCAqIG4gKyBfaTEwXSArIFJbX2kxMCAqIG4gKyBfaTEwXSA+IDAgPyAxIDogMDtcbiAgICAgIGVbaXRlciAlIG9wdHMubWluSXRlcmF0aW9ucyAqIG4gKyBfaTEwXSA9IEU7XG4gICAgICBLICs9IEU7XG4gICAgfVxuXG4gICAgaWYgKEsgPiAwICYmIChpdGVyID49IG9wdHMubWluSXRlcmF0aW9ucyAtIDEgfHwgaXRlciA9PSBvcHRzLm1heEl0ZXJhdGlvbnMgLSAxKSkge1xuICAgICAgdmFyIF9zdW0gPSAwO1xuXG4gICAgICBmb3IgKHZhciBfaTExID0gMDsgX2kxMSA8IG47IF9pMTErKykge1xuICAgICAgICBzZVtfaTExXSA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgX2o1ID0gMDsgX2o1IDwgb3B0cy5taW5JdGVyYXRpb25zOyBfajUrKykge1xuICAgICAgICAgIHNlW19pMTFdICs9IGVbX2o1ICogbiArIF9pMTFdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlW19pMTFdID09PSAwIHx8IHNlW19pMTFdID09PSBvcHRzLm1pbkl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICBfc3VtKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKF9zdW0gPT09IG4pIHtcbiAgICAgICAgLy8gdGhlbiB3ZSBoYXZlIGNvbnZlcmdlbmNlXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBJZGVudGlmeSBleGVtcGxhcnMgKGNsdXN0ZXIgY2VudGVycylcblxuXG4gIHZhciBleGVtcGxhcnNJbmRpY2VzID0gZmluZEV4ZW1wbGFycyhuLCBSLCBBKTsgLy8gQXNzaWduIG5vZGVzIHRvIGNsdXN0ZXJzXG5cbiAgdmFyIGNsdXN0ZXJJbmRpY2VzID0gYXNzaWduKG4sIFMsIGV4ZW1wbGFyc0luZGljZXMpO1xuICB2YXIgY2x1c3RlcnMgPSB7fTtcblxuICBmb3IgKHZhciBjID0gMDsgYyA8IGV4ZW1wbGFyc0luZGljZXMubGVuZ3RoOyBjKyspIHtcbiAgICBjbHVzdGVyc1tleGVtcGxhcnNJbmRpY2VzW2NdXSA9IFtdO1xuICB9XG5cbiAgZm9yICh2YXIgX2kxMiA9IDA7IF9pMTIgPCBub2Rlcy5sZW5ndGg7IF9pMTIrKykge1xuICAgIHZhciBwb3MgPSBpZDJwb3NpdGlvbltub2Rlc1tfaTEyXS5pZCgpXTtcblxuICAgIHZhciBjbHVzdGVySW5kZXggPSBjbHVzdGVySW5kaWNlc1twb3NdO1xuXG4gICAgaWYgKGNsdXN0ZXJJbmRleCAhPSBudWxsKSB7XG4gICAgICAvLyB0aGUgbm9kZSBtYXkgaGF2ZSBub3QgYmVlbiBhc3NpZ25lZCBhIGNsdXN0ZXIgaWYgbm8gdmFsaWQgYXR0cmlidXRlcyB3ZXJlIHNwZWNpZmllZFxuICAgICAgY2x1c3RlcnNbY2x1c3RlckluZGV4XS5wdXNoKG5vZGVzW19pMTJdKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmV0Q2x1c3RlcnMgPSBuZXcgQXJyYXkoZXhlbXBsYXJzSW5kaWNlcy5sZW5ndGgpO1xuXG4gIGZvciAodmFyIF9jID0gMDsgX2MgPCBleGVtcGxhcnNJbmRpY2VzLmxlbmd0aDsgX2MrKykge1xuICAgIHJldENsdXN0ZXJzW19jXSA9IGN5LmNvbGxlY3Rpb24oY2x1c3RlcnNbZXhlbXBsYXJzSW5kaWNlc1tfY11dKTtcbiAgfVxuXG4gIHJldHVybiByZXRDbHVzdGVycztcbn07XG5cbnZhciBhZmZpbml0eVByb3BhZ2F0aW9uJDEgPSB7XG4gIGFmZmluaXR5UHJvcGFnYXRpb246IGFmZmluaXR5UHJvcGFnYXRpb24sXG4gIGFwOiBhZmZpbml0eVByb3BhZ2F0aW9uXG59O1xuXG52YXIgaGllcmhvbHplckRlZmF1bHRzID0gZGVmYXVsdHMkZyh7XG4gIHJvb3Q6IHVuZGVmaW5lZCxcbiAgZGlyZWN0ZWQ6IGZhbHNlXG59KTtcbnZhciBlbGVzZm4kayA9IHtcbiAgaGllcmhvbHplcjogZnVuY3Rpb24gaGllcmhvbHplcihvcHRpb25zKSB7XG4gICAgaWYgKCFwbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICByb290OiBhcmdzWzBdLFxuICAgICAgICBkaXJlY3RlZDogYXJnc1sxXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgX2hpZXJob2x6ZXJEZWZhdWx0cyA9IGhpZXJob2x6ZXJEZWZhdWx0cyhvcHRpb25zKSxcbiAgICAgICAgcm9vdCA9IF9oaWVyaG9semVyRGVmYXVsdHMucm9vdCxcbiAgICAgICAgZGlyZWN0ZWQgPSBfaGllcmhvbHplckRlZmF1bHRzLmRpcmVjdGVkO1xuXG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciBkZmxhZyA9IGZhbHNlO1xuICAgIHZhciBvZGRJbjtcbiAgICB2YXIgb2RkT3V0O1xuICAgIHZhciBzdGFydFZlcnRleDtcbiAgICBpZiAocm9vdCkgc3RhcnRWZXJ0ZXggPSBzdHJpbmcocm9vdCkgPyB0aGlzLmZpbHRlcihyb290KVswXS5pZCgpIDogcm9vdFswXS5pZCgpO1xuICAgIHZhciBub2RlcyA9IHt9O1xuICAgIHZhciBlZGdlcyA9IHt9O1xuXG4gICAgaWYgKGRpcmVjdGVkKSB7XG4gICAgICBlbGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcblxuICAgICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgICAgdmFyIGluZCA9IGVsZS5pbmRlZ3JlZSh0cnVlKTtcbiAgICAgICAgICB2YXIgb3V0ZCA9IGVsZS5vdXRkZWdyZWUodHJ1ZSk7XG4gICAgICAgICAgdmFyIGQxID0gaW5kIC0gb3V0ZDtcbiAgICAgICAgICB2YXIgZDIgPSBvdXRkIC0gaW5kO1xuXG4gICAgICAgICAgaWYgKGQxID09IDEpIHtcbiAgICAgICAgICAgIGlmIChvZGRJbikgZGZsYWcgPSB0cnVlO2Vsc2Ugb2RkSW4gPSBpZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGQyID09IDEpIHtcbiAgICAgICAgICAgIGlmIChvZGRPdXQpIGRmbGFnID0gdHJ1ZTtlbHNlIG9kZE91dCA9IGlkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZDIgPiAxIHx8IGQxID4gMSkge1xuICAgICAgICAgICAgZGZsYWcgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5vZGVzW2lkXSA9IFtdO1xuICAgICAgICAgIGVsZS5vdXRnb2VycygpLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmlzRWRnZSgpKSBub2Rlc1tpZF0ucHVzaChlLmlkKCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkZ2VzW2lkXSA9IFt1bmRlZmluZWQsIGVsZS50YXJnZXQoKS5pZCgpXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuXG4gICAgICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgICB2YXIgZCA9IGVsZS5kZWdyZWUodHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoZCAlIDIpIHtcbiAgICAgICAgICAgIGlmICghb2RkSW4pIG9kZEluID0gaWQ7ZWxzZSBpZiAoIW9kZE91dCkgb2RkT3V0ID0gaWQ7ZWxzZSBkZmxhZyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm9kZXNbaWRdID0gW107XG4gICAgICAgICAgZWxlLmNvbm5lY3RlZEVkZ2VzKCkuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVzW2lkXS5wdXNoKGUuaWQoKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWRnZXNbaWRdID0gW2VsZS5zb3VyY2UoKS5pZCgpLCBlbGUudGFyZ2V0KCkuaWQoKV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICBmb3VuZDogZmFsc2UsXG4gICAgICB0cmFpbDogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBpZiAoZGZsYWcpIHJldHVybiByZXN1bHQ7ZWxzZSBpZiAob2RkT3V0ICYmIG9kZEluKSB7XG4gICAgICBpZiAoZGlyZWN0ZWQpIHtcbiAgICAgICAgaWYgKHN0YXJ0VmVydGV4ICYmIG9kZE91dCAhPSBzdGFydFZlcnRleCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydFZlcnRleCA9IG9kZE91dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdGFydFZlcnRleCAmJiBvZGRPdXQgIT0gc3RhcnRWZXJ0ZXggJiYgb2RkSW4gIT0gc3RhcnRWZXJ0ZXgpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKCFzdGFydFZlcnRleCkge1xuICAgICAgICAgIHN0YXJ0VmVydGV4ID0gb2RkT3V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghc3RhcnRWZXJ0ZXgpIHN0YXJ0VmVydGV4ID0gZWxlc1swXS5pZCgpO1xuICAgIH1cblxuICAgIHZhciB3YWxrID0gZnVuY3Rpb24gd2Fsayh2KSB7XG4gICAgICB2YXIgY3VycmVudE5vZGUgPSB2O1xuICAgICAgdmFyIHN1YnRvdXIgPSBbdl07XG4gICAgICB2YXIgYWRqLCBhZGpUYWlsLCBhZGpIZWFkO1xuXG4gICAgICB3aGlsZSAobm9kZXNbY3VycmVudE5vZGVdLmxlbmd0aCkge1xuICAgICAgICBhZGogPSBub2Rlc1tjdXJyZW50Tm9kZV0uc2hpZnQoKTtcbiAgICAgICAgYWRqVGFpbCA9IGVkZ2VzW2Fkal1bMF07XG4gICAgICAgIGFkakhlYWQgPSBlZGdlc1thZGpdWzFdO1xuXG4gICAgICAgIGlmIChjdXJyZW50Tm9kZSAhPSBhZGpIZWFkKSB7XG4gICAgICAgICAgbm9kZXNbYWRqSGVhZF0gPSBub2Rlc1thZGpIZWFkXS5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlICE9IGFkajtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjdXJyZW50Tm9kZSA9IGFkakhlYWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIWRpcmVjdGVkICYmIGN1cnJlbnROb2RlICE9IGFkalRhaWwpIHtcbiAgICAgICAgICBub2Rlc1thZGpUYWlsXSA9IG5vZGVzW2FkalRhaWxdLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUgIT0gYWRqO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGN1cnJlbnROb2RlID0gYWRqVGFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1YnRvdXIudW5zaGlmdChhZGopO1xuICAgICAgICBzdWJ0b3VyLnVuc2hpZnQoY3VycmVudE5vZGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3VidG91cjtcbiAgICB9O1xuXG4gICAgdmFyIHRyYWlsID0gW107XG4gICAgdmFyIHN1YnRvdXIgPSBbXTtcbiAgICBzdWJ0b3VyID0gd2FsayhzdGFydFZlcnRleCk7XG5cbiAgICB3aGlsZSAoc3VidG91ci5sZW5ndGggIT0gMSkge1xuICAgICAgaWYgKG5vZGVzW3N1YnRvdXJbMF1dLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHRyYWlsLnVuc2hpZnQoZWxlcy5nZXRFbGVtZW50QnlJZChzdWJ0b3VyLnNoaWZ0KCkpKTtcbiAgICAgICAgdHJhaWwudW5zaGlmdChlbGVzLmdldEVsZW1lbnRCeUlkKHN1YnRvdXIuc2hpZnQoKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VidG91ciA9IHdhbGsoc3VidG91ci5zaGlmdCgpKS5jb25jYXQoc3VidG91cik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJhaWwudW5zaGlmdChlbGVzLmdldEVsZW1lbnRCeUlkKHN1YnRvdXIuc2hpZnQoKSkpOyAvLyBmaW5hbCBub2RlXG5cbiAgICBmb3IgKHZhciBkIGluIG5vZGVzKSB7XG4gICAgICBpZiAobm9kZXNbZF0ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzdWx0LmZvdW5kID0gdHJ1ZTtcbiAgICByZXN1bHQudHJhaWwgPSB0aGlzLnNwYXduKHRyYWlsLCB0cnVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG52YXIgaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZCA9IGZ1bmN0aW9uIGhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWQoKSB7XG4gIHZhciBlbGVzID0gdGhpcztcbiAgdmFyIG5vZGVzID0ge307XG4gIHZhciBpZCA9IDA7XG4gIHZhciBlZGdlQ291bnQgPSAwO1xuICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIHZpc2l0ZWRFZGdlcyA9IHt9O1xuXG4gIHZhciBidWlsZENvbXBvbmVudCA9IGZ1bmN0aW9uIGJ1aWxkQ29tcG9uZW50KHgsIHkpIHtcbiAgICB2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7XG4gICAgdmFyIGN1dHNldCA9IFtdO1xuICAgIHZhciBjb21wb25lbnQgPSBlbGVzLnNwYXduKCk7XG5cbiAgICB3aGlsZSAoc3RhY2tbaV0ueCAhPSB4IHx8IHN0YWNrW2ldLnkgIT0geSkge1xuICAgICAgY3V0c2V0LnB1c2goc3RhY2sucG9wKCkuZWRnZSk7XG4gICAgICBpLS07XG4gICAgfVxuXG4gICAgY3V0c2V0LnB1c2goc3RhY2sucG9wKCkuZWRnZSk7XG4gICAgY3V0c2V0LmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHZhciBjb25uZWN0ZWROb2RlcyA9IGVkZ2UuY29ubmVjdGVkTm9kZXMoKS5pbnRlcnNlY3Rpb24oZWxlcyk7XG4gICAgICBjb21wb25lbnQubWVyZ2UoZWRnZSk7XG4gICAgICBjb25uZWN0ZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBub2RlSWQgPSBub2RlLmlkKCk7XG4gICAgICAgIHZhciBjb25uZWN0ZWRFZGdlcyA9IG5vZGUuY29ubmVjdGVkRWRnZXMoKS5pbnRlcnNlY3Rpb24oZWxlcyk7XG4gICAgICAgIGNvbXBvbmVudC5tZXJnZShub2RlKTtcblxuICAgICAgICBpZiAoIW5vZGVzW25vZGVJZF0uY3V0VmVydGV4KSB7XG4gICAgICAgICAgY29tcG9uZW50Lm1lcmdlKGNvbm5lY3RlZEVkZ2VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21wb25lbnQubWVyZ2UoY29ubmVjdGVkRWRnZXMuZmlsdGVyKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgICByZXR1cm4gZWRnZS5pc0xvb3AoKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICB9O1xuXG4gIHZhciBiaWNvbm5lY3RlZFNlYXJjaCA9IGZ1bmN0aW9uIGJpY29ubmVjdGVkU2VhcmNoKHJvb3QsIGN1cnJlbnROb2RlLCBwYXJlbnQpIHtcbiAgICBpZiAocm9vdCA9PT0gcGFyZW50KSBlZGdlQ291bnQgKz0gMTtcbiAgICBub2Rlc1tjdXJyZW50Tm9kZV0gPSB7XG4gICAgICBpZDogaWQsXG4gICAgICBsb3c6IGlkKyssXG4gICAgICBjdXRWZXJ0ZXg6IGZhbHNlXG4gICAgfTtcbiAgICB2YXIgZWRnZXMgPSBlbGVzLmdldEVsZW1lbnRCeUlkKGN1cnJlbnROb2RlKS5jb25uZWN0ZWRFZGdlcygpLmludGVyc2VjdGlvbihlbGVzKTtcblxuICAgIGlmIChlZGdlcy5zaXplKCkgPT09IDApIHtcbiAgICAgIGNvbXBvbmVudHMucHVzaChlbGVzLnNwYXduKGVsZXMuZ2V0RWxlbWVudEJ5SWQoY3VycmVudE5vZGUpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzb3VyY2VJZCwgdGFyZ2V0SWQsIG90aGVyTm9kZUlkLCBlZGdlSWQ7XG4gICAgICBlZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIHNvdXJjZUlkID0gZWRnZS5zb3VyY2UoKS5pZCgpO1xuICAgICAgICB0YXJnZXRJZCA9IGVkZ2UudGFyZ2V0KCkuaWQoKTtcbiAgICAgICAgb3RoZXJOb2RlSWQgPSBzb3VyY2VJZCA9PT0gY3VycmVudE5vZGUgPyB0YXJnZXRJZCA6IHNvdXJjZUlkO1xuXG4gICAgICAgIGlmIChvdGhlck5vZGVJZCAhPT0gcGFyZW50KSB7XG4gICAgICAgICAgZWRnZUlkID0gZWRnZS5pZCgpO1xuXG4gICAgICAgICAgaWYgKCF2aXNpdGVkRWRnZXNbZWRnZUlkXSkge1xuICAgICAgICAgICAgdmlzaXRlZEVkZ2VzW2VkZ2VJZF0gPSB0cnVlO1xuICAgICAgICAgICAgc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgIHg6IGN1cnJlbnROb2RlLFxuICAgICAgICAgICAgICB5OiBvdGhlck5vZGVJZCxcbiAgICAgICAgICAgICAgZWRnZTogZWRnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCEob3RoZXJOb2RlSWQgaW4gbm9kZXMpKSB7XG4gICAgICAgICAgICBiaWNvbm5lY3RlZFNlYXJjaChyb290LCBvdGhlck5vZGVJZCwgY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgbm9kZXNbY3VycmVudE5vZGVdLmxvdyA9IE1hdGgubWluKG5vZGVzW2N1cnJlbnROb2RlXS5sb3csIG5vZGVzW290aGVyTm9kZUlkXS5sb3cpO1xuXG4gICAgICAgICAgICBpZiAobm9kZXNbY3VycmVudE5vZGVdLmlkIDw9IG5vZGVzW290aGVyTm9kZUlkXS5sb3cpIHtcbiAgICAgICAgICAgICAgbm9kZXNbY3VycmVudE5vZGVdLmN1dFZlcnRleCA9IHRydWU7XG4gICAgICAgICAgICAgIGJ1aWxkQ29tcG9uZW50KGN1cnJlbnROb2RlLCBvdGhlck5vZGVJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGVzW2N1cnJlbnROb2RlXS5sb3cgPSBNYXRoLm1pbihub2Rlc1tjdXJyZW50Tm9kZV0ubG93LCBub2Rlc1tvdGhlck5vZGVJZF0uaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGVsZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgdmFyIG5vZGVJZCA9IGVsZS5pZCgpO1xuXG4gICAgICBpZiAoIShub2RlSWQgaW4gbm9kZXMpKSB7XG4gICAgICAgIGVkZ2VDb3VudCA9IDA7XG4gICAgICAgIGJpY29ubmVjdGVkU2VhcmNoKG5vZGVJZCwgbm9kZUlkKTtcbiAgICAgICAgbm9kZXNbbm9kZUlkXS5jdXRWZXJ0ZXggPSBlZGdlQ291bnQgPiAxO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciBjdXRWZXJ0aWNlcyA9IE9iamVjdC5rZXlzKG5vZGVzKS5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIG5vZGVzW2lkXS5jdXRWZXJ0ZXg7XG4gIH0pLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gZWxlcy5nZXRFbGVtZW50QnlJZChpZCk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGN1dDogZWxlcy5zcGF3bihjdXRWZXJ0aWNlcyksXG4gICAgY29tcG9uZW50czogY29tcG9uZW50c1xuICB9O1xufTtcblxudmFyIGhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWQkMSA9IHtcbiAgaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZDogaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZCxcbiAgaHRiYzogaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZCxcbiAgaHRiOiBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkLFxuICBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkQ29tcG9uZW50czogaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZFxufTtcblxudmFyIHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkID0gZnVuY3Rpb24gdGFyamFuU3Ryb25nbHlDb25uZWN0ZWQoKSB7XG4gIHZhciBlbGVzID0gdGhpcztcbiAgdmFyIG5vZGVzID0ge307XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBjb21wb25lbnRzID0gW107XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgY3V0ID0gZWxlcy5zcGF3bihlbGVzKTtcblxuICB2YXIgc3Ryb25nbHlDb25uZWN0ZWRTZWFyY2ggPSBmdW5jdGlvbiBzdHJvbmdseUNvbm5lY3RlZFNlYXJjaChzb3VyY2VOb2RlSWQpIHtcbiAgICBzdGFjay5wdXNoKHNvdXJjZU5vZGVJZCk7XG4gICAgbm9kZXNbc291cmNlTm9kZUlkXSA9IHtcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIGxvdzogaW5kZXgrKyxcbiAgICAgIGV4cGxvcmVkOiBmYWxzZVxuICAgIH07XG4gICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gZWxlcy5nZXRFbGVtZW50QnlJZChzb3VyY2VOb2RlSWQpLmNvbm5lY3RlZEVkZ2VzKCkuaW50ZXJzZWN0aW9uKGVsZXMpO1xuICAgIGNvbm5lY3RlZEVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHZhciB0YXJnZXROb2RlSWQgPSBlZGdlLnRhcmdldCgpLmlkKCk7XG5cbiAgICAgIGlmICh0YXJnZXROb2RlSWQgIT09IHNvdXJjZU5vZGVJZCkge1xuICAgICAgICBpZiAoISh0YXJnZXROb2RlSWQgaW4gbm9kZXMpKSB7XG4gICAgICAgICAgc3Ryb25nbHlDb25uZWN0ZWRTZWFyY2godGFyZ2V0Tm9kZUlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbm9kZXNbdGFyZ2V0Tm9kZUlkXS5leHBsb3JlZCkge1xuICAgICAgICAgIG5vZGVzW3NvdXJjZU5vZGVJZF0ubG93ID0gTWF0aC5taW4obm9kZXNbc291cmNlTm9kZUlkXS5sb3csIG5vZGVzW3RhcmdldE5vZGVJZF0ubG93KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKG5vZGVzW3NvdXJjZU5vZGVJZF0uaW5kZXggPT09IG5vZGVzW3NvdXJjZU5vZGVJZF0ubG93KSB7XG4gICAgICB2YXIgY29tcG9uZW50Tm9kZXMgPSBlbGVzLnNwYXduKCk7XG5cbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgdmFyIG5vZGVJZCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBjb21wb25lbnROb2Rlcy5tZXJnZShlbGVzLmdldEVsZW1lbnRCeUlkKG5vZGVJZCkpO1xuICAgICAgICBub2Rlc1tub2RlSWRdLmxvdyA9IG5vZGVzW3NvdXJjZU5vZGVJZF0uaW5kZXg7XG4gICAgICAgIG5vZGVzW25vZGVJZF0uZXhwbG9yZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmIChub2RlSWQgPT09IHNvdXJjZU5vZGVJZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21wb25lbnRFZGdlcyA9IGNvbXBvbmVudE5vZGVzLmVkZ2VzV2l0aChjb21wb25lbnROb2Rlcyk7XG4gICAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50Tm9kZXMubWVyZ2UoY29tcG9uZW50RWRnZXMpO1xuICAgICAgY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICBjdXQgPSBjdXQuZGlmZmVyZW5jZShjb21wb25lbnQpO1xuICAgIH1cbiAgfTtcblxuICBlbGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgIHZhciBub2RlSWQgPSBlbGUuaWQoKTtcblxuICAgICAgaWYgKCEobm9kZUlkIGluIG5vZGVzKSkge1xuICAgICAgICBzdHJvbmdseUNvbm5lY3RlZFNlYXJjaChub2RlSWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY3V0OiBjdXQsXG4gICAgY29tcG9uZW50czogY29tcG9uZW50c1xuICB9O1xufTtcblxudmFyIHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkJDEgPSB7XG4gIHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkOiB0YXJqYW5TdHJvbmdseUNvbm5lY3RlZCxcbiAgdHNjOiB0YXJqYW5TdHJvbmdseUNvbm5lY3RlZCxcbiAgdHNjYzogdGFyamFuU3Ryb25nbHlDb25uZWN0ZWQsXG4gIHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkQ29tcG9uZW50czogdGFyamFuU3Ryb25nbHlDb25uZWN0ZWRcbn07XG5cbnZhciBlbGVzZm4kaiA9IHt9O1xuW2VsZXNmbiR2LCBlbGVzZm4kdSwgZWxlc2ZuJHQsIGVsZXNmbiRzLCBlbGVzZm4kciwgZWxlc2ZuJHEsIGVsZXNmbiRwLCBlbGVzZm4kbywgZWxlc2ZuJG4sIGVsZXNmbiRtLCBlbGVzZm4kbCwgbWFya292Q2x1c3RlcmluZyQxLCBrQ2x1c3RlcmluZywgaGllcmFyY2hpY2FsQ2x1c3RlcmluZyQxLCBhZmZpbml0eVByb3BhZ2F0aW9uJDEsIGVsZXNmbiRrLCBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkJDEsIHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkJDFdLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gIGV4dGVuZChlbGVzZm4kaiwgcHJvcHMpO1xufSk7XG5cbi8qIVxuRW1iZWRkYWJsZSBNaW5pbXVtIFN0cmljdGx5LUNvbXBsaWFudCBQcm9taXNlcy9BKyAxLjEuMSBUaGVuYWJsZVxuQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgUmFsZiBTLiBFbmdlbHNjaGFsbCAoaHR0cDovL2VuZ2Vsc2NoYWxsLmNvbSlcbkxpY2Vuc2VkIHVuZGVyIFRoZSBNSVQgTGljZW5zZSAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiovXG5cbi8qICBwcm9taXNlIHN0YXRlcyBbUHJvbWlzZXMvQSsgMi4xXSAgKi9cbnZhciBTVEFURV9QRU5ESU5HID0gMDtcbi8qICBbUHJvbWlzZXMvQSsgMi4xLjFdICAqL1xuXG52YXIgU1RBVEVfRlVMRklMTEVEID0gMTtcbi8qICBbUHJvbWlzZXMvQSsgMi4xLjJdICAqL1xuXG52YXIgU1RBVEVfUkVKRUNURUQgPSAyO1xuLyogIFtQcm9taXNlcy9BKyAyLjEuM10gICovXG5cbi8qICBwcm9taXNlIG9iamVjdCBjb25zdHJ1Y3RvciAgKi9cblxudmFyIGFwaSA9IGZ1bmN0aW9uIGFwaShleGVjdXRvcikge1xuICAvKiAgb3B0aW9uYWxseSBzdXBwb3J0IG5vbi1jb25zdHJ1Y3Rvci9wbGFpbi1mdW5jdGlvbiBjYWxsICAqL1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgYXBpKSkgcmV0dXJuIG5ldyBhcGkoZXhlY3V0b3IpO1xuICAvKiAgaW5pdGlhbGl6ZSBvYmplY3QgICovXG5cbiAgdGhpcy5pZCA9ICdUaGVuYWJsZS8xLjAuNyc7XG4gIHRoaXMuc3RhdGUgPSBTVEFURV9QRU5ESU5HO1xuICAvKiAgaW5pdGlhbCBzdGF0ZSAgKi9cblxuICB0aGlzLmZ1bGZpbGxWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgLyogIGluaXRpYWwgdmFsdWUgICovXG5cbiAgLyogIFtQcm9taXNlcy9BKyAxLjMsIDIuMS4yLjJdICAqL1xuXG4gIHRoaXMucmVqZWN0UmVhc29uID0gdW5kZWZpbmVkO1xuICAvKiAgaW5pdGlhbCByZWFzb24gKi9cblxuICAvKiAgW1Byb21pc2VzL0ErIDEuNSwgMi4xLjMuMl0gICovXG5cbiAgdGhpcy5vbkZ1bGZpbGxlZCA9IFtdO1xuICAvKiAgaW5pdGlhbCBoYW5kbGVycyAgKi9cblxuICB0aGlzLm9uUmVqZWN0ZWQgPSBbXTtcbiAgLyogIGluaXRpYWwgaGFuZGxlcnMgICovXG5cbiAgLyogIHByb3ZpZGUgb3B0aW9uYWwgaW5mb3JtYXRpb24taGlkaW5nIHByb3h5ICAqL1xuXG4gIHRoaXMucHJveHkgPSB7XG4gICAgdGhlbjogdGhpcy50aGVuLmJpbmQodGhpcylcbiAgfTtcbiAgLyogIHN1cHBvcnQgb3B0aW9uYWwgZXhlY3V0b3IgZnVuY3Rpb24gICovXG5cbiAgaWYgKHR5cGVvZiBleGVjdXRvciA9PT0gJ2Z1bmN0aW9uJykgZXhlY3V0b3IuY2FsbCh0aGlzLCB0aGlzLmZ1bGZpbGwuYmluZCh0aGlzKSwgdGhpcy5yZWplY3QuYmluZCh0aGlzKSk7XG59O1xuLyogIHByb21pc2UgQVBJIG1ldGhvZHMgICovXG5cblxuYXBpLnByb3RvdHlwZSA9IHtcbiAgLyogIHByb21pc2UgcmVzb2x2aW5nIG1ldGhvZHMgICovXG4gIGZ1bGZpbGw6IGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHtcbiAgICByZXR1cm4gZGVsaXZlcih0aGlzLCBTVEFURV9GVUxGSUxMRUQsICdmdWxmaWxsVmFsdWUnLCB2YWx1ZSk7XG4gIH0sXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGRlbGl2ZXIodGhpcywgU1RBVEVfUkVKRUNURUQsICdyZWplY3RSZWFzb24nLCB2YWx1ZSk7XG4gIH0sXG5cbiAgLyogIFwiVGhlIHRoZW4gTWV0aG9kXCIgW1Byb21pc2VzL0ErIDEuMSwgMS4yLCAyLjJdICAqL1xuICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgdmFyIGN1cnIgPSB0aGlzO1xuICAgIHZhciBuZXh0ID0gbmV3IGFwaSgpO1xuICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjddICAqL1xuXG4gICAgY3Vyci5vbkZ1bGZpbGxlZC5wdXNoKHJlc29sdmVyKG9uRnVsZmlsbGVkLCBuZXh0LCAnZnVsZmlsbCcpKTtcbiAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi4yLzIuMi42XSAgKi9cblxuICAgIGN1cnIub25SZWplY3RlZC5wdXNoKHJlc29sdmVyKG9uUmVqZWN0ZWQsIG5leHQsICdyZWplY3QnKSk7XG4gICAgLyogIFtQcm9taXNlcy9BKyAyLjIuMy8yLjIuNl0gICovXG5cbiAgICBleGVjdXRlKGN1cnIpO1xuICAgIHJldHVybiBuZXh0LnByb3h5O1xuICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjcsIDMuM10gICovXG4gIH1cbn07XG4vKiAgZGVsaXZlciBhbiBhY3Rpb24gICovXG5cbnZhciBkZWxpdmVyID0gZnVuY3Rpb24gZGVsaXZlcihjdXJyLCBzdGF0ZSwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKGN1cnIuc3RhdGUgPT09IFNUQVRFX1BFTkRJTkcpIHtcbiAgICBjdXJyLnN0YXRlID0gc3RhdGU7XG4gICAgLyogIFtQcm9taXNlcy9BKyAyLjEuMi4xLCAyLjEuMy4xXSAgKi9cblxuICAgIGN1cnJbbmFtZV0gPSB2YWx1ZTtcbiAgICAvKiAgW1Byb21pc2VzL0ErIDIuMS4yLjIsIDIuMS4zLjJdICAqL1xuXG4gICAgZXhlY3V0ZShjdXJyKTtcbiAgfVxuXG4gIHJldHVybiBjdXJyO1xufTtcbi8qICBleGVjdXRlIGFsbCBoYW5kbGVycyAgKi9cblxuXG52YXIgZXhlY3V0ZSA9IGZ1bmN0aW9uIGV4ZWN1dGUoY3Vycikge1xuICBpZiAoY3Vyci5zdGF0ZSA9PT0gU1RBVEVfRlVMRklMTEVEKSBleGVjdXRlX2hhbmRsZXJzKGN1cnIsICdvbkZ1bGZpbGxlZCcsIGN1cnIuZnVsZmlsbFZhbHVlKTtlbHNlIGlmIChjdXJyLnN0YXRlID09PSBTVEFURV9SRUpFQ1RFRCkgZXhlY3V0ZV9oYW5kbGVycyhjdXJyLCAnb25SZWplY3RlZCcsIGN1cnIucmVqZWN0UmVhc29uKTtcbn07XG4vKiAgZXhlY3V0ZSBwYXJ0aWN1bGFyIHNldCBvZiBoYW5kbGVycyAgKi9cblxuXG52YXIgZXhlY3V0ZV9oYW5kbGVycyA9IGZ1bmN0aW9uIGV4ZWN1dGVfaGFuZGxlcnMoY3VyciwgbmFtZSwgdmFsdWUpIHtcbiAgLyogZ2xvYmFsIHNldEltbWVkaWF0ZTogdHJ1ZSAqL1xuXG4gIC8qIGdsb2JhbCBzZXRUaW1lb3V0OiB0cnVlICovXG5cbiAgLyogIHNob3J0LWNpcmN1aXQgcHJvY2Vzc2luZyAgKi9cbiAgaWYgKGN1cnJbbmFtZV0ubGVuZ3RoID09PSAwKSByZXR1cm47XG4gIC8qICBpdGVyYXRlIG92ZXIgYWxsIGhhbmRsZXJzLCBleGFjdGx5IG9uY2UgICovXG5cbiAgdmFyIGhhbmRsZXJzID0gY3VycltuYW1lXTtcbiAgY3VycltuYW1lXSA9IFtdO1xuICAvKiAgW1Byb21pc2VzL0ErIDIuMi4yLjMsIDIuMi4zLjNdICAqL1xuXG4gIHZhciBmdW5jID0gZnVuY3Rpb24gZnVuYygpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoYW5kbGVyc1tpXSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjVdICAqL1xuXG4gIH07XG4gIC8qICBleGVjdXRlIHByb2NlZHVyZSBhc3luY2hyb25vdXNseSAgKi9cblxuICAvKiAgW1Byb21pc2VzL0ErIDIuMi40LCAzLjFdICAqL1xuXG5cbiAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHNldEltbWVkaWF0ZShmdW5jKTtlbHNlIHNldFRpbWVvdXQoZnVuYywgMCk7XG59O1xuLyogIGdlbmVyYXRlIGEgcmVzb2x2ZXIgZnVuY3Rpb24gICovXG5cblxudmFyIHJlc29sdmVyID0gZnVuY3Rpb24gcmVzb2x2ZXIoY2IsIG5leHQsIG1ldGhvZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjEsIDIuMi43LjMsIDIuMi43LjRdICAqL1xuICAgICAgbmV4dFttZXRob2RdLmNhbGwobmV4dCwgdmFsdWUpO1xuICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNy4zLCAyLjIuNy40XSAgKi9cbiAgICBlbHNlIHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGNiKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjIuMSwgMi4yLjMuMSwgMi4yLjUsIDMuMl0gICovXG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICBuZXh0LnJlamVjdChlKTtcbiAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNy4yXSAgKi9cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUobmV4dCwgcmVzdWx0KTtcbiAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjcuMV0gICovXG4gICAgfVxuICB9O1xufTtcbi8qICBcIlByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmVcIiAgKi9cblxuLyogIFtQcm9taXNlcy9BKyAyLjNdICAqL1xuXG5cbnZhciByZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZShwcm9taXNlLCB4KSB7XG4gIC8qICBzYW5pdHkgY2hlY2sgYXJndW1lbnRzICAqL1xuXG4gIC8qICBbUHJvbWlzZXMvQSsgMi4zLjFdICAqL1xuICBpZiAocHJvbWlzZSA9PT0geCB8fCBwcm9taXNlLnByb3h5ID09PSB4KSB7XG4gICAgcHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignY2Fubm90IHJlc29sdmUgcHJvbWlzZSB3aXRoIGl0c2VsZicpKTtcbiAgICByZXR1cm47XG4gIH1cbiAgLyogIHN1cmdpY2FsbHkgY2hlY2sgZm9yIGEgXCJ0aGVuXCIgbWV0aG9kXG4gICAgKG1haW5seSB0byBqdXN0IGNhbGwgdGhlIFwiZ2V0dGVyXCIgb2YgXCJ0aGVuXCIgb25seSBvbmNlKSAgKi9cblxuXG4gIHZhciB0aGVuO1xuXG4gIGlmIChfdHlwZW9mKHgpID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsIHx8IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoZW4gPSB4LnRoZW47XG4gICAgfVxuICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMSwgMy41XSAgKi9cbiAgICBjYXRjaCAoZSkge1xuICAgICAgcHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjJdICAqL1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIC8qICBoYW5kbGUgb3duIFRoZW5hYmxlcyAgICBbUHJvbWlzZXMvQSsgMi4zLjJdXG4gICAgYW5kIHNpbWlsYXIgXCJ0aGVuYWJsZXNcIiBbUHJvbWlzZXMvQSsgMi4zLjNdICAqL1xuXG5cbiAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHJlc29sdmVkID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgLyogIGNhbGwgcmV0cmlldmVkIFwidGhlblwiIG1ldGhvZCAqL1xuXG4gICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjNdICAqL1xuICAgICAgdGhlbi5jYWxsKHgsXG4gICAgICAvKiAgcmVzb2x2ZVByb21pc2UgICovXG5cbiAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy4xXSAgKi9cbiAgICAgIGZ1bmN0aW9uICh5KSB7XG4gICAgICAgIGlmIChyZXNvbHZlZCkgcmV0dXJuO1xuICAgICAgICByZXNvbHZlZCA9IHRydWU7XG4gICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy4zXSAgKi9cblxuICAgICAgICBpZiAoeSA9PT0geClcbiAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDMuNl0gICovXG4gICAgICAgICAgcHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignY2lyY3VsYXIgdGhlbmFibGUgY2hhaW4nKSk7ZWxzZSByZXNvbHZlKHByb21pc2UsIHkpO1xuICAgICAgfSxcbiAgICAgIC8qICByZWplY3RQcm9taXNlICAqL1xuXG4gICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuMl0gICovXG4gICAgICBmdW5jdGlvbiAocikge1xuICAgICAgICBpZiAocmVzb2x2ZWQpIHJldHVybjtcbiAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuM10gICovXG5cbiAgICAgICAgcHJvbWlzZS5yZWplY3Qocik7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuM10gICovXG4gICAgICAgIHByb21pc2UucmVqZWN0KGUpO1xuICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjRdICAqL1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuICAvKiAgaGFuZGxlIG90aGVyIHZhbHVlcyAgKi9cblxuXG4gIHByb21pc2UuZnVsZmlsbCh4KTtcbiAgLyogIFtQcm9taXNlcy9BKyAyLjMuNCwgMi4zLjMuNF0gICovXG59OyAvLyBzbyB3ZSBhbHdheXMgaGF2ZSBQcm9taXNlLmFsbCgpXG5cblxuYXBpLmFsbCA9IGZ1bmN0aW9uIChwcykge1xuICByZXR1cm4gbmV3IGFwaShmdW5jdGlvbiAocmVzb2x2ZUFsbCwgcmVqZWN0QWxsKSB7XG4gICAgdmFyIHZhbHMgPSBuZXcgQXJyYXkocHMubGVuZ3RoKTtcbiAgICB2YXIgZG9uZUNvdW50ID0gMDtcblxuICAgIHZhciBmdWxmaWxsID0gZnVuY3Rpb24gZnVsZmlsbChpLCB2YWwpIHtcbiAgICAgIHZhbHNbaV0gPSB2YWw7XG4gICAgICBkb25lQ291bnQrKztcblxuICAgICAgaWYgKGRvbmVDb3VudCA9PT0gcHMubGVuZ3RoKSB7XG4gICAgICAgIHJlc29sdmVBbGwodmFscyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIChmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgcCA9IHBzW2ldO1xuICAgICAgICB2YXIgaXNQcm9taXNlID0gcCAhPSBudWxsICYmIHAudGhlbiAhPSBudWxsO1xuXG4gICAgICAgIGlmIChpc1Byb21pc2UpIHtcbiAgICAgICAgICBwLnRoZW4oZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgZnVsZmlsbChpLCB2YWwpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdEFsbChlcnIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB2YWwgPSBwO1xuICAgICAgICAgIGZ1bGZpbGwoaSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfSkoaSk7XG4gICAgfVxuICB9KTtcbn07XG5cbmFwaS5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gbmV3IGFwaShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVzb2x2ZSh2YWwpO1xuICB9KTtcbn07XG5cbmFwaS5yZWplY3QgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiBuZXcgYXBpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZWplY3QodmFsKTtcbiAgfSk7XG59O1xuXG52YXIgUHJvbWlzZSQxID0gdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnID8gUHJvbWlzZSA6IGFwaTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG52YXIgQW5pbWF0aW9uID0gZnVuY3Rpb24gQW5pbWF0aW9uKHRhcmdldCwgb3B0cywgb3B0czIpIHtcbiAgdmFyIGlzQ29yZSA9IGNvcmUodGFyZ2V0KTtcbiAgdmFyIGlzRWxlID0gIWlzQ29yZTtcblxuICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlID0gZXh0ZW5kKHtcbiAgICBkdXJhdGlvbjogMTAwMFxuICB9LCBvcHRzLCBvcHRzMik7XG5cbiAgX3AudGFyZ2V0ID0gdGFyZ2V0O1xuICBfcC5zdHlsZSA9IF9wLnN0eWxlIHx8IF9wLmNzcztcbiAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuICBfcC5wbGF5aW5nID0gZmFsc2U7XG4gIF9wLmhvb2tlZCA9IGZhbHNlO1xuICBfcC5hcHBseWluZyA9IGZhbHNlO1xuICBfcC5wcm9ncmVzcyA9IDA7XG4gIF9wLmNvbXBsZXRlcyA9IFtdO1xuICBfcC5mcmFtZXMgPSBbXTtcblxuICBpZiAoX3AuY29tcGxldGUgJiYgZm4kNihfcC5jb21wbGV0ZSkpIHtcbiAgICBfcC5jb21wbGV0ZXMucHVzaChfcC5jb21wbGV0ZSk7XG4gIH1cblxuICBpZiAoaXNFbGUpIHtcbiAgICB2YXIgcG9zID0gdGFyZ2V0LnBvc2l0aW9uKCk7XG4gICAgX3Auc3RhcnRQb3NpdGlvbiA9IF9wLnN0YXJ0UG9zaXRpb24gfHwge1xuICAgICAgeDogcG9zLngsXG4gICAgICB5OiBwb3MueVxuICAgIH07XG4gICAgX3Auc3RhcnRTdHlsZSA9IF9wLnN0YXJ0U3R5bGUgfHwgdGFyZ2V0LmN5KCkuc3R5bGUoKS5nZXRBbmltYXRpb25TdGFydFN0eWxlKHRhcmdldCwgX3Auc3R5bGUpO1xuICB9XG5cbiAgaWYgKGlzQ29yZSkge1xuICAgIHZhciBwYW4gPSB0YXJnZXQucGFuKCk7XG4gICAgX3Auc3RhcnRQYW4gPSB7XG4gICAgICB4OiBwYW4ueCxcbiAgICAgIHk6IHBhbi55XG4gICAgfTtcbiAgICBfcC5zdGFydFpvb20gPSB0YXJnZXQuem9vbSgpO1xuICB9IC8vIGZvciBmdXR1cmUgdGltZWxpbmUvYW5pbWF0aW9ucyBpbXBsXG5cblxuICB0aGlzLmxlbmd0aCA9IDE7XG4gIHRoaXNbMF0gPSB0aGlzO1xufTtcblxudmFyIGFuaWZuID0gQW5pbWF0aW9uLnByb3RvdHlwZTtcbmV4dGVuZChhbmlmbiwge1xuICBpbnN0YW5jZVN0cmluZzogZnVuY3Rpb24gaW5zdGFuY2VTdHJpbmcoKSB7XG4gICAgcmV0dXJuICdhbmltYXRpb24nO1xuICB9LFxuICBob29rOiBmdW5jdGlvbiBob29rKCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiAoIV9wLmhvb2tlZCkge1xuICAgICAgLy8gYWRkIHRvIHRhcmdldCdzIGFuaW1hdGlvbiBxdWV1ZVxuICAgICAgdmFyIHE7XG4gICAgICB2YXIgdEFuaSA9IF9wLnRhcmdldC5fcHJpdmF0ZS5hbmltYXRpb247XG5cbiAgICAgIGlmIChfcC5xdWV1ZSkge1xuICAgICAgICBxID0gdEFuaS5xdWV1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHEgPSB0QW5pLmN1cnJlbnQ7XG4gICAgICB9XG5cbiAgICAgIHEucHVzaCh0aGlzKTsgLy8gYWRkIHRvIHRoZSBhbmltYXRpb24gbG9vcCBwb29sXG5cbiAgICAgIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKF9wLnRhcmdldCkpIHtcbiAgICAgICAgX3AudGFyZ2V0LmN5KCkuYWRkVG9BbmltYXRpb25Qb29sKF9wLnRhcmdldCk7XG4gICAgICB9XG5cbiAgICAgIF9wLmhvb2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHBsYXk6IGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTsgLy8gYXV0b3Jld2luZFxuXG4gICAgaWYgKF9wLnByb2dyZXNzID09PSAxKSB7XG4gICAgICBfcC5wcm9ncmVzcyA9IDA7XG4gICAgfVxuXG4gICAgX3AucGxheWluZyA9IHRydWU7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlOyAvLyBuZWVkcyB0byBiZSBzdGFydGVkIGJ5IGFuaW1hdGlvbiBsb29wXG5cbiAgICBfcC5zdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5ob29rKCk7IC8vIHRoZSBhbmltYXRpb24gbG9vcCB3aWxsIHN0YXJ0IHRoZSBhbmltYXRpb24uLi5cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBwbGF5aW5nOiBmdW5jdGlvbiBwbGF5aW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnBsYXlpbmc7XG4gIH0sXG4gIGFwcGx5OiBmdW5jdGlvbiBhcHBseSgpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIF9wLmFwcGx5aW5nID0gdHJ1ZTtcbiAgICBfcC5zdGFydGVkID0gZmFsc2U7IC8vIG5lZWRzIHRvIGJlIHN0YXJ0ZWQgYnkgYW5pbWF0aW9uIGxvb3BcblxuICAgIF9wLnN0b3BwZWQgPSBmYWxzZTtcbiAgICB0aGlzLmhvb2soKTsgLy8gdGhlIGFuaW1hdGlvbiBsb29wIHdpbGwgYXBwbHkgdGhlIGFuaW1hdGlvbiBhdCB0aGlzIHByb2dyZXNzXG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYXBwbHlpbmc6IGZ1bmN0aW9uIGFwcGx5aW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmFwcGx5aW5nO1xuICB9LFxuICBwYXVzZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICBfcC5wbGF5aW5nID0gZmFsc2U7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgX3AucGxheWluZyA9IGZhbHNlO1xuICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBfcC5zdG9wcGVkID0gdHJ1ZTsgLy8gdG8gYmUgcmVtb3ZlZCBmcm9tIGFuaW1hdGlvbiBxdWV1ZXNcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZXdpbmQ6IGZ1bmN0aW9uIHJld2luZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9ncmVzcygwKTtcbiAgfSxcbiAgZmFzdGZvcndhcmQ6IGZ1bmN0aW9uIGZhc3Rmb3J3YXJkKCkge1xuICAgIHJldHVybiB0aGlzLnByb2dyZXNzKDEpO1xuICB9LFxuICB0aW1lOiBmdW5jdGlvbiB0aW1lKHQpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgaWYgKHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIF9wLnByb2dyZXNzICogX3AuZHVyYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnByb2dyZXNzKHQgLyBfcC5kdXJhdGlvbik7XG4gICAgfVxuICB9LFxuICBwcm9ncmVzczogZnVuY3Rpb24gcHJvZ3Jlc3MocCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIHdhc1BsYXlpbmcgPSBfcC5wbGF5aW5nO1xuXG4gICAgaWYgKHAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIF9wLnByb2dyZXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAod2FzUGxheWluZykge1xuICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICB9XG5cbiAgICAgIF9wLnByb2dyZXNzID0gcDtcbiAgICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKHdhc1BsYXlpbmcpIHtcbiAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGNvbXBsZXRlZDogZnVuY3Rpb24gY29tcGxldGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnByb2dyZXNzID09PSAxO1xuICB9LFxuICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIHdhc1BsYXlpbmcgPSBfcC5wbGF5aW5nO1xuXG4gICAgaWYgKHdhc1BsYXlpbmcpIHtcbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICB9XG5cbiAgICBfcC5wcm9ncmVzcyA9IDEgLSBfcC5wcm9ncmVzcztcbiAgICBfcC5zdGFydGVkID0gZmFsc2U7XG5cbiAgICB2YXIgc3dhcCA9IGZ1bmN0aW9uIHN3YXAoYSwgYikge1xuICAgICAgdmFyIF9wYSA9IF9wW2FdO1xuXG4gICAgICBpZiAoX3BhID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfcFthXSA9IF9wW2JdO1xuICAgICAgX3BbYl0gPSBfcGE7XG4gICAgfTtcblxuICAgIHN3YXAoJ3pvb20nLCAnc3RhcnRab29tJyk7XG4gICAgc3dhcCgncGFuJywgJ3N0YXJ0UGFuJyk7XG4gICAgc3dhcCgncG9zaXRpb24nLCAnc3RhcnRQb3NpdGlvbicpOyAvLyBzd2FwIHN0eWxlc1xuXG4gICAgaWYgKF9wLnN0eWxlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9wLnN0eWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wID0gX3Auc3R5bGVbaV07XG4gICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuICAgICAgICB2YXIgc3RhcnRTdHlsZVByb3AgPSBfcC5zdGFydFN0eWxlW25hbWVdO1xuICAgICAgICBfcC5zdGFydFN0eWxlW25hbWVdID0gcHJvcDtcbiAgICAgICAgX3Auc3R5bGVbaV0gPSBzdGFydFN0eWxlUHJvcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod2FzUGxheWluZykge1xuICAgICAgdGhpcy5wbGF5KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHByb21pc2U6IGZ1bmN0aW9uIHByb21pc2UodHlwZSkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIGFycjtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnZnJhbWUnOlxuICAgICAgICBhcnIgPSBfcC5mcmFtZXM7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgY2FzZSAnY29tcGxldGUnOlxuICAgICAgY2FzZSAnY29tcGxldGVkJzpcbiAgICAgICAgYXJyID0gX3AuY29tcGxldGVzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGFyci5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn0pO1xuYW5pZm4uY29tcGxldGUgPSBhbmlmbi5jb21wbGV0ZWQ7XG5hbmlmbi5ydW4gPSBhbmlmbi5wbGF5O1xuYW5pZm4ucnVubmluZyA9IGFuaWZuLnBsYXlpbmc7XG5cbnZhciBkZWZpbmUkMyA9IHtcbiAgYW5pbWF0ZWQ6IGZ1bmN0aW9uIGFuaW1hdGVkKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBhbmltYXRlZEltcGwoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcblxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZSA9IGFsbFswXTtcblxuICAgICAgaWYgKGVsZSkge1xuICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmFuaW1hdGlvbi5jdXJyZW50Lmxlbmd0aCA+IDA7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgLy8gYW5pbWF0ZWRcbiAgY2xlYXJRdWV1ZTogZnVuY3Rpb24gY2xlYXJRdWV1ZSgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gY2xlYXJRdWV1ZUltcGwoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcblxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gYWxsW2ldO1xuICAgICAgICBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLnF1ZXVlID0gW107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH0sXG4gIC8vIGNsZWFyUXVldWVcbiAgZGVsYXk6IGZ1bmN0aW9uIGRlbGF5KCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBkZWxheUltcGwodGltZSwgY29tcGxldGUpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSh7XG4gICAgICAgIGRlbGF5OiB0aW1lLFxuICAgICAgICBkdXJhdGlvbjogdGltZSxcbiAgICAgICAgY29tcGxldGU6IGNvbXBsZXRlXG4gICAgICB9KTtcbiAgICB9O1xuICB9LFxuICAvLyBkZWxheVxuICBkZWxheUFuaW1hdGlvbjogZnVuY3Rpb24gZGVsYXlBbmltYXRpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlbGF5QW5pbWF0aW9uSW1wbCh0aW1lLCBjb21wbGV0ZSkge1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5hbmltYXRpb24oe1xuICAgICAgICBkZWxheTogdGltZSxcbiAgICAgICAgZHVyYXRpb246IHRpbWUsXG4gICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVxuICAgICAgfSk7XG4gICAgfTtcbiAgfSxcbiAgLy8gZGVsYXlcbiAgYW5pbWF0aW9uOiBmdW5jdGlvbiBhbmltYXRpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFuaW1hdGlvbkltcGwocHJvcGVydGllcywgcGFyYW1zKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcblxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuICAgICAgdmFyIGlzQ29yZSA9ICFzZWxmSXNBcnJheUxpa2U7XG4gICAgICB2YXIgaXNFbGVzID0gIWlzQ29yZTtcblxuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgICAgIHByb3BlcnRpZXMgPSBleHRlbmQoe30sIHByb3BlcnRpZXMsIHBhcmFtcyk7XG4gICAgICB2YXIgcHJvcGVydGllc0VtcHR5ID0gT2JqZWN0LmtleXMocHJvcGVydGllcykubGVuZ3RoID09PSAwO1xuXG4gICAgICBpZiAocHJvcGVydGllc0VtcHR5KSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKGFsbFswXSwgcHJvcGVydGllcyk7IC8vIG5vdGhpbmcgdG8gYW5pbWF0ZVxuICAgICAgfVxuXG4gICAgICBpZiAocHJvcGVydGllcy5kdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BlcnRpZXMuZHVyYXRpb24gPSA0MDA7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcGVydGllcy5kdXJhdGlvbikge1xuICAgICAgICBjYXNlICdzbG93JzpcbiAgICAgICAgICBwcm9wZXJ0aWVzLmR1cmF0aW9uID0gNjAwO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Zhc3QnOlxuICAgICAgICAgIHByb3BlcnRpZXMuZHVyYXRpb24gPSAyMDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0VsZXMpIHtcbiAgICAgICAgcHJvcGVydGllcy5zdHlsZSA9IHN0eWxlLmdldFByb3BzTGlzdChwcm9wZXJ0aWVzLnN0eWxlIHx8IHByb3BlcnRpZXMuY3NzKTtcbiAgICAgICAgcHJvcGVydGllcy5jc3MgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0VsZXMgJiYgcHJvcGVydGllcy5yZW5kZXJlZFBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHJwb3MgPSBwcm9wZXJ0aWVzLnJlbmRlcmVkUG9zaXRpb247XG4gICAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICAgIHByb3BlcnRpZXMucG9zaXRpb24gPSByZW5kZXJlZFRvTW9kZWxQb3NpdGlvbihycG9zLCB6b29tLCBwYW4pO1xuICAgICAgfSAvLyBvdmVycmlkZSBwYW4gdy8gcGFuQnkgaWYgc2V0XG5cblxuICAgICAgaWYgKGlzQ29yZSAmJiBwcm9wZXJ0aWVzLnBhbkJ5ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHBhbkJ5ID0gcHJvcGVydGllcy5wYW5CeTtcbiAgICAgICAgdmFyIGN5UGFuID0gY3kucGFuKCk7XG4gICAgICAgIHByb3BlcnRpZXMucGFuID0ge1xuICAgICAgICAgIHg6IGN5UGFuLnggKyBwYW5CeS54LFxuICAgICAgICAgIHk6IGN5UGFuLnkgKyBwYW5CeS55XG4gICAgICAgIH07XG4gICAgICB9IC8vIG92ZXJyaWRlIHBhbiB3LyBjZW50ZXIgaWYgc2V0XG5cblxuICAgICAgdmFyIGNlbnRlciA9IHByb3BlcnRpZXMuY2VudGVyIHx8IHByb3BlcnRpZXMuY2VudHJlO1xuXG4gICAgICBpZiAoaXNDb3JlICYmIGNlbnRlciAhPSBudWxsKSB7XG4gICAgICAgIHZhciBjZW50ZXJQYW4gPSBjeS5nZXRDZW50ZXJQYW4oY2VudGVyLmVsZXMsIHByb3BlcnRpZXMuem9vbSk7XG5cbiAgICAgICAgaWYgKGNlbnRlclBhbiAhPSBudWxsKSB7XG4gICAgICAgICAgcHJvcGVydGllcy5wYW4gPSBjZW50ZXJQYW47XG4gICAgICAgIH1cbiAgICAgIH0gLy8gb3ZlcnJpZGUgcGFuICYgem9vbSB3LyBmaXQgaWYgc2V0XG5cblxuICAgICAgaWYgKGlzQ29yZSAmJiBwcm9wZXJ0aWVzLmZpdCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBmaXQgPSBwcm9wZXJ0aWVzLmZpdDtcbiAgICAgICAgdmFyIGZpdFZwID0gY3kuZ2V0Rml0Vmlld3BvcnQoZml0LmVsZXMgfHwgZml0LmJvdW5kaW5nQm94LCBmaXQucGFkZGluZyk7XG5cbiAgICAgICAgaWYgKGZpdFZwICE9IG51bGwpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IGZpdFZwLnBhbjtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnpvb20gPSBmaXRWcC56b29tO1xuICAgICAgICB9XG4gICAgICB9IC8vIG92ZXJyaWRlIHpvb20gKCYgcG90ZW50aWFsbHkgcGFuKSB3LyB6b29tIG9iaiBpZiBzZXRcblxuXG4gICAgICBpZiAoaXNDb3JlICYmIHBsYWluT2JqZWN0KHByb3BlcnRpZXMuem9vbSkpIHtcbiAgICAgICAgdmFyIHZwID0gY3kuZ2V0Wm9vbWVkVmlld3BvcnQocHJvcGVydGllcy56b29tKTtcblxuICAgICAgICBpZiAodnAgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICh2cC56b29tZWQpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuem9vbSA9IHZwLnpvb207XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZwLnBhbm5lZCkge1xuICAgICAgICAgICAgcHJvcGVydGllcy5wYW4gPSB2cC5wYW47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BlcnRpZXMuem9vbSA9IG51bGw7IC8vIGFuIGluYXZhbGlkIHpvb20gKGUuZy4gbm8gZGVsdGEpIGdldHMgYXV0b21hdGljYWxseSBkZXN0cm95ZWRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEFuaW1hdGlvbihhbGxbMF0sIHByb3BlcnRpZXMpO1xuICAgIH07XG4gIH0sXG4gIC8vIGFuaW1hdGVcbiAgYW5pbWF0ZTogZnVuY3Rpb24gYW5pbWF0ZSgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYW5pbWF0ZUltcGwocHJvcGVydGllcywgcGFyYW1zKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcblxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSBleHRlbmQoe30sIHByb3BlcnRpZXMsIHBhcmFtcyk7XG4gICAgICB9IC8vIG1hbnVhbGx5IGhvb2sgYW5kIHJ1biB0aGUgYW5pbWF0aW9uXG5cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGFsbFtpXTtcbiAgICAgICAgdmFyIHF1ZXVlID0gZWxlLmFuaW1hdGVkKCkgJiYgKHByb3BlcnRpZXMucXVldWUgPT09IHVuZGVmaW5lZCB8fCBwcm9wZXJ0aWVzLnF1ZXVlKTtcbiAgICAgICAgdmFyIGFuaSA9IGVsZS5hbmltYXRpb24ocHJvcGVydGllcywgcXVldWUgPyB7XG4gICAgICAgICAgcXVldWU6IHRydWVcbiAgICAgICAgfSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIGFuaS5wbGF5KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH07XG4gIH0sXG4gIC8vIGFuaW1hdGVcbiAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc3RvcEltcGwoY2xlYXJRdWV1ZSwganVtcFRvRW5kKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcblxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gYWxsW2ldO1xuICAgICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICAgIHZhciBhbmlzID0gX3AuYW5pbWF0aW9uLmN1cnJlbnQ7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbmlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIGFuaSA9IGFuaXNbal07XG4gICAgICAgICAgdmFyIGFuaV9wID0gYW5pLl9wcml2YXRlO1xuXG4gICAgICAgICAgaWYgKGp1bXBUb0VuZCkge1xuICAgICAgICAgICAgLy8gbmV4dCBpdGVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBsb29wLCB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAgICAvLyB3aWxsIGdvIHN0cmFpZ2h0IHRvIHRoZSBlbmQgYW5kIGJlIHJlbW92ZWRcbiAgICAgICAgICAgIGFuaV9wLmR1cmF0aW9uID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gY2xlYXIgdGhlIHF1ZXVlIG9mIGZ1dHVyZSBhbmltYXRpb25zXG5cblxuICAgICAgICBpZiAoY2xlYXJRdWV1ZSkge1xuICAgICAgICAgIF9wLmFuaW1hdGlvbi5xdWV1ZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFqdW1wVG9FbmQpIHtcbiAgICAgICAgICBfcC5hbmltYXRpb24uY3VycmVudCA9IFtdO1xuICAgICAgICB9XG4gICAgICB9IC8vIHdlIGhhdmUgdG8gbm90aWZ5ICh0aGUgYW5pbWF0aW9uIGxvb3AgZG9lc24ndCBkbyBpdCBmb3IgdXMgb24gYHN0b3BgKVxuXG5cbiAgICAgIGN5Lm5vdGlmeSgnZHJhdycpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfSAvLyBzdG9wXG5cbn07IC8vIGRlZmluZVxuXG52YXIgZGVmaW5lJDIgPSB7XG4gIC8vIGFjY2VzcyBkYXRhIGZpZWxkXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEocGFyYW1zKSB7XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgZmllbGQ6ICdkYXRhJyxcbiAgICAgIGJpbmRpbmdFdmVudDogJ2RhdGEnLFxuICAgICAgYWxsb3dCaW5kaW5nOiBmYWxzZSxcbiAgICAgIGFsbG93U2V0dGluZzogZmFsc2UsXG4gICAgICBhbGxvd0dldHRpbmc6IGZhbHNlLFxuICAgICAgc2V0dGluZ0V2ZW50OiAnZGF0YScsXG4gICAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogZmFsc2UsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICBpbW11dGFibGVLZXlzOiB7fSxcbiAgICAgIC8vIGtleSA9PiB0cnVlIGlmIGltbXV0YWJsZVxuICAgICAgdXBkYXRlU3R5bGU6IGZhbHNlLFxuICAgICAgYmVmb3JlR2V0OiBmdW5jdGlvbiBiZWZvcmVHZXQoc2VsZikge30sXG4gICAgICBiZWZvcmVTZXQ6IGZ1bmN0aW9uIGJlZm9yZVNldChzZWxmLCBvYmopIHt9LFxuICAgICAgb25TZXQ6IGZ1bmN0aW9uIG9uU2V0KHNlbGYpIHt9LFxuICAgICAgY2FuU2V0OiBmdW5jdGlvbiBjYW5TZXQoc2VsZikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHBhcmFtcyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMsIHBhcmFtcyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRhdGFJbXBsKG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgcCA9IHBhcmFtcztcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuXG4gICAgICB2YXIgc2luZ2xlID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZlswXSA6IHNlbGY7IC8vIC5kYXRhKCdmb28nLCAuLi4pXG5cbiAgICAgIGlmIChzdHJpbmcobmFtZSkpIHtcbiAgICAgICAgLy8gc2V0IG9yIGdldCBwcm9wZXJ0eVxuICAgICAgICB2YXIgaXNQYXRoTGlrZSA9IG5hbWUuaW5kZXhPZignLicpICE9PSAtMTsgLy8gdGhlcmUgbWlnaHQgYmUgYSBub3JtYWwgZmllbGQgd2l0aCBhIGRvdCBcblxuICAgICAgICB2YXIgcGF0aCA9IGlzUGF0aExpa2UgJiYgdG9QYXRoX19kZWZhdWx0W1wiZGVmYXVsdFwiXShuYW1lKTsgLy8gLmRhdGEoJ2ZvbycpXG5cbiAgICAgICAgaWYgKHAuYWxsb3dHZXR0aW5nICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBnZXRcbiAgICAgICAgICB2YXIgcmV0O1xuXG4gICAgICAgICAgaWYgKHNpbmdsZSkge1xuICAgICAgICAgICAgcC5iZWZvcmVHZXQoc2luZ2xlKTsgLy8gY2hlY2sgaWYgaXQncyBwYXRoIGFuZCBhIGZpZWxkIHdpdGggdGhlIHNhbWUgbmFtZSBkb2Vzbid0IGV4aXN0XG5cbiAgICAgICAgICAgIGlmIChwYXRoICYmIHNpbmdsZS5fcHJpdmF0ZVtwLmZpZWxkXVtuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldCA9IGdldF9fZGVmYXVsdFtcImRlZmF1bHRcIl0oc2luZ2xlLl9wcml2YXRlW3AuZmllbGRdLCBwYXRoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldCA9IHNpbmdsZS5fcHJpdmF0ZVtwLmZpZWxkXVtuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmV0OyAvLyAuZGF0YSgnZm9vJywgJ2JhcicpXG4gICAgICAgIH0gZWxzZSBpZiAocC5hbGxvd1NldHRpbmcgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIHNldFxuICAgICAgICAgIHZhciB2YWxpZCA9ICFwLmltbXV0YWJsZUtleXNbbmFtZV07XG5cbiAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBfZGVmaW5lUHJvcGVydHkoe30sIG5hbWUsIHZhbHVlKTtcblxuICAgICAgICAgICAgcC5iZWZvcmVTZXQoc2VsZiwgY2hhbmdlKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhbGwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBlbGUgPSBhbGxbaV07XG5cbiAgICAgICAgICAgICAgaWYgKHAuY2FuU2V0KGVsZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocGF0aCAmJiBzaW5nbGUuX3ByaXZhdGVbcC5maWVsZF1bbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgc2V0X19kZWZhdWx0W1wiZGVmYXVsdFwiXShlbGUuX3ByaXZhdGVbcC5maWVsZF0sIHBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZWxlLl9wcml2YXRlW3AuZmllbGRdW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIHVwZGF0ZSBtYXBwZXJzIGlmIGFza2VkXG5cblxuICAgICAgICAgICAgaWYgKHAudXBkYXRlU3R5bGUpIHtcbiAgICAgICAgICAgICAgc2VsZi51cGRhdGVTdHlsZSgpO1xuICAgICAgICAgICAgfSAvLyBjYWxsIG9uU2V0IGNhbGxiYWNrXG5cblxuICAgICAgICAgICAgcC5vblNldChzZWxmKTtcblxuICAgICAgICAgICAgaWYgKHAuc2V0dGluZ1RyaWdnZXJzRXZlbnQpIHtcbiAgICAgICAgICAgICAgc2VsZltwLnRyaWdnZXJGbk5hbWVdKHAuc2V0dGluZ0V2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gLmRhdGEoeyAnZm9vJzogJ2JhcicgfSlcblxuICAgICAgfSBlbHNlIGlmIChwLmFsbG93U2V0dGluZyAmJiBwbGFpbk9iamVjdChuYW1lKSkge1xuICAgICAgICAvLyBleHRlbmRcbiAgICAgICAgdmFyIG9iaiA9IG5hbWU7XG4gICAgICAgIHZhciBrLCB2O1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIHAuYmVmb3JlU2V0KHNlbGYsIG9iaik7XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGtleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgayA9IGtleXNbX2ldO1xuICAgICAgICAgIHYgPSBvYmpba107XG5cbiAgICAgICAgICB2YXIgX3ZhbGlkID0gIXAuaW1tdXRhYmxlS2V5c1trXTtcblxuICAgICAgICAgIGlmIChfdmFsaWQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYWxsLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBfZWxlID0gYWxsW2pdO1xuXG4gICAgICAgICAgICAgIGlmIChwLmNhblNldChfZWxlKSkge1xuICAgICAgICAgICAgICAgIF9lbGUuX3ByaXZhdGVbcC5maWVsZF1ba10gPSB2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHVwZGF0ZSBtYXBwZXJzIGlmIGFza2VkXG5cblxuICAgICAgICBpZiAocC51cGRhdGVTdHlsZSkge1xuICAgICAgICAgIHNlbGYudXBkYXRlU3R5bGUoKTtcbiAgICAgICAgfSAvLyBjYWxsIG9uU2V0IGNhbGxiYWNrXG5cblxuICAgICAgICBwLm9uU2V0KHNlbGYpO1xuXG4gICAgICAgIGlmIChwLnNldHRpbmdUcmlnZ2Vyc0V2ZW50KSB7XG4gICAgICAgICAgc2VsZltwLnRyaWdnZXJGbk5hbWVdKHAuc2V0dGluZ0V2ZW50KTtcbiAgICAgICAgfSAvLyAuZGF0YShmdW5jdGlvbigpeyAuLi4gfSlcblxuICAgICAgfSBlbHNlIGlmIChwLmFsbG93QmluZGluZyAmJiBmbiQ2KG5hbWUpKSB7XG4gICAgICAgIC8vIGJpbmQgdG8gZXZlbnRcbiAgICAgICAgdmFyIGZuID0gbmFtZTtcbiAgICAgICAgc2VsZi5vbihwLmJpbmRpbmdFdmVudCwgZm4pOyAvLyAuZGF0YSgpXG4gICAgICB9IGVsc2UgaWYgKHAuYWxsb3dHZXR0aW5nICYmIG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBnZXQgd2hvbGUgb2JqZWN0XG4gICAgICAgIHZhciBfcmV0O1xuXG4gICAgICAgIGlmIChzaW5nbGUpIHtcbiAgICAgICAgICBwLmJlZm9yZUdldChzaW5nbGUpO1xuICAgICAgICAgIF9yZXQgPSBzaW5nbGUuX3ByaXZhdGVbcC5maWVsZF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3JldDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluYWJpbGl0eVxuICAgIH07IC8vIGZ1bmN0aW9uXG4gIH0sXG4gIC8vIGRhdGFcbiAgLy8gcmVtb3ZlIGRhdGEgZmllbGRcbiAgcmVtb3ZlRGF0YTogZnVuY3Rpb24gcmVtb3ZlRGF0YShwYXJhbXMpIHtcbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICBmaWVsZDogJ2RhdGEnLFxuICAgICAgZXZlbnQ6ICdkYXRhJyxcbiAgICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICAgIHRyaWdnZXJFdmVudDogZmFsc2UsXG4gICAgICBpbW11dGFibGVLZXlzOiB7fSAvLyBrZXkgPT4gdHJ1ZSBpZiBpbW11dGFibGVcblxuICAgIH07XG4gICAgcGFyYW1zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlRGF0YUltcGwobmFtZXMpIHtcbiAgICAgIHZhciBwID0gcGFyYW1zO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICAvLyAucmVtb3ZlRGF0YSgnZm9vIGJhcicpXG5cbiAgICAgIGlmIChzdHJpbmcobmFtZXMpKSB7XG4gICAgICAgIC8vIHRoZW4gZ2V0IHRoZSBsaXN0IG9mIGtleXMsIGFuZCBkZWxldGUgdGhlbVxuICAgICAgICB2YXIga2V5cyA9IG5hbWVzLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIHZhciBsID0ga2V5cy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAvLyBkZWxldGUgZWFjaCBub24tZW1wdHkga2V5XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgICBpZiAoZW1wdHlTdHJpbmcoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHZhbGlkID0gIXAuaW1tdXRhYmxlS2V5c1trZXldOyAvLyBub3QgdmFsaWQgaWYgaW1tdXRhYmxlXG5cbiAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlfYSA9IDAsIGxfYSA9IGFsbC5sZW5ndGg7IGlfYSA8IGxfYTsgaV9hKyspIHtcbiAgICAgICAgICAgICAgYWxsW2lfYV0uX3ByaXZhdGVbcC5maWVsZF1ba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocC50cmlnZ2VyRXZlbnQpIHtcbiAgICAgICAgICBzZWxmW3AudHJpZ2dlckZuTmFtZV0ocC5ldmVudCk7XG4gICAgICAgIH0gLy8gLnJlbW92ZURhdGEoKVxuXG4gICAgICB9IGVsc2UgaWYgKG5hbWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdGhlbiBkZWxldGUgYWxsIGtleXNcbiAgICAgICAgZm9yICh2YXIgX2lfYSA9IDAsIF9sX2EgPSBhbGwubGVuZ3RoOyBfaV9hIDwgX2xfYTsgX2lfYSsrKSB7XG4gICAgICAgICAgdmFyIF9wcml2YXRlRmllbGRzID0gYWxsW19pX2FdLl9wcml2YXRlW3AuZmllbGRdO1xuXG4gICAgICAgICAgdmFyIF9rZXlzID0gT2JqZWN0LmtleXMoX3ByaXZhdGVGaWVsZHMpO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgX2tleXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgdmFyIF9rZXkgPSBfa2V5c1tfaTJdO1xuICAgICAgICAgICAgdmFyIHZhbGlkS2V5VG9EZWxldGUgPSAhcC5pbW11dGFibGVLZXlzW19rZXldO1xuXG4gICAgICAgICAgICBpZiAodmFsaWRLZXlUb0RlbGV0ZSkge1xuICAgICAgICAgICAgICBfcHJpdmF0ZUZpZWxkc1tfa2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocC50cmlnZ2VyRXZlbnQpIHtcbiAgICAgICAgICBzZWxmW3AudHJpZ2dlckZuTmFtZV0ocC5ldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluaW5nXG4gICAgfTsgLy8gZnVuY3Rpb25cbiAgfSAvLyByZW1vdmVEYXRhXG5cbn07IC8vIGRlZmluZVxuXG52YXIgZGVmaW5lJDEgPSB7XG4gIGV2ZW50QWxpYXNlc09uOiBmdW5jdGlvbiBldmVudEFsaWFzZXNPbihwcm90bykge1xuICAgIHZhciBwID0gcHJvdG87XG4gICAgcC5hZGRMaXN0ZW5lciA9IHAubGlzdGVuID0gcC5iaW5kID0gcC5vbjtcbiAgICBwLnVubGlzdGVuID0gcC51bmJpbmQgPSBwLm9mZiA9IHAucmVtb3ZlTGlzdGVuZXI7XG4gICAgcC50cmlnZ2VyID0gcC5lbWl0OyAvLyB0aGlzIGlzIGp1c3QgYSB3cmFwcGVyIGFsaWFzIG9mIC5vbigpXG5cbiAgICBwLnBvbiA9IHAucHJvbWlzZU9uID0gZnVuY3Rpb24gKGV2ZW50cywgc2VsZWN0b3IpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2soZSkge1xuICAgICAgICAgIHNlbGYub2ZmLmFwcGx5KHNlbGYsIG9mZkFyZ3MpO1xuICAgICAgICAgIHJlc29sdmUoZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG9uQXJncyA9IGFyZ3MuY29uY2F0KFtjYWxsYmFja10pO1xuICAgICAgICB2YXIgb2ZmQXJncyA9IG9uQXJncy5jb25jYXQoW10pO1xuICAgICAgICBzZWxmLm9uLmFwcGx5KHNlbGYsIG9uQXJncyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG59OyAvLyBkZWZpbmVcblxuLy8gdXNlIHRoaXMgbW9kdWxlIHRvIGNoZXJyeSBwaWNrIGZ1bmN0aW9ucyBpbnRvIHlvdXIgcHJvdG90eXBlXG52YXIgZGVmaW5lID0ge307XG5bZGVmaW5lJDMsIGRlZmluZSQyLCBkZWZpbmUkMV0uZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICBleHRlbmQoZGVmaW5lLCBtKTtcbn0pO1xuXG52YXIgZWxlc2ZuJGkgPSB7XG4gIGFuaW1hdGU6IGRlZmluZS5hbmltYXRlKCksXG4gIGFuaW1hdGlvbjogZGVmaW5lLmFuaW1hdGlvbigpLFxuICBhbmltYXRlZDogZGVmaW5lLmFuaW1hdGVkKCksXG4gIGNsZWFyUXVldWU6IGRlZmluZS5jbGVhclF1ZXVlKCksXG4gIGRlbGF5OiBkZWZpbmUuZGVsYXkoKSxcbiAgZGVsYXlBbmltYXRpb246IGRlZmluZS5kZWxheUFuaW1hdGlvbigpLFxuICBzdG9wOiBkZWZpbmUuc3RvcCgpXG59O1xuXG52YXIgZWxlc2ZuJGggPSB7XG4gIGNsYXNzZXM6IGZ1bmN0aW9uIGNsYXNzZXMoX2NsYXNzZXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoX2NsYXNzZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICBzZWxmWzBdLl9wcml2YXRlLmNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7XG4gICAgICAgIHJldHVybiByZXQucHVzaChjbHMpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSBlbHNlIGlmICghYXJyYXkoX2NsYXNzZXMpKSB7XG4gICAgICAvLyBleHRyYWN0IGNsYXNzZXMgZnJvbSBzdHJpbmdcbiAgICAgIF9jbGFzc2VzID0gKF9jbGFzc2VzIHx8ICcnKS5tYXRjaCgvXFxTKy9nKSB8fCBbXTtcbiAgICB9XG5cbiAgICB2YXIgY2hhbmdlZCA9IFtdO1xuICAgIHZhciBjbGFzc2VzU2V0ID0gbmV3IFNldCQxKF9jbGFzc2VzKTsgLy8gY2hlY2sgYW5kIHVwZGF0ZSBlYWNoIGVsZVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgZWxlID0gc2VsZltqXTtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBlbGVDbGFzc2VzID0gX3AuY2xhc3NlcztcbiAgICAgIHZhciBjaGFuZ2VkRWxlID0gZmFsc2U7IC8vIGNoZWNrIGlmIGVsZSBoYXMgYWxsIG9mIHRoZSBwYXNzZWQgY2xhc3Nlc1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9jbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjbHMgPSBfY2xhc3Nlc1tpXTtcbiAgICAgICAgdmFyIGVsZUhhc0NsYXNzID0gZWxlQ2xhc3Nlcy5oYXMoY2xzKTtcblxuICAgICAgICBpZiAoIWVsZUhhc0NsYXNzKSB7XG4gICAgICAgICAgY2hhbmdlZEVsZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gY2hlY2sgaWYgZWxlIGhhcyBjbGFzc2VzIG91dHNpZGUgb2YgdGhvc2UgcGFzc2VkXG5cblxuICAgICAgaWYgKCFjaGFuZ2VkRWxlKSB7XG4gICAgICAgIGNoYW5nZWRFbGUgPSBlbGVDbGFzc2VzLnNpemUgIT09IF9jbGFzc2VzLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZWRFbGUpIHtcbiAgICAgICAgX3AuY2xhc3NlcyA9IGNsYXNzZXNTZXQ7XG4gICAgICAgIGNoYW5nZWQucHVzaChlbGUpO1xuICAgICAgfVxuICAgIH0gLy8gdHJpZ2dlciB1cGRhdGUgc3R5bGUgb24gdGhvc2UgZWxlcyB0aGF0IGhhZCBjbGFzcyBjaGFuZ2VzXG5cblxuICAgIGlmIChjaGFuZ2VkLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuc3Bhd24oY2hhbmdlZCkudXBkYXRlU3R5bGUoKS5lbWl0KCdjbGFzcycpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9LFxuICBhZGRDbGFzczogZnVuY3Rpb24gYWRkQ2xhc3MoY2xhc3Nlcykge1xuICAgIHJldHVybiB0aGlzLnRvZ2dsZUNsYXNzKGNsYXNzZXMsIHRydWUpO1xuICB9LFxuICBoYXNDbGFzczogZnVuY3Rpb24gaGFzQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgcmV0dXJuIGVsZSAhPSBudWxsICYmIGVsZS5fcHJpdmF0ZS5jbGFzc2VzLmhhcyhjbGFzc05hbWUpO1xuICB9LFxuICB0b2dnbGVDbGFzczogZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoY2xhc3NlcywgdG9nZ2xlKSB7XG4gICAgaWYgKCFhcnJheShjbGFzc2VzKSkge1xuICAgICAgLy8gZXh0cmFjdCBjbGFzc2VzIGZyb20gc3RyaW5nXG4gICAgICBjbGFzc2VzID0gY2xhc3Nlcy5tYXRjaCgvXFxTKy9nKSB8fCBbXTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHRvZ2dsZVVuZGVmZCA9IHRvZ2dsZSA9PT0gdW5kZWZpbmVkO1xuICAgIHZhciBjaGFuZ2VkID0gW107IC8vIGVsZXMgd2hvIGhhZCBjbGFzc2VzIGNoYW5nZWRcblxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHNlbGYubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHNlbGZbaV07XG4gICAgICB2YXIgZWxlQ2xhc3NlcyA9IGVsZS5fcHJpdmF0ZS5jbGFzc2VzO1xuICAgICAgdmFyIGNoYW5nZWRFbGUgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjbGFzc2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBjbHMgPSBjbGFzc2VzW2pdO1xuICAgICAgICB2YXIgaGFzQ2xhc3MgPSBlbGVDbGFzc2VzLmhhcyhjbHMpO1xuICAgICAgICB2YXIgY2hhbmdlZE5vdyA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0b2dnbGUgfHwgdG9nZ2xlVW5kZWZkICYmICFoYXNDbGFzcykge1xuICAgICAgICAgIGVsZUNsYXNzZXMuYWRkKGNscyk7XG4gICAgICAgICAgY2hhbmdlZE5vdyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRvZ2dsZSB8fCB0b2dnbGVVbmRlZmQgJiYgaGFzQ2xhc3MpIHtcbiAgICAgICAgICBlbGVDbGFzc2VzW1wiZGVsZXRlXCJdKGNscyk7XG4gICAgICAgICAgY2hhbmdlZE5vdyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNoYW5nZWRFbGUgJiYgY2hhbmdlZE5vdykge1xuICAgICAgICAgIGNoYW5nZWQucHVzaChlbGUpO1xuICAgICAgICAgIGNoYW5nZWRFbGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIGZvciBqIGNsYXNzZXNcblxuICAgIH0gLy8gZm9yIGkgZWxlc1xuICAgIC8vIHRyaWdnZXIgdXBkYXRlIHN0eWxlIG9uIHRob3NlIGVsZXMgdGhhdCBoYWQgY2xhc3MgY2hhbmdlc1xuXG5cbiAgICBpZiAoY2hhbmdlZC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnNwYXduKGNoYW5nZWQpLnVwZGF0ZVN0eWxlKCkuZW1pdCgnY2xhc3MnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfSxcbiAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGNsYXNzZXMpIHtcbiAgICByZXR1cm4gdGhpcy50b2dnbGVDbGFzcyhjbGFzc2VzLCBmYWxzZSk7XG4gIH0sXG4gIGZsYXNoQ2xhc3M6IGZ1bmN0aW9uIGZsYXNoQ2xhc3MoY2xhc3NlcywgZHVyYXRpb24pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoZHVyYXRpb24gPT0gbnVsbCkge1xuICAgICAgZHVyYXRpb24gPSAyNTA7XG4gICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PT0gMCkge1xuICAgICAgcmV0dXJuIHNlbGY7IC8vIG5vdGhpbmcgdG8gZG8gcmVhbGx5XG4gICAgfVxuXG4gICAgc2VsZi5hZGRDbGFzcyhjbGFzc2VzKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYucmVtb3ZlQ2xhc3MoY2xhc3Nlcyk7XG4gICAgfSwgZHVyYXRpb24pO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG59O1xuZWxlc2ZuJGguY2xhc3NOYW1lID0gZWxlc2ZuJGguY2xhc3NOYW1lcyA9IGVsZXNmbiRoLmNsYXNzZXM7XG5cbnZhciB0b2tlbnMgPSB7XG4gIG1ldGFDaGFyOiAnW1xcXFwhXFxcXFwiXFxcXCNcXFxcJFxcXFwlXFxcXCZcXFxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFwuXFxcXC9cXFxcOlxcXFw7XFxcXDxcXFxcPVxcXFw+XFxcXD9cXFxcQFxcXFxbXFxcXF1cXFxcXlxcXFxgXFxcXHtcXFxcfFxcXFx9XFxcXH5dJyxcbiAgLy8gY2hhcnMgd2UgbmVlZCB0byBlc2NhcGUgaW4gbGV0IG5hbWVzLCBldGNcbiAgY29tcGFyYXRvck9wOiAnPXxcXFxcIT18Pnw+PXw8fDw9fFxcXFwkPXxcXFxcXj18XFxcXCo9JyxcbiAgLy8gYmluYXJ5IGNvbXBhcmlzb24gb3AgKHVzZWQgaW4gZGF0YSBzZWxlY3RvcnMpXG4gIGJvb2xPcDogJ1xcXFw/fFxcXFwhfFxcXFxeJyxcbiAgLy8gYm9vbGVhbiAodW5hcnkpIG9wZXJhdG9ycyAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycylcbiAgc3RyaW5nOiAnXCIoPzpcXFxcXFxcXFwifFteXCJdKSpcIicgKyAnfCcgKyBcIicoPzpcXFxcXFxcXCd8W14nXSkqJ1wiLFxuICAvLyBzdHJpbmcgbGl0ZXJhbHMgKHVzZWQgaW4gZGF0YSBzZWxlY3RvcnMpIC0tIGRvdWJsZXF1b3RlcyB8IHNpbmdsZXF1b3Rlc1xuICBudW1iZXI6IG51bWJlcixcbiAgLy8gbnVtYmVyIGxpdGVyYWwgKHVzZWQgaW4gZGF0YSBzZWxlY3RvcnMpIC0tLSBlLmcuIDAuMTIzNCwgMTIzNCwgMTJlMTIzXG4gIG1ldGE6ICdkZWdyZWV8aW5kZWdyZWV8b3V0ZGVncmVlJyxcbiAgLy8gYWxsb3dlZCBtZXRhZGF0YSBmaWVsZHMgKGkuZS4gYWxsb3dlZCBmdW5jdGlvbnMgdG8gdXNlIGZyb20gQ29sbGVjdGlvbilcbiAgc2VwYXJhdG9yOiAnXFxcXHMqLFxcXFxzKicsXG4gIC8vIHF1ZXJpZXMgYXJlIHNlcGFyYXRlZCBieSBjb21tYXMsIGUuZy4gZWRnZVtmb28gPSAnYmFyJ10sIG5vZGUuc29tZUNsYXNzXG4gIGRlc2NlbmRhbnQ6ICdcXFxccysnLFxuICBjaGlsZDogJ1xcXFxzKz5cXFxccysnLFxuICBzdWJqZWN0OiAnXFxcXCQnLFxuICBncm91cDogJ25vZGV8ZWRnZXxcXFxcKicsXG4gIGRpcmVjdGVkRWRnZTogJ1xcXFxzKy0+XFxcXHMrJyxcbiAgdW5kaXJlY3RlZEVkZ2U6ICdcXFxccys8LT5cXFxccysnXG59O1xudG9rZW5zLnZhcmlhYmxlID0gJyg/OltcXFxcdy0uXXwoPzpcXFxcXFxcXCcgKyB0b2tlbnMubWV0YUNoYXIgKyAnKSkrJzsgLy8gYSB2YXJpYWJsZSBuYW1lIGNhbiBoYXZlIGxldHRlcnMsIG51bWJlcnMsIGRhc2hlcywgYW5kIHBlcmlvZHNcblxudG9rZW5zLmNsYXNzTmFtZSA9ICcoPzpbXFxcXHctXXwoPzpcXFxcXFxcXCcgKyB0b2tlbnMubWV0YUNoYXIgKyAnKSkrJzsgLy8gYSBjbGFzcyBuYW1lIGhhcyB0aGUgc2FtZSBydWxlcyBhcyBhIHZhcmlhYmxlIGV4Y2VwdCBpdCBjYW4ndCBoYXZlIGEgJy4nIGluIHRoZSBuYW1lXG5cbnRva2Vucy52YWx1ZSA9IHRva2Vucy5zdHJpbmcgKyAnfCcgKyB0b2tlbnMubnVtYmVyOyAvLyBhIHZhbHVlIGxpdGVyYWwsIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXJcblxudG9rZW5zLmlkID0gdG9rZW5zLnZhcmlhYmxlOyAvLyBhbiBlbGVtZW50IGlkIChmb2xsb3dzIHZhcmlhYmxlIGNvbnZlbnRpb25zKVxuXG4oZnVuY3Rpb24gKCkge1xuICB2YXIgb3BzLCBvcCwgaTsgLy8gYWRkIEAgdmFyaWFudHMgdG8gY29tcGFyYXRvck9wXG5cbiAgb3BzID0gdG9rZW5zLmNvbXBhcmF0b3JPcC5zcGxpdCgnfCcpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIHtcbiAgICBvcCA9IG9wc1tpXTtcbiAgICB0b2tlbnMuY29tcGFyYXRvck9wICs9ICd8QCcgKyBvcDtcbiAgfSAvLyBhZGQgISB2YXJpYW50cyB0byBjb21wYXJhdG9yT3BcblxuXG4gIG9wcyA9IHRva2Vucy5jb21wYXJhdG9yT3Auc3BsaXQoJ3wnKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3AgPSBvcHNbaV07XG5cbiAgICBpZiAob3AuaW5kZXhPZignIScpID49IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gc2tpcCBvcHMgdGhhdCBleHBsaWNpdGx5IGNvbnRhaW4gIVxuXG5cbiAgICBpZiAob3AgPT09ICc9Jykge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBza2lwID0gYi9jICE9IGlzIGV4cGxpY2l0bHkgZGVmaW5lZFxuXG5cbiAgICB0b2tlbnMuY29tcGFyYXRvck9wICs9ICd8XFxcXCEnICsgb3A7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogTWFrZSBhIG5ldyBxdWVyeSBvYmplY3RcbiAqXG4gKiBAcHJvcCB0eXBlIHtUeXBlfSBUaGUgdHlwZSBlbnVtIChpbnQpIG9mIHRoZSBxdWVyeVxuICogQHByb3AgY2hlY2tzIExpc3Qgb2YgY2hlY2tzIHRvIG1ha2UgYWdhaW5zdCBhbiBlbGUgdG8gdGVzdCBmb3IgYSBtYXRjaFxuICovXG52YXIgbmV3UXVlcnkgPSBmdW5jdGlvbiBuZXdRdWVyeSgpIHtcbiAgcmV0dXJuIHtcbiAgICBjaGVja3M6IFtdXG4gIH07XG59O1xuXG4vKipcbiAqIEEgY2hlY2sgdHlwZSBlbnVtLWxpa2Ugb2JqZWN0LiAgVXNlcyBpbnRlZ2VyIHZhbHVlcyBmb3IgZmFzdCBtYXRjaCgpIGxvb2t1cC5cbiAqIFRoZSBvcmRlcmluZyBkb2VzIG5vdCBtYXR0ZXIgYXMgbG9uZyBhcyB0aGUgaW50cyBhcmUgdW5pcXVlLlxuICovXG52YXIgVHlwZSA9IHtcbiAgLyoqIEUuZy4gbm9kZSAqL1xuICBHUk9VUDogMCxcblxuICAvKiogQSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzICovXG4gIENPTExFQ1RJT046IDEsXG5cbiAgLyoqIEEgZmlsdGVyKGVsZSkgZnVuY3Rpb24gKi9cbiAgRklMVEVSOiAyLFxuXG4gIC8qKiBFLmcuIFtmb28gPiAxXSAqL1xuICBEQVRBX0NPTVBBUkU6IDMsXG5cbiAgLyoqIEUuZy4gW2Zvb10gKi9cbiAgREFUQV9FWElTVDogNCxcblxuICAvKiogRS5nLiBbP2Zvb10gKi9cbiAgREFUQV9CT09MOiA1LFxuXG4gIC8qKiBFLmcuIFtbZGVncmVlID4gMl1dICovXG4gIE1FVEFfQ09NUEFSRTogNixcblxuICAvKiogRS5nLiA6c2VsZWN0ZWQgKi9cbiAgU1RBVEU6IDcsXG5cbiAgLyoqIEUuZy4gI2ZvbyAqL1xuICBJRDogOCxcblxuICAvKiogRS5nLiAuZm9vICovXG4gIENMQVNTOiA5LFxuXG4gIC8qKiBFLmcuICNmb28gPC0+ICNiYXIgKi9cbiAgVU5ESVJFQ1RFRF9FREdFOiAxMCxcblxuICAvKiogRS5nLiAjZm9vIC0+ICNiYXIgKi9cbiAgRElSRUNURURfRURHRTogMTEsXG5cbiAgLyoqIEUuZy4gJCNmb28gLT4gI2JhciAqL1xuICBOT0RFX1NPVVJDRTogMTIsXG5cbiAgLyoqIEUuZy4gI2ZvbyAtPiAkI2JhciAqL1xuICBOT0RFX1RBUkdFVDogMTMsXG5cbiAgLyoqIEUuZy4gJCNmb28gPC0+ICNiYXIgKi9cbiAgTk9ERV9ORUlHSEJPUjogMTQsXG5cbiAgLyoqIEUuZy4gI2ZvbyA+ICNiYXIgKi9cbiAgQ0hJTEQ6IDE1LFxuXG4gIC8qKiBFLmcuICNmb28gI2JhciAqL1xuICBERVNDRU5EQU5UOiAxNixcblxuICAvKiogRS5nLiAkI2ZvbyA+ICNiYXIgKi9cbiAgUEFSRU5UOiAxNyxcblxuICAvKiogRS5nLiAkI2ZvbyAjYmFyICovXG4gIEFOQ0VTVE9SOiAxOCxcblxuICAvKiogRS5nLiAjZm9vID4gJGJhciA+ICNiYXogKi9cbiAgQ09NUE9VTkRfU1BMSVQ6IDE5LFxuXG4gIC8qKiBBbHdheXMgbWF0Y2hlcywgdXNlZnVsIHBsYWNlaG9sZGVyIGZvciBzdWJqZWN0IGluIGBDT01QT1VORF9TUExJVGAgKi9cbiAgVFJVRTogMjBcbn07XG5cbnZhciBzdGF0ZVNlbGVjdG9ycyA9IFt7XG4gIHNlbGVjdG9yOiAnOnNlbGVjdGVkJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLnNlbGVjdGVkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6dW5zZWxlY3RlZCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuc2VsZWN0ZWQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpzZWxlY3RhYmxlJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLnNlbGVjdGFibGUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzp1bnNlbGVjdGFibGUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiAhZWxlLnNlbGVjdGFibGUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpsb2NrZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUubG9ja2VkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6dW5sb2NrZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiAhZWxlLmxvY2tlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnZpc2libGUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUudmlzaWJsZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmhpZGRlbicsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUudmlzaWJsZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnRyYW5zcGFyZW50JyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLnRyYW5zcGFyZW50KCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6Z3JhYmJlZCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5ncmFiYmVkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6ZnJlZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuZ3JhYmJlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnJlbW92ZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUucmVtb3ZlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmluc2lkZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUucmVtb3ZlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmdyYWJiYWJsZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5ncmFiYmFibGUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzp1bmdyYWJiYWJsZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuZ3JhYmJhYmxlKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6YW5pbWF0ZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuYW5pbWF0ZWQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzp1bmFuaW1hdGVkJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5hbmltYXRlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnBhcmVudCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5pc1BhcmVudCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmNoaWxkbGVzcycsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5pc0NoaWxkbGVzcygpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmNoaWxkJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmlzQ2hpbGQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpvcnBoYW4nLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuaXNPcnBoYW4oKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpub25vcnBoYW4nLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuaXNDaGlsZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmNvbXBvdW5kJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICByZXR1cm4gZWxlLmlzUGFyZW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbGUuc291cmNlKCkuaXNQYXJlbnQoKSB8fCBlbGUudGFyZ2V0KCkuaXNQYXJlbnQoKTtcbiAgICB9XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6bG9vcCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5pc0xvb3AoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpzaW1wbGUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuaXNTaW1wbGUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzphY3RpdmUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuYWN0aXZlKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6aW5hY3RpdmUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiAhZWxlLmFjdGl2ZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmJhY2tncm91bmRpbmcnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuYmFja2dyb3VuZGluZygpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOm5vbmJhY2tncm91bmRpbmcnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiAhZWxlLmJhY2tncm91bmRpbmcoKTtcbiAgfVxufV0uc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAvLyBuLmIuIHNlbGVjdG9ycyB0aGF0IGFyZSBzdGFydGluZyBzdWJzdHJpbmdzIG9mIG90aGVycyBtdXN0IGhhdmUgdGhlIGxvbmdlciBvbmVzIGZpcnN0XG4gIHJldHVybiBkZXNjZW5kaW5nKGEuc2VsZWN0b3IsIGIuc2VsZWN0b3IpO1xufSk7XG5cbnZhciBsb29rdXAgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxUb0ZuID0ge307XG4gIHZhciBzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVTZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICBzID0gc3RhdGVTZWxlY3RvcnNbaV07XG4gICAgc2VsVG9GbltzLnNlbGVjdG9yXSA9IHMubWF0Y2hlcztcbiAgfVxuXG4gIHJldHVybiBzZWxUb0ZuO1xufSgpO1xuXG52YXIgc3RhdGVTZWxlY3Rvck1hdGNoZXMgPSBmdW5jdGlvbiBzdGF0ZVNlbGVjdG9yTWF0Y2hlcyhzZWwsIGVsZSkge1xuICByZXR1cm4gbG9va3VwW3NlbF0oZWxlKTtcbn07XG52YXIgc3RhdGVTZWxlY3RvclJlZ2V4ID0gJygnICsgc3RhdGVTZWxlY3RvcnMubWFwKGZ1bmN0aW9uIChzKSB7XG4gIHJldHVybiBzLnNlbGVjdG9yO1xufSkuam9pbignfCcpICsgJyknO1xuXG4vLyBzbyB0aGF0IHZhbHVlcyBnZXQgY29tcGFyZWQgcHJvcGVybHkgaW4gU2VsZWN0b3IuZmlsdGVyKClcblxudmFyIGNsZWFuTWV0YUNoYXJzID0gZnVuY3Rpb24gY2xlYW5NZXRhQ2hhcnMoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcXFxcXCgnICsgdG9rZW5zLm1ldGFDaGFyICsgJyknLCAnZycpLCBmdW5jdGlvbiAobWF0Y2gsICQxKSB7XG4gICAgcmV0dXJuICQxO1xuICB9KTtcbn07XG5cbnZhciByZXBsYWNlTGFzdFF1ZXJ5ID0gZnVuY3Rpb24gcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgZXhhbWluaW5nUXVlcnksIHJlcGxhY2VtZW50UXVlcnkpIHtcbiAgc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV0gPSByZXBsYWNlbWVudFF1ZXJ5O1xufTsgLy8gTk9URTogYWRkIG5ldyBleHByZXNzaW9uIHN5bnRheCBoZXJlIHRvIGhhdmUgaXQgcmVjb2duaXNlZCBieSB0aGUgcGFyc2VyO1xuLy8gLSBhIHF1ZXJ5IGNvbnRhaW5zIGFsbCBhZGphY2VudCAoaS5lLiBubyBzZXBhcmF0b3IgaW4gYmV0d2VlbikgZXhwcmVzc2lvbnM7XG4vLyAtIHRoZSBjdXJyZW50IHF1ZXJ5IGlzIHN0b3JlZCBpbiBzZWxlY3RvcltpXVxuLy8gLSB5b3UgbmVlZCB0byBjaGVjayB0aGUgcXVlcnkgb2JqZWN0cyBpbiBtYXRjaCgpIGZvciBpdCBhY3R1YWxseSBmaWx0ZXIgcHJvcGVybHksIGJ1dCB0aGF0J3MgcHJldHR5IHN0cmFpZ2h0IGZvcndhcmRcblxuXG52YXIgZXhwcnMgPSBbe1xuICBuYW1lOiAnZ3JvdXAnLFxuICAvLyBqdXN0IHVzZWQgZm9yIGlkZW50aWZ5aW5nIHdoZW4gZGVidWdnaW5nXG4gIHF1ZXJ5OiB0cnVlLFxuICByZWdleDogJygnICsgdG9rZW5zLmdyb3VwICsgJyknLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmKSB7XG4gICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMSksXG4gICAgICAgIGdyb3VwID0gX3JlZjJbMF07XG5cbiAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICB0eXBlOiBUeXBlLkdST1VQLFxuICAgICAgdmFsdWU6IGdyb3VwID09PSAnKicgPyBncm91cCA6IGdyb3VwICsgJ3MnXG4gICAgfSk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ3N0YXRlJyxcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiBzdGF0ZVNlbGVjdG9yUmVnZXgsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWYzKSB7XG4gICAgdmFyIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDEpLFxuICAgICAgICBzdGF0ZSA9IF9yZWY0WzBdO1xuXG4gICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgdHlwZTogVHlwZS5TVEFURSxcbiAgICAgIHZhbHVlOiBzdGF0ZVxuICAgIH0pO1xuICB9XG59LCB7XG4gIG5hbWU6ICdpZCcsXG4gIHF1ZXJ5OiB0cnVlLFxuICByZWdleDogJ1xcXFwjKCcgKyB0b2tlbnMuaWQgKyAnKScsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWY1KSB7XG4gICAgdmFyIF9yZWY2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjUsIDEpLFxuICAgICAgICBpZCA9IF9yZWY2WzBdO1xuXG4gICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgdHlwZTogVHlwZS5JRCxcbiAgICAgIHZhbHVlOiBjbGVhbk1ldGFDaGFycyhpZClcbiAgICB9KTtcbiAgfVxufSwge1xuICBuYW1lOiAnY2xhc3NOYW1lJyxcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiAnXFxcXC4oJyArIHRva2Vucy5jbGFzc05hbWUgKyAnKScsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWY3KSB7XG4gICAgdmFyIF9yZWY4ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjcsIDEpLFxuICAgICAgICBjbGFzc05hbWUgPSBfcmVmOFswXTtcblxuICAgIHF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgIHR5cGU6IFR5cGUuQ0xBU1MsXG4gICAgICB2YWx1ZTogY2xlYW5NZXRhQ2hhcnMoY2xhc3NOYW1lKVxuICAgIH0pO1xuICB9XG59LCB7XG4gIG5hbWU6ICdkYXRhRXhpc3RzJyxcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiAnXFxcXFtcXFxccyooJyArIHRva2Vucy52YXJpYWJsZSArICcpXFxcXHMqXFxcXF0nLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmOSkge1xuICAgIHZhciBfcmVmMTAgPSBfc2xpY2VkVG9BcnJheShfcmVmOSwgMSksXG4gICAgICAgIHZhcmlhYmxlID0gX3JlZjEwWzBdO1xuXG4gICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgdHlwZTogVHlwZS5EQVRBX0VYSVNULFxuICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKHZhcmlhYmxlKVxuICAgIH0pO1xuICB9XG59LCB7XG4gIG5hbWU6ICdkYXRhQ29tcGFyZScsXG4gIHF1ZXJ5OiB0cnVlLFxuICByZWdleDogJ1xcXFxbXFxcXHMqKCcgKyB0b2tlbnMudmFyaWFibGUgKyAnKVxcXFxzKignICsgdG9rZW5zLmNvbXBhcmF0b3JPcCArICcpXFxcXHMqKCcgKyB0b2tlbnMudmFsdWUgKyAnKVxcXFxzKlxcXFxdJyxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSwgX3JlZjExKSB7XG4gICAgdmFyIF9yZWYxMiA9IF9zbGljZWRUb0FycmF5KF9yZWYxMSwgMyksXG4gICAgICAgIHZhcmlhYmxlID0gX3JlZjEyWzBdLFxuICAgICAgICBjb21wYXJhdG9yT3AgPSBfcmVmMTJbMV0sXG4gICAgICAgIHZhbHVlID0gX3JlZjEyWzJdO1xuXG4gICAgdmFyIHZhbHVlSXNTdHJpbmcgPSBuZXcgUmVnRXhwKCdeJyArIHRva2Vucy5zdHJpbmcgKyAnJCcpLmV4ZWModmFsdWUpICE9IG51bGw7XG5cbiAgICBpZiAodmFsdWVJc1N0cmluZykge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSwgdmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgdHlwZTogVHlwZS5EQVRBX0NPTVBBUkUsXG4gICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnModmFyaWFibGUpLFxuICAgICAgb3BlcmF0b3I6IGNvbXBhcmF0b3JPcCxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xuICB9XG59LCB7XG4gIG5hbWU6ICdkYXRhQm9vbCcsXG4gIHF1ZXJ5OiB0cnVlLFxuICByZWdleDogJ1xcXFxbXFxcXHMqKCcgKyB0b2tlbnMuYm9vbE9wICsgJylcXFxccyooJyArIHRva2Vucy52YXJpYWJsZSArICcpXFxcXHMqXFxcXF0nLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmMTMpIHtcbiAgICB2YXIgX3JlZjE0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjEzLCAyKSxcbiAgICAgICAgYm9vbE9wID0gX3JlZjE0WzBdLFxuICAgICAgICB2YXJpYWJsZSA9IF9yZWYxNFsxXTtcblxuICAgIHF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgIHR5cGU6IFR5cGUuREFUQV9CT09MLFxuICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKHZhcmlhYmxlKSxcbiAgICAgIG9wZXJhdG9yOiBib29sT3BcbiAgICB9KTtcbiAgfVxufSwge1xuICBuYW1lOiAnbWV0YUNvbXBhcmUnLFxuICBxdWVyeTogdHJ1ZSxcbiAgcmVnZXg6ICdcXFxcW1xcXFxbXFxcXHMqKCcgKyB0b2tlbnMubWV0YSArICcpXFxcXHMqKCcgKyB0b2tlbnMuY29tcGFyYXRvck9wICsgJylcXFxccyooJyArIHRva2Vucy5udW1iZXIgKyAnKVxcXFxzKlxcXFxdXFxcXF0nLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmMTUpIHtcbiAgICB2YXIgX3JlZjE2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjE1LCAzKSxcbiAgICAgICAgbWV0YSA9IF9yZWYxNlswXSxcbiAgICAgICAgY29tcGFyYXRvck9wID0gX3JlZjE2WzFdLFxuICAgICAgICBudW1iZXIgPSBfcmVmMTZbMl07XG5cbiAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICB0eXBlOiBUeXBlLk1FVEFfQ09NUEFSRSxcbiAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyhtZXRhKSxcbiAgICAgIG9wZXJhdG9yOiBjb21wYXJhdG9yT3AsXG4gICAgICB2YWx1ZTogcGFyc2VGbG9hdChudW1iZXIpXG4gICAgfSk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ25leHRRdWVyeScsXG4gIHNlcGFyYXRvcjogdHJ1ZSxcbiAgcmVnZXg6IHRva2Vucy5zZXBhcmF0b3IsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICB2YXIgY3VycmVudFN1YmplY3QgPSBzZWxlY3Rvci5jdXJyZW50U3ViamVjdDtcbiAgICB2YXIgZWRnZUNvdW50ID0gc2VsZWN0b3IuZWRnZUNvdW50O1xuICAgIHZhciBjb21wb3VuZENvdW50ID0gc2VsZWN0b3IuY29tcG91bmRDb3VudDtcbiAgICB2YXIgbGFzdFEgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXTtcblxuICAgIGlmIChjdXJyZW50U3ViamVjdCAhPSBudWxsKSB7XG4gICAgICBsYXN0US5zdWJqZWN0ID0gY3VycmVudFN1YmplY3Q7XG4gICAgICBzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9IG51bGw7XG4gICAgfVxuXG4gICAgbGFzdFEuZWRnZUNvdW50ID0gZWRnZUNvdW50O1xuICAgIGxhc3RRLmNvbXBvdW5kQ291bnQgPSBjb21wb3VuZENvdW50O1xuICAgIHNlbGVjdG9yLmVkZ2VDb3VudCA9IDA7XG4gICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCA9IDA7IC8vIGdvIG9uIHRvIG5leHQgcXVlcnlcblxuICAgIHZhciBuZXh0UXVlcnkgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGgrK10gPSBuZXdRdWVyeSgpO1xuICAgIHJldHVybiBuZXh0UXVlcnk7IC8vIHRoaXMgaXMgdGhlIG5ldyBxdWVyeSB0byBiZSBmaWxsZWQgYnkgdGhlIGZvbGxvd2luZyBleHByc1xuICB9XG59LCB7XG4gIG5hbWU6ICdkaXJlY3RlZEVkZ2UnLFxuICBzZXBhcmF0b3I6IHRydWUsXG4gIHJlZ2V4OiB0b2tlbnMuZGlyZWN0ZWRFZGdlLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gICAgaWYgKHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID09IG51bGwpIHtcbiAgICAgIC8vIHVuZGlyZWN0ZWQgZWRnZVxuICAgICAgdmFyIGVkZ2VRdWVyeSA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgc291cmNlID0gcXVlcnk7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3UXVlcnkoKTtcbiAgICAgIGVkZ2VRdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuRElSRUNURURfRURHRSxcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgICB9KTsgLy8gdGhlIHF1ZXJ5IGluIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgdGhlIGVkZ2UgcmF0aGVyIHRoYW4gdGhlIHNvdXJjZVxuXG4gICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBxdWVyeSwgZWRnZVF1ZXJ5KTtcbiAgICAgIHNlbGVjdG9yLmVkZ2VDb3VudCsrOyAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgdGFyZ2V0IHF1ZXJ5IHdpdGggZXhwcmVzc2lvbnMgdGhhdCBmb2xsb3dcblxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc291cmNlL3RhcmdldFxuICAgICAgdmFyIHNyY1RndFEgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIF9zb3VyY2UgPSBxdWVyeTtcblxuICAgICAgdmFyIF90YXJnZXQgPSBuZXdRdWVyeSgpO1xuXG4gICAgICBzcmNUZ3RRLmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5OT0RFX1NPVVJDRSxcbiAgICAgICAgc291cmNlOiBfc291cmNlLFxuICAgICAgICB0YXJnZXQ6IF90YXJnZXRcbiAgICAgIH0pOyAvLyB0aGUgcXVlcnkgaW4gdGhlIHNlbGVjdG9yIHNob3VsZCBiZSB0aGUgbmVpZ2hib3VyaG9vZCByYXRoZXIgdGhhbiB0aGUgbm9kZVxuXG4gICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBxdWVyeSwgc3JjVGd0USk7XG4gICAgICBzZWxlY3Rvci5lZGdlQ291bnQrKztcbiAgICAgIHJldHVybiBfdGFyZ2V0OyAvLyBub3cgcG9wdWxhdGluZyB0aGUgdGFyZ2V0IHdpdGggdGhlIGZvbGxvd2luZyBleHByZXNzaW9uc1xuICAgIH1cbiAgfVxufSwge1xuICBuYW1lOiAndW5kaXJlY3RlZEVkZ2UnLFxuICBzZXBhcmF0b3I6IHRydWUsXG4gIHJlZ2V4OiB0b2tlbnMudW5kaXJlY3RlZEVkZ2UsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPT0gbnVsbCkge1xuICAgICAgLy8gdW5kaXJlY3RlZCBlZGdlXG4gICAgICB2YXIgZWRnZVF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBzb3VyY2UgPSBxdWVyeTtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXdRdWVyeSgpO1xuICAgICAgZWRnZVF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5VTkRJUkVDVEVEX0VER0UsXG4gICAgICAgIG5vZGVzOiBbc291cmNlLCB0YXJnZXRdXG4gICAgICB9KTsgLy8gdGhlIHF1ZXJ5IGluIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgdGhlIGVkZ2UgcmF0aGVyIHRoYW4gdGhlIHNvdXJjZVxuXG4gICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBxdWVyeSwgZWRnZVF1ZXJ5KTtcbiAgICAgIHNlbGVjdG9yLmVkZ2VDb3VudCsrOyAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgdGFyZ2V0IHF1ZXJ5IHdpdGggZXhwcmVzc2lvbnMgdGhhdCBmb2xsb3dcblxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbmVpZ2hib3VyaG9vZFxuICAgICAgdmFyIG5ob29kUSA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgbm9kZSA9IHF1ZXJ5O1xuICAgICAgdmFyIG5laWdoYm9yID0gbmV3UXVlcnkoKTtcbiAgICAgIG5ob29kUS5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuTk9ERV9ORUlHSEJPUixcbiAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgbmVpZ2hib3I6IG5laWdoYm9yXG4gICAgICB9KTsgLy8gdGhlIHF1ZXJ5IGluIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgdGhlIG5laWdoYm91cmhvb2QgcmF0aGVyIHRoYW4gdGhlIG5vZGVcblxuICAgICAgcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgcXVlcnksIG5ob29kUSk7XG4gICAgICByZXR1cm4gbmVpZ2hib3I7IC8vIG5vdyBwb3B1bGF0aW5nIHRoZSBuZWlnaGJvciB3aXRoIGZvbGxvd2luZyBleHByZXNzaW9uc1xuICAgIH1cbiAgfVxufSwge1xuICBuYW1lOiAnY2hpbGQnLFxuICBzZXBhcmF0b3I6IHRydWUsXG4gIHJlZ2V4OiB0b2tlbnMuY2hpbGQsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPT0gbnVsbCkge1xuICAgICAgLy8gZGVmYXVsdDogY2hpbGQgcXVlcnlcbiAgICAgIHZhciBwYXJlbnRDaGlsZFF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBjaGlsZCA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgcGFyZW50ID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV07XG4gICAgICBwYXJlbnRDaGlsZFF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5DSElMRCxcbiAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgIGNoaWxkOiBjaGlsZFxuICAgICAgfSk7IC8vIHRoZSBxdWVyeSBpbiB0aGUgc2VsZWN0b3Igc2hvdWxkIGJlIHRoZSAnPicgaXRzZWxmXG5cbiAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIHF1ZXJ5LCBwYXJlbnRDaGlsZFF1ZXJ5KTtcbiAgICAgIHNlbGVjdG9yLmNvbXBvdW5kQ291bnQrKzsgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIGNoaWxkIHF1ZXJ5IHdpdGggZXhwcmVzc2lvbnMgdGhhdCBmb2xsb3dcblxuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH0gZWxzZSBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPT09IHF1ZXJ5KSB7XG4gICAgICAvLyBjb21wb3VuZCBzcGxpdCBxdWVyeVxuICAgICAgdmFyIGNvbXBvdW5kID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBsZWZ0ID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgcmlnaHQgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIHN1YmplY3QgPSBuZXdRdWVyeSgpO1xuXG4gICAgICB2YXIgX2NoaWxkID0gbmV3UXVlcnkoKTtcblxuICAgICAgdmFyIF9wYXJlbnQgPSBuZXdRdWVyeSgpOyAvLyBzZXQgdXAgdGhlIHJvb3QgY29tcG91bmQgcVxuXG5cbiAgICAgIGNvbXBvdW5kLmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5DT01QT1VORF9TUExJVCxcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICBzdWJqZWN0OiBzdWJqZWN0XG4gICAgICB9KTsgLy8gcG9wdWxhdGUgdGhlIHN1YmplY3QgYW5kIHJlcGxhY2UgdGhlIHEgYXQgdGhlIG9sZCBzcG90ICh3aXRoaW4gbGVmdCkgd2l0aCBUUlVFXG5cbiAgICAgIHN1YmplY3QuY2hlY2tzID0gcXVlcnkuY2hlY2tzOyAvLyB0YWtlIHRoZSBjaGVja3MgZnJvbSB0aGUgbGVmdFxuXG4gICAgICBxdWVyeS5jaGVja3MgPSBbe1xuICAgICAgICB0eXBlOiBUeXBlLlRSVUVcbiAgICAgIH1dOyAvLyBjaGVja3MgdW5kZXIgbGVmdCByZWZzIHRoZSBzdWJqZWN0IGltcGxpY2l0bHlcbiAgICAgIC8vIHNldCB1cCB0aGUgcmlnaHQgcVxuXG4gICAgICBfcGFyZW50LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5UUlVFXG4gICAgICB9KTsgLy8gcGFyZW50IGltcGxpY2l0bHkgcmVmcyB0aGUgc3ViamVjdFxuXG5cbiAgICAgIHJpZ2h0LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5QQVJFTlQsXG4gICAgICAgIC8vIHR5cGUgaXMgc3dhcHBlZCBvbiByaWdodCBzaWRlIHF1ZXJpZXNcbiAgICAgICAgcGFyZW50OiBfcGFyZW50LFxuICAgICAgICBjaGlsZDogX2NoaWxkIC8vIGVtcHR5IGZvciBub3dcblxuICAgICAgfSk7XG4gICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBsZWZ0LCBjb21wb3VuZCk7IC8vIHVwZGF0ZSB0aGUgcmVmIHNpbmNlIHdlIG1vdmVkIHRoaW5ncyBhcm91bmQgZm9yIGBxdWVyeWBcblxuICAgICAgc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCsrO1xuICAgICAgcmV0dXJuIF9jaGlsZDsgLy8gbm93IHBvcHVsYXRpbmcgdGhlIHJpZ2h0IHNpZGUncyBjaGlsZFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwYXJlbnQgcXVlcnlcbiAgICAgIC8vIGluZm8gZm9yIHBhcmVudCBxdWVyeVxuICAgICAgdmFyIF9wYXJlbnQyID0gbmV3UXVlcnkoKTtcblxuICAgICAgdmFyIF9jaGlsZDIgPSBuZXdRdWVyeSgpO1xuXG4gICAgICB2YXIgcGNRQ2hlY2tzID0gW3tcbiAgICAgICAgdHlwZTogVHlwZS5QQVJFTlQsXG4gICAgICAgIHBhcmVudDogX3BhcmVudDIsXG4gICAgICAgIGNoaWxkOiBfY2hpbGQyXG4gICAgICB9XTsgLy8gdGhlIHBhcmVudC1jaGlsZCBxdWVyeSB0YWtlcyB0aGUgcGxhY2Ugb2YgdGhlIHF1ZXJ5IHByZXZpb3VzbHkgYmVpbmcgcG9wdWxhdGVkXG5cbiAgICAgIF9wYXJlbnQyLmNoZWNrcyA9IHF1ZXJ5LmNoZWNrczsgLy8gdGhlIHByZXZpb3VzIHF1ZXJ5IGNvbnRhaW5zIHRoZSBjaGVja3MgZm9yIHRoZSBwYXJlbnRcblxuICAgICAgcXVlcnkuY2hlY2tzID0gcGNRQ2hlY2tzOyAvLyBwYyBxdWVyeSB0YWtlcyBvdmVyXG5cbiAgICAgIHNlbGVjdG9yLmNvbXBvdW5kQ291bnQrKztcbiAgICAgIHJldHVybiBfY2hpbGQyOyAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgY2hpbGRcbiAgICB9XG4gIH1cbn0sIHtcbiAgbmFtZTogJ2Rlc2NlbmRhbnQnLFxuICBzZXBhcmF0b3I6IHRydWUsXG4gIHJlZ2V4OiB0b2tlbnMuZGVzY2VuZGFudCxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSkge1xuICAgIGlmIChzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9PSBudWxsKSB7XG4gICAgICAvLyBkZWZhdWx0OiBkZXNjZW5kYW50IHF1ZXJ5XG4gICAgICB2YXIgYW5jQ2hRdWVyeSA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgZGVzY2VuZGFudCA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXTtcbiAgICAgIGFuY0NoUXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLkRFU0NFTkRBTlQsXG4gICAgICAgIGFuY2VzdG9yOiBhbmNlc3RvcixcbiAgICAgICAgZGVzY2VuZGFudDogZGVzY2VuZGFudFxuICAgICAgfSk7IC8vIHRoZSBxdWVyeSBpbiB0aGUgc2VsZWN0b3Igc2hvdWxkIGJlIHRoZSAnPicgaXRzZWxmXG5cbiAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIHF1ZXJ5LCBhbmNDaFF1ZXJ5KTtcbiAgICAgIHNlbGVjdG9yLmNvbXBvdW5kQ291bnQrKzsgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIGRlc2NlbmRhbnQgcXVlcnkgd2l0aCBleHByZXNzaW9ucyB0aGF0IGZvbGxvd1xuXG4gICAgICByZXR1cm4gZGVzY2VuZGFudDtcbiAgICB9IGVsc2UgaWYgKHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID09PSBxdWVyeSkge1xuICAgICAgLy8gY29tcG91bmQgc3BsaXQgcXVlcnlcbiAgICAgIHZhciBjb21wb3VuZCA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgbGVmdCA9IHNlbGVjdG9yW3NlbGVjdG9yLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIHJpZ2h0ID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBzdWJqZWN0ID0gbmV3UXVlcnkoKTtcblxuICAgICAgdmFyIF9kZXNjZW5kYW50ID0gbmV3UXVlcnkoKTtcblxuICAgICAgdmFyIF9hbmNlc3RvciA9IG5ld1F1ZXJ5KCk7IC8vIHNldCB1cCB0aGUgcm9vdCBjb21wb3VuZCBxXG5cblxuICAgICAgY29tcG91bmQuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLkNPTVBPVU5EX1NQTElULFxuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIHN1YmplY3Q6IHN1YmplY3RcbiAgICAgIH0pOyAvLyBwb3B1bGF0ZSB0aGUgc3ViamVjdCBhbmQgcmVwbGFjZSB0aGUgcSBhdCB0aGUgb2xkIHNwb3QgKHdpdGhpbiBsZWZ0KSB3aXRoIFRSVUVcblxuICAgICAgc3ViamVjdC5jaGVja3MgPSBxdWVyeS5jaGVja3M7IC8vIHRha2UgdGhlIGNoZWNrcyBmcm9tIHRoZSBsZWZ0XG5cbiAgICAgIHF1ZXJ5LmNoZWNrcyA9IFt7XG4gICAgICAgIHR5cGU6IFR5cGUuVFJVRVxuICAgICAgfV07IC8vIGNoZWNrcyB1bmRlciBsZWZ0IHJlZnMgdGhlIHN1YmplY3QgaW1wbGljaXRseVxuICAgICAgLy8gc2V0IHVwIHRoZSByaWdodCBxXG5cbiAgICAgIF9hbmNlc3Rvci5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuVFJVRVxuICAgICAgfSk7IC8vIGFuY2VzdG9yIGltcGxpY2l0bHkgcmVmcyB0aGUgc3ViamVjdFxuXG5cbiAgICAgIHJpZ2h0LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5BTkNFU1RPUixcbiAgICAgICAgLy8gdHlwZSBpcyBzd2FwcGVkIG9uIHJpZ2h0IHNpZGUgcXVlcmllc1xuICAgICAgICBhbmNlc3RvcjogX2FuY2VzdG9yLFxuICAgICAgICBkZXNjZW5kYW50OiBfZGVzY2VuZGFudCAvLyBlbXB0eSBmb3Igbm93XG5cbiAgICAgIH0pO1xuICAgICAgcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgbGVmdCwgY29tcG91bmQpOyAvLyB1cGRhdGUgdGhlIHJlZiBzaW5jZSB3ZSBtb3ZlZCB0aGluZ3MgYXJvdW5kIGZvciBgcXVlcnlgXG5cbiAgICAgIHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID0gc3ViamVjdDtcbiAgICAgIHNlbGVjdG9yLmNvbXBvdW5kQ291bnQrKztcbiAgICAgIHJldHVybiBfZGVzY2VuZGFudDsgLy8gbm93IHBvcHVsYXRpbmcgdGhlIHJpZ2h0IHNpZGUncyBkZXNjZW5kYW50XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGFuY2VzdG9yIHF1ZXJ5XG4gICAgICAvLyBpbmZvIGZvciBwYXJlbnQgcXVlcnlcbiAgICAgIHZhciBfYW5jZXN0b3IyID0gbmV3UXVlcnkoKTtcblxuICAgICAgdmFyIF9kZXNjZW5kYW50MiA9IG5ld1F1ZXJ5KCk7XG5cbiAgICAgIHZhciBhZFFDaGVja3MgPSBbe1xuICAgICAgICB0eXBlOiBUeXBlLkFOQ0VTVE9SLFxuICAgICAgICBhbmNlc3RvcjogX2FuY2VzdG9yMixcbiAgICAgICAgZGVzY2VuZGFudDogX2Rlc2NlbmRhbnQyXG4gICAgICB9XTsgLy8gdGhlIHBhcmVudC1jaGlsZCBxdWVyeSB0YWtlcyB0aGUgcGxhY2Ugb2YgdGhlIHF1ZXJ5IHByZXZpb3VzbHkgYmVpbmcgcG9wdWxhdGVkXG5cbiAgICAgIF9hbmNlc3RvcjIuY2hlY2tzID0gcXVlcnkuY2hlY2tzOyAvLyB0aGUgcHJldmlvdXMgcXVlcnkgY29udGFpbnMgdGhlIGNoZWNrcyBmb3IgdGhlIHBhcmVudFxuXG4gICAgICBxdWVyeS5jaGVja3MgPSBhZFFDaGVja3M7IC8vIHBjIHF1ZXJ5IHRha2VzIG92ZXJcblxuICAgICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCsrO1xuICAgICAgcmV0dXJuIF9kZXNjZW5kYW50MjsgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIGNoaWxkXG4gICAgfVxuICB9XG59LCB7XG4gIG5hbWU6ICdzdWJqZWN0JyxcbiAgbW9kaWZpZXI6IHRydWUsXG4gIHJlZ2V4OiB0b2tlbnMuc3ViamVjdCxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSkge1xuICAgIGlmIChzZWxlY3Rvci5jdXJyZW50U3ViamVjdCAhPSBudWxsICYmIHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ICE9PSBxdWVyeSkge1xuICAgICAgd2FybignUmVkZWZpbml0aW9uIG9mIHN1YmplY3QgaW4gc2VsZWN0b3IgYCcgKyBzZWxlY3Rvci50b1N0cmluZygpICsgJ2AnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9IHF1ZXJ5O1xuICAgIHZhciB0b3BRID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV07XG4gICAgdmFyIHRvcENoayA9IHRvcFEuY2hlY2tzWzBdO1xuICAgIHZhciB0b3BUeXBlID0gdG9wQ2hrID09IG51bGwgPyBudWxsIDogdG9wQ2hrLnR5cGU7XG5cbiAgICBpZiAodG9wVHlwZSA9PT0gVHlwZS5ESVJFQ1RFRF9FREdFKSB7XG4gICAgICAvLyBkaXJlY3RlZCBlZGdlIHdpdGggc3ViamVjdCBvbiB0aGUgdGFyZ2V0XG4gICAgICAvLyBjaGFuZ2UgdG8gdGFyZ2V0IG5vZGUgY2hlY2tcbiAgICAgIHRvcENoay50eXBlID0gVHlwZS5OT0RFX1RBUkdFVDtcbiAgICB9IGVsc2UgaWYgKHRvcFR5cGUgPT09IFR5cGUuVU5ESVJFQ1RFRF9FREdFKSB7XG4gICAgICAvLyB1bmRpcmVjdGVkIGVkZ2Ugd2l0aCBzdWJqZWN0IG9uIHRoZSBzZWNvbmQgbm9kZVxuICAgICAgLy8gY2hhbmdlIHRvIG5laWdoYm9yIGNoZWNrXG4gICAgICB0b3BDaGsudHlwZSA9IFR5cGUuTk9ERV9ORUlHSEJPUjtcbiAgICAgIHRvcENoay5ub2RlID0gdG9wQ2hrLm5vZGVzWzFdOyAvLyBzZWNvbmQgbm9kZSBpcyBzdWJqZWN0XG5cbiAgICAgIHRvcENoay5uZWlnaGJvciA9IHRvcENoay5ub2Rlc1swXTsgLy8gY2xlYW4gdXAgdW51c2VkIGZpZWxkcyBmb3IgbmV3IHR5cGVcblxuICAgICAgdG9wQ2hrLm5vZGVzID0gbnVsbDtcbiAgICB9XG4gIH1cbn1dO1xuZXhwcnMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZS5yZWdleE9iaiA9IG5ldyBSZWdFeHAoJ14nICsgZS5yZWdleCk7XG59KTtcblxuLyoqXG4gKiBPZiBhbGwgdGhlIGV4cHJlc3Npb25zLCBmaW5kIHRoZSBmaXJzdCBtYXRjaCBpbiB0aGUgcmVtYWluaW5nIHRleHQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtYWluaW5nIFRoZSByZW1haW5pbmcgdGV4dCB0byBwYXJzZVxuICogQHJldHVybnMgVGhlIG1hdGNoZWQgZXhwcmVzc2lvbiBhbmQgdGhlIG5ld2x5IHJlbWFpbmluZyB0ZXh0IGB7IGV4cHIsIG1hdGNoLCBuYW1lLCByZW1haW5pbmcgfWBcbiAqL1xuXG52YXIgY29uc3VtZUV4cHIgPSBmdW5jdGlvbiBjb25zdW1lRXhwcihyZW1haW5pbmcpIHtcbiAgdmFyIGV4cHI7XG4gIHZhciBtYXRjaDtcbiAgdmFyIG5hbWU7XG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCBleHBycy5sZW5ndGg7IGorKykge1xuICAgIHZhciBlID0gZXhwcnNbal07XG4gICAgdmFyIG4gPSBlLm5hbWU7XG4gICAgdmFyIG0gPSByZW1haW5pbmcubWF0Y2goZS5yZWdleE9iaik7XG5cbiAgICBpZiAobSAhPSBudWxsKSB7XG4gICAgICBtYXRjaCA9IG07XG4gICAgICBleHByID0gZTtcbiAgICAgIG5hbWUgPSBuO1xuICAgICAgdmFyIGNvbnN1bWVkID0gbVswXTtcbiAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHJpbmcoY29uc3VtZWQubGVuZ3RoKTtcbiAgICAgIGJyZWFrOyAvLyB3ZSd2ZSBjb25zdW1lZCBvbmUgZXhwciwgc28gd2UgY2FuIHJldHVybiBub3dcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cHI6IGV4cHIsXG4gICAgbWF0Y2g6IG1hdGNoLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgcmVtYWluaW5nOiByZW1haW5pbmdcbiAgfTtcbn07XG4vKipcbiAqIENvbnN1bWUgYWxsIHRoZSBsZWFkaW5nIHdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1haW5pbmcgVGhlIHRleHQgdG8gY29uc3VtZVxuICogQHJldHVybnMgVGhlIHRleHQgd2l0aCB0aGUgbGVhZGluZyB3aGl0ZXNwYWNlIHJlbW92ZWRcbiAqL1xuXG5cbnZhciBjb25zdW1lV2hpdGVzcGFjZSA9IGZ1bmN0aW9uIGNvbnN1bWVXaGl0ZXNwYWNlKHJlbWFpbmluZykge1xuICB2YXIgbWF0Y2ggPSByZW1haW5pbmcubWF0Y2goL15cXHMrLyk7XG5cbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIGNvbnN1bWVkID0gbWF0Y2hbMF07XG4gICAgcmVtYWluaW5nID0gcmVtYWluaW5nLnN1YnN0cmluZyhjb25zdW1lZC5sZW5ndGgpO1xuICB9XG5cbiAgcmV0dXJuIHJlbWFpbmluZztcbn07XG4vKipcbiAqIFBhcnNlIHRoZSBzdHJpbmcgYW5kIHN0b3JlIHRoZSBwYXJzZWQgcmVwcmVzZW50YXRpb24gaW4gdGhlIFNlbGVjdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFRoZSBzZWxlY3RvciBzdHJpbmdcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgc2VsZWN0b3Igd2FzIHN1Y2Nlc3NmdWxseSBwYXJzZWQsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gKi9cblxuXG52YXIgcGFyc2UgPSBmdW5jdGlvbiBwYXJzZShzZWxlY3Rvcikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByZW1haW5pbmcgPSBzZWxmLmlucHV0VGV4dCA9IHNlbGVjdG9yO1xuICB2YXIgY3VycmVudFF1ZXJ5ID0gc2VsZlswXSA9IG5ld1F1ZXJ5KCk7XG4gIHNlbGYubGVuZ3RoID0gMTtcbiAgcmVtYWluaW5nID0gY29uc3VtZVdoaXRlc3BhY2UocmVtYWluaW5nKTsgLy8gZ2V0IHJpZCBvZiBsZWFkaW5nIHdoaXRlc3BhY2VcblxuICBmb3IgKDs7KSB7XG4gICAgdmFyIGV4cHJJbmZvID0gY29uc3VtZUV4cHIocmVtYWluaW5nKTtcblxuICAgIGlmIChleHBySW5mby5leHByID09IG51bGwpIHtcbiAgICAgIHdhcm4oJ1RoZSBzZWxlY3RvciBgJyArIHNlbGVjdG9yICsgJ2BpcyBpbnZhbGlkJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gZXhwckluZm8ubWF0Y2guc2xpY2UoMSk7IC8vIGxldCB0aGUgdG9rZW4gcG9wdWxhdGUgdGhlIHNlbGVjdG9yIG9iamVjdCBpbiBjdXJyZW50UXVlcnlcblxuICAgICAgdmFyIHJldCA9IGV4cHJJbmZvLmV4cHIucG9wdWxhdGUoc2VsZiwgY3VycmVudFF1ZXJ5LCBhcmdzKTtcblxuICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBleGl0IGlmIHBvcHVsYXRpb24gZmFpbGVkXG4gICAgICB9IGVsc2UgaWYgKHJldCAhPSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnRRdWVyeSA9IHJldDsgLy8gY2hhbmdlIHRoZSBjdXJyZW50IHF1ZXJ5IHRvIGJlIGZpbGxlZCBpZiB0aGUgZXhwciBzcGVjaWZpZXNcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZW1haW5pbmcgPSBleHBySW5mby5yZW1haW5pbmc7IC8vIHdlJ3JlIGRvbmUgd2hlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBwYXJzZVxuXG4gICAgaWYgKHJlbWFpbmluZy5tYXRjaCgvXlxccyokLykpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsYXN0USA9IHNlbGZbc2VsZi5sZW5ndGggLSAxXTtcblxuICBpZiAoc2VsZi5jdXJyZW50U3ViamVjdCAhPSBudWxsKSB7XG4gICAgbGFzdFEuc3ViamVjdCA9IHNlbGYuY3VycmVudFN1YmplY3Q7XG4gIH1cblxuICBsYXN0US5lZGdlQ291bnQgPSBzZWxmLmVkZ2VDb3VudDtcbiAgbGFzdFEuY29tcG91bmRDb3VudCA9IHNlbGYuY29tcG91bmRDb3VudDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcSA9IHNlbGZbaV07IC8vIGluIGZ1dHVyZSwgdGhpcyBjb3VsZCBwb3RlbnRpYWxseSBiZSBhbGxvd2VkIGlmIHRoZXJlIHdlcmUgb3BlcmF0b3IgcHJlY2VkZW5jZSBhbmQgZGV0ZWN0aW9uIG9mIGludmFsaWQgY29tYmluYXRpb25zXG5cbiAgICBpZiAocS5jb21wb3VuZENvdW50ID4gMCAmJiBxLmVkZ2VDb3VudCA+IDApIHtcbiAgICAgIHdhcm4oJ1RoZSBzZWxlY3RvciBgJyArIHNlbGVjdG9yICsgJ2AgaXMgaW52YWxpZCBiZWNhdXNlIGl0IHVzZXMgYm90aCBhIGNvbXBvdW5kIHNlbGVjdG9yIGFuZCBhbiBlZGdlIHNlbGVjdG9yJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHEuZWRnZUNvdW50ID4gMSkge1xuICAgICAgd2FybignVGhlIHNlbGVjdG9yIGAnICsgc2VsZWN0b3IgKyAnYCBpcyBpbnZhbGlkIGJlY2F1c2UgaXQgdXNlcyBtdWx0aXBsZSBlZGdlIHNlbGVjdG9ycycpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAocS5lZGdlQ291bnQgPT09IDEpIHtcbiAgICAgIHdhcm4oJ1RoZSBzZWxlY3RvciBgJyArIHNlbGVjdG9yICsgJ2AgaXMgZGVwcmVjYXRlZC4gIEVkZ2Ugc2VsZWN0b3JzIGRvIG5vdCB0YWtlIGVmZmVjdCBvbiBjaGFuZ2VzIHRvIHNvdXJjZSBhbmQgdGFyZ2V0IG5vZGVzIGFmdGVyIGFuIGVkZ2UgaXMgYWRkZWQsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiAgVXNlIGEgY2xhc3Mgb3IgZGF0YSBzZWxlY3RvciBvbiBlZGdlcyBpbnN0ZWFkLCB1cGRhdGluZyB0aGUgY2xhc3Mgb3IgZGF0YSBvZiBhbiBlZGdlIHdoZW4geW91ciBhcHAgZGV0ZWN0cyBhIGNoYW5nZSBpbiBzb3VyY2Ugb3IgdGFyZ2V0IG5vZGVzLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlOyAvLyBzdWNjZXNzXG59O1xuLyoqXG4gKiBHZXQgdGhlIHNlbGVjdG9yIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nLiAgVGhpcyB2YWx1ZSB1c2VzIGRlZmF1bHQgZm9ybWF0dGluZyxcbiAqIHNvIHRoaW5ncyBsaWtlIHNwYWNpbmcgbWF5IGRpZmZlciBmcm9tIHRoZSBpbnB1dCB0ZXh0IHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc2VsZWN0b3Igc3RyaW5nXG4gKi9cblxuXG52YXIgdG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgaWYgKHRoaXMudG9TdHJpbmdDYWNoZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmdDYWNoZTtcbiAgfVxuXG4gIHZhciBjbGVhbiA9IGZ1bmN0aW9uIGNsZWFuKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY2xlYW5WYWwgPSBmdW5jdGlvbiBjbGVhblZhbCh2YWwpIHtcbiAgICBpZiAoc3RyaW5nKHZhbCkpIHtcbiAgICAgIHJldHVybiAnXCInICsgdmFsICsgJ1wiJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNsZWFuKHZhbCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBzcGFjZSA9IGZ1bmN0aW9uIHNwYWNlKHZhbCkge1xuICAgIHJldHVybiAnICcgKyB2YWwgKyAnICc7XG4gIH07XG5cbiAgdmFyIGNoZWNrVG9TdHJpbmcgPSBmdW5jdGlvbiBjaGVja1RvU3RyaW5nKGNoZWNrLCBzdWJqZWN0KSB7XG4gICAgdmFyIHR5cGUgPSBjaGVjay50eXBlLFxuICAgICAgICB2YWx1ZSA9IGNoZWNrLnZhbHVlO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFR5cGUuR1JPVVA6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZ3JvdXAgPSBjbGVhbih2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIGdyb3VwLnN1YnN0cmluZygwLCBncm91cC5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFR5cGUuREFUQV9DT01QQVJFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGZpZWxkID0gY2hlY2suZmllbGQsXG4gICAgICAgICAgICAgIG9wZXJhdG9yID0gY2hlY2sub3BlcmF0b3I7XG4gICAgICAgICAgcmV0dXJuICdbJyArIGZpZWxkICsgc3BhY2UoY2xlYW4ob3BlcmF0b3IpKSArIGNsZWFuVmFsKHZhbHVlKSArICddJztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFR5cGUuREFUQV9CT09MOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9vcGVyYXRvciA9IGNoZWNrLm9wZXJhdG9yLFxuICAgICAgICAgICAgICBfZmllbGQgPSBjaGVjay5maWVsZDtcbiAgICAgICAgICByZXR1cm4gJ1snICsgY2xlYW4oX29wZXJhdG9yKSArIF9maWVsZCArICddJztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFR5cGUuREFUQV9FWElTVDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfZmllbGQyID0gY2hlY2suZmllbGQ7XG4gICAgICAgICAgcmV0dXJuICdbJyArIF9maWVsZDIgKyAnXSc7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBUeXBlLk1FVEFfQ09NUEFSRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfb3BlcmF0b3IyID0gY2hlY2sub3BlcmF0b3IsXG4gICAgICAgICAgICAgIF9maWVsZDMgPSBjaGVjay5maWVsZDtcbiAgICAgICAgICByZXR1cm4gJ1tbJyArIF9maWVsZDMgKyBzcGFjZShjbGVhbihfb3BlcmF0b3IyKSkgKyBjbGVhblZhbCh2YWx1ZSkgKyAnXV0nO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgVHlwZS5TVEFURTpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFR5cGUuSUQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gJyMnICsgdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBUeXBlLkNMQVNTOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuICcuJyArIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgVHlwZS5QQVJFTlQ6XG4gICAgICBjYXNlIFR5cGUuQ0hJTEQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gcXVlcnlUb1N0cmluZyhjaGVjay5wYXJlbnQsIHN1YmplY3QpICsgc3BhY2UoJz4nKSArIHF1ZXJ5VG9TdHJpbmcoY2hlY2suY2hpbGQsIHN1YmplY3QpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgVHlwZS5BTkNFU1RPUjpcbiAgICAgIGNhc2UgVHlwZS5ERVNDRU5EQU5UOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHF1ZXJ5VG9TdHJpbmcoY2hlY2suYW5jZXN0b3IsIHN1YmplY3QpICsgJyAnICsgcXVlcnlUb1N0cmluZyhjaGVjay5kZXNjZW5kYW50LCBzdWJqZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFR5cGUuQ09NUE9VTkRfU1BMSVQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGhzID0gcXVlcnlUb1N0cmluZyhjaGVjay5sZWZ0LCBzdWJqZWN0KTtcbiAgICAgICAgICB2YXIgc3ViID0gcXVlcnlUb1N0cmluZyhjaGVjay5zdWJqZWN0LCBzdWJqZWN0KTtcbiAgICAgICAgICB2YXIgcmhzID0gcXVlcnlUb1N0cmluZyhjaGVjay5yaWdodCwgc3ViamVjdCk7XG4gICAgICAgICAgcmV0dXJuIGxocyArIChsaHMubGVuZ3RoID4gMCA/ICcgJyA6ICcnKSArIHN1YiArIHJocztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFR5cGUuVFJVRTpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgcXVlcnlUb1N0cmluZyA9IGZ1bmN0aW9uIHF1ZXJ5VG9TdHJpbmcocXVlcnksIHN1YmplY3QpIHtcbiAgICByZXR1cm4gcXVlcnkuY2hlY2tzLnJlZHVjZShmdW5jdGlvbiAoc3RyLCBjaGssIGkpIHtcbiAgICAgIHJldHVybiBzdHIgKyAoc3ViamVjdCA9PT0gcXVlcnkgJiYgaSA9PT0gMCA/ICckJyA6ICcnKSArIGNoZWNrVG9TdHJpbmcoY2hrLCBzdWJqZWN0KTtcbiAgICB9LCAnJyk7XG4gIH07XG5cbiAgdmFyIHN0ciA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBxdWVyeSA9IHRoaXNbaV07XG4gICAgc3RyICs9IHF1ZXJ5VG9TdHJpbmcocXVlcnksIHF1ZXJ5LnN1YmplY3QpO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMSAmJiBpIDwgdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICBzdHIgKz0gJywgJztcbiAgICB9XG4gIH1cblxuICB0aGlzLnRvU3RyaW5nQ2FjaGUgPSBzdHI7XG4gIHJldHVybiBzdHI7XG59O1xudmFyIHBhcnNlJDEgPSB7XG4gIHBhcnNlOiBwYXJzZSxcbiAgdG9TdHJpbmc6IHRvU3RyaW5nXG59O1xuXG52YXIgdmFsQ21wID0gZnVuY3Rpb24gdmFsQ21wKGZpZWxkVmFsLCBvcGVyYXRvciwgdmFsdWUpIHtcbiAgdmFyIG1hdGNoZXM7XG4gIHZhciBpc0ZpZWxkU3RyID0gc3RyaW5nKGZpZWxkVmFsKTtcbiAgdmFyIGlzRmllbGROdW0gPSBudW1iZXIkMShmaWVsZFZhbCk7XG4gIHZhciBpc1ZhbFN0ciA9IHN0cmluZyh2YWx1ZSk7XG4gIHZhciBmaWVsZFN0ciwgdmFsU3RyO1xuICB2YXIgY2FzZUluc2Vuc2l0aXZlID0gZmFsc2U7XG4gIHZhciBub3RFeHByID0gZmFsc2U7XG4gIHZhciBpc0luZXFDbXAgPSBmYWxzZTtcblxuICBpZiAob3BlcmF0b3IuaW5kZXhPZignIScpID49IDApIHtcbiAgICBvcGVyYXRvciA9IG9wZXJhdG9yLnJlcGxhY2UoJyEnLCAnJyk7XG4gICAgbm90RXhwciA9IHRydWU7XG4gIH1cblxuICBpZiAob3BlcmF0b3IuaW5kZXhPZignQCcpID49IDApIHtcbiAgICBvcGVyYXRvciA9IG9wZXJhdG9yLnJlcGxhY2UoJ0AnLCAnJyk7XG4gICAgY2FzZUluc2Vuc2l0aXZlID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChpc0ZpZWxkU3RyIHx8IGlzVmFsU3RyIHx8IGNhc2VJbnNlbnNpdGl2ZSkge1xuICAgIGZpZWxkU3RyID0gIWlzRmllbGRTdHIgJiYgIWlzRmllbGROdW0gPyAnJyA6ICcnICsgZmllbGRWYWw7XG4gICAgdmFsU3RyID0gJycgKyB2YWx1ZTtcbiAgfSAvLyBpZiB3ZSdyZSBkb2luZyBhIGNhc2UgaW5zZW5zaXRpdmUgY29tcGFyaXNvbiwgdGhlbiB3ZSdyZSB1c2luZyBhIFNUUklORyBjb21wYXJpc29uXG4gIC8vIGV2ZW4gaWYgd2UncmUgY29tcGFyaW5nIG51bWJlcnNcblxuXG4gIGlmIChjYXNlSW5zZW5zaXRpdmUpIHtcbiAgICBmaWVsZFZhbCA9IGZpZWxkU3RyID0gZmllbGRTdHIudG9Mb3dlckNhc2UoKTtcbiAgICB2YWx1ZSA9IHZhbFN0ciA9IHZhbFN0ci50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgIGNhc2UgJyo9JzpcbiAgICAgIG1hdGNoZXMgPSBmaWVsZFN0ci5pbmRleE9mKHZhbFN0cikgPj0gMDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnJD0nOlxuICAgICAgbWF0Y2hlcyA9IGZpZWxkU3RyLmluZGV4T2YodmFsU3RyLCBmaWVsZFN0ci5sZW5ndGggLSB2YWxTdHIubGVuZ3RoKSA+PSAwO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdePSc6XG4gICAgICBtYXRjaGVzID0gZmllbGRTdHIuaW5kZXhPZih2YWxTdHIpID09PSAwO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICc9JzpcbiAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCA9PT0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJz4nOlxuICAgICAgaXNJbmVxQ21wID0gdHJ1ZTtcbiAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCA+IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICc+PSc6XG4gICAgICBpc0luZXFDbXAgPSB0cnVlO1xuICAgICAgbWF0Y2hlcyA9IGZpZWxkVmFsID49IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICc8JzpcbiAgICAgIGlzSW5lcUNtcCA9IHRydWU7XG4gICAgICBtYXRjaGVzID0gZmllbGRWYWwgPCB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnPD0nOlxuICAgICAgaXNJbmVxQ21wID0gdHJ1ZTtcbiAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCA8PSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIG1hdGNoZXMgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICB9IC8vIGFwcGx5IHRoZSBub3Qgb3AsIGJ1dCBudWxsIHZhbHMgZm9yIGluZXF1YWxpdGllcyBzaG91bGQgYWx3YXlzIHN0YXkgbm9uLW1hdGNoaW5nXG5cblxuICBpZiAobm90RXhwciAmJiAoZmllbGRWYWwgIT0gbnVsbCB8fCAhaXNJbmVxQ21wKSkge1xuICAgIG1hdGNoZXMgPSAhbWF0Y2hlcztcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzO1xufTtcbnZhciBib29sQ21wID0gZnVuY3Rpb24gYm9vbENtcChmaWVsZFZhbCwgb3BlcmF0b3IpIHtcbiAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgIGNhc2UgJz8nOlxuICAgICAgcmV0dXJuIGZpZWxkVmFsID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgY2FzZSAnISc6XG4gICAgICByZXR1cm4gZmllbGRWYWwgPyBmYWxzZSA6IHRydWU7XG5cbiAgICBjYXNlICdeJzpcbiAgICAgIHJldHVybiBmaWVsZFZhbCA9PT0gdW5kZWZpbmVkO1xuICB9XG59O1xudmFyIGV4aXN0Q21wID0gZnVuY3Rpb24gZXhpc3RDbXAoZmllbGRWYWwpIHtcbiAgcmV0dXJuIGZpZWxkVmFsICE9PSB1bmRlZmluZWQ7XG59O1xudmFyIGRhdGEkMSA9IGZ1bmN0aW9uIGRhdGEoZWxlLCBmaWVsZCkge1xuICByZXR1cm4gZWxlLmRhdGEoZmllbGQpO1xufTtcbnZhciBtZXRhID0gZnVuY3Rpb24gbWV0YShlbGUsIGZpZWxkKSB7XG4gIHJldHVybiBlbGVbZmllbGRdKCk7XG59O1xuXG4vKiogQSBsb29rdXAgb2YgYG1hdGNoKGNoZWNrLCBlbGUpYCBmdW5jdGlvbnMgYnkgYFR5cGVgIGludCAqL1xuXG52YXIgbWF0Y2ggPSBbXTtcbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBxdWVyeSBtYXRjaGVzIGZvciB0aGUgZWxlbWVudFxuICogQHBhcmFtIHF1ZXJ5IFRoZSBgeyB0eXBlLCB2YWx1ZSwgLi4uIH1gIHF1ZXJ5IG9iamVjdFxuICogQHBhcmFtIGVsZSBUaGUgZWxlbWVudCB0byBjb21wYXJlIGFnYWluc3RcbiovXG5cbnZhciBtYXRjaGVzJDEgPSBmdW5jdGlvbiBtYXRjaGVzKHF1ZXJ5LCBlbGUpIHtcbiAgcmV0dXJuIHF1ZXJ5LmNoZWNrcy5ldmVyeShmdW5jdGlvbiAoY2hrKSB7XG4gICAgcmV0dXJuIG1hdGNoW2Noay50eXBlXShjaGssIGVsZSk7XG4gIH0pO1xufTtcblxubWF0Y2hbVHlwZS5HUk9VUF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgZ3JvdXAgPSBjaGVjay52YWx1ZTtcbiAgcmV0dXJuIGdyb3VwID09PSAnKicgfHwgZ3JvdXAgPT09IGVsZS5ncm91cCgpO1xufTtcblxubWF0Y2hbVHlwZS5TVEFURV0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgc3RhdGVTZWxlY3RvciA9IGNoZWNrLnZhbHVlO1xuICByZXR1cm4gc3RhdGVTZWxlY3Rvck1hdGNoZXMoc3RhdGVTZWxlY3RvciwgZWxlKTtcbn07XG5cbm1hdGNoW1R5cGUuSURdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGlkID0gY2hlY2sudmFsdWU7XG4gIHJldHVybiBlbGUuaWQoKSA9PT0gaWQ7XG59O1xuXG5tYXRjaFtUeXBlLkNMQVNTXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHZhciBjbHMgPSBjaGVjay52YWx1ZTtcbiAgcmV0dXJuIGVsZS5oYXNDbGFzcyhjbHMpO1xufTtcblxubWF0Y2hbVHlwZS5NRVRBX0NPTVBBUkVdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGZpZWxkID0gY2hlY2suZmllbGQsXG4gICAgICBvcGVyYXRvciA9IGNoZWNrLm9wZXJhdG9yLFxuICAgICAgdmFsdWUgPSBjaGVjay52YWx1ZTtcbiAgcmV0dXJuIHZhbENtcChtZXRhKGVsZSwgZmllbGQpLCBvcGVyYXRvciwgdmFsdWUpO1xufTtcblxubWF0Y2hbVHlwZS5EQVRBX0NPTVBBUkVdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGZpZWxkID0gY2hlY2suZmllbGQsXG4gICAgICBvcGVyYXRvciA9IGNoZWNrLm9wZXJhdG9yLFxuICAgICAgdmFsdWUgPSBjaGVjay52YWx1ZTtcbiAgcmV0dXJuIHZhbENtcChkYXRhJDEoZWxlLCBmaWVsZCksIG9wZXJhdG9yLCB2YWx1ZSk7XG59O1xuXG5tYXRjaFtUeXBlLkRBVEFfQk9PTF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgZmllbGQgPSBjaGVjay5maWVsZCxcbiAgICAgIG9wZXJhdG9yID0gY2hlY2sub3BlcmF0b3I7XG4gIHJldHVybiBib29sQ21wKGRhdGEkMShlbGUsIGZpZWxkKSwgb3BlcmF0b3IpO1xufTtcblxubWF0Y2hbVHlwZS5EQVRBX0VYSVNUXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHZhciBmaWVsZCA9IGNoZWNrLmZpZWxkO1xuICAgICAgY2hlY2sub3BlcmF0b3I7XG4gIHJldHVybiBleGlzdENtcChkYXRhJDEoZWxlLCBmaWVsZCkpO1xufTtcblxubWF0Y2hbVHlwZS5VTkRJUkVDVEVEX0VER0VdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIHFBID0gY2hlY2subm9kZXNbMF07XG4gIHZhciBxQiA9IGNoZWNrLm5vZGVzWzFdO1xuICB2YXIgc3JjID0gZWxlLnNvdXJjZSgpO1xuICB2YXIgdGd0ID0gZWxlLnRhcmdldCgpO1xuICByZXR1cm4gbWF0Y2hlcyQxKHFBLCBzcmMpICYmIG1hdGNoZXMkMShxQiwgdGd0KSB8fCBtYXRjaGVzJDEocUIsIHNyYykgJiYgbWF0Y2hlcyQxKHFBLCB0Z3QpO1xufTtcblxubWF0Y2hbVHlwZS5OT0RFX05FSUdIQk9SXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzJDEoY2hlY2subm9kZSwgZWxlKSAmJiBlbGUubmVpZ2hib3Job29kKCkuc29tZShmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBuLmlzTm9kZSgpICYmIG1hdGNoZXMkMShjaGVjay5uZWlnaGJvciwgbik7XG4gIH0pO1xufTtcblxubWF0Y2hbVHlwZS5ESVJFQ1RFRF9FREdFXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzJDEoY2hlY2suc291cmNlLCBlbGUuc291cmNlKCkpICYmIG1hdGNoZXMkMShjaGVjay50YXJnZXQsIGVsZS50YXJnZXQoKSk7XG59O1xuXG5tYXRjaFtUeXBlLk5PREVfU09VUkNFXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzJDEoY2hlY2suc291cmNlLCBlbGUpICYmIGVsZS5vdXRnb2VycygpLnNvbWUoZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gbi5pc05vZGUoKSAmJiBtYXRjaGVzJDEoY2hlY2sudGFyZ2V0LCBuKTtcbiAgfSk7XG59O1xuXG5tYXRjaFtUeXBlLk5PREVfVEFSR0VUXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzJDEoY2hlY2sudGFyZ2V0LCBlbGUpICYmIGVsZS5pbmNvbWVycygpLnNvbWUoZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gbi5pc05vZGUoKSAmJiBtYXRjaGVzJDEoY2hlY2suc291cmNlLCBuKTtcbiAgfSk7XG59O1xuXG5tYXRjaFtUeXBlLkNISUxEXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzJDEoY2hlY2suY2hpbGQsIGVsZSkgJiYgbWF0Y2hlcyQxKGNoZWNrLnBhcmVudCwgZWxlLnBhcmVudCgpKTtcbn07XG5cbm1hdGNoW1R5cGUuUEFSRU5UXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzJDEoY2hlY2sucGFyZW50LCBlbGUpICYmIGVsZS5jaGlsZHJlbigpLnNvbWUoZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLmNoaWxkLCBjKTtcbiAgfSk7XG59O1xuXG5tYXRjaFtUeXBlLkRFU0NFTkRBTlRdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5kZXNjZW5kYW50LCBlbGUpICYmIGVsZS5hbmNlc3RvcnMoKS5zb21lKGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5hbmNlc3RvciwgYSk7XG4gIH0pO1xufTtcblxubWF0Y2hbVHlwZS5BTkNFU1RPUl0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLmFuY2VzdG9yLCBlbGUpICYmIGVsZS5kZXNjZW5kYW50cygpLnNvbWUoZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLmRlc2NlbmRhbnQsIGQpO1xuICB9KTtcbn07XG5cbm1hdGNoW1R5cGUuQ09NUE9VTkRfU1BMSVRdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5zdWJqZWN0LCBlbGUpICYmIG1hdGNoZXMkMShjaGVjay5sZWZ0LCBlbGUpICYmIG1hdGNoZXMkMShjaGVjay5yaWdodCwgZWxlKTtcbn07XG5cbm1hdGNoW1R5cGUuVFJVRV0gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxubWF0Y2hbVHlwZS5DT0xMRUNUSU9OXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHZhciBjb2xsZWN0aW9uID0gY2hlY2sudmFsdWU7XG4gIHJldHVybiBjb2xsZWN0aW9uLmhhcyhlbGUpO1xufTtcblxubWF0Y2hbVHlwZS5GSUxURVJdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGZpbHRlciA9IGNoZWNrLnZhbHVlO1xuICByZXR1cm4gZmlsdGVyKGVsZSk7XG59O1xuXG52YXIgZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24pIHtcbiAgdmFyIHNlbGYgPSB0aGlzOyAvLyBmb3IgMSBpZCAjZm9vIHF1ZXJpZXMsIGp1c3QgZ2V0IHRoZSBlbGVtZW50XG5cbiAgaWYgKHNlbGYubGVuZ3RoID09PSAxICYmIHNlbGZbMF0uY2hlY2tzLmxlbmd0aCA9PT0gMSAmJiBzZWxmWzBdLmNoZWNrc1swXS50eXBlID09PSBUeXBlLklEKSB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uZ2V0RWxlbWVudEJ5SWQoc2VsZlswXS5jaGVja3NbMF0udmFsdWUpLmNvbGxlY3Rpb24oKTtcbiAgfVxuXG4gIHZhciBzZWxlY3RvckZ1bmN0aW9uID0gZnVuY3Rpb24gc2VsZWN0b3JGdW5jdGlvbihlbGVtZW50KSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcXVlcnkgPSBzZWxmW2pdO1xuXG4gICAgICBpZiAobWF0Y2hlcyQxKHF1ZXJ5LCBlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgaWYgKHNlbGYudGV4dCgpID09IG51bGwpIHtcbiAgICBzZWxlY3RvckZ1bmN0aW9uID0gZnVuY3Rpb24gc2VsZWN0b3JGdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gY29sbGVjdGlvbi5maWx0ZXIoc2VsZWN0b3JGdW5jdGlvbik7XG59OyAvLyBmaWx0ZXJcbi8vIGRvZXMgc2VsZWN0b3IgbWF0Y2ggYSBzaW5nbGUgZWxlbWVudD9cblxuXG52YXIgbWF0Y2hlcyA9IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmb3IgKHZhciBqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKyspIHtcbiAgICB2YXIgcXVlcnkgPSBzZWxmW2pdO1xuXG4gICAgaWYgKG1hdGNoZXMkMShxdWVyeSwgZWxlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTsgLy8gbWF0Y2hlc1xuXG5cbnZhciBtYXRjaGluZyA9IHtcbiAgbWF0Y2hlczogbWF0Y2hlcyxcbiAgZmlsdGVyOiBmaWx0ZXJcbn07XG5cbnZhciBTZWxlY3RvciA9IGZ1bmN0aW9uIFNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gIHRoaXMuaW5wdXRUZXh0ID0gc2VsZWN0b3I7XG4gIHRoaXMuY3VycmVudFN1YmplY3QgPSBudWxsO1xuICB0aGlzLmNvbXBvdW5kQ291bnQgPSAwO1xuICB0aGlzLmVkZ2VDb3VudCA9IDA7XG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICBpZiAoc2VsZWN0b3IgPT0gbnVsbCB8fCBzdHJpbmcoc2VsZWN0b3IpICYmIHNlbGVjdG9yLm1hdGNoKC9eXFxzKiQvKSkgOyBlbHNlIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKHNlbGVjdG9yKSkge1xuICAgIHRoaXMuYWRkUXVlcnkoe1xuICAgICAgY2hlY2tzOiBbe1xuICAgICAgICB0eXBlOiBUeXBlLkNPTExFQ1RJT04sXG4gICAgICAgIHZhbHVlOiBzZWxlY3Rvci5jb2xsZWN0aW9uKClcbiAgICAgIH1dXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoZm4kNihzZWxlY3RvcikpIHtcbiAgICB0aGlzLmFkZFF1ZXJ5KHtcbiAgICAgIGNoZWNrczogW3tcbiAgICAgICAgdHlwZTogVHlwZS5GSUxURVIsXG4gICAgICAgIHZhbHVlOiBzZWxlY3RvclxuICAgICAgfV1cbiAgICB9KTtcbiAgfSBlbHNlIGlmIChzdHJpbmcoc2VsZWN0b3IpKSB7XG4gICAgaWYgKCF0aGlzLnBhcnNlKHNlbGVjdG9yKSkge1xuICAgICAgdGhpcy5pbnZhbGlkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZXJyb3IoJ0Egc2VsZWN0b3IgbXVzdCBiZSBjcmVhdGVkIGZyb20gYSBzdHJpbmc7IGZvdW5kICcpO1xuICB9XG59O1xuXG52YXIgc2VsZm4gPSBTZWxlY3Rvci5wcm90b3R5cGU7XG5bcGFyc2UkMSwgbWF0Y2hpbmddLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgcmV0dXJuIGV4dGVuZChzZWxmbiwgcCk7XG59KTtcblxuc2VsZm4udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaW5wdXRUZXh0O1xufTtcblxuc2VsZm4uc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoO1xufTtcblxuc2VsZm4uZXEgPSBmdW5jdGlvbiAoaSkge1xuICByZXR1cm4gdGhpc1tpXTtcbn07XG5cbnNlbGZuLnNhbWVUZXh0ID0gZnVuY3Rpb24gKG90aGVyU2VsKSB7XG4gIHJldHVybiAhdGhpcy5pbnZhbGlkICYmICFvdGhlclNlbC5pbnZhbGlkICYmIHRoaXMudGV4dCgpID09PSBvdGhlclNlbC50ZXh0KCk7XG59O1xuXG5zZWxmbi5hZGRRdWVyeSA9IGZ1bmN0aW9uIChxKSB7XG4gIHRoaXNbdGhpcy5sZW5ndGgrK10gPSBxO1xufTtcblxuc2VsZm4uc2VsZWN0b3IgPSBzZWxmbi50b1N0cmluZztcblxudmFyIGVsZXNmbiRnID0ge1xuICBhbGxBcmU6IGZ1bmN0aW9uIGFsbEFyZShzZWxlY3Rvcikge1xuICAgIHZhciBzZWxPYmogPSBuZXcgU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIHJldHVybiB0aGlzLmV2ZXJ5KGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBzZWxPYmoubWF0Y2hlcyhlbGUpO1xuICAgIH0pO1xuICB9LFxuICBpczogZnVuY3Rpb24gaXMoc2VsZWN0b3IpIHtcbiAgICB2YXIgc2VsT2JqID0gbmV3IFNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICByZXR1cm4gdGhpcy5zb21lKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBzZWxPYmoubWF0Y2hlcyhlbGUpO1xuICAgIH0pO1xuICB9LFxuICBzb21lOiBmdW5jdGlvbiBzb21lKGZuLCB0aGlzQXJnKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmV0ID0gIXRoaXNBcmcgPyBmbih0aGlzW2ldLCBpLCB0aGlzKSA6IGZuLmFwcGx5KHRoaXNBcmcsIFt0aGlzW2ldLCBpLCB0aGlzXSk7XG5cbiAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBldmVyeTogZnVuY3Rpb24gZXZlcnkoZm4sIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByZXQgPSAhdGhpc0FyZyA/IGZuKHRoaXNbaV0sIGksIHRoaXMpIDogZm4uYXBwbHkodGhpc0FyZywgW3RoaXNbaV0sIGksIHRoaXNdKTtcblxuICAgICAgaWYgKCFyZXQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBzYW1lOiBmdW5jdGlvbiBzYW1lKGNvbGxlY3Rpb24pIHtcbiAgICAvLyBjaGVhcCBjb2xsZWN0aW9uIHJlZiBjaGVja1xuICAgIGlmICh0aGlzID09PSBjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb2xsZWN0aW9uID0gdGhpcy5jeSgpLmNvbGxlY3Rpb24oY29sbGVjdGlvbik7XG4gICAgdmFyIHRoaXNMZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICB2YXIgY29sbGVjdGlvbkxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoOyAvLyBjaGVhcCBsZW5ndGggY2hlY2tcblxuICAgIGlmICh0aGlzTGVuZ3RoICE9PSBjb2xsZWN0aW9uTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBjaGVhcCBlbGVtZW50IHJlZiBjaGVja1xuXG5cbiAgICBpZiAodGhpc0xlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXNbMF0gPT09IGNvbGxlY3Rpb25bMF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZXZlcnkoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uaGFzRWxlbWVudFdpdGhJZChlbGUuaWQoKSk7XG4gICAgfSk7XG4gIH0sXG4gIGFueVNhbWU6IGZ1bmN0aW9uIGFueVNhbWUoY29sbGVjdGlvbikge1xuICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbihjb2xsZWN0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5zb21lKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmhhc0VsZW1lbnRXaXRoSWQoZWxlLmlkKCkpO1xuICAgIH0pO1xuICB9LFxuICBhbGxBcmVOZWlnaGJvcnM6IGZ1bmN0aW9uIGFsbEFyZU5laWdoYm9ycyhjb2xsZWN0aW9uKSB7XG4gICAgY29sbGVjdGlvbiA9IHRoaXMuY3koKS5jb2xsZWN0aW9uKGNvbGxlY3Rpb24pO1xuICAgIHZhciBuaG9vZCA9IHRoaXMubmVpZ2hib3Job29kKCk7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uZXZlcnkoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIG5ob29kLmhhc0VsZW1lbnRXaXRoSWQoZWxlLmlkKCkpO1xuICAgIH0pO1xuICB9LFxuICBjb250YWluczogZnVuY3Rpb24gY29udGFpbnMoY29sbGVjdGlvbikge1xuICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbihjb2xsZWN0aW9uKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uZXZlcnkoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIHNlbGYuaGFzRWxlbWVudFdpdGhJZChlbGUuaWQoKSk7XG4gICAgfSk7XG4gIH1cbn07XG5lbGVzZm4kZy5hbGxBcmVOZWlnaGJvdXJzID0gZWxlc2ZuJGcuYWxsQXJlTmVpZ2hib3JzO1xuZWxlc2ZuJGcuaGFzID0gZWxlc2ZuJGcuY29udGFpbnM7XG5lbGVzZm4kZy5lcXVhbCA9IGVsZXNmbiRnLmVxdWFscyA9IGVsZXNmbiRnLnNhbWU7XG5cbnZhciBjYWNoZSA9IGZ1bmN0aW9uIGNhY2hlKGZuLCBuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0cmF2ZXJzYWxDYWNoZShhcmcxLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gICAgdmFyIHNlbGVjdG9yT3JFbGVzID0gYXJnMTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIGtleTtcblxuICAgIGlmIChzZWxlY3Rvck9yRWxlcyA9PSBudWxsKSB7XG4gICAgICBrZXkgPSAnJztcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24oc2VsZWN0b3JPckVsZXMpICYmIHNlbGVjdG9yT3JFbGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAga2V5ID0gc2VsZWN0b3JPckVsZXMuaWQoKTtcbiAgICB9XG5cbiAgICBpZiAoZWxlcy5sZW5ndGggPT09IDEgJiYga2V5KSB7XG4gICAgICB2YXIgX3AgPSBlbGVzWzBdLl9wcml2YXRlO1xuICAgICAgdmFyIHRjaCA9IF9wLnRyYXZlcnNhbENhY2hlID0gX3AudHJhdmVyc2FsQ2FjaGUgfHwge307XG4gICAgICB2YXIgY2ggPSB0Y2hbbmFtZV0gPSB0Y2hbbmFtZV0gfHwgW107XG4gICAgICB2YXIgaGFzaCA9IGhhc2hTdHJpbmcoa2V5KTtcbiAgICAgIHZhciBjYWNoZUhpdCA9IGNoW2hhc2hdO1xuXG4gICAgICBpZiAoY2FjaGVIaXQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlSGl0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNoW2hhc2hdID0gZm4uY2FsbChlbGVzLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZuLmNhbGwoZWxlcywgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCk7XG4gICAgfVxuICB9O1xufTtcblxudmFyIGVsZXNmbiRmID0ge1xuICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChzZWxlY3Rvcikge1xuICAgIHZhciBwYXJlbnRzID0gW107IC8vIG9wdGltaXNhdGlvbiBmb3Igc2luZ2xlIGVsZSBjYWxsXG5cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzWzBdLl9wcml2YXRlLnBhcmVudDtcblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICB2YXIgX3BhcmVudCA9IGVsZS5fcHJpdmF0ZS5wYXJlbnQ7XG5cbiAgICAgIGlmIChfcGFyZW50KSB7XG4gICAgICAgIHBhcmVudHMucHVzaChfcGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3bihwYXJlbnRzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LFxuICBwYXJlbnRzOiBmdW5jdGlvbiBwYXJlbnRzKHNlbGVjdG9yKSB7XG4gICAgdmFyIHBhcmVudHMgPSBbXTtcbiAgICB2YXIgZWxlcyA9IHRoaXMucGFyZW50KCk7XG5cbiAgICB3aGlsZSAoZWxlcy5ub25lbXB0eSgpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIHBhcmVudHMucHVzaChlbGUpO1xuICAgICAgfVxuXG4gICAgICBlbGVzID0gZWxlcy5wYXJlbnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3bihwYXJlbnRzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LFxuICBjb21tb25BbmNlc3RvcnM6IGZ1bmN0aW9uIGNvbW1vbkFuY2VzdG9ycyhzZWxlY3Rvcikge1xuICAgIHZhciBhbmNlc3RvcnM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIHBhcmVudHMgPSBlbGUucGFyZW50cygpO1xuICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzIHx8IHBhcmVudHM7XG4gICAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuaW50ZXJzZWN0KHBhcmVudHMpOyAvLyBjdXJyZW50IGxpc3QgbXVzdCBiZSBjb21tb24gd2l0aCBjdXJyZW50IGVsZSBwYXJlbnRzIHNldFxuICAgIH1cblxuICAgIHJldHVybiBhbmNlc3RvcnMuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgb3JwaGFuczogZnVuY3Rpb24gb3JwaGFucyhzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLnN0ZEZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzT3JwaGFuKCk7XG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgbm9ub3JwaGFuczogZnVuY3Rpb24gbm9ub3JwaGFucyhzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLnN0ZEZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzQ2hpbGQoKTtcbiAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LFxuICBjaGlsZHJlbjogY2FjaGUoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIGVsZUNoaWxkcmVuID0gZWxlLl9wcml2YXRlLmNoaWxkcmVuO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZUNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goZWxlQ2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKGNoaWxkcmVuLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LCAnY2hpbGRyZW4nKSxcbiAgc2libGluZ3M6IGZ1bmN0aW9uIHNpYmxpbmdzKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50KCkuY2hpbGRyZW4oKS5ub3QodGhpcykuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgaXNQYXJlbnQ6IGZ1bmN0aW9uIGlzUGFyZW50KCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUuX3ByaXZhdGUuY2hpbGRyZW4ubGVuZ3RoICE9PSAwO1xuICAgIH1cbiAgfSxcbiAgaXNDaGlsZGxlc3M6IGZ1bmN0aW9uIGlzQ2hpbGRsZXNzKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUuX3ByaXZhdGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgfSxcbiAgaXNDaGlsZDogZnVuY3Rpb24gaXNDaGlsZCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNOb2RlKCkgJiYgZWxlLl9wcml2YXRlLnBhcmVudCAhPSBudWxsO1xuICAgIH1cbiAgfSxcbiAgaXNPcnBoYW46IGZ1bmN0aW9uIGlzT3JwaGFuKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUuX3ByaXZhdGUucGFyZW50ID09IG51bGw7XG4gICAgfVxuICB9LFxuICBkZXNjZW5kYW50czogZnVuY3Rpb24gZGVzY2VuZGFudHMoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGFkZChlbGVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIGVsZW1lbnRzLnB1c2goZWxlKTtcblxuICAgICAgICBpZiAoZWxlLmNoaWxkcmVuKCkubm9uZW1wdHkoKSkge1xuICAgICAgICAgIGFkZChlbGUuY2hpbGRyZW4oKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBhZGQodGhpcy5jaGlsZHJlbigpKTtcbiAgICByZXR1cm4gdGhpcy5zcGF3bihlbGVtZW50cywgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZm9yRWFjaENvbXBvdW5kKGVsZXMsIGZuLCBpbmNsdWRlU2VsZiwgcmVjdXJzaXZlU3RlcCkge1xuICB2YXIgcSA9IFtdO1xuICB2YXIgZGlkID0gbmV3IFNldCQxKCk7XG4gIHZhciBjeSA9IGVsZXMuY3koKTtcbiAgdmFyIGhhc0NvbXBvdW5kcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgIGlmIChpbmNsdWRlU2VsZikge1xuICAgICAgcS5wdXNoKGVsZSk7XG4gICAgfSBlbHNlIGlmIChoYXNDb21wb3VuZHMpIHtcbiAgICAgIHJlY3Vyc2l2ZVN0ZXAocSwgZGlkLCBlbGUpO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChxLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgX2VsZSA9IHEuc2hpZnQoKTtcblxuICAgIGZuKF9lbGUpO1xuICAgIGRpZC5hZGQoX2VsZS5pZCgpKTtcblxuICAgIGlmIChoYXNDb21wb3VuZHMpIHtcbiAgICAgIHJlY3Vyc2l2ZVN0ZXAocSwgZGlkLCBfZWxlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlcztcbn1cblxuZnVuY3Rpb24gYWRkQ2hpbGRyZW4ocSwgZGlkLCBlbGUpIHtcbiAgaWYgKGVsZS5pc1BhcmVudCgpKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gZWxlLl9wcml2YXRlLmNoaWxkcmVuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgIGlmICghZGlkLmhhcyhjaGlsZC5pZCgpKSkge1xuICAgICAgICBxLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSAvLyB2ZXJ5IGVmZmljaWVudCB2ZXJzaW9uIG9mIGVsZXMuYWRkKCBlbGVzLmRlc2NlbmRhbnRzKCkgKS5mb3JFYWNoKClcbi8vIGZvciBpbnRlcm5hbCB1c2VcblxuXG5lbGVzZm4kZi5mb3JFYWNoRG93biA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgaW5jbHVkZVNlbGYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gIHJldHVybiBmb3JFYWNoQ29tcG91bmQodGhpcywgZm4sIGluY2x1ZGVTZWxmLCBhZGRDaGlsZHJlbik7XG59O1xuXG5mdW5jdGlvbiBhZGRQYXJlbnQocSwgZGlkLCBlbGUpIHtcbiAgaWYgKGVsZS5pc0NoaWxkKCkpIHtcbiAgICB2YXIgcGFyZW50ID0gZWxlLl9wcml2YXRlLnBhcmVudDtcblxuICAgIGlmICghZGlkLmhhcyhwYXJlbnQuaWQoKSkpIHtcbiAgICAgIHEucHVzaChwYXJlbnQpO1xuICAgIH1cbiAgfVxufVxuXG5lbGVzZm4kZi5mb3JFYWNoVXAgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIGluY2x1ZGVTZWxmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICByZXR1cm4gZm9yRWFjaENvbXBvdW5kKHRoaXMsIGZuLCBpbmNsdWRlU2VsZiwgYWRkUGFyZW50KTtcbn07XG5cbmZ1bmN0aW9uIGFkZFBhcmVudEFuZENoaWxkcmVuKHEsIGRpZCwgZWxlKSB7XG4gIGFkZFBhcmVudChxLCBkaWQsIGVsZSk7XG4gIGFkZENoaWxkcmVuKHEsIGRpZCwgZWxlKTtcbn1cblxuZWxlc2ZuJGYuZm9yRWFjaFVwQW5kRG93biA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgaW5jbHVkZVNlbGYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gIHJldHVybiBmb3JFYWNoQ29tcG91bmQodGhpcywgZm4sIGluY2x1ZGVTZWxmLCBhZGRQYXJlbnRBbmRDaGlsZHJlbik7XG59OyAvLyBhbGlhc2VzXG5cblxuZWxlc2ZuJGYuYW5jZXN0b3JzID0gZWxlc2ZuJGYucGFyZW50cztcblxudmFyIGZuJDUsIGVsZXNmbiRlO1xuZm4kNSA9IGVsZXNmbiRlID0ge1xuICBkYXRhOiBkZWZpbmUuZGF0YSh7XG4gICAgZmllbGQ6ICdkYXRhJyxcbiAgICBiaW5kaW5nRXZlbnQ6ICdkYXRhJyxcbiAgICBhbGxvd0JpbmRpbmc6IHRydWUsXG4gICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgIHNldHRpbmdFdmVudDogJ2RhdGEnLFxuICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICBhbGxvd0dldHRpbmc6IHRydWUsXG4gICAgaW1tdXRhYmxlS2V5czoge1xuICAgICAgJ2lkJzogdHJ1ZSxcbiAgICAgICdzb3VyY2UnOiB0cnVlLFxuICAgICAgJ3RhcmdldCc6IHRydWUsXG4gICAgICAncGFyZW50JzogdHJ1ZVxuICAgIH0sXG4gICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgfSksXG4gIHJlbW92ZURhdGE6IGRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICBmaWVsZDogJ2RhdGEnLFxuICAgIGV2ZW50OiAnZGF0YScsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIHRyaWdnZXJFdmVudDogdHJ1ZSxcbiAgICBpbW11dGFibGVLZXlzOiB7XG4gICAgICAnaWQnOiB0cnVlLFxuICAgICAgJ3NvdXJjZSc6IHRydWUsXG4gICAgICAndGFyZ2V0JzogdHJ1ZSxcbiAgICAgICdwYXJlbnQnOiB0cnVlXG4gICAgfSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9KSxcbiAgc2NyYXRjaDogZGVmaW5lLmRhdGEoe1xuICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgYmluZGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nRXZlbnQ6ICdzY3JhdGNoJyxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gIH0pLFxuICByZW1vdmVTY3JhdGNoOiBkZWZpbmUucmVtb3ZlRGF0YSh7XG4gICAgZmllbGQ6ICdzY3JhdGNoJyxcbiAgICBldmVudDogJ3NjcmF0Y2gnLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICB0cmlnZ2VyRXZlbnQ6IHRydWUsXG4gICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgfSksXG4gIHJzY3JhdGNoOiBkZWZpbmUuZGF0YSh7XG4gICAgZmllbGQ6ICdyc2NyYXRjaCcsXG4gICAgYWxsb3dCaW5kaW5nOiBmYWxzZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IGZhbHNlLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZVxuICB9KSxcbiAgcmVtb3ZlUnNjcmF0Y2g6IGRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICBmaWVsZDogJ3JzY3JhdGNoJyxcbiAgICB0cmlnZ2VyRXZlbnQ6IGZhbHNlXG4gIH0pLFxuICBpZDogZnVuY3Rpb24gaWQoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgfVxuICB9XG59OyAvLyBhbGlhc2VzXG5cbmZuJDUuYXR0ciA9IGZuJDUuZGF0YTtcbmZuJDUucmVtb3ZlQXR0ciA9IGZuJDUucmVtb3ZlRGF0YTtcbnZhciBkYXRhID0gZWxlc2ZuJGU7XG5cbnZhciBlbGVzZm4kZCA9IHt9O1xuXG5mdW5jdGlvbiBkZWZpbmVEZWdyZWVGdW5jdGlvbihjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gKGluY2x1ZGVMb29wcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmIChpbmNsdWRlTG9vcHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5jbHVkZUxvb3BzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5pc05vZGUoKSAmJiAhc2VsZi5yZW1vdmVkKCkpIHtcbiAgICAgIHZhciBkZWdyZWUgPSAwO1xuICAgICAgdmFyIG5vZGUgPSBzZWxmWzBdO1xuICAgICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gbm9kZS5fcHJpdmF0ZS5lZGdlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25uZWN0ZWRFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IGNvbm5lY3RlZEVkZ2VzW2ldO1xuXG4gICAgICAgIGlmICghaW5jbHVkZUxvb3BzICYmIGVkZ2UuaXNMb29wKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZ3JlZSArPSBjYWxsYmFjayhub2RlLCBlZGdlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlZ3JlZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfTtcbn1cblxuZXh0ZW5kKGVsZXNmbiRkLCB7XG4gIGRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGVkZ2UpIHtcbiAgICBpZiAoZWRnZS5zb3VyY2UoKS5zYW1lKGVkZ2UudGFyZ2V0KCkpKSB7XG4gICAgICByZXR1cm4gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9KSxcbiAgaW5kZWdyZWU6IGRlZmluZURlZ3JlZUZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBlZGdlKSB7XG4gICAgaWYgKGVkZ2UudGFyZ2V0KCkuc2FtZShub2RlKSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSksXG4gIG91dGRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGVkZ2UpIHtcbiAgICBpZiAoZWRnZS5zb3VyY2UoKS5zYW1lKG5vZGUpKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9KVxufSk7XG5cbmZ1bmN0aW9uIGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKGRlZ3JlZUZuLCBjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gKGluY2x1ZGVMb29wcykge1xuICAgIHZhciByZXQ7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IG5vZGVzW2ldO1xuICAgICAgdmFyIGRlZ3JlZSA9IGVsZVtkZWdyZWVGbl0oaW5jbHVkZUxvb3BzKTtcblxuICAgICAgaWYgKGRlZ3JlZSAhPT0gdW5kZWZpbmVkICYmIChyZXQgPT09IHVuZGVmaW5lZCB8fCBjYWxsYmFjayhkZWdyZWUsIHJldCkpKSB7XG4gICAgICAgIHJldCA9IGRlZ3JlZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9O1xufVxuXG5leHRlbmQoZWxlc2ZuJGQsIHtcbiAgbWluRGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignZGVncmVlJywgZnVuY3Rpb24gKGRlZ3JlZSwgbWluKSB7XG4gICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgfSksXG4gIG1heERlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ2RlZ3JlZScsIGZ1bmN0aW9uIChkZWdyZWUsIG1heCkge1xuICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gIH0pLFxuICBtaW5JbmRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ2luZGVncmVlJywgZnVuY3Rpb24gKGRlZ3JlZSwgbWluKSB7XG4gICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgfSksXG4gIG1heEluZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignaW5kZWdyZWUnLCBmdW5jdGlvbiAoZGVncmVlLCBtYXgpIHtcbiAgICByZXR1cm4gZGVncmVlID4gbWF4O1xuICB9KSxcbiAgbWluT3V0ZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignb3V0ZGVncmVlJywgZnVuY3Rpb24gKGRlZ3JlZSwgbWluKSB7XG4gICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgfSksXG4gIG1heE91dGRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ291dGRlZ3JlZScsIGZ1bmN0aW9uIChkZWdyZWUsIG1heCkge1xuICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gIH0pXG59KTtcbmV4dGVuZChlbGVzZm4kZCwge1xuICB0b3RhbERlZ3JlZTogZnVuY3Rpb24gdG90YWxEZWdyZWUoaW5jbHVkZUxvb3BzKSB7XG4gICAgdmFyIHRvdGFsID0gMDtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbCArPSBub2Rlc1tpXS5kZWdyZWUoaW5jbHVkZUxvb3BzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG90YWw7XG4gIH1cbn0pO1xuXG52YXIgZm4kNCwgZWxlc2ZuJGM7XG5cbnZhciBiZWZvcmVQb3NpdGlvblNldCA9IGZ1bmN0aW9uIGJlZm9yZVBvc2l0aW9uU2V0KGVsZXMsIG5ld1Bvcywgc2lsZW50KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgaWYgKCFlbGUubG9ja2VkKCkpIHtcbiAgICAgIHZhciBvbGRQb3MgPSBlbGUuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICB2YXIgZGVsdGEgPSB7XG4gICAgICAgIHg6IG5ld1Bvcy54ICE9IG51bGwgPyBuZXdQb3MueCAtIG9sZFBvcy54IDogMCxcbiAgICAgICAgeTogbmV3UG9zLnkgIT0gbnVsbCA/IG5ld1Bvcy55IC0gb2xkUG9zLnkgOiAwXG4gICAgICB9O1xuXG4gICAgICBpZiAoZWxlLmlzUGFyZW50KCkgJiYgIShkZWx0YS54ID09PSAwICYmIGRlbHRhLnkgPT09IDApKSB7XG4gICAgICAgIGVsZS5jaGlsZHJlbigpLnNoaWZ0KGRlbHRhLCBzaWxlbnQpO1xuICAgICAgfVxuXG4gICAgICBlbGUuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcG9zaXRpb25EZWYgPSB7XG4gIGZpZWxkOiAncG9zaXRpb24nLFxuICBiaW5kaW5nRXZlbnQ6ICdwb3NpdGlvbicsXG4gIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICBzZXR0aW5nRXZlbnQ6ICdwb3NpdGlvbicsXG4gIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICB0cmlnZ2VyRm5OYW1lOiAnZW1pdEFuZE5vdGlmeScsXG4gIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgdmFsaWRLZXlzOiBbJ3gnLCAneSddLFxuICBiZWZvcmVHZXQ6IGZ1bmN0aW9uIGJlZm9yZUdldChlbGUpIHtcbiAgICBlbGUudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgfSxcbiAgYmVmb3JlU2V0OiBmdW5jdGlvbiBiZWZvcmVTZXQoZWxlcywgbmV3UG9zKSB7XG4gICAgYmVmb3JlUG9zaXRpb25TZXQoZWxlcywgbmV3UG9zLCBmYWxzZSk7XG4gIH0sXG4gIG9uU2V0OiBmdW5jdGlvbiBvblNldChlbGVzKSB7XG4gICAgZWxlcy5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcbiAgfSxcbiAgY2FuU2V0OiBmdW5jdGlvbiBjYW5TZXQoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUubG9ja2VkKCk7XG4gIH1cbn07XG5mbiQ0ID0gZWxlc2ZuJGMgPSB7XG4gIHBvc2l0aW9uOiBkZWZpbmUuZGF0YShwb3NpdGlvbkRlZiksXG4gIC8vIHBvc2l0aW9uIGJ1dCBubyBub3RpZmljYXRpb24gdG8gcmVuZGVyZXJcbiAgc2lsZW50UG9zaXRpb246IGRlZmluZS5kYXRhKGV4dGVuZCh7fSwgcG9zaXRpb25EZWYsIHtcbiAgICBhbGxvd0JpbmRpbmc6IGZhbHNlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogZmFsc2UsXG4gICAgYWxsb3dHZXR0aW5nOiBmYWxzZSxcbiAgICBiZWZvcmVTZXQ6IGZ1bmN0aW9uIGJlZm9yZVNldChlbGVzLCBuZXdQb3MpIHtcbiAgICAgIGJlZm9yZVBvc2l0aW9uU2V0KGVsZXMsIG5ld1BvcywgdHJ1ZSk7XG4gICAgfSxcbiAgICBvblNldDogZnVuY3Rpb24gb25TZXQoZWxlcykge1xuICAgICAgZWxlcy5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcbiAgICB9XG4gIH0pKSxcbiAgcG9zaXRpb25zOiBmdW5jdGlvbiBwb3NpdGlvbnMocG9zLCBzaWxlbnQpIHtcbiAgICBpZiAocGxhaW5PYmplY3QocG9zKSkge1xuICAgICAgaWYgKHNpbGVudCkge1xuICAgICAgICB0aGlzLnNpbGVudFBvc2l0aW9uKHBvcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBvc2l0aW9uKHBvcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmbiQ2KHBvcykpIHtcbiAgICAgIHZhciBfZm4gPSBwb3M7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICBjeS5zdGFydEJhdGNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcblxuICAgICAgICB2YXIgX3BvcyA9IHZvaWQgMDtcblxuICAgICAgICBpZiAoX3BvcyA9IF9mbihlbGUsIGkpKSB7XG4gICAgICAgICAgaWYgKHNpbGVudCkge1xuICAgICAgICAgICAgZWxlLnNpbGVudFBvc2l0aW9uKF9wb3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGUucG9zaXRpb24oX3Bvcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN5LmVuZEJhdGNoKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHNpbGVudFBvc2l0aW9uczogZnVuY3Rpb24gc2lsZW50UG9zaXRpb25zKHBvcykge1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9ucyhwb3MsIHRydWUpO1xuICB9LFxuICBzaGlmdDogZnVuY3Rpb24gc2hpZnQoZGltLCB2YWwsIHNpbGVudCkge1xuICAgIHZhciBkZWx0YTtcblxuICAgIGlmIChwbGFpbk9iamVjdChkaW0pKSB7XG4gICAgICBkZWx0YSA9IHtcbiAgICAgICAgeDogbnVtYmVyJDEoZGltLngpID8gZGltLnggOiAwLFxuICAgICAgICB5OiBudW1iZXIkMShkaW0ueSkgPyBkaW0ueSA6IDBcbiAgICAgIH07XG4gICAgICBzaWxlbnQgPSB2YWw7XG4gICAgfSBlbHNlIGlmIChzdHJpbmcoZGltKSAmJiBudW1iZXIkMSh2YWwpKSB7XG4gICAgICBkZWx0YSA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICAgIGRlbHRhW2RpbV0gPSB2YWw7XG4gICAgfVxuXG4gICAgaWYgKGRlbHRhICE9IG51bGwpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIGN5LnN0YXJ0QmF0Y2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldOyAvLyBleGNsdWRlIGFueSBub2RlIHRoYXQgaXMgYSBkZXNjZW5kYW50IG9mIHRoZSBjYWxsaW5nIGNvbGxlY3Rpb25cblxuICAgICAgICBpZiAoY3kuaGFzQ29tcG91bmROb2RlcygpICYmIGVsZS5pc0NoaWxkKCkgJiYgZWxlLmFuY2VzdG9ycygpLmFueVNhbWUodGhpcykpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3MgPSBlbGUucG9zaXRpb24oKTtcbiAgICAgICAgdmFyIG5ld1BvcyA9IHtcbiAgICAgICAgICB4OiBwb3MueCArIGRlbHRhLngsXG4gICAgICAgICAgeTogcG9zLnkgKyBkZWx0YS55XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHNpbGVudCkge1xuICAgICAgICAgIGVsZS5zaWxlbnRQb3NpdGlvbihuZXdQb3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZS5wb3NpdGlvbihuZXdQb3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN5LmVuZEJhdGNoKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNpbGVudFNoaWZ0OiBmdW5jdGlvbiBzaWxlbnRTaGlmdChkaW0sIHZhbCkge1xuICAgIGlmIChwbGFpbk9iamVjdChkaW0pKSB7XG4gICAgICB0aGlzLnNoaWZ0KGRpbSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChzdHJpbmcoZGltKSAmJiBudW1iZXIkMSh2YWwpKSB7XG4gICAgICB0aGlzLnNoaWZ0KGRpbSwgdmFsLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gZ2V0L3NldCB0aGUgcmVuZGVyZWQgKGkuZS4gb24gc2NyZWVuKSBwb3NpdG9uIG9mIHRoZSBlbGVtZW50XG4gIHJlbmRlcmVkUG9zaXRpb246IGZ1bmN0aW9uIHJlbmRlcmVkUG9zaXRpb24oZGltLCB2YWwpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgIHZhciBycG9zID0gcGxhaW5PYmplY3QoZGltKSA/IGRpbSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgc2V0dGluZyA9IHJwb3MgIT09IHVuZGVmaW5lZCB8fCB2YWwgIT09IHVuZGVmaW5lZCAmJiBzdHJpbmcoZGltKTtcblxuICAgIGlmIChlbGUgJiYgZWxlLmlzTm9kZSgpKSB7XG4gICAgICAvLyBtdXN0IGhhdmUgYW4gZWxlbWVudCBhbmQgbXVzdCBiZSBhIG5vZGUgdG8gcmV0dXJuIHBvc2l0aW9uXG4gICAgICBpZiAoc2V0dGluZykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgX2VsZSA9IHRoaXNbaV07XG5cbiAgICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHNldCBvbmUgZGltZW5zaW9uXG4gICAgICAgICAgICBfZWxlLnBvc2l0aW9uKGRpbSwgKHZhbCAtIHBhbltkaW1dKSAvIHpvb20pO1xuICAgICAgICAgIH0gZWxzZSBpZiAocnBvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBzZXQgd2hvbGUgcG9zaXRpb25cbiAgICAgICAgICAgIF9lbGUucG9zaXRpb24ocmVuZGVyZWRUb01vZGVsUG9zaXRpb24ocnBvcywgem9vbSwgcGFuKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBnZXR0aW5nXG4gICAgICAgIHZhciBwb3MgPSBlbGUucG9zaXRpb24oKTtcbiAgICAgICAgcnBvcyA9IG1vZGVsVG9SZW5kZXJlZFBvc2l0aW9uKHBvcywgem9vbSwgcGFuKTtcblxuICAgICAgICBpZiAoZGltID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyB0aGVuIHJldHVybiB0aGUgd2hvbGUgcmVuZGVyZWQgcG9zaXRpb25cbiAgICAgICAgICByZXR1cm4gcnBvcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0aGVuIHJldHVybiB0aGUgc3BlY2lmaWVkIGRpbWVuc2lvblxuICAgICAgICAgIHJldHVybiBycG9zW2RpbV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFzZXR0aW5nKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBmb3IgZW1wdHkgY29sbGVjdGlvbiBjYXNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIC8vIGdldC9zZXQgdGhlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnRcbiAgcmVsYXRpdmVQb3NpdGlvbjogZnVuY3Rpb24gcmVsYXRpdmVQb3NpdGlvbihkaW0sIHZhbCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgcHBvcyA9IHBsYWluT2JqZWN0KGRpbSkgPyBkaW0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIHNldHRpbmcgPSBwcG9zICE9PSB1bmRlZmluZWQgfHwgdmFsICE9PSB1bmRlZmluZWQgJiYgc3RyaW5nKGRpbSk7XG4gICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgICBpZiAoZWxlICYmIGVsZS5pc05vZGUoKSkge1xuICAgICAgLy8gbXVzdCBoYXZlIGFuIGVsZW1lbnQgYW5kIG11c3QgYmUgYSBub2RlIHRvIHJldHVybiBwb3NpdGlvblxuICAgICAgaWYgKHNldHRpbmcpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIF9lbGUyID0gdGhpc1tpXTtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gaGFzQ29tcG91bmROb2RlcyA/IF9lbGUyLnBhcmVudCgpIDogbnVsbDtcbiAgICAgICAgICB2YXIgaGFzUGFyZW50ID0gcGFyZW50ICYmIHBhcmVudC5sZW5ndGggPiAwO1xuICAgICAgICAgIHZhciByZWxhdGl2ZVRvUGFyZW50ID0gaGFzUGFyZW50O1xuXG4gICAgICAgICAgaWYgKGhhc1BhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBvcmlnaW4gPSByZWxhdGl2ZVRvUGFyZW50ID8gcGFyZW50LnBvc2l0aW9uKCkgOiB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHNldCBvbmUgZGltZW5zaW9uXG4gICAgICAgICAgICBfZWxlMi5wb3NpdGlvbihkaW0sIHZhbCArIG9yaWdpbltkaW1dKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBwb3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gc2V0IHdob2xlIHBvc2l0aW9uXG4gICAgICAgICAgICBfZWxlMi5wb3NpdGlvbih7XG4gICAgICAgICAgICAgIHg6IHBwb3MueCArIG9yaWdpbi54LFxuICAgICAgICAgICAgICB5OiBwcG9zLnkgKyBvcmlnaW4ueVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBnZXR0aW5nXG4gICAgICAgIHZhciBwb3MgPSBlbGUucG9zaXRpb24oKTtcblxuICAgICAgICB2YXIgX3BhcmVudCA9IGhhc0NvbXBvdW5kTm9kZXMgPyBlbGUucGFyZW50KCkgOiBudWxsO1xuXG4gICAgICAgIHZhciBfaGFzUGFyZW50ID0gX3BhcmVudCAmJiBfcGFyZW50Lmxlbmd0aCA+IDA7XG5cbiAgICAgICAgdmFyIF9yZWxhdGl2ZVRvUGFyZW50ID0gX2hhc1BhcmVudDtcblxuICAgICAgICBpZiAoX2hhc1BhcmVudCkge1xuICAgICAgICAgIF9wYXJlbnQgPSBfcGFyZW50WzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9vcmlnaW4gPSBfcmVsYXRpdmVUb1BhcmVudCA/IF9wYXJlbnQucG9zaXRpb24oKSA6IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcblxuICAgICAgICBwcG9zID0ge1xuICAgICAgICAgIHg6IHBvcy54IC0gX29yaWdpbi54LFxuICAgICAgICAgIHk6IHBvcy55IC0gX29yaWdpbi55XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGRpbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gdGhlbiByZXR1cm4gdGhlIHdob2xlIHJlbmRlcmVkIHBvc2l0aW9uXG4gICAgICAgICAgcmV0dXJuIHBwb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdGhlbiByZXR1cm4gdGhlIHNwZWNpZmllZCBkaW1lbnNpb25cbiAgICAgICAgICByZXR1cm4gcHBvc1tkaW1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghc2V0dGluZykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gZm9yIGVtcHR5IGNvbGxlY3Rpb24gY2FzZVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9XG59OyAvLyBhbGlhc2VzXG5cbmZuJDQubW9kZWxQb3NpdGlvbiA9IGZuJDQucG9pbnQgPSBmbiQ0LnBvc2l0aW9uO1xuZm4kNC5tb2RlbFBvc2l0aW9ucyA9IGZuJDQucG9pbnRzID0gZm4kNC5wb3NpdGlvbnM7XG5mbiQ0LnJlbmRlcmVkUG9pbnQgPSBmbiQ0LnJlbmRlcmVkUG9zaXRpb247XG5mbiQ0LnJlbGF0aXZlUG9pbnQgPSBmbiQ0LnJlbGF0aXZlUG9zaXRpb247XG52YXIgcG9zaXRpb24gPSBlbGVzZm4kYztcblxudmFyIGZuJDMsIGVsZXNmbiRiO1xuZm4kMyA9IGVsZXNmbiRiID0ge307XG5cbmVsZXNmbiRiLnJlbmRlcmVkQm91bmRpbmdCb3ggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgYmIgPSB0aGlzLmJvdW5kaW5nQm94KG9wdGlvbnMpO1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciB6b29tID0gY3kuem9vbSgpO1xuICB2YXIgcGFuID0gY3kucGFuKCk7XG4gIHZhciB4MSA9IGJiLngxICogem9vbSArIHBhbi54O1xuICB2YXIgeDIgPSBiYi54MiAqIHpvb20gKyBwYW4ueDtcbiAgdmFyIHkxID0gYmIueTEgKiB6b29tICsgcGFuLnk7XG4gIHZhciB5MiA9IGJiLnkyICogem9vbSArIHBhbi55O1xuICByZXR1cm4ge1xuICAgIHgxOiB4MSxcbiAgICB4MjogeDIsXG4gICAgeTE6IHkxLFxuICAgIHkyOiB5MixcbiAgICB3OiB4MiAtIHgxLFxuICAgIGg6IHkyIC0geTFcbiAgfTtcbn07XG5cbmVsZXNmbiRiLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNpbGVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpIHx8ICFjeS5oYXNDb21wb3VuZE5vZGVzKCkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMuZm9yRWFjaFVwKGZ1bmN0aW9uIChlbGUpIHtcbiAgICBpZiAoZWxlLmlzUGFyZW50KCkpIHtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIF9wLmNvbXBvdW5kQm91bmRzQ2xlYW4gPSBmYWxzZTtcbiAgICAgIF9wLmJiQ2FjaGUgPSBudWxsO1xuXG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICBlbGUuZW1pdEFuZE5vdGlmeSgnYm91bmRzJyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5lbGVzZm4kYi51cGRhdGVDb21wb3VuZEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGZvcmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpOyAvLyBub3QgcG9zc2libGUgdG8gZG8gb24gbm9uLWNvbXBvdW5kIGdyYXBocyBvciB3aXRoIHRoZSBzdHlsZSBkaXNhYmxlZFxuXG4gIGlmICghY3kuc3R5bGVFbmFibGVkKCkgfHwgIWN5Lmhhc0NvbXBvdW5kTm9kZXMoKSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHNhdmUgY3ljbGVzIHdoZW4gYmF0Y2hpbmcgLS0gYnV0IGJvdW5kcyB3aWxsIGJlIHN0YWxlIChvciBub3QgZXhpc3QgeWV0KVxuXG5cbiAgaWYgKCFmb3JjZSAmJiBjeS5iYXRjaGluZygpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGUocGFyZW50KSB7XG4gICAgaWYgKCFwYXJlbnQuaXNQYXJlbnQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBfcCA9IHBhcmVudC5fcHJpdmF0ZTtcbiAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnQuY2hpbGRyZW4oKTtcbiAgICB2YXIgaW5jbHVkZUxhYmVscyA9IHBhcmVudC5wc3R5bGUoJ2NvbXBvdW5kLXNpemluZy13cnQtbGFiZWxzJykudmFsdWUgPT09ICdpbmNsdWRlJztcbiAgICB2YXIgbWluID0ge1xuICAgICAgd2lkdGg6IHtcbiAgICAgICAgdmFsOiBwYXJlbnQucHN0eWxlKCdtaW4td2lkdGgnKS5wZlZhbHVlLFxuICAgICAgICBsZWZ0OiBwYXJlbnQucHN0eWxlKCdtaW4td2lkdGgtYmlhcy1sZWZ0JyksXG4gICAgICAgIHJpZ2h0OiBwYXJlbnQucHN0eWxlKCdtaW4td2lkdGgtYmlhcy1yaWdodCcpXG4gICAgICB9LFxuICAgICAgaGVpZ2h0OiB7XG4gICAgICAgIHZhbDogcGFyZW50LnBzdHlsZSgnbWluLWhlaWdodCcpLnBmVmFsdWUsXG4gICAgICAgIHRvcDogcGFyZW50LnBzdHlsZSgnbWluLWhlaWdodC1iaWFzLXRvcCcpLFxuICAgICAgICBib3R0b206IHBhcmVudC5wc3R5bGUoJ21pbi1oZWlnaHQtYmlhcy1ib3R0b20nKVxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGJiID0gY2hpbGRyZW4uYm91bmRpbmdCb3goe1xuICAgICAgaW5jbHVkZUxhYmVsczogaW5jbHVkZUxhYmVscyxcbiAgICAgIGluY2x1ZGVPdmVybGF5czogZmFsc2UsXG4gICAgICAvLyB1cGRhdGluZyB0aGUgY29tcG91bmQgYm91bmRzIGhhcHBlbnMgb3V0c2lkZSBvZiB0aGUgcmVndWxhclxuICAgICAgLy8gY2FjaGUgY3ljbGUgKGkuZS4gYmVmb3JlIGZpcmVkIGV2ZW50cylcbiAgICAgIHVzZUNhY2hlOiBmYWxzZVxuICAgIH0pO1xuICAgIHZhciBwb3MgPSBfcC5wb3NpdGlvbjsgLy8gaWYgY2hpbGRyZW4gdGFrZSB1cCB6ZXJvIGFyZWEgdGhlbiBrZWVwIHBvc2l0aW9uIGFuZCBmYWxsIGJhY2sgb24gc3R5bGVzaGVldCB3L2hcblxuICAgIGlmIChiYi53ID09PSAwIHx8IGJiLmggPT09IDApIHtcbiAgICAgIGJiID0ge1xuICAgICAgICB3OiBwYXJlbnQucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUsXG4gICAgICAgIGg6IHBhcmVudC5wc3R5bGUoJ2hlaWdodCcpLnBmVmFsdWVcbiAgICAgIH07XG4gICAgICBiYi54MSA9IHBvcy54IC0gYmIudyAvIDI7XG4gICAgICBiYi54MiA9IHBvcy54ICsgYmIudyAvIDI7XG4gICAgICBiYi55MSA9IHBvcy55IC0gYmIuaCAvIDI7XG4gICAgICBiYi55MiA9IHBvcy55ICsgYmIuaCAvIDI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZUJpYXNWYWx1ZXMocHJvcERpZmYsIHByb3BCaWFzLCBwcm9wQmlhc0NvbXBsZW1lbnQpIHtcbiAgICAgIHZhciBiaWFzRGlmZiA9IDA7XG4gICAgICB2YXIgYmlhc0NvbXBsZW1lbnREaWZmID0gMDtcbiAgICAgIHZhciBiaWFzVG90YWwgPSBwcm9wQmlhcyArIHByb3BCaWFzQ29tcGxlbWVudDtcblxuICAgICAgaWYgKHByb3BEaWZmID4gMCAmJiBiaWFzVG90YWwgPiAwKSB7XG4gICAgICAgIGJpYXNEaWZmID0gcHJvcEJpYXMgLyBiaWFzVG90YWwgKiBwcm9wRGlmZjtcbiAgICAgICAgYmlhc0NvbXBsZW1lbnREaWZmID0gcHJvcEJpYXNDb21wbGVtZW50IC8gYmlhc1RvdGFsICogcHJvcERpZmY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJpYXNEaWZmOiBiaWFzRGlmZixcbiAgICAgICAgYmlhc0NvbXBsZW1lbnREaWZmOiBiaWFzQ29tcGxlbWVudERpZmZcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVBhZGRpbmdWYWx1ZXMod2lkdGgsIGhlaWdodCwgcGFkZGluZ09iamVjdCwgcmVsYXRpdmVUbykge1xuICAgICAgLy8gQXNzdW1pbmcgcGVyY2VudGFnZSBpcyBudW1iZXIgZnJvbSAwIHRvIDFcbiAgICAgIGlmIChwYWRkaW5nT2JqZWN0LnVuaXRzID09PSAnJScpIHtcbiAgICAgICAgc3dpdGNoIChyZWxhdGl2ZVRvKSB7XG4gICAgICAgICAgY2FzZSAnd2lkdGgnOlxuICAgICAgICAgICAgcmV0dXJuIHdpZHRoID4gMCA/IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqIHdpZHRoIDogMDtcblxuICAgICAgICAgIGNhc2UgJ2hlaWdodCc6XG4gICAgICAgICAgICByZXR1cm4gaGVpZ2h0ID4gMCA/IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqIGhlaWdodCA6IDA7XG5cbiAgICAgICAgICBjYXNlICdhdmVyYWdlJzpcbiAgICAgICAgICAgIHJldHVybiB3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCA/IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqICh3aWR0aCArIGhlaWdodCkgLyAyIDogMDtcblxuICAgICAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgICAgICByZXR1cm4gd2lkdGggPiAwICYmIGhlaWdodCA+IDAgPyB3aWR0aCA+IGhlaWdodCA/IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqIGhlaWdodCA6IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqIHdpZHRoIDogMDtcblxuICAgICAgICAgIGNhc2UgJ21heCc6XG4gICAgICAgICAgICByZXR1cm4gd2lkdGggPiAwICYmIGhlaWdodCA+IDAgPyB3aWR0aCA+IGhlaWdodCA/IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqIHdpZHRoIDogcGFkZGluZ09iamVjdC5wZlZhbHVlICogaGVpZ2h0IDogMDtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYWRkaW5nT2JqZWN0LnVuaXRzID09PSAncHgnKSB7XG4gICAgICAgIHJldHVybiBwYWRkaW5nT2JqZWN0LnBmVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGVmdFZhbCA9IG1pbi53aWR0aC5sZWZ0LnZhbHVlO1xuXG4gICAgaWYgKG1pbi53aWR0aC5sZWZ0LnVuaXRzID09PSAncHgnICYmIG1pbi53aWR0aC52YWwgPiAwKSB7XG4gICAgICBsZWZ0VmFsID0gbGVmdFZhbCAqIDEwMCAvIG1pbi53aWR0aC52YWw7XG4gICAgfVxuXG4gICAgdmFyIHJpZ2h0VmFsID0gbWluLndpZHRoLnJpZ2h0LnZhbHVlO1xuXG4gICAgaWYgKG1pbi53aWR0aC5yaWdodC51bml0cyA9PT0gJ3B4JyAmJiBtaW4ud2lkdGgudmFsID4gMCkge1xuICAgICAgcmlnaHRWYWwgPSByaWdodFZhbCAqIDEwMCAvIG1pbi53aWR0aC52YWw7XG4gICAgfVxuXG4gICAgdmFyIHRvcFZhbCA9IG1pbi5oZWlnaHQudG9wLnZhbHVlO1xuXG4gICAgaWYgKG1pbi5oZWlnaHQudG9wLnVuaXRzID09PSAncHgnICYmIG1pbi5oZWlnaHQudmFsID4gMCkge1xuICAgICAgdG9wVmFsID0gdG9wVmFsICogMTAwIC8gbWluLmhlaWdodC52YWw7XG4gICAgfVxuXG4gICAgdmFyIGJvdHRvbVZhbCA9IG1pbi5oZWlnaHQuYm90dG9tLnZhbHVlO1xuXG4gICAgaWYgKG1pbi5oZWlnaHQuYm90dG9tLnVuaXRzID09PSAncHgnICYmIG1pbi5oZWlnaHQudmFsID4gMCkge1xuICAgICAgYm90dG9tVmFsID0gYm90dG9tVmFsICogMTAwIC8gbWluLmhlaWdodC52YWw7XG4gICAgfVxuXG4gICAgdmFyIHdpZHRoQmlhc0RpZmZzID0gY29tcHV0ZUJpYXNWYWx1ZXMobWluLndpZHRoLnZhbCAtIGJiLncsIGxlZnRWYWwsIHJpZ2h0VmFsKTtcbiAgICB2YXIgZGlmZkxlZnQgPSB3aWR0aEJpYXNEaWZmcy5iaWFzRGlmZjtcbiAgICB2YXIgZGlmZlJpZ2h0ID0gd2lkdGhCaWFzRGlmZnMuYmlhc0NvbXBsZW1lbnREaWZmO1xuICAgIHZhciBoZWlnaHRCaWFzRGlmZnMgPSBjb21wdXRlQmlhc1ZhbHVlcyhtaW4uaGVpZ2h0LnZhbCAtIGJiLmgsIHRvcFZhbCwgYm90dG9tVmFsKTtcbiAgICB2YXIgZGlmZlRvcCA9IGhlaWdodEJpYXNEaWZmcy5iaWFzRGlmZjtcbiAgICB2YXIgZGlmZkJvdHRvbSA9IGhlaWdodEJpYXNEaWZmcy5iaWFzQ29tcGxlbWVudERpZmY7XG4gICAgX3AuYXV0b1BhZGRpbmcgPSBjb21wdXRlUGFkZGluZ1ZhbHVlcyhiYi53LCBiYi5oLCBwYXJlbnQucHN0eWxlKCdwYWRkaW5nJyksIHBhcmVudC5wc3R5bGUoJ3BhZGRpbmctcmVsYXRpdmUtdG8nKS52YWx1ZSk7XG4gICAgX3AuYXV0b1dpZHRoID0gTWF0aC5tYXgoYmIudywgbWluLndpZHRoLnZhbCk7XG4gICAgcG9zLnggPSAoLWRpZmZMZWZ0ICsgYmIueDEgKyBiYi54MiArIGRpZmZSaWdodCkgLyAyO1xuICAgIF9wLmF1dG9IZWlnaHQgPSBNYXRoLm1heChiYi5oLCBtaW4uaGVpZ2h0LnZhbCk7XG4gICAgcG9zLnkgPSAoLWRpZmZUb3AgKyBiYi55MSArIGJiLnkyICsgZGlmZkJvdHRvbSkgLyAyO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuXG4gICAgaWYgKCFfcC5jb21wb3VuZEJvdW5kc0NsZWFuIHx8IGZvcmNlKSB7XG4gICAgICB1cGRhdGUoZWxlKTtcblxuICAgICAgaWYgKCFjeS5iYXRjaGluZygpKSB7XG4gICAgICAgIF9wLmNvbXBvdW5kQm91bmRzQ2xlYW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxudmFyIG5vbmluZiA9IGZ1bmN0aW9uIG5vbmluZih4KSB7XG4gIGlmICh4ID09PSBJbmZpbml0eSB8fCB4ID09PSAtSW5maW5pdHkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB4O1xufTtcblxudmFyIHVwZGF0ZUJvdW5kcyA9IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kcyhiLCB4MSwgeTEsIHgyLCB5Mikge1xuICAvLyBkb24ndCB1cGRhdGUgd2l0aCB6ZXJvIGFyZWEgYm94ZXNcbiAgaWYgKHgyIC0geDEgPT09IDAgfHwgeTIgLSB5MSA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBkb24ndCB1cGRhdGUgd2l0aCBudWxsIGRpbVxuXG5cbiAgaWYgKHgxID09IG51bGwgfHwgeTEgPT0gbnVsbCB8fCB4MiA9PSBudWxsIHx8IHkyID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBiLngxID0geDEgPCBiLngxID8geDEgOiBiLngxO1xuICBiLngyID0geDIgPiBiLngyID8geDIgOiBiLngyO1xuICBiLnkxID0geTEgPCBiLnkxID8geTEgOiBiLnkxO1xuICBiLnkyID0geTIgPiBiLnkyID8geTIgOiBiLnkyO1xuICBiLncgPSBiLngyIC0gYi54MTtcbiAgYi5oID0gYi55MiAtIGIueTE7XG59O1xuXG52YXIgdXBkYXRlQm91bmRzRnJvbUJveCA9IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kc0Zyb21Cb3goYiwgYjIpIHtcbiAgaWYgKGIyID09IG51bGwpIHtcbiAgICByZXR1cm4gYjtcbiAgfVxuXG4gIHJldHVybiB1cGRhdGVCb3VuZHMoYiwgYjIueDEsIGIyLnkxLCBiMi54MiwgYjIueTIpO1xufTtcblxudmFyIHByZWZpeGVkUHJvcGVydHkgPSBmdW5jdGlvbiBwcmVmaXhlZFByb3BlcnR5KG9iaiwgZmllbGQsIHByZWZpeCkge1xuICByZXR1cm4gZ2V0UHJlZml4ZWRQcm9wZXJ0eShvYmosIGZpZWxkLCBwcmVmaXgpO1xufTtcblxudmFyIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyA9IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyhib3VuZHMsIGVsZSwgcHJlZml4KSB7XG4gIGlmIChlbGUuY3koKS5oZWFkbGVzcygpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICB2YXIgaGFsZkFyVyA9IHJzdHlsZS5hcnJvd1dpZHRoIC8gMjtcbiAgdmFyIGFycm93VHlwZSA9IGVsZS5wc3R5bGUocHJlZml4ICsgJy1hcnJvdy1zaGFwZScpLnZhbHVlO1xuICB2YXIgeDtcbiAgdmFyIHk7XG5cbiAgaWYgKGFycm93VHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgaWYgKHByZWZpeCA9PT0gJ3NvdXJjZScpIHtcbiAgICAgIHggPSByc3R5bGUuc3JjWDtcbiAgICAgIHkgPSByc3R5bGUuc3JjWTtcbiAgICB9IGVsc2UgaWYgKHByZWZpeCA9PT0gJ3RhcmdldCcpIHtcbiAgICAgIHggPSByc3R5bGUudGd0WDtcbiAgICAgIHkgPSByc3R5bGUudGd0WTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHJzdHlsZS5taWRYO1xuICAgICAgeSA9IHJzdHlsZS5taWRZO1xuICAgIH0gLy8gYWx3YXlzIHN0b3JlIHRoZSBpbmRpdmlkdWFsIGFycm93IGJvdW5kc1xuXG5cbiAgICB2YXIgYmJzID0gX3AuYXJyb3dCb3VuZHMgPSBfcC5hcnJvd0JvdW5kcyB8fCB7fTtcbiAgICB2YXIgYmIgPSBiYnNbcHJlZml4XSA9IGJic1twcmVmaXhdIHx8IHt9O1xuICAgIGJiLngxID0geCAtIGhhbGZBclc7XG4gICAgYmIueTEgPSB5IC0gaGFsZkFyVztcbiAgICBiYi54MiA9IHggKyBoYWxmQXJXO1xuICAgIGJiLnkyID0geSArIGhhbGZBclc7XG4gICAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gICAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG4gICAgZXhwYW5kQm91bmRpbmdCb3goYmIsIDEpO1xuICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGJiLngxLCBiYi55MSwgYmIueDIsIGJiLnkyKTtcbiAgfVxufTtcblxudmFyIHVwZGF0ZUJvdW5kc0Zyb21MYWJlbCA9IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kc0Zyb21MYWJlbChib3VuZHMsIGVsZSwgcHJlZml4KSB7XG4gIGlmIChlbGUuY3koKS5oZWFkbGVzcygpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHByZWZpeERhc2g7XG5cbiAgaWYgKHByZWZpeCkge1xuICAgIHByZWZpeERhc2ggPSBwcmVmaXggKyAnLSc7XG4gIH0gZWxzZSB7XG4gICAgcHJlZml4RGFzaCA9ICcnO1xuICB9XG5cbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICB2YXIgbGFiZWwgPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAnbGFiZWwnKS5zdHJWYWx1ZTtcblxuICBpZiAobGFiZWwpIHtcbiAgICB2YXIgaGFsaWduID0gZWxlLnBzdHlsZSgndGV4dC1oYWxpZ24nKTtcbiAgICB2YXIgdmFsaWduID0gZWxlLnBzdHlsZSgndGV4dC12YWxpZ24nKTtcbiAgICB2YXIgbGFiZWxXaWR0aCA9IHByZWZpeGVkUHJvcGVydHkocnN0eWxlLCAnbGFiZWxXaWR0aCcsIHByZWZpeCk7XG4gICAgdmFyIGxhYmVsSGVpZ2h0ID0gcHJlZml4ZWRQcm9wZXJ0eShyc3R5bGUsICdsYWJlbEhlaWdodCcsIHByZWZpeCk7XG4gICAgdmFyIGxhYmVsWCA9IHByZWZpeGVkUHJvcGVydHkocnN0eWxlLCAnbGFiZWxYJywgcHJlZml4KTtcbiAgICB2YXIgbGFiZWxZID0gcHJlZml4ZWRQcm9wZXJ0eShyc3R5bGUsICdsYWJlbFknLCBwcmVmaXgpO1xuICAgIHZhciBtYXJnaW5YID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ3RleHQtbWFyZ2luLXgnKS5wZlZhbHVlO1xuICAgIHZhciBtYXJnaW5ZID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ3RleHQtbWFyZ2luLXknKS5wZlZhbHVlO1xuICAgIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gICAgdmFyIHJvdGF0aW9uID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ3RleHQtcm90YXRpb24nKTtcbiAgICB2YXIgb3V0bGluZVdpZHRoID0gZWxlLnBzdHlsZSgndGV4dC1vdXRsaW5lLXdpZHRoJykucGZWYWx1ZTtcbiAgICB2YXIgYm9yZGVyV2lkdGggPSBlbGUucHN0eWxlKCd0ZXh0LWJvcmRlci13aWR0aCcpLnBmVmFsdWU7XG4gICAgdmFyIGhhbGZCb3JkZXJXaWR0aCA9IGJvcmRlcldpZHRoIC8gMjtcbiAgICB2YXIgcGFkZGluZyA9IGVsZS5wc3R5bGUoJ3RleHQtYmFja2dyb3VuZC1wYWRkaW5nJykucGZWYWx1ZTtcbiAgICB2YXIgbWFyZ2luT2ZFcnJvciA9IDI7IC8vIGV4cGFuZCB0byB3b3JrIGFyb3VuZCBicm93c2VyIGRpbWVuc2lvbiBpbmFjY3VyYWNpZXNcblxuICAgIHZhciBsaCA9IGxhYmVsSGVpZ2h0O1xuICAgIHZhciBsdyA9IGxhYmVsV2lkdGg7XG4gICAgdmFyIGx3XzIgPSBsdyAvIDI7XG4gICAgdmFyIGxoXzIgPSBsaCAvIDI7XG4gICAgdmFyIGx4MSwgbHgyLCBseTEsIGx5MjtcblxuICAgIGlmIChpc0VkZ2UpIHtcbiAgICAgIGx4MSA9IGxhYmVsWCAtIGx3XzI7XG4gICAgICBseDIgPSBsYWJlbFggKyBsd18yO1xuICAgICAgbHkxID0gbGFiZWxZIC0gbGhfMjtcbiAgICAgIGx5MiA9IGxhYmVsWSArIGxoXzI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoaGFsaWduLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgIGx4MSA9IGxhYmVsWCAtIGx3O1xuICAgICAgICAgIGx4MiA9IGxhYmVsWDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGx4MSA9IGxhYmVsWCAtIGx3XzI7XG4gICAgICAgICAgbHgyID0gbGFiZWxYICsgbHdfMjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgbHgxID0gbGFiZWxYO1xuICAgICAgICAgIGx4MiA9IGxhYmVsWCArIGx3O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHZhbGlnbi52YWx1ZSkge1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIGx5MSA9IGxhYmVsWSAtIGxoO1xuICAgICAgICAgIGx5MiA9IGxhYmVsWTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGx5MSA9IGxhYmVsWSAtIGxoXzI7XG4gICAgICAgICAgbHkyID0gbGFiZWxZICsgbGhfMjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIGx5MSA9IGxhYmVsWTtcbiAgICAgICAgICBseTIgPSBsYWJlbFkgKyBsaDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IC8vIHNoaWZ0IGJ5IG1hcmdpbiBhbmQgZXhwYW5kIGJ5IG91dGxpbmUgYW5kIGJvcmRlclxuXG5cbiAgICBseDEgKz0gbWFyZ2luWCAtIE1hdGgubWF4KG91dGxpbmVXaWR0aCwgaGFsZkJvcmRlcldpZHRoKSAtIHBhZGRpbmcgLSBtYXJnaW5PZkVycm9yO1xuICAgIGx4MiArPSBtYXJnaW5YICsgTWF0aC5tYXgob3V0bGluZVdpZHRoLCBoYWxmQm9yZGVyV2lkdGgpICsgcGFkZGluZyArIG1hcmdpbk9mRXJyb3I7XG4gICAgbHkxICs9IG1hcmdpblkgLSBNYXRoLm1heChvdXRsaW5lV2lkdGgsIGhhbGZCb3JkZXJXaWR0aCkgLSBwYWRkaW5nIC0gbWFyZ2luT2ZFcnJvcjtcbiAgICBseTIgKz0gbWFyZ2luWSArIE1hdGgubWF4KG91dGxpbmVXaWR0aCwgaGFsZkJvcmRlcldpZHRoKSArIHBhZGRpbmcgKyBtYXJnaW5PZkVycm9yOyAvLyBhbHdheXMgc3RvcmUgdGhlIHVucm90YXRlZCBsYWJlbCBib3VuZHMgc2VwYXJhdGVseVxuXG4gICAgdmFyIGJiUHJlZml4ID0gcHJlZml4IHx8ICdtYWluJztcbiAgICB2YXIgYmJzID0gX3AubGFiZWxCb3VuZHM7XG4gICAgdmFyIGJiID0gYmJzW2JiUHJlZml4XSA9IGJic1tiYlByZWZpeF0gfHwge307XG4gICAgYmIueDEgPSBseDE7XG4gICAgYmIueTEgPSBseTE7XG4gICAgYmIueDIgPSBseDI7XG4gICAgYmIueTIgPSBseTI7XG4gICAgYmIudyA9IGx4MiAtIGx4MTtcbiAgICBiYi5oID0gbHkyIC0gbHkxO1xuICAgIHZhciBpc0F1dG9yb3RhdGUgPSBpc0VkZ2UgJiYgcm90YXRpb24uc3RyVmFsdWUgPT09ICdhdXRvcm90YXRlJztcbiAgICB2YXIgaXNQZlZhbHVlID0gcm90YXRpb24ucGZWYWx1ZSAhPSBudWxsICYmIHJvdGF0aW9uLnBmVmFsdWUgIT09IDA7XG5cbiAgICBpZiAoaXNBdXRvcm90YXRlIHx8IGlzUGZWYWx1ZSkge1xuICAgICAgdmFyIHRoZXRhID0gaXNBdXRvcm90YXRlID8gcHJlZml4ZWRQcm9wZXJ0eShfcC5yc3R5bGUsICdsYWJlbEFuZ2xlJywgcHJlZml4KSA6IHJvdGF0aW9uLnBmVmFsdWU7XG4gICAgICB2YXIgY29zID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgdmFyIHNpbiA9IE1hdGguc2luKHRoZXRhKTsgLy8gcm90YXRpb24gcG9pbnQgKGRlZmF1bHQgdmFsdWUgZm9yIGNlbnRlci1jZW50ZXIpXG5cbiAgICAgIHZhciB4byA9IChseDEgKyBseDIpIC8gMjtcbiAgICAgIHZhciB5byA9IChseTEgKyBseTIpIC8gMjtcblxuICAgICAgaWYgKCFpc0VkZ2UpIHtcbiAgICAgICAgc3dpdGNoIChoYWxpZ24udmFsdWUpIHtcbiAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIHhvID0gbHgyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICB4byA9IGx4MTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh2YWxpZ24udmFsdWUpIHtcbiAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgeW8gPSBseTI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICB5byA9IGx5MTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciByb3RhdGUgPSBmdW5jdGlvbiByb3RhdGUoeCwgeSkge1xuICAgICAgICB4ID0geCAtIHhvO1xuICAgICAgICB5ID0geSAtIHlvO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHggKiBjb3MgLSB5ICogc2luICsgeG8sXG4gICAgICAgICAgeTogeCAqIHNpbiArIHkgKiBjb3MgKyB5b1xuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgdmFyIHB4MXkxID0gcm90YXRlKGx4MSwgbHkxKTtcbiAgICAgIHZhciBweDF5MiA9IHJvdGF0ZShseDEsIGx5Mik7XG4gICAgICB2YXIgcHgyeTEgPSByb3RhdGUobHgyLCBseTEpO1xuICAgICAgdmFyIHB4MnkyID0gcm90YXRlKGx4MiwgbHkyKTtcbiAgICAgIGx4MSA9IE1hdGgubWluKHB4MXkxLngsIHB4MXkyLngsIHB4MnkxLngsIHB4MnkyLngpO1xuICAgICAgbHgyID0gTWF0aC5tYXgocHgxeTEueCwgcHgxeTIueCwgcHgyeTEueCwgcHgyeTIueCk7XG4gICAgICBseTEgPSBNYXRoLm1pbihweDF5MS55LCBweDF5Mi55LCBweDJ5MS55LCBweDJ5Mi55KTtcbiAgICAgIGx5MiA9IE1hdGgubWF4KHB4MXkxLnksIHB4MXkyLnksIHB4MnkxLnksIHB4MnkyLnkpO1xuICAgIH1cblxuICAgIHZhciBiYlByZWZpeFJvdCA9IGJiUHJlZml4ICsgJ1JvdCc7XG4gICAgdmFyIGJiUm90ID0gYmJzW2JiUHJlZml4Um90XSA9IGJic1tiYlByZWZpeFJvdF0gfHwge307XG4gICAgYmJSb3QueDEgPSBseDE7XG4gICAgYmJSb3QueTEgPSBseTE7XG4gICAgYmJSb3QueDIgPSBseDI7XG4gICAgYmJSb3QueTIgPSBseTI7XG4gICAgYmJSb3QudyA9IGx4MiAtIGx4MTtcbiAgICBiYlJvdC5oID0gbHkyIC0gbHkxO1xuICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGx4MSwgbHkxLCBseDIsIGx5Mik7XG4gICAgdXBkYXRlQm91bmRzKF9wLmxhYmVsQm91bmRzLmFsbCwgbHgxLCBseTEsIGx4MiwgbHkyKTtcbiAgfVxuXG4gIHJldHVybiBib3VuZHM7XG59OyAvLyBnZXQgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgZWxlbWVudHMgKGluIHJhdyBtb2RlbCBwb3NpdGlvbilcblxuXG52YXIgYm91bmRpbmdCb3hJbXBsID0gZnVuY3Rpb24gYm91bmRpbmdCb3hJbXBsKGVsZSwgb3B0aW9ucykge1xuICB2YXIgY3kgPSBlbGUuX3ByaXZhdGUuY3k7XG4gIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5zdHlsZUVuYWJsZWQoKTtcbiAgdmFyIGhlYWRsZXNzID0gY3kuaGVhZGxlc3MoKTtcbiAgdmFyIGJvdW5kcyA9IG1ha2VCb3VuZGluZ0JveCgpO1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBpc05vZGUgPSBlbGUuaXNOb2RlKCk7XG4gIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gIHZhciBleDEsIGV4MiwgZXkxLCBleTI7IC8vIGV4dHJlbWEgb2YgYm9keSAvIGxpbmVzXG5cbiAgdmFyIHgsIHk7IC8vIG5vZGUgcG9zXG5cbiAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgdmFyIG1hbnVhbEV4cGFuc2lvbiA9IGlzTm9kZSAmJiBzdHlsZUVuYWJsZWQgPyBlbGUucHN0eWxlKCdib3VuZHMtZXhwYW5zaW9uJykucGZWYWx1ZSA6IFswXTsgLy8gbXVzdCB1c2UgYGRpc3BsYXlgIHByb3Agb25seSwgYXMgcmVhZGluZyBgY29tcG91bmQud2lkdGgoKWAgY2F1c2VzIHJlY3Vyc2lvblxuICAvLyAob3RoZXIgZmFjdG9ycyBsaWtlIHdpZHRoIHZhbHVlcyB3aWxsIGJlIGNvbnNpZGVyZWQgbGF0ZXIgaW4gdGhpcyBmdW5jdGlvbiBhbnl3YXkpXG5cbiAgdmFyIGlzRGlzcGxheWVkID0gZnVuY3Rpb24gaXNEaXNwbGF5ZWQoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5wc3R5bGUoJ2Rpc3BsYXknKS52YWx1ZSAhPT0gJ25vbmUnO1xuICB9O1xuXG4gIHZhciBkaXNwbGF5ZWQgPSAhc3R5bGVFbmFibGVkIHx8IGlzRGlzcGxheWVkKGVsZSkgLy8gbXVzdCB0YWtlIGludG8gYWNjb3VudCBjb25uZWN0ZWQgbm9kZXMgYi9jIG9mIGltcGxpY2l0IGVkZ2UgaGlkaW5nIG9uIGRpc3BsYXk6bm9uZSBub2RlXG4gICYmICghaXNFZGdlIHx8IGlzRGlzcGxheWVkKGVsZS5zb3VyY2UoKSkgJiYgaXNEaXNwbGF5ZWQoZWxlLnRhcmdldCgpKSk7XG5cbiAgaWYgKGRpc3BsYXllZCkge1xuICAgIC8vIGRpc3BsYXllZCBzdWZmaWNlcywgc2luY2Ugd2Ugd2lsbCBmaW5kIHplcm8gYXJlYSBlbGVzIGFueXdheVxuICAgIHZhciBvdmVybGF5T3BhY2l0eSA9IDA7XG4gICAgdmFyIG92ZXJsYXlQYWRkaW5nID0gMDtcblxuICAgIGlmIChzdHlsZUVuYWJsZWQgJiYgb3B0aW9ucy5pbmNsdWRlT3ZlcmxheXMpIHtcbiAgICAgIG92ZXJsYXlPcGFjaXR5ID0gZWxlLnBzdHlsZSgnb3ZlcmxheS1vcGFjaXR5JykudmFsdWU7XG5cbiAgICAgIGlmIChvdmVybGF5T3BhY2l0eSAhPT0gMCkge1xuICAgICAgICBvdmVybGF5UGFkZGluZyA9IGVsZS5wc3R5bGUoJ292ZXJsYXktcGFkZGluZycpLnZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmRlcmxheU9wYWNpdHkgPSAwO1xuICAgIHZhciB1bmRlcmxheVBhZGRpbmcgPSAwO1xuXG4gICAgaWYgKHN0eWxlRW5hYmxlZCAmJiBvcHRpb25zLmluY2x1ZGVVbmRlcmxheXMpIHtcbiAgICAgIHVuZGVybGF5T3BhY2l0eSA9IGVsZS5wc3R5bGUoJ3VuZGVybGF5LW9wYWNpdHknKS52YWx1ZTtcblxuICAgICAgaWYgKHVuZGVybGF5T3BhY2l0eSAhPT0gMCkge1xuICAgICAgICB1bmRlcmxheVBhZGRpbmcgPSBlbGUucHN0eWxlKCd1bmRlcmxheS1wYWRkaW5nJykudmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHBhZGRpbmcgPSBNYXRoLm1heChvdmVybGF5UGFkZGluZywgdW5kZXJsYXlQYWRkaW5nKTtcbiAgICB2YXIgdyA9IDA7XG4gICAgdmFyIHdIYWxmID0gMDtcblxuICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgIHcgPSBlbGUucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG4gICAgICB3SGFsZiA9IHcgLyAyO1xuICAgIH1cblxuICAgIGlmIChpc05vZGUgJiYgb3B0aW9ucy5pbmNsdWRlTm9kZXMpIHtcbiAgICAgIHZhciBwb3MgPSBlbGUucG9zaXRpb24oKTtcbiAgICAgIHggPSBwb3MueDtcbiAgICAgIHkgPSBwb3MueTtcblxuICAgICAgdmFyIF93ID0gZWxlLm91dGVyV2lkdGgoKTtcblxuICAgICAgdmFyIGhhbGZXID0gX3cgLyAyO1xuICAgICAgdmFyIGggPSBlbGUub3V0ZXJIZWlnaHQoKTtcbiAgICAgIHZhciBoYWxmSCA9IGggLyAyOyAvLyBoYW5kbGUgbm9kZSBkaW1lbnNpb25zXG4gICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgIGV4MSA9IHggLSBoYWxmVztcbiAgICAgIGV4MiA9IHggKyBoYWxmVztcbiAgICAgIGV5MSA9IHkgLSBoYWxmSDtcbiAgICAgIGV5MiA9IHkgKyBoYWxmSDtcbiAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSwgZXkxLCBleDIsIGV5Mik7XG4gICAgfSBlbHNlIGlmIChpc0VkZ2UgJiYgb3B0aW9ucy5pbmNsdWRlRWRnZXMpIHtcbiAgICAgIGlmIChzdHlsZUVuYWJsZWQgJiYgIWhlYWRsZXNzKSB7XG4gICAgICAgIHZhciBjdXJ2ZVN0eWxlID0gZWxlLnBzdHlsZSgnY3VydmUtc3R5bGUnKS5zdHJWYWx1ZTsgLy8gaGFuZGxlIGVkZ2UgZGltZW5zaW9ucyAocm91Z2ggYm94IGVzdGltYXRlKVxuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgZXgxID0gTWF0aC5taW4ocnN0eWxlLnNyY1gsIHJzdHlsZS5taWRYLCByc3R5bGUudGd0WCk7XG4gICAgICAgIGV4MiA9IE1hdGgubWF4KHJzdHlsZS5zcmNYLCByc3R5bGUubWlkWCwgcnN0eWxlLnRndFgpO1xuICAgICAgICBleTEgPSBNYXRoLm1pbihyc3R5bGUuc3JjWSwgcnN0eWxlLm1pZFksIHJzdHlsZS50Z3RZKTtcbiAgICAgICAgZXkyID0gTWF0aC5tYXgocnN0eWxlLnNyY1ksIHJzdHlsZS5taWRZLCByc3R5bGUudGd0WSk7IC8vIHRha2UgaW50byBhY2NvdW50IGVkZ2Ugd2lkdGhcblxuICAgICAgICBleDEgLT0gd0hhbGY7XG4gICAgICAgIGV4MiArPSB3SGFsZjtcbiAgICAgICAgZXkxIC09IHdIYWxmO1xuICAgICAgICBleTIgKz0gd0hhbGY7XG4gICAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSwgZXkxLCBleDIsIGV5Mik7IC8vIHByZWNpc2UgZWRnZXNcbiAgICAgICAgLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgIGlmIChjdXJ2ZVN0eWxlID09PSAnaGF5c3RhY2snKSB7XG4gICAgICAgICAgdmFyIGhwdHMgPSByc3R5bGUuaGF5c3RhY2tQdHM7XG5cbiAgICAgICAgICBpZiAoaHB0cyAmJiBocHRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgZXgxID0gaHB0c1swXS54O1xuICAgICAgICAgICAgZXkxID0gaHB0c1swXS55O1xuICAgICAgICAgICAgZXgyID0gaHB0c1sxXS54O1xuICAgICAgICAgICAgZXkyID0gaHB0c1sxXS55O1xuXG4gICAgICAgICAgICBpZiAoZXgxID4gZXgyKSB7XG4gICAgICAgICAgICAgIHZhciB0ZW1wID0gZXgxO1xuICAgICAgICAgICAgICBleDEgPSBleDI7XG4gICAgICAgICAgICAgIGV4MiA9IHRlbXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleTEgPiBleTIpIHtcbiAgICAgICAgICAgICAgdmFyIF90ZW1wID0gZXkxO1xuICAgICAgICAgICAgICBleTEgPSBleTI7XG4gICAgICAgICAgICAgIGV5MiA9IF90ZW1wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBleDEgLSB3SGFsZiwgZXkxIC0gd0hhbGYsIGV4MiArIHdIYWxmLCBleTIgKyB3SGFsZik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGN1cnZlU3R5bGUgPT09ICdiZXppZXInIHx8IGN1cnZlU3R5bGUgPT09ICd1bmJ1bmRsZWQtYmV6aWVyJyB8fCBjdXJ2ZVN0eWxlID09PSAnc2VnbWVudHMnIHx8IGN1cnZlU3R5bGUgPT09ICd0YXhpJykge1xuICAgICAgICAgIHZhciBwdHM7XG5cbiAgICAgICAgICBzd2l0Y2ggKGN1cnZlU3R5bGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Jlemllcic6XG4gICAgICAgICAgICBjYXNlICd1bmJ1bmRsZWQtYmV6aWVyJzpcbiAgICAgICAgICAgICAgcHRzID0gcnN0eWxlLmJlemllclB0cztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3NlZ21lbnRzJzpcbiAgICAgICAgICAgIGNhc2UgJ3RheGknOlxuICAgICAgICAgICAgICBwdHMgPSByc3R5bGUubGluZVB0cztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHB0cyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHB0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICB2YXIgcHQgPSBwdHNbal07XG4gICAgICAgICAgICAgIGV4MSA9IHB0LnggLSB3SGFsZjtcbiAgICAgICAgICAgICAgZXgyID0gcHQueCArIHdIYWxmO1xuICAgICAgICAgICAgICBleTEgPSBwdC55IC0gd0hhbGY7XG4gICAgICAgICAgICAgIGV5MiA9IHB0LnkgKyB3SGFsZjtcbiAgICAgICAgICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgZXgxLCBleTEsIGV4MiwgZXkyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gYmV6aWVyLWxpa2Ugb3Igc2VnbWVudC1saWtlIGVkZ2VcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaGVhZGxlc3Mgb3Igc3R5bGUgZGlzYWJsZWRcbiAgICAgICAgLy8gZmFsbGJhY2sgb24gc291cmNlIGFuZCB0YXJnZXQgcG9zaXRpb25zXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICB2YXIgbjEgPSBlbGUuc291cmNlKCk7XG4gICAgICAgIHZhciBuMXBvcyA9IG4xLnBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBuMiA9IGVsZS50YXJnZXQoKTtcbiAgICAgICAgdmFyIG4ycG9zID0gbjIucG9zaXRpb24oKTtcbiAgICAgICAgZXgxID0gbjFwb3MueDtcbiAgICAgICAgZXgyID0gbjJwb3MueDtcbiAgICAgICAgZXkxID0gbjFwb3MueTtcbiAgICAgICAgZXkyID0gbjJwb3MueTtcblxuICAgICAgICBpZiAoZXgxID4gZXgyKSB7XG4gICAgICAgICAgdmFyIF90ZW1wMiA9IGV4MTtcbiAgICAgICAgICBleDEgPSBleDI7XG4gICAgICAgICAgZXgyID0gX3RlbXAyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV5MSA+IGV5Mikge1xuICAgICAgICAgIHZhciBfdGVtcDMgPSBleTE7XG4gICAgICAgICAgZXkxID0gZXkyO1xuICAgICAgICAgIGV5MiA9IF90ZW1wMztcbiAgICAgICAgfSAvLyB0YWtlIGludG8gYWNjb3VudCBlZGdlIHdpZHRoXG5cblxuICAgICAgICBleDEgLT0gd0hhbGY7XG4gICAgICAgIGV4MiArPSB3SGFsZjtcbiAgICAgICAgZXkxIC09IHdIYWxmO1xuICAgICAgICBleTIgKz0gd0hhbGY7XG4gICAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSwgZXkxLCBleDIsIGV5Mik7XG4gICAgICB9IC8vIGhlYWRsZXNzIG9yIHN0eWxlIGRpc2FibGVkXG5cbiAgICB9IC8vIGVkZ2VzXG4gICAgLy8gaGFuZGxlIGVkZ2UgYXJyb3cgc2l6ZVxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4gICAgaWYgKHN0eWxlRW5hYmxlZCAmJiBvcHRpb25zLmluY2x1ZGVFZGdlcyAmJiBpc0VkZ2UpIHtcbiAgICAgIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyhib3VuZHMsIGVsZSwgJ21pZC1zb3VyY2UnKTtcbiAgICAgIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyhib3VuZHMsIGVsZSwgJ21pZC10YXJnZXQnKTtcbiAgICAgIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyhib3VuZHMsIGVsZSwgJ3NvdXJjZScpO1xuICAgICAgdXBkYXRlQm91bmRzRnJvbUFycm93KGJvdW5kcywgZWxlLCAndGFyZ2V0Jyk7XG4gICAgfSAvLyBnaG9zdFxuICAgIC8vLy8vLy8vXG5cblxuICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgIHZhciBnaG9zdCA9IGVsZS5wc3R5bGUoJ2dob3N0JykudmFsdWUgPT09ICd5ZXMnO1xuXG4gICAgICBpZiAoZ2hvc3QpIHtcbiAgICAgICAgdmFyIGd4ID0gZWxlLnBzdHlsZSgnZ2hvc3Qtb2Zmc2V0LXgnKS5wZlZhbHVlO1xuICAgICAgICB2YXIgZ3kgPSBlbGUucHN0eWxlKCdnaG9zdC1vZmZzZXQteScpLnBmVmFsdWU7XG4gICAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGJvdW5kcy54MSArIGd4LCBib3VuZHMueTEgKyBneSwgYm91bmRzLngyICsgZ3gsIGJvdW5kcy55MiArIGd5KTtcbiAgICAgIH1cbiAgICB9IC8vIGFsd2F5cyBzdG9yZSB0aGUgYm9keSBib3VuZHMgc2VwYXJhdGVseSBmcm9tIHRoZSBsYWJlbHNcblxuXG4gICAgdmFyIGJiQm9keSA9IF9wLmJvZHlCb3VuZHMgPSBfcC5ib2R5Qm91bmRzIHx8IHt9O1xuICAgIGFzc2lnbkJvdW5kaW5nQm94KGJiQm9keSwgYm91bmRzKTtcbiAgICBleHBhbmRCb3VuZGluZ0JveFNpZGVzKGJiQm9keSwgbWFudWFsRXhwYW5zaW9uKTtcbiAgICBleHBhbmRCb3VuZGluZ0JveChiYkJvZHksIDEpOyAvLyBleHBhbmQgdG8gd29yayBhcm91bmQgYnJvd3NlciBkaW1lbnNpb24gaW5hY2N1cmFjaWVzXG4gICAgLy8gb3ZlcmxheVxuICAgIC8vLy8vLy8vLy9cblxuICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgIGV4MSA9IGJvdW5kcy54MTtcbiAgICAgIGV4MiA9IGJvdW5kcy54MjtcbiAgICAgIGV5MSA9IGJvdW5kcy55MTtcbiAgICAgIGV5MiA9IGJvdW5kcy55MjtcbiAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSAtIHBhZGRpbmcsIGV5MSAtIHBhZGRpbmcsIGV4MiArIHBhZGRpbmcsIGV5MiArIHBhZGRpbmcpO1xuICAgIH0gLy8gYWx3YXlzIHN0b3JlIHRoZSBib2R5IGJvdW5kcyBzZXBhcmF0ZWx5IGZyb20gdGhlIGxhYmVsc1xuXG5cbiAgICB2YXIgYmJPdmVybGF5ID0gX3Aub3ZlcmxheUJvdW5kcyA9IF9wLm92ZXJsYXlCb3VuZHMgfHwge307XG4gICAgYXNzaWduQm91bmRpbmdCb3goYmJPdmVybGF5LCBib3VuZHMpO1xuICAgIGV4cGFuZEJvdW5kaW5nQm94U2lkZXMoYmJPdmVybGF5LCBtYW51YWxFeHBhbnNpb24pO1xuICAgIGV4cGFuZEJvdW5kaW5nQm94KGJiT3ZlcmxheSwgMSk7IC8vIGV4cGFuZCB0byB3b3JrIGFyb3VuZCBicm93c2VyIGRpbWVuc2lvbiBpbmFjY3VyYWNpZXNcbiAgICAvLyBoYW5kbGUgbGFiZWwgZGltZW5zaW9uc1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICB2YXIgYmJMYWJlbHMgPSBfcC5sYWJlbEJvdW5kcyA9IF9wLmxhYmVsQm91bmRzIHx8IHt9O1xuXG4gICAgaWYgKGJiTGFiZWxzLmFsbCAhPSBudWxsKSB7XG4gICAgICBjbGVhckJvdW5kaW5nQm94KGJiTGFiZWxzLmFsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJiTGFiZWxzLmFsbCA9IG1ha2VCb3VuZGluZ0JveCgpO1xuICAgIH1cblxuICAgIGlmIChzdHlsZUVuYWJsZWQgJiYgb3B0aW9ucy5pbmNsdWRlTGFiZWxzKSB7XG4gICAgICBpZiAob3B0aW9ucy5pbmNsdWRlTWFpbkxhYmVscykge1xuICAgICAgICB1cGRhdGVCb3VuZHNGcm9tTGFiZWwoYm91bmRzLCBlbGUsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNFZGdlKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVTb3VyY2VMYWJlbHMpIHtcbiAgICAgICAgICB1cGRhdGVCb3VuZHNGcm9tTGFiZWwoYm91bmRzLCBlbGUsICdzb3VyY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVUYXJnZXRMYWJlbHMpIHtcbiAgICAgICAgICB1cGRhdGVCb3VuZHNGcm9tTGFiZWwoYm91bmRzLCBlbGUsICd0YXJnZXQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gc3R5bGUgZW5hYmxlZCBmb3IgbGFiZWxzXG5cbiAgfSAvLyBpZiBkaXNwbGF5ZWRcblxuXG4gIGJvdW5kcy54MSA9IG5vbmluZihib3VuZHMueDEpO1xuICBib3VuZHMueTEgPSBub25pbmYoYm91bmRzLnkxKTtcbiAgYm91bmRzLngyID0gbm9uaW5mKGJvdW5kcy54Mik7XG4gIGJvdW5kcy55MiA9IG5vbmluZihib3VuZHMueTIpO1xuICBib3VuZHMudyA9IG5vbmluZihib3VuZHMueDIgLSBib3VuZHMueDEpO1xuICBib3VuZHMuaCA9IG5vbmluZihib3VuZHMueTIgLSBib3VuZHMueTEpO1xuXG4gIGlmIChib3VuZHMudyA+IDAgJiYgYm91bmRzLmggPiAwICYmIGRpc3BsYXllZCkge1xuICAgIGV4cGFuZEJvdW5kaW5nQm94U2lkZXMoYm91bmRzLCBtYW51YWxFeHBhbnNpb24pOyAvLyBleHBhbmQgYm91bmRzIGJ5IDEgYmVjYXVzZSBhbnRpYWxpYXNpbmcgY2FuIGluY3JlYXNlIHRoZSB2aXN1YWwvZWZmZWN0aXZlIHNpemUgYnkgMSBvbiBhbGwgc2lkZXNcblxuICAgIGV4cGFuZEJvdW5kaW5nQm94KGJvdW5kcywgMSk7XG4gIH1cblxuICByZXR1cm4gYm91bmRzO1xufTtcblxudmFyIGdldEtleSA9IGZ1bmN0aW9uIGdldEtleShvcHRzKSB7XG4gIHZhciBpID0gMDtcblxuICB2YXIgdGYgPSBmdW5jdGlvbiB0Zih2YWwpIHtcbiAgICByZXR1cm4gKHZhbCA/IDEgOiAwKSA8PCBpKys7XG4gIH07XG5cbiAgdmFyIGtleSA9IDA7XG4gIGtleSArPSB0ZihvcHRzLmluY3VkZU5vZGVzKTtcbiAga2V5ICs9IHRmKG9wdHMuaW5jbHVkZUVkZ2VzKTtcbiAga2V5ICs9IHRmKG9wdHMuaW5jbHVkZUxhYmVscyk7XG4gIGtleSArPSB0ZihvcHRzLmluY2x1ZGVNYWluTGFiZWxzKTtcbiAga2V5ICs9IHRmKG9wdHMuaW5jbHVkZVNvdXJjZUxhYmVscyk7XG4gIGtleSArPSB0ZihvcHRzLmluY2x1ZGVUYXJnZXRMYWJlbHMpO1xuICBrZXkgKz0gdGYob3B0cy5pbmNsdWRlT3ZlcmxheXMpO1xuICByZXR1cm4ga2V5O1xufTtcblxudmFyIGdldEJvdW5kaW5nQm94UG9zS2V5ID0gZnVuY3Rpb24gZ2V0Qm91bmRpbmdCb3hQb3NLZXkoZWxlKSB7XG4gIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICB2YXIgcDEgPSBlbGUuc291cmNlKCkucG9zaXRpb24oKTtcbiAgICB2YXIgcDIgPSBlbGUudGFyZ2V0KCkucG9zaXRpb24oKTtcblxuICAgIHZhciByID0gZnVuY3Rpb24gcih4KSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCh4KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGhhc2hJbnRzQXJyYXkoW3IocDEueCksIHIocDEueSksIHIocDIueCksIHIocDIueSldKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxudmFyIGNhY2hlZEJvdW5kaW5nQm94SW1wbCA9IGZ1bmN0aW9uIGNhY2hlZEJvdW5kaW5nQm94SW1wbChlbGUsIG9wdHMpIHtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgYmI7XG4gIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gIHZhciBrZXkgPSBvcHRzID09IG51bGwgPyBkZWZCYk9wdHNLZXkgOiBnZXRLZXkob3B0cyk7XG4gIHZhciB1c2luZ0RlZk9wdHMgPSBrZXkgPT09IGRlZkJiT3B0c0tleTtcbiAgdmFyIGN1cnJQb3NLZXkgPSBnZXRCb3VuZGluZ0JveFBvc0tleShlbGUpO1xuICB2YXIgaXNQb3NLZXlTYW1lID0gX3AuYmJDYWNoZVBvc0tleSA9PT0gY3VyclBvc0tleTtcbiAgdmFyIHVzZUNhY2hlID0gb3B0cy51c2VDYWNoZSAmJiBpc1Bvc0tleVNhbWU7XG5cbiAgdmFyIGlzRGlydHkgPSBmdW5jdGlvbiBpc0RpcnR5KGVsZSkge1xuICAgIHJldHVybiBlbGUuX3ByaXZhdGUuYmJDYWNoZSA9PSBudWxsIHx8IGVsZS5fcHJpdmF0ZS5zdHlsZURpcnR5O1xuICB9O1xuXG4gIHZhciBuZWVkUmVjYWxjID0gIXVzZUNhY2hlIHx8IGlzRGlydHkoZWxlKSB8fCBpc0VkZ2UgJiYgaXNEaXJ0eShlbGUuc291cmNlKCkpIHx8IGlzRGlydHkoZWxlLnRhcmdldCgpKTtcblxuICBpZiAobmVlZFJlY2FsYykge1xuICAgIGlmICghaXNQb3NLZXlTYW1lKSB7XG4gICAgICBlbGUucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKHVzZUNhY2hlKTtcbiAgICB9XG5cbiAgICBiYiA9IGJvdW5kaW5nQm94SW1wbChlbGUsIGRlZkJiT3B0cyk7XG4gICAgX3AuYmJDYWNoZSA9IGJiO1xuICAgIF9wLmJiQ2FjaGVQb3NLZXkgPSBjdXJyUG9zS2V5O1xuICB9IGVsc2Uge1xuICAgIGJiID0gX3AuYmJDYWNoZTtcbiAgfSAvLyBub3QgdXNpbmcgZGVmIG9wdHMgPT4gbmVlZCB0byBidWlsZCB1cCBiYiBmcm9tIGNvbWJpbmF0aW9uIG9mIHN1YiBiYnNcblxuXG4gIGlmICghdXNpbmdEZWZPcHRzKSB7XG4gICAgdmFyIGlzTm9kZSA9IGVsZS5pc05vZGUoKTtcbiAgICBiYiA9IG1ha2VCb3VuZGluZ0JveCgpO1xuXG4gICAgaWYgKG9wdHMuaW5jbHVkZU5vZGVzICYmIGlzTm9kZSB8fCBvcHRzLmluY2x1ZGVFZGdlcyAmJiAhaXNOb2RlKSB7XG4gICAgICBpZiAob3B0cy5pbmNsdWRlT3ZlcmxheXMpIHtcbiAgICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChiYiwgX3Aub3ZlcmxheUJvdW5kcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJiLCBfcC5ib2R5Qm91bmRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0cy5pbmNsdWRlTGFiZWxzKSB7XG4gICAgICBpZiAob3B0cy5pbmNsdWRlTWFpbkxhYmVscyAmJiAoIWlzRWRnZSB8fCBvcHRzLmluY2x1ZGVTb3VyY2VMYWJlbHMgJiYgb3B0cy5pbmNsdWRlVGFyZ2V0TGFiZWxzKSkge1xuICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJiLCBfcC5sYWJlbEJvdW5kcy5hbGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9wdHMuaW5jbHVkZU1haW5MYWJlbHMpIHtcbiAgICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJiLCBfcC5sYWJlbEJvdW5kcy5tYWluUm90KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRzLmluY2x1ZGVTb3VyY2VMYWJlbHMpIHtcbiAgICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJiLCBfcC5sYWJlbEJvdW5kcy5zb3VyY2VSb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdHMuaW5jbHVkZVRhcmdldExhYmVscykge1xuICAgICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21Cb3goYmIsIF9wLmxhYmVsQm91bmRzLnRhcmdldFJvdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgICBiYi5oID0gYmIueTIgLSBiYi55MTtcbiAgfVxuXG4gIHJldHVybiBiYjtcbn07XG5cbnZhciBkZWZCYk9wdHMgPSB7XG4gIGluY2x1ZGVOb2RlczogdHJ1ZSxcbiAgaW5jbHVkZUVkZ2VzOiB0cnVlLFxuICBpbmNsdWRlTGFiZWxzOiB0cnVlLFxuICBpbmNsdWRlTWFpbkxhYmVsczogdHJ1ZSxcbiAgaW5jbHVkZVNvdXJjZUxhYmVsczogdHJ1ZSxcbiAgaW5jbHVkZVRhcmdldExhYmVsczogdHJ1ZSxcbiAgaW5jbHVkZU92ZXJsYXlzOiB0cnVlLFxuICBpbmNsdWRlVW5kZXJsYXlzOiB0cnVlLFxuICB1c2VDYWNoZTogdHJ1ZVxufTtcbnZhciBkZWZCYk9wdHNLZXkgPSBnZXRLZXkoZGVmQmJPcHRzKTtcbnZhciBmaWxsZWRCYk9wdHMgPSBkZWZhdWx0cyRnKGRlZkJiT3B0cyk7XG5cbmVsZXNmbiRiLmJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIGJvdW5kczsgLy8gdGhlIG1haW4gdXNlY2FzZSBpcyBlbGUuYm91bmRpbmdCb3goKSBmb3IgYSBzaW5nbGUgZWxlbWVudCB3aXRoIG5vL2RlZiBvcHRpb25zXG4gIC8vIHNwZWNpZmllZCBzLnQuIHRoZSBjYWNoZSBpcyB1c2VkLCBzbyBjaGVjayBmb3IgdGhpcyBjYXNlIHRvIG1ha2UgaXQgZmFzdGVyIGJ5XG4gIC8vIGF2b2lkaW5nIHRoZSBvdmVyaGVhZCBvZiB0aGUgcmVzdCBvZiB0aGUgZnVuY3Rpb25cblxuICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpc1swXS5fcHJpdmF0ZS5iYkNhY2hlICE9IG51bGwgJiYgIXRoaXNbMF0uX3ByaXZhdGUuc3R5bGVEaXJ0eSAmJiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMudXNlQ2FjaGUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnVzZUNhY2hlID09PSB0cnVlKSkge1xuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZCYk9wdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBmaWxsZWRCYk9wdHMob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgYm91bmRzID0gY2FjaGVkQm91bmRpbmdCb3hJbXBsKHRoaXNbMF0sIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIGJvdW5kcyA9IG1ha2VCb3VuZGluZ0JveCgpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZkJiT3B0cztcbiAgICB2YXIgb3B0cyA9IGZpbGxlZEJiT3B0cyhvcHRpb25zKTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIGN5ID0gZWxlcy5jeSgpO1xuICAgIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5zdHlsZUVuYWJsZWQoKTtcblxuICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgICB2YXIgY3VyclBvc0tleSA9IGdldEJvdW5kaW5nQm94UG9zS2V5KGVsZSk7XG4gICAgICAgIHZhciBpc1Bvc0tleVNhbWUgPSBfcC5iYkNhY2hlUG9zS2V5ID09PSBjdXJyUG9zS2V5O1xuICAgICAgICB2YXIgdXNlQ2FjaGUgPSBvcHRzLnVzZUNhY2hlICYmIGlzUG9zS2V5U2FtZSAmJiAhX3Auc3R5bGVEaXJ0eTtcbiAgICAgICAgZWxlLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSh1c2VDYWNoZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVDb21wb3VuZEJvdW5kcyghb3B0aW9ucy51c2VDYWNoZSk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfZWxlID0gZWxlc1tfaV07XG4gICAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJvdW5kcywgY2FjaGVkQm91bmRpbmdCb3hJbXBsKF9lbGUsIG9wdHMpKTtcbiAgICB9XG4gIH1cblxuICBib3VuZHMueDEgPSBub25pbmYoYm91bmRzLngxKTtcbiAgYm91bmRzLnkxID0gbm9uaW5mKGJvdW5kcy55MSk7XG4gIGJvdW5kcy54MiA9IG5vbmluZihib3VuZHMueDIpO1xuICBib3VuZHMueTIgPSBub25pbmYoYm91bmRzLnkyKTtcbiAgYm91bmRzLncgPSBub25pbmYoYm91bmRzLngyIC0gYm91bmRzLngxKTtcbiAgYm91bmRzLmggPSBub25pbmYoYm91bmRzLnkyIC0gYm91bmRzLnkxKTtcbiAgcmV0dXJuIGJvdW5kcztcbn07XG5cbmVsZXNmbiRiLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9wID0gdGhpc1tpXS5fcHJpdmF0ZTtcbiAgICBfcC5iYkNhY2hlID0gbnVsbDtcbiAgICBfcC5iYkNhY2hlUG9zS2V5ID0gbnVsbDtcbiAgICBfcC5ib2R5Qm91bmRzID0gbnVsbDtcbiAgICBfcC5vdmVybGF5Qm91bmRzID0gbnVsbDtcbiAgICBfcC5sYWJlbEJvdW5kcy5hbGwgPSBudWxsO1xuICAgIF9wLmxhYmVsQm91bmRzLnNvdXJjZSA9IG51bGw7XG4gICAgX3AubGFiZWxCb3VuZHMudGFyZ2V0ID0gbnVsbDtcbiAgICBfcC5sYWJlbEJvdW5kcy5tYWluID0gbnVsbDtcbiAgICBfcC5sYWJlbEJvdW5kcy5zb3VyY2VSb3QgPSBudWxsO1xuICAgIF9wLmxhYmVsQm91bmRzLnRhcmdldFJvdCA9IG51bGw7XG4gICAgX3AubGFiZWxCb3VuZHMubWFpblJvdCA9IG51bGw7XG4gICAgX3AuYXJyb3dCb3VuZHMuc291cmNlID0gbnVsbDtcbiAgICBfcC5hcnJvd0JvdW5kcy50YXJnZXQgPSBudWxsO1xuICAgIF9wLmFycm93Qm91bmRzWydtaWQtc291cmNlJ10gPSBudWxsO1xuICAgIF9wLmFycm93Qm91bmRzWydtaWQtdGFyZ2V0J10gPSBudWxsO1xuICB9XG5cbiAgdGhpcy5lbWl0QW5kTm90aWZ5KCdib3VuZHMnKTtcbiAgcmV0dXJuIHRoaXM7XG59OyAvLyBwcml2YXRlIGhlbHBlciB0byBnZXQgYm91bmRpbmcgYm94IGZvciBjdXN0b20gbm9kZSBwb3NpdGlvbnNcbi8vIC0gZ29vZCBmb3IgcGVyZiBpbiBjZXJ0YWluIGNhc2VzIGJ1dCBjdXJyZW50bHkgcmVxdWlyZXMgZGlydHlpbmcgdGhlIHJlbmRlcmVkIHN0eWxlXG4vLyAtIHdvdWxkIGJlIGJldHRlciB0byBub3QgbW9kaWZ5IHRoZSBub2RlcyBidXQgdGhlIG5vZGVzIGFyZSByZWFkIGRpcmVjdGx5IGV2ZXJ5d2hlcmUgaW4gdGhlIHJlbmRlcmVyLi4uXG4vLyAtIHRyeSB0byB1c2UgZm9yIG9ubHkgdGhpbmdzIGxpa2UgZGlzY3JldGUgbGF5b3V0cyB3aGVyZSB0aGUgbm9kZSBwb3NpdGlvbiB3b3VsZCBjaGFuZ2UgYW55d2F5XG5cblxuZWxlc2ZuJGIuYm91bmRpbmdCb3hBdCA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gIHZhciBwYXJlbnRzID0gY3kuY29sbGVjdGlvbigpO1xuXG4gIGlmIChoYXNDb21wb3VuZE5vZGVzKSB7XG4gICAgcGFyZW50cyA9IG5vZGVzLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuaXNQYXJlbnQoKTtcbiAgICB9KTtcbiAgICBub2RlcyA9IG5vZGVzLm5vdChwYXJlbnRzKTtcbiAgfVxuXG4gIGlmIChwbGFpbk9iamVjdChmbikpIHtcbiAgICB2YXIgb2JqID0gZm47XG5cbiAgICBmbiA9IGZ1bmN0aW9uIGZuKCkge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHN0b3JlT2xkUG9zID0gZnVuY3Rpb24gc3RvcmVPbGRQb3Mobm9kZSwgaSkge1xuICAgIHJldHVybiBub2RlLl9wcml2YXRlLmJiQXRPbGRQb3MgPSBmbihub2RlLCBpKTtcbiAgfTtcblxuICB2YXIgZ2V0T2xkUG9zID0gZnVuY3Rpb24gZ2V0T2xkUG9zKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5fcHJpdmF0ZS5iYkF0T2xkUG9zO1xuICB9O1xuXG4gIGN5LnN0YXJ0QmF0Y2goKTtcbiAgbm9kZXMuZm9yRWFjaChzdG9yZU9sZFBvcykuc2lsZW50UG9zaXRpb25zKGZuKTtcblxuICBpZiAoaGFzQ29tcG91bmROb2Rlcykge1xuICAgIHBhcmVudHMuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG4gICAgcGFyZW50cy5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUoKTtcbiAgICBwYXJlbnRzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKHRydWUpOyAvLyBmb3JjZSB1cGRhdGUgYi9jIHdlJ3JlIGluc2lkZSBhIGJhdGNoIGN5Y2xlXG4gIH1cblxuICB2YXIgYmIgPSBjb3B5Qm91bmRpbmdCb3godGhpcy5ib3VuZGluZ0JveCh7XG4gICAgdXNlQ2FjaGU6IGZhbHNlXG4gIH0pKTtcbiAgbm9kZXMuc2lsZW50UG9zaXRpb25zKGdldE9sZFBvcyk7XG5cbiAgaWYgKGhhc0NvbXBvdW5kTm9kZXMpIHtcbiAgICBwYXJlbnRzLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuICAgIHBhcmVudHMuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7XG4gICAgcGFyZW50cy51cGRhdGVDb21wb3VuZEJvdW5kcyh0cnVlKTsgLy8gZm9yY2UgdXBkYXRlIGIvYyB3ZSdyZSBpbnNpZGUgYSBiYXRjaCBjeWNsZVxuICB9XG5cbiAgY3kuZW5kQmF0Y2goKTtcbiAgcmV0dXJuIGJiO1xufTtcblxuZm4kMy5ib3VuZGluZ2JveCA9IGZuJDMuYmIgPSBmbiQzLmJvdW5kaW5nQm94O1xuZm4kMy5yZW5kZXJlZEJvdW5kaW5nYm94ID0gZm4kMy5yZW5kZXJlZEJvdW5kaW5nQm94O1xudmFyIGJvdW5kcyA9IGVsZXNmbiRiO1xuXG52YXIgZm4kMiwgZWxlc2ZuJGE7XG5mbiQyID0gZWxlc2ZuJGEgPSB7fTtcblxudmFyIGRlZmluZURpbUZucyA9IGZ1bmN0aW9uIGRlZmluZURpbUZucyhvcHRzKSB7XG4gIG9wdHMudXBwZXJjYXNlTmFtZSA9IGNhcGl0YWxpemUob3B0cy5uYW1lKTtcbiAgb3B0cy5hdXRvTmFtZSA9ICdhdXRvJyArIG9wdHMudXBwZXJjYXNlTmFtZTtcbiAgb3B0cy5sYWJlbE5hbWUgPSAnbGFiZWwnICsgb3B0cy51cHBlcmNhc2VOYW1lO1xuICBvcHRzLm91dGVyTmFtZSA9ICdvdXRlcicgKyBvcHRzLnVwcGVyY2FzZU5hbWU7XG4gIG9wdHMudXBwZXJjYXNlT3V0ZXJOYW1lID0gY2FwaXRhbGl6ZShvcHRzLm91dGVyTmFtZSk7XG5cbiAgZm4kMltvcHRzLm5hbWVdID0gZnVuY3Rpb24gZGltSW1wbCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIGN5ID0gX3AuY3k7XG4gICAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnN0eWxlRW5hYmxlZDtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgICAgaWYgKGVsZS5pc1BhcmVudCgpKSB7XG4gICAgICAgICAgZWxlLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICAgICAgcmV0dXJuIF9wW29wdHMuYXV0b05hbWVdIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZCA9IGVsZS5wc3R5bGUob3B0cy5uYW1lKTtcblxuICAgICAgICBzd2l0Y2ggKGQuc3RyVmFsdWUpIHtcbiAgICAgICAgICBjYXNlICdsYWJlbCc6XG4gICAgICAgICAgICBlbGUucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKCk7XG4gICAgICAgICAgICByZXR1cm4gX3AucnN0eWxlW29wdHMubGFiZWxOYW1lXSB8fCAwO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBkLnBmVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmbiQyWydvdXRlcicgKyBvcHRzLnVwcGVyY2FzZU5hbWVdID0gZnVuY3Rpb24gb3V0ZXJEaW1JbXBsKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgY3kgPSBfcC5jeTtcbiAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgaWYgKHN0eWxlRW5hYmxlZCkge1xuICAgICAgICB2YXIgZGltID0gZWxlW29wdHMubmFtZV0oKTtcbiAgICAgICAgdmFyIGJvcmRlciA9IGVsZS5wc3R5bGUoJ2JvcmRlci13aWR0aCcpLnBmVmFsdWU7IC8vIG4uYi4gMS8yIGVhY2ggc2lkZVxuXG4gICAgICAgIHZhciBwYWRkaW5nID0gMiAqIGVsZS5wYWRkaW5nKCk7XG4gICAgICAgIHJldHVybiBkaW0gKyBib3JkZXIgKyBwYWRkaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZuJDJbJ3JlbmRlcmVkJyArIG9wdHMudXBwZXJjYXNlTmFtZV0gPSBmdW5jdGlvbiByZW5kZXJlZERpbUltcGwoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICB2YXIgZCA9IGVsZVtvcHRzLm5hbWVdKCk7XG4gICAgICByZXR1cm4gZCAqIHRoaXMuY3koKS56b29tKCk7XG4gICAgfVxuICB9O1xuXG4gIGZuJDJbJ3JlbmRlcmVkJyArIG9wdHMudXBwZXJjYXNlT3V0ZXJOYW1lXSA9IGZ1bmN0aW9uIHJlbmRlcmVkT3V0ZXJEaW1JbXBsKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgdmFyIG9kID0gZWxlW29wdHMub3V0ZXJOYW1lXSgpO1xuICAgICAgcmV0dXJuIG9kICogdGhpcy5jeSgpLnpvb20oKTtcbiAgICB9XG4gIH07XG59O1xuXG5kZWZpbmVEaW1GbnMoe1xuICBuYW1lOiAnd2lkdGgnXG59KTtcbmRlZmluZURpbUZucyh7XG4gIG5hbWU6ICdoZWlnaHQnXG59KTtcblxuZWxlc2ZuJGEucGFkZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcblxuICBpZiAoZWxlLmlzUGFyZW50KCkpIHtcbiAgICBlbGUudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcblxuICAgIGlmIChfcC5hdXRvUGFkZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gX3AuYXV0b1BhZGRpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbGUucHN0eWxlKCdwYWRkaW5nJykucGZWYWx1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsZS5wc3R5bGUoJ3BhZGRpbmcnKS5wZlZhbHVlO1xuICB9XG59O1xuXG5lbGVzZm4kYS5wYWRkZWRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbGUgPSB0aGlzWzBdO1xuICByZXR1cm4gZWxlLmhlaWdodCgpICsgMiAqIGVsZS5wYWRkaW5nKCk7XG59O1xuXG5lbGVzZm4kYS5wYWRkZWRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIHJldHVybiBlbGUud2lkdGgoKSArIDIgKiBlbGUucGFkZGluZygpO1xufTtcblxudmFyIHdpZHRoSGVpZ2h0ID0gZWxlc2ZuJGE7XG5cbnZhciBpZkVkZ2UgPSBmdW5jdGlvbiBpZkVkZ2UoZWxlLCBnZXRWYWx1ZSkge1xuICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgcmV0dXJuIGdldFZhbHVlKGVsZSk7XG4gIH1cbn07XG5cbnZhciBpZkVkZ2VSZW5kZXJlZFBvc2l0aW9uID0gZnVuY3Rpb24gaWZFZGdlUmVuZGVyZWRQb3NpdGlvbihlbGUsIGdldFBvaW50KSB7XG4gIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICB2YXIgY3kgPSBlbGUuY3koKTtcbiAgICByZXR1cm4gbW9kZWxUb1JlbmRlcmVkUG9zaXRpb24oZ2V0UG9pbnQoZWxlKSwgY3kuem9vbSgpLCBjeS5wYW4oKSk7XG4gIH1cbn07XG5cbnZhciBpZkVkZ2VSZW5kZXJlZFBvc2l0aW9ucyA9IGZ1bmN0aW9uIGlmRWRnZVJlbmRlcmVkUG9zaXRpb25zKGVsZSwgZ2V0UG9pbnRzKSB7XG4gIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICB2YXIgY3kgPSBlbGUuY3koKTtcbiAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgcmV0dXJuIGdldFBvaW50cyhlbGUpLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIG1vZGVsVG9SZW5kZXJlZFBvc2l0aW9uKHAsIHpvb20sIHBhbik7XG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBjb250cm9sUG9pbnRzID0gZnVuY3Rpb24gY29udHJvbFBvaW50cyhlbGUpIHtcbiAgcmV0dXJuIGVsZS5yZW5kZXJlcigpLmdldENvbnRyb2xQb2ludHMoZWxlKTtcbn07XG5cbnZhciBzZWdtZW50UG9pbnRzID0gZnVuY3Rpb24gc2VnbWVudFBvaW50cyhlbGUpIHtcbiAgcmV0dXJuIGVsZS5yZW5kZXJlcigpLmdldFNlZ21lbnRQb2ludHMoZWxlKTtcbn07XG5cbnZhciBzb3VyY2VFbmRwb2ludCA9IGZ1bmN0aW9uIHNvdXJjZUVuZHBvaW50KGVsZSkge1xuICByZXR1cm4gZWxlLnJlbmRlcmVyKCkuZ2V0U291cmNlRW5kcG9pbnQoZWxlKTtcbn07XG5cbnZhciB0YXJnZXRFbmRwb2ludCA9IGZ1bmN0aW9uIHRhcmdldEVuZHBvaW50KGVsZSkge1xuICByZXR1cm4gZWxlLnJlbmRlcmVyKCkuZ2V0VGFyZ2V0RW5kcG9pbnQoZWxlKTtcbn07XG5cbnZhciBtaWRwb2ludCA9IGZ1bmN0aW9uIG1pZHBvaW50KGVsZSkge1xuICByZXR1cm4gZWxlLnJlbmRlcmVyKCkuZ2V0RWRnZU1pZHBvaW50KGVsZSk7XG59O1xuXG52YXIgcHRzID0ge1xuICBjb250cm9sUG9pbnRzOiB7XG4gICAgZ2V0OiBjb250cm9sUG9pbnRzLFxuICAgIG11bHQ6IHRydWVcbiAgfSxcbiAgc2VnbWVudFBvaW50czoge1xuICAgIGdldDogc2VnbWVudFBvaW50cyxcbiAgICBtdWx0OiB0cnVlXG4gIH0sXG4gIHNvdXJjZUVuZHBvaW50OiB7XG4gICAgZ2V0OiBzb3VyY2VFbmRwb2ludFxuICB9LFxuICB0YXJnZXRFbmRwb2ludDoge1xuICAgIGdldDogdGFyZ2V0RW5kcG9pbnRcbiAgfSxcbiAgbWlkcG9pbnQ6IHtcbiAgICBnZXQ6IG1pZHBvaW50XG4gIH1cbn07XG5cbnZhciByZW5kZXJlZE5hbWUgPSBmdW5jdGlvbiByZW5kZXJlZE5hbWUobmFtZSkge1xuICByZXR1cm4gJ3JlbmRlcmVkJyArIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyKDEpO1xufTtcblxudmFyIGVkZ2VQb2ludHMgPSBPYmplY3Qua2V5cyhwdHMpLnJlZHVjZShmdW5jdGlvbiAob2JqLCBuYW1lKSB7XG4gIHZhciBzcGVjID0gcHRzW25hbWVdO1xuICB2YXIgck5hbWUgPSByZW5kZXJlZE5hbWUobmFtZSk7XG5cbiAgb2JqW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpZkVkZ2UodGhpcywgc3BlYy5nZXQpO1xuICB9O1xuXG4gIGlmIChzcGVjLm11bHQpIHtcbiAgICBvYmpbck5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGlmRWRnZVJlbmRlcmVkUG9zaXRpb25zKHRoaXMsIHNwZWMuZ2V0KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG9ialtyTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaWZFZGdlUmVuZGVyZWRQb3NpdGlvbih0aGlzLCBzcGVjLmdldCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59LCB7fSk7XG5cbnZhciBkaW1lbnNpb25zID0gZXh0ZW5kKHt9LCBwb3NpdGlvbiwgYm91bmRzLCB3aWR0aEhlaWdodCwgZWRnZVBvaW50cyk7XG5cbi8qIVxuRXZlbnQgb2JqZWN0IGJhc2VkIG9uIGpRdWVyeSBldmVudHMsIE1JVCBsaWNlbnNlXG5cbmh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlL1xuaHR0cHM6Ly90bGRybGVnYWwuY29tL2xpY2Vuc2UvbWl0LWxpY2Vuc2Vcbmh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvbWFzdGVyL3NyYy9ldmVudC5qc1xuKi9cbnZhciBFdmVudCA9IGZ1bmN0aW9uIEV2ZW50KHNyYywgcHJvcHMpIHtcbiAgdGhpcy5yZWN5Y2xlKHNyYywgcHJvcHMpO1xufTtcblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcbiAgcmV0dXJuIHRydWU7XG59IC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxuXG5cbkV2ZW50LnByb3RvdHlwZSA9IHtcbiAgaW5zdGFuY2VTdHJpbmc6IGZ1bmN0aW9uIGluc3RhbmNlU3RyaW5nKCkge1xuICAgIHJldHVybiAnZXZlbnQnO1xuICB9LFxuICByZWN5Y2xlOiBmdW5jdGlvbiByZWN5Y2xlKHNyYywgcHJvcHMpIHtcbiAgICB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuRmFsc2U7XG5cbiAgICBpZiAoc3JjICE9IG51bGwgJiYgc3JjLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAvLyBCcm93c2VyIEV2ZW50IG9iamVjdFxuICAgICAgdGhpcy50eXBlID0gc3JjLnR5cGU7IC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG4gICAgICAvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblxuICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCA/IHJldHVyblRydWUgOiByZXR1cm5GYWxzZTtcbiAgICB9IGVsc2UgaWYgKHNyYyAhPSBudWxsICYmIHNyYy50eXBlKSB7XG4gICAgICAvLyBQbGFpbiBvYmplY3QgY29udGFpbmluZyBhbGwgZXZlbnQgZGV0YWlsc1xuICAgICAgcHJvcHMgPSBzcmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEV2ZW50IHN0cmluZ1xuICAgICAgdGhpcy50eXBlID0gc3JjO1xuICAgIH0gLy8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3RcblxuXG4gICAgaWYgKHByb3BzICE9IG51bGwpIHtcbiAgICAgIC8vIG1vcmUgZWZmaWNpZW50IHRvIG1hbnVhbGx5IGNvcHkgZmllbGRzIHdlIHVzZVxuICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gcHJvcHMub3JpZ2luYWxFdmVudDtcbiAgICAgIHRoaXMudHlwZSA9IHByb3BzLnR5cGUgIT0gbnVsbCA/IHByb3BzLnR5cGUgOiB0aGlzLnR5cGU7XG4gICAgICB0aGlzLmN5ID0gcHJvcHMuY3k7XG4gICAgICB0aGlzLnRhcmdldCA9IHByb3BzLnRhcmdldDtcbiAgICAgIHRoaXMucG9zaXRpb24gPSBwcm9wcy5wb3NpdGlvbjtcbiAgICAgIHRoaXMucmVuZGVyZWRQb3NpdGlvbiA9IHByb3BzLnJlbmRlcmVkUG9zaXRpb247XG4gICAgICB0aGlzLm5hbWVzcGFjZSA9IHByb3BzLm5hbWVzcGFjZTtcbiAgICAgIHRoaXMubGF5b3V0ID0gcHJvcHMubGF5b3V0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmN5ICE9IG51bGwgJiYgdGhpcy5wb3NpdGlvbiAhPSBudWxsICYmIHRoaXMucmVuZGVyZWRQb3NpdGlvbiA9PSBudWxsKSB7XG4gICAgICAvLyBjcmVhdGUgYSByZW5kZXJlZCBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgcGFzc2VkIHBvc2l0aW9uXG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgIHZhciB6b29tID0gdGhpcy5jeS56b29tKCk7XG4gICAgICB2YXIgcGFuID0gdGhpcy5jeS5wYW4oKTtcbiAgICAgIHRoaXMucmVuZGVyZWRQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogcG9zLnggKiB6b29tICsgcGFuLngsXG4gICAgICAgIHk6IHBvcy55ICogem9vbSArIHBhbi55XG4gICAgICB9O1xuICAgIH0gLy8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblxuXG4gICAgdGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICB9LFxuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG4gICAgaWYgKCFlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBpZiBwcmV2ZW50RGVmYXVsdCBleGlzdHMgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuXG5cbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSxcbiAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG4gICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cbiAgICBpZiAoIWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGlmIHN0b3BQcm9wYWdhdGlvbiBleGlzdHMgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuXG5cbiAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9LFxuICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIHtcbiAgICB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgICB0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9LFxuICBpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuICBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG4gIGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZVxufTtcblxudmFyIGV2ZW50UmVnZXggPSAvXihbXi5dKykoXFwuKD86W14uXSspKT8kLzsgLy8gcmVnZXggZm9yIG1hdGNoaW5nIGV2ZW50IHN0cmluZ3MgKGUuZy4gXCJjbGljay5uYW1lc3BhY2VcIilcblxudmFyIHVuaXZlcnNhbE5hbWVzcGFjZSA9ICcuKic7IC8vIG1hdGNoZXMgYXMgaWYgbm8gbmFtZXNwYWNlIHNwZWNpZmllZCBhbmQgcHJldmVudHMgdXNlcnMgZnJvbSB1bmJpbmRpbmcgYWNjaWRlbnRhbGx5XG5cbnZhciBkZWZhdWx0cyQ4ID0ge1xuICBxdWFsaWZpZXJDb21wYXJlOiBmdW5jdGlvbiBxdWFsaWZpZXJDb21wYXJlKHExLCBxMikge1xuICAgIHJldHVybiBxMSA9PT0gcTI7XG4gIH0sXG4gIGV2ZW50TWF0Y2hlczogZnVuY3Rpb25cbiAgICAvKmNvbnRleHQsIGxpc3RlbmVyLCBldmVudE9iaiovXG4gIGV2ZW50TWF0Y2hlcygpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgYWRkRXZlbnRGaWVsZHM6IGZ1bmN0aW9uXG4gICAgLypjb250ZXh0LCBldnQqL1xuICBhZGRFdmVudEZpZWxkcygpIHt9LFxuICBjYWxsYmFja0NvbnRleHQ6IGZ1bmN0aW9uIGNhbGxiYWNrQ29udGV4dChjb250ZXh0XG4gIC8qLCBsaXN0ZW5lciwgZXZlbnRPYmoqL1xuICApIHtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfSxcbiAgYmVmb3JlRW1pdDogZnVuY3Rpb25cbiAgICAvKiBjb250ZXh0LCBsaXN0ZW5lciwgZXZlbnRPYmogKi9cbiAgYmVmb3JlRW1pdCgpIHt9LFxuICBhZnRlckVtaXQ6IGZ1bmN0aW9uXG4gICAgLyogY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqICovXG4gIGFmdGVyRW1pdCgpIHt9LFxuICBidWJibGU6IGZ1bmN0aW9uXG4gICAgLypjb250ZXh0Ki9cbiAgYnViYmxlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgcGFyZW50OiBmdW5jdGlvblxuICAgIC8qY29udGV4dCovXG4gIHBhcmVudCgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgY29udGV4dDogbnVsbFxufTtcbnZhciBkZWZhdWx0c0tleXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0cyQ4KTtcbnZhciBlbXB0eU9wdHMgPSB7fTtcblxuZnVuY3Rpb24gRW1pdHRlcigpIHtcbiAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGVtcHR5T3B0cztcbiAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcblxuICAvLyBtaWNyby1vcHRpbWlzYXRpb24gdnMgT2JqZWN0LmFzc2lnbigpIC0tIHJlZHVjZXMgRWxlbWVudCBpbnN0YW50aWF0aW9uIHRpbWVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWZhdWx0c0tleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gZGVmYXVsdHNLZXlzW2ldO1xuICAgIHRoaXNba2V5XSA9IG9wdHNba2V5XSB8fCBkZWZhdWx0cyQ4W2tleV07XG4gIH1cblxuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0IHx8IHRoaXMuY29udGV4dDtcbiAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgdGhpcy5lbWl0dGluZyA9IDA7XG59XG5cbnZhciBwID0gRW1pdHRlci5wcm90b3R5cGU7XG5cbnZhciBmb3JFYWNoRXZlbnQgPSBmdW5jdGlvbiBmb3JFYWNoRXZlbnQoc2VsZiwgaGFuZGxlciwgZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mLCBjb25mT3ZlcnJpZGVzKSB7XG4gIGlmIChmbiQ2KHF1YWxpZmllcikpIHtcbiAgICBjYWxsYmFjayA9IHF1YWxpZmllcjtcbiAgICBxdWFsaWZpZXIgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNvbmZPdmVycmlkZXMpIHtcbiAgICBpZiAoY29uZiA9PSBudWxsKSB7XG4gICAgICBjb25mID0gY29uZk92ZXJyaWRlcztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZiA9IGV4dGVuZCh7fSwgY29uZiwgY29uZk92ZXJyaWRlcyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGV2ZW50TGlzdCA9IGFycmF5KGV2ZW50cykgPyBldmVudHMgOiBldmVudHMuc3BsaXQoL1xccysvKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50TGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBldnQgPSBldmVudExpc3RbaV07XG5cbiAgICBpZiAoZW1wdHlTdHJpbmcoZXZ0KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoID0gZXZ0Lm1hdGNoKGV2ZW50UmVnZXgpOyAvLyB0eXBlWy5uYW1lc3BhY2VdXG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciB0eXBlID0gbWF0Y2hbMV07XG4gICAgICB2YXIgbmFtZXNwYWNlID0gbWF0Y2hbMl0gPyBtYXRjaFsyXSA6IG51bGw7XG4gICAgICB2YXIgcmV0ID0gaGFuZGxlcihzZWxmLCBldnQsIHR5cGUsIG5hbWVzcGFjZSwgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZik7XG5cbiAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBhbGxvdyBleGl0aW5nIGVhcmx5XG5cbiAgICB9XG4gIH1cbn07XG5cbnZhciBtYWtlRXZlbnRPYmogPSBmdW5jdGlvbiBtYWtlRXZlbnRPYmooc2VsZiwgb2JqKSB7XG4gIHNlbGYuYWRkRXZlbnRGaWVsZHMoc2VsZi5jb250ZXh0LCBvYmopO1xuICByZXR1cm4gbmV3IEV2ZW50KG9iai50eXBlLCBvYmopO1xufTtcblxudmFyIGZvckVhY2hFdmVudE9iaiA9IGZ1bmN0aW9uIGZvckVhY2hFdmVudE9iaihzZWxmLCBoYW5kbGVyLCBldmVudHMpIHtcbiAgaWYgKGV2ZW50KGV2ZW50cykpIHtcbiAgICBoYW5kbGVyKHNlbGYsIGV2ZW50cyk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKHBsYWluT2JqZWN0KGV2ZW50cykpIHtcbiAgICBoYW5kbGVyKHNlbGYsIG1ha2VFdmVudE9iaihzZWxmLCBldmVudHMpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZXZlbnRMaXN0ID0gYXJyYXkoZXZlbnRzKSA/IGV2ZW50cyA6IGV2ZW50cy5zcGxpdCgvXFxzKy8pO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGV2dCA9IGV2ZW50TGlzdFtpXTtcblxuICAgIGlmIChlbXB0eVN0cmluZyhldnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2ggPSBldnQubWF0Y2goZXZlbnRSZWdleCk7IC8vIHR5cGVbLm5hbWVzcGFjZV1cblxuICAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIHR5cGUgPSBtYXRjaFsxXTtcbiAgICAgIHZhciBuYW1lc3BhY2UgPSBtYXRjaFsyXSA/IG1hdGNoWzJdIDogbnVsbDtcbiAgICAgIHZhciBldmVudE9iaiA9IG1ha2VFdmVudE9iaihzZWxmLCB7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgICAgICB0YXJnZXQ6IHNlbGYuY29udGV4dFxuICAgICAgfSk7XG4gICAgICBoYW5kbGVyKHNlbGYsIGV2ZW50T2JqKTtcbiAgICB9XG4gIH1cbn07XG5cbnAub24gPSBwLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZiwgY29uZk92ZXJyaWRlcykge1xuICBmb3JFYWNoRXZlbnQodGhpcywgZnVuY3Rpb24gKHNlbGYsIGV2ZW50LCB0eXBlLCBuYW1lc3BhY2UsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYpIHtcbiAgICBpZiAoZm4kNihjYWxsYmFjaykpIHtcbiAgICAgIHNlbGYubGlzdGVuZXJzLnB1c2goe1xuICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgIC8vIGZ1bGwgZXZlbnQgc3RyaW5nXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgLy8gY2FsbGJhY2sgdG8gcnVuXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIC8vIHRoZSBldmVudCB0eXBlIChlLmcuICdjbGljaycpXG4gICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgICAgICAvLyB0aGUgZXZlbnQgbmFtZXNwYWNlIChlLmcuIFwiLmZvb1wiKVxuICAgICAgICBxdWFsaWZpZXI6IHF1YWxpZmllcixcbiAgICAgICAgLy8gYSByZXN0cmljdGlvbiBvbiB3aGV0aGVyIHRvIG1hdGNoIHRoaXMgZW1pdHRlclxuICAgICAgICBjb25mOiBjb25mIC8vIGFkZGl0aW9uYWwgY29uZmlndXJhdGlvblxuXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZiwgY29uZk92ZXJyaWRlcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucC5vbmUgPSBmdW5jdGlvbiAoZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mKSB7XG4gIHJldHVybiB0aGlzLm9uKGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZiwge1xuICAgIG9uZTogdHJ1ZVxuICB9KTtcbn07XG5cbnAucmVtb3ZlTGlzdGVuZXIgPSBwLm9mZiA9IGZ1bmN0aW9uIChldmVudHMsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAodGhpcy5lbWl0dGluZyAhPT0gMCkge1xuICAgIHRoaXMubGlzdGVuZXJzID0gY29weUFycmF5KHRoaXMubGlzdGVuZXJzKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycztcblxuICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuICAgIGZvckVhY2hFdmVudChfdGhpcywgZnVuY3Rpb24gKHNlbGYsIGV2ZW50LCB0eXBlLCBuYW1lc3BhY2UsIHF1YWxpZmllciwgY2FsbGJhY2tcbiAgICAvKiwgY29uZiovXG4gICAgKSB7XG4gICAgICBpZiAoKGxpc3RlbmVyLnR5cGUgPT09IHR5cGUgfHwgZXZlbnRzID09PSAnKicpICYmICghbmFtZXNwYWNlICYmIGxpc3RlbmVyLm5hbWVzcGFjZSAhPT0gJy4qJyB8fCBsaXN0ZW5lci5uYW1lc3BhY2UgPT09IG5hbWVzcGFjZSkgJiYgKCFxdWFsaWZpZXIgfHwgc2VsZi5xdWFsaWZpZXJDb21wYXJlKGxpc3RlbmVyLnF1YWxpZmllciwgcXVhbGlmaWVyKSkgJiYgKCFjYWxsYmFjayB8fCBsaXN0ZW5lci5jYWxsYmFjayA9PT0gY2FsbGJhY2spKSB7XG4gICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCBldmVudHMsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYpO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBfbG9vcChpKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxucC5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlbW92ZUxpc3RlbmVyKCcqJyk7XG59O1xuXG5wLmVtaXQgPSBwLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnRzLCBleHRyYVBhcmFtcywgbWFudWFsQ2FsbGJhY2spIHtcbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzO1xuICB2YXIgbnVtTGlzdGVuZXJzQmVmb3JlRW1pdCA9IGxpc3RlbmVycy5sZW5ndGg7XG4gIHRoaXMuZW1pdHRpbmcrKztcblxuICBpZiAoIWFycmF5KGV4dHJhUGFyYW1zKSkge1xuICAgIGV4dHJhUGFyYW1zID0gW2V4dHJhUGFyYW1zXTtcbiAgfVxuXG4gIGZvckVhY2hFdmVudE9iaih0aGlzLCBmdW5jdGlvbiAoc2VsZiwgZXZlbnRPYmopIHtcbiAgICBpZiAobWFudWFsQ2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgbGlzdGVuZXJzID0gW3tcbiAgICAgICAgZXZlbnQ6IGV2ZW50T2JqLmV2ZW50LFxuICAgICAgICB0eXBlOiBldmVudE9iai50eXBlLFxuICAgICAgICBuYW1lc3BhY2U6IGV2ZW50T2JqLm5hbWVzcGFjZSxcbiAgICAgICAgY2FsbGJhY2s6IG1hbnVhbENhbGxiYWNrXG4gICAgICB9XTtcbiAgICAgIG51bUxpc3RlbmVyc0JlZm9yZUVtaXQgPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIH1cblxuICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoaSkge1xuICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuXG4gICAgICBpZiAobGlzdGVuZXIudHlwZSA9PT0gZXZlbnRPYmoudHlwZSAmJiAoIWxpc3RlbmVyLm5hbWVzcGFjZSB8fCBsaXN0ZW5lci5uYW1lc3BhY2UgPT09IGV2ZW50T2JqLm5hbWVzcGFjZSB8fCBsaXN0ZW5lci5uYW1lc3BhY2UgPT09IHVuaXZlcnNhbE5hbWVzcGFjZSkgJiYgc2VsZi5ldmVudE1hdGNoZXMoc2VsZi5jb250ZXh0LCBsaXN0ZW5lciwgZXZlbnRPYmopKSB7XG4gICAgICAgIHZhciBhcmdzID0gW2V2ZW50T2JqXTtcblxuICAgICAgICBpZiAoZXh0cmFQYXJhbXMgIT0gbnVsbCkge1xuICAgICAgICAgIHB1c2goYXJncywgZXh0cmFQYXJhbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5iZWZvcmVFbWl0KHNlbGYuY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqKTtcblxuICAgICAgICBpZiAobGlzdGVuZXIuY29uZiAmJiBsaXN0ZW5lci5jb25mLm9uZSkge1xuICAgICAgICAgIHNlbGYubGlzdGVuZXJzID0gc2VsZi5saXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICByZXR1cm4gbCAhPT0gbGlzdGVuZXI7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29udGV4dCA9IHNlbGYuY2FsbGJhY2tDb250ZXh0KHNlbGYuY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqKTtcbiAgICAgICAgdmFyIHJldCA9IGxpc3RlbmVyLmNhbGxiYWNrLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBzZWxmLmFmdGVyRW1pdChzZWxmLmNvbnRleHQsIGxpc3RlbmVyLCBldmVudE9iaik7XG5cbiAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBldmVudE9iai5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBldmVudE9iai5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGlmIGxpc3RlbmVyIG1hdGNoZXNcblxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUxpc3RlbmVyc0JlZm9yZUVtaXQ7IGkrKykge1xuICAgICAgX2xvb3AyKGkpO1xuICAgIH0gLy8gZm9yIGxpc3RlbmVyXG5cblxuICAgIGlmIChzZWxmLmJ1YmJsZShzZWxmLmNvbnRleHQpICYmICFldmVudE9iai5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICBzZWxmLnBhcmVudChzZWxmLmNvbnRleHQpLmVtaXQoZXZlbnRPYmosIGV4dHJhUGFyYW1zKTtcbiAgICB9XG4gIH0sIGV2ZW50cyk7XG4gIHRoaXMuZW1pdHRpbmctLTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG52YXIgZW1pdHRlck9wdGlvbnMkMSA9IHtcbiAgcXVhbGlmaWVyQ29tcGFyZTogZnVuY3Rpb24gcXVhbGlmaWVyQ29tcGFyZShzZWxlY3RvcjEsIHNlbGVjdG9yMikge1xuICAgIGlmIChzZWxlY3RvcjEgPT0gbnVsbCB8fCBzZWxlY3RvcjIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHNlbGVjdG9yMSA9PSBudWxsICYmIHNlbGVjdG9yMiA9PSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2VsZWN0b3IxLnNhbWVUZXh0KHNlbGVjdG9yMik7XG4gICAgfVxuICB9LFxuICBldmVudE1hdGNoZXM6IGZ1bmN0aW9uIGV2ZW50TWF0Y2hlcyhlbGUsIGxpc3RlbmVyLCBldmVudE9iaikge1xuICAgIHZhciBzZWxlY3RvciA9IGxpc3RlbmVyLnF1YWxpZmllcjtcblxuICAgIGlmIChzZWxlY3RvciAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlICE9PSBldmVudE9iai50YXJnZXQgJiYgZWxlbWVudChldmVudE9iai50YXJnZXQpICYmIHNlbGVjdG9yLm1hdGNoZXMoZXZlbnRPYmoudGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgYWRkRXZlbnRGaWVsZHM6IGZ1bmN0aW9uIGFkZEV2ZW50RmllbGRzKGVsZSwgZXZ0KSB7XG4gICAgZXZ0LmN5ID0gZWxlLmN5KCk7XG4gICAgZXZ0LnRhcmdldCA9IGVsZTtcbiAgfSxcbiAgY2FsbGJhY2tDb250ZXh0OiBmdW5jdGlvbiBjYWxsYmFja0NvbnRleHQoZWxlLCBsaXN0ZW5lciwgZXZlbnRPYmopIHtcbiAgICByZXR1cm4gbGlzdGVuZXIucXVhbGlmaWVyICE9IG51bGwgPyBldmVudE9iai50YXJnZXQgOiBlbGU7XG4gIH0sXG4gIGJlZm9yZUVtaXQ6IGZ1bmN0aW9uIGJlZm9yZUVtaXQoY29udGV4dCwgbGlzdGVuZXJcbiAgLyosIGV2ZW50T2JqKi9cbiAgKSB7XG4gICAgaWYgKGxpc3RlbmVyLmNvbmYgJiYgbGlzdGVuZXIuY29uZi5vbmNlKSB7XG4gICAgICBsaXN0ZW5lci5jb25mLm9uY2VDb2xsZWN0aW9uLnJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyLmV2ZW50LCBsaXN0ZW5lci5xdWFsaWZpZXIsIGxpc3RlbmVyLmNhbGxiYWNrKTtcbiAgICB9XG4gIH0sXG4gIGJ1YmJsZTogZnVuY3Rpb24gYnViYmxlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChlbGUpIHtcbiAgICByZXR1cm4gZWxlLmlzQ2hpbGQoKSA/IGVsZS5wYXJlbnQoKSA6IGVsZS5jeSgpO1xuICB9XG59O1xuXG52YXIgYXJnU2VsZWN0b3IkMSA9IGZ1bmN0aW9uIGFyZ1NlbGVjdG9yKGFyZykge1xuICBpZiAoc3RyaW5nKGFyZykpIHtcbiAgICByZXR1cm4gbmV3IFNlbGVjdG9yKGFyZyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfVxufTtcblxudmFyIGVsZXNmbiQ5ID0ge1xuICBjcmVhdGVFbWl0dGVyOiBmdW5jdGlvbiBjcmVhdGVFbWl0dGVyKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG5cbiAgICAgIGlmICghX3AuZW1pdHRlcikge1xuICAgICAgICBfcC5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoZW1pdHRlck9wdGlvbnMkMSwgZWxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW1pdHRlcjogZnVuY3Rpb24gZW1pdHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbWl0dGVyO1xuICB9LFxuICBvbjogZnVuY3Rpb24gb24oZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICB2YXIgYXJnU2VsID0gYXJnU2VsZWN0b3IkMShzZWxlY3Rvcik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgZWxlLmVtaXR0ZXIoKS5vbihldmVudHMsIGFyZ1NlbCwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZW1vdmVMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICB2YXIgYXJnU2VsID0gYXJnU2VsZWN0b3IkMShzZWxlY3Rvcik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgZWxlLmVtaXR0ZXIoKS5yZW1vdmVMaXN0ZW5lcihldmVudHMsIGFyZ1NlbCwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZW1vdmVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgZWxlLmVtaXR0ZXIoKS5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgb25lOiBmdW5jdGlvbiBvbmUoZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICB2YXIgYXJnU2VsID0gYXJnU2VsZWN0b3IkMShzZWxlY3Rvcik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgZWxlLmVtaXR0ZXIoKS5vbmUoZXZlbnRzLCBhcmdTZWwsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgb25jZTogZnVuY3Rpb24gb25jZShldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgIHZhciBhcmdTZWwgPSBhcmdTZWxlY3RvciQxKHNlbGVjdG9yKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICBlbGUuZW1pdHRlcigpLm9uKGV2ZW50cywgYXJnU2VsLCBjYWxsYmFjaywge1xuICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICBvbmNlQ29sbGVjdGlvbjogdGhpc1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBlbWl0OiBmdW5jdGlvbiBlbWl0KGV2ZW50cywgZXh0cmFQYXJhbXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgZWxlLmVtaXR0ZXIoKS5lbWl0KGV2ZW50cywgZXh0cmFQYXJhbXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBlbWl0QW5kTm90aWZ5OiBmdW5jdGlvbiBlbWl0QW5kTm90aWZ5KGV2ZW50LCBleHRyYVBhcmFtcykge1xuICAgIC8vIGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gZW1wdHkgY29sbGVjdGlvbnMgZG9uJ3QgbmVlZCB0byBub3RpZnkgYW55dGhpbmdcbiAgICAvLyBub3RpZnkgcmVuZGVyZXJcblxuXG4gICAgdGhpcy5jeSgpLm5vdGlmeShldmVudCwgdGhpcyk7XG4gICAgdGhpcy5lbWl0KGV2ZW50LCBleHRyYVBhcmFtcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5kZWZpbmUuZXZlbnRBbGlhc2VzT24oZWxlc2ZuJDkpO1xuXG52YXIgZWxlc2ZuJDggPSB7XG4gIG5vZGVzOiBmdW5jdGlvbiBub2RlcyhzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpO1xuICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sXG4gIGVkZ2VzOiBmdW5jdGlvbiBlZGdlcyhzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzRWRnZSgpO1xuICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sXG4gIC8vIGludGVybmFsIGhlbHBlciB0byBnZXQgbm9kZXMgYW5kIGVkZ2VzIGFzIHNlcGFyYXRlIGNvbGxlY3Rpb25zIHdpdGggc2luZ2xlIGl0ZXJhdGlvbiBvdmVyIGVsZW1lbnRzXG4gIGJ5R3JvdXA6IGZ1bmN0aW9uIGJ5R3JvdXAoKSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5zcGF3bigpO1xuICAgIHZhciBlZGdlcyA9IHRoaXMuc3Bhd24oKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG5cbiAgICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgbm9kZXMucHVzaChlbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRnZXMucHVzaChlbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBub2Rlczogbm9kZXMsXG4gICAgICBlZGdlczogZWRnZXNcbiAgICB9O1xuICB9LFxuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihfZmlsdGVyLCB0aGlzQXJnKSB7XG4gICAgaWYgKF9maWx0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gY2hlY2sgdGhpcyBmaXJzdCBiL2MgaXQncyB0aGUgbW9zdCBjb21tb24vcGVyZm9ybWFudCBjYXNlXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2UgaWYgKHN0cmluZyhfZmlsdGVyKSB8fCBlbGVtZW50T3JDb2xsZWN0aW9uKF9maWx0ZXIpKSB7XG4gICAgICByZXR1cm4gbmV3IFNlbGVjdG9yKF9maWx0ZXIpLmZpbHRlcih0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGZuJDYoX2ZpbHRlcikpIHtcbiAgICAgIHZhciBmaWx0ZXJFbGVzID0gdGhpcy5zcGF3bigpO1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIHZhciBpbmNsdWRlID0gdGhpc0FyZyA/IF9maWx0ZXIuYXBwbHkodGhpc0FyZywgW2VsZSwgaSwgZWxlc10pIDogX2ZpbHRlcihlbGUsIGksIGVsZXMpO1xuXG4gICAgICAgIGlmIChpbmNsdWRlKSB7XG4gICAgICAgICAgZmlsdGVyRWxlcy5wdXNoKGVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZpbHRlckVsZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oKTsgLy8gaWYgbm90IGhhbmRsZWQgYnkgYWJvdmUsIGdpdmUgJ2VtIGFuIGVtcHR5IGNvbGxlY3Rpb25cbiAgfSxcbiAgbm90OiBmdW5jdGlvbiBub3QodG9SZW1vdmUpIHtcbiAgICBpZiAoIXRvUmVtb3ZlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0cmluZyh0b1JlbW92ZSkpIHtcbiAgICAgICAgdG9SZW1vdmUgPSB0aGlzLmZpbHRlcih0b1JlbW92ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuc3Bhd24oKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpc1tpXTtcbiAgICAgICAgdmFyIHJlbW92ZSA9IHRvUmVtb3ZlLmhhcyhlbGVtZW50KTtcblxuICAgICAgICBpZiAoIXJlbW92ZSkge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH1cbiAgfSxcbiAgYWJzb2x1dGVDb21wbGVtZW50OiBmdW5jdGlvbiBhYnNvbHV0ZUNvbXBsZW1lbnQoKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHJldHVybiBjeS5tdXRhYmxlRWxlbWVudHMoKS5ub3QodGhpcyk7XG4gIH0sXG4gIGludGVyc2VjdDogZnVuY3Rpb24gaW50ZXJzZWN0KG90aGVyKSB7XG4gICAgLy8gaWYgYSBzZWxlY3RvciBpcyBzcGVjaWZpZWQsIHRoZW4gZmlsdGVyIGJ5IGl0IGluc3RlYWRcbiAgICBpZiAoc3RyaW5nKG90aGVyKSkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gb3RoZXI7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50cyA9IHRoaXMuc3Bhd24oKTtcbiAgICB2YXIgY29sMSA9IHRoaXM7XG4gICAgdmFyIGNvbDIgPSBvdGhlcjtcbiAgICB2YXIgY29sMVNtYWxsZXIgPSB0aGlzLmxlbmd0aCA8IG90aGVyLmxlbmd0aDtcbiAgICB2YXIgY29sUyA9IGNvbDFTbWFsbGVyID8gY29sMSA6IGNvbDI7XG4gICAgdmFyIGNvbEwgPSBjb2wxU21hbGxlciA/IGNvbDIgOiBjb2wxO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xTLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gY29sU1tpXTtcblxuICAgICAgaWYgKGNvbEwuaGFzKGVsZSkpIHtcbiAgICAgICAgZWxlbWVudHMucHVzaChlbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50cztcbiAgfSxcbiAgeG9yOiBmdW5jdGlvbiB4b3Iob3RoZXIpIHtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgaWYgKHN0cmluZyhvdGhlcikpIHtcbiAgICAgIG90aGVyID0gY3kuJChvdGhlcik7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5zcGF3bigpO1xuICAgIHZhciBjb2wxID0gdGhpcztcbiAgICB2YXIgY29sMiA9IG90aGVyO1xuXG4gICAgdmFyIGFkZCA9IGZ1bmN0aW9uIGFkZChjb2wsIG90aGVyKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gY29sW2ldO1xuICAgICAgICB2YXIgaWQgPSBlbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgICAgdmFyIGluT3RoZXIgPSBvdGhlci5oYXNFbGVtZW50V2l0aElkKGlkKTtcblxuICAgICAgICBpZiAoIWluT3RoZXIpIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgYWRkKGNvbDEsIGNvbDIpO1xuICAgIGFkZChjb2wyLCBjb2wxKTtcbiAgICByZXR1cm4gZWxlbWVudHM7XG4gIH0sXG4gIGRpZmY6IGZ1bmN0aW9uIGRpZmYob3RoZXIpIHtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgaWYgKHN0cmluZyhvdGhlcikpIHtcbiAgICAgIG90aGVyID0gY3kuJChvdGhlcik7XG4gICAgfVxuXG4gICAgdmFyIGxlZnQgPSB0aGlzLnNwYXduKCk7XG4gICAgdmFyIHJpZ2h0ID0gdGhpcy5zcGF3bigpO1xuICAgIHZhciBib3RoID0gdGhpcy5zcGF3bigpO1xuICAgIHZhciBjb2wxID0gdGhpcztcbiAgICB2YXIgY29sMiA9IG90aGVyO1xuXG4gICAgdmFyIGFkZCA9IGZ1bmN0aW9uIGFkZChjb2wsIG90aGVyLCByZXRFbGVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gY29sW2ldO1xuICAgICAgICB2YXIgaWQgPSBlbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgICAgdmFyIGluT3RoZXIgPSBvdGhlci5oYXNFbGVtZW50V2l0aElkKGlkKTtcblxuICAgICAgICBpZiAoaW5PdGhlcikge1xuICAgICAgICAgIGJvdGgubWVyZ2UoZWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXRFbGVzLnB1c2goZWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBhZGQoY29sMSwgY29sMiwgbGVmdCk7XG4gICAgYWRkKGNvbDIsIGNvbDEsIHJpZ2h0KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogbGVmdCxcbiAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgIGJvdGg6IGJvdGhcbiAgICB9O1xuICB9LFxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh0b0FkZCkge1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICBpZiAoIXRvQWRkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoc3RyaW5nKHRvQWRkKSkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gdG9BZGQ7XG4gICAgICB0b0FkZCA9IGN5Lm11dGFibGVFbGVtZW50cygpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5zcGF3blNlbGYoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9BZGQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0b0FkZFtpXTtcbiAgICAgIHZhciBhZGQgPSAhdGhpcy5oYXMoZWxlKTtcblxuICAgICAgaWYgKGFkZCkge1xuICAgICAgICBlbGVtZW50cy5wdXNoKGVsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnRzO1xuICB9LFxuICAvLyBpbiBwbGFjZSBtZXJnZSBvbiBjYWxsaW5nIGNvbGxlY3Rpb25cbiAgbWVyZ2U6IGZ1bmN0aW9uIG1lcmdlKHRvQWRkKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgY3kgPSBfcC5jeTtcblxuICAgIGlmICghdG9BZGQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh0b0FkZCAmJiBzdHJpbmcodG9BZGQpKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSB0b0FkZDtcbiAgICAgIHRvQWRkID0gY3kubXV0YWJsZUVsZW1lbnRzKCkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICB2YXIgbWFwID0gX3AubWFwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b0FkZC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRvQWRkRWxlID0gdG9BZGRbaV07XG4gICAgICB2YXIgaWQgPSB0b0FkZEVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgdmFyIGFkZCA9ICFtYXAuaGFzKGlkKTtcblxuICAgICAgaWYgKGFkZCkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmxlbmd0aCsrO1xuICAgICAgICB0aGlzW2luZGV4XSA9IHRvQWRkRWxlO1xuICAgICAgICBtYXAuc2V0KGlkLCB7XG4gICAgICAgICAgZWxlOiB0b0FkZEVsZSxcbiAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHVubWVyZ2VBdDogZnVuY3Rpb24gdW5tZXJnZUF0KGkpIHtcbiAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciBtYXAgPSBfcC5tYXA7IC8vIHJlbW92ZSBlbGVcblxuICAgIHRoaXNbaV0gPSB1bmRlZmluZWQ7XG4gICAgbWFwW1wiZGVsZXRlXCJdKGlkKTtcbiAgICB2YXIgdW5tZXJnZWRMYXN0RWxlID0gaSA9PT0gdGhpcy5sZW5ndGggLSAxOyAvLyByZXBsYWNlIGVtcHR5IHNwb3Qgd2l0aCBsYXN0IGVsZSBpbiBjb2xsZWN0aW9uXG5cbiAgICBpZiAodGhpcy5sZW5ndGggPiAxICYmICF1bm1lcmdlZExhc3RFbGUpIHtcbiAgICAgIHZhciBsYXN0RWxlSSA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBsYXN0RWxlID0gdGhpc1tsYXN0RWxlSV07XG4gICAgICB2YXIgbGFzdEVsZUlkID0gbGFzdEVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgdGhpc1tsYXN0RWxlSV0gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzW2ldID0gbGFzdEVsZTtcbiAgICAgIG1hcC5zZXQobGFzdEVsZUlkLCB7XG4gICAgICAgIGVsZTogbGFzdEVsZSxcbiAgICAgICAgaW5kZXg6IGlcbiAgICAgIH0pO1xuICAgIH0gLy8gdGhlIGNvbGxlY3Rpb24gaXMgbm93IDEgZWxlIHNtYWxsZXJcblxuXG4gICAgdGhpcy5sZW5ndGgtLTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gcmVtb3ZlIHNpbmdsZSBlbGUgaW4gcGxhY2UgaW4gY2FsbGluZyBjb2xsZWN0aW9uXG4gIHVubWVyZ2VPbmU6IGZ1bmN0aW9uIHVubWVyZ2VPbmUoZWxlKSB7XG4gICAgZWxlID0gZWxlWzBdO1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgdmFyIG1hcCA9IF9wLm1hcDtcbiAgICB2YXIgZW50cnkgPSBtYXAuZ2V0KGlkKTtcblxuICAgIGlmICghZW50cnkpIHtcbiAgICAgIHJldHVybiB0aGlzOyAvLyBubyBuZWVkIHRvIHJlbW92ZVxuICAgIH1cblxuICAgIHZhciBpID0gZW50cnkuaW5kZXg7XG4gICAgdGhpcy51bm1lcmdlQXQoaSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIHJlbW92ZSBlbGVzIGluIHBsYWNlIG9uIGNhbGxpbmcgY29sbGVjdGlvblxuICB1bm1lcmdlOiBmdW5jdGlvbiB1bm1lcmdlKHRvUmVtb3ZlKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgIGlmICghdG9SZW1vdmUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh0b1JlbW92ZSAmJiBzdHJpbmcodG9SZW1vdmUpKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSB0b1JlbW92ZTtcbiAgICAgIHRvUmVtb3ZlID0gY3kubXV0YWJsZUVsZW1lbnRzKCkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvUmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnVubWVyZ2VPbmUodG9SZW1vdmVbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICB1bm1lcmdlQnk6IGZ1bmN0aW9uIHVubWVyZ2VCeSh0b1JtRm4pIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG5cbiAgICAgIGlmICh0b1JtRm4oZWxlKSkge1xuICAgICAgICB0aGlzLnVubWVyZ2VBdChpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgbWFwOiBmdW5jdGlvbiBtYXAobWFwRm4sIHRoaXNBcmcpIHtcbiAgICB2YXIgYXJyID0gW107XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciByZXQgPSB0aGlzQXJnID8gbWFwRm4uYXBwbHkodGhpc0FyZywgW2VsZSwgaSwgZWxlc10pIDogbWFwRm4oZWxlLCBpLCBlbGVzKTtcbiAgICAgIGFyci5wdXNoKHJldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjtcbiAgfSxcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoZm4sIGluaXRpYWxWYWx1ZSkge1xuICAgIHZhciB2YWwgPSBpbml0aWFsVmFsdWU7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWwgPSBmbih2YWwsIGVsZXNbaV0sIGksIGVsZXMpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG4gIH0sXG4gIG1heDogZnVuY3Rpb24gbWF4KHZhbEZuLCB0aGlzQXJnKSB7XG4gICAgdmFyIG1heCA9IC1JbmZpbml0eTtcbiAgICB2YXIgbWF4RWxlO1xuICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICB2YXIgdmFsID0gdGhpc0FyZyA/IHZhbEZuLmFwcGx5KHRoaXNBcmcsIFtlbGUsIGksIGVsZXNdKSA6IHZhbEZuKGVsZSwgaSwgZWxlcyk7XG5cbiAgICAgIGlmICh2YWwgPiBtYXgpIHtcbiAgICAgICAgbWF4ID0gdmFsO1xuICAgICAgICBtYXhFbGUgPSBlbGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBtYXgsXG4gICAgICBlbGU6IG1heEVsZVxuICAgIH07XG4gIH0sXG4gIG1pbjogZnVuY3Rpb24gbWluKHZhbEZuLCB0aGlzQXJnKSB7XG4gICAgdmFyIG1pbiA9IEluZmluaXR5O1xuICAgIHZhciBtaW5FbGU7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciB2YWwgPSB0aGlzQXJnID8gdmFsRm4uYXBwbHkodGhpc0FyZywgW2VsZSwgaSwgZWxlc10pIDogdmFsRm4oZWxlLCBpLCBlbGVzKTtcblxuICAgICAgaWYgKHZhbCA8IG1pbikge1xuICAgICAgICBtaW4gPSB2YWw7XG4gICAgICAgIG1pbkVsZSA9IGVsZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IG1pbixcbiAgICAgIGVsZTogbWluRWxlXG4gICAgfTtcbiAgfVxufTsgLy8gYWxpYXNlc1xuXG52YXIgZm4kMSA9IGVsZXNmbiQ4O1xuZm4kMVsndSddID0gZm4kMVsnfCddID0gZm4kMVsnKyddID0gZm4kMS51bmlvbiA9IGZuJDEub3IgPSBmbiQxLmFkZDtcbmZuJDFbJ1xcXFwnXSA9IGZuJDFbJyEnXSA9IGZuJDFbJy0nXSA9IGZuJDEuZGlmZmVyZW5jZSA9IGZuJDEucmVsYXRpdmVDb21wbGVtZW50ID0gZm4kMS5zdWJ0cmFjdCA9IGZuJDEubm90O1xuZm4kMVsnbiddID0gZm4kMVsnJiddID0gZm4kMVsnLiddID0gZm4kMS5hbmQgPSBmbiQxLmludGVyc2VjdGlvbiA9IGZuJDEuaW50ZXJzZWN0O1xuZm4kMVsnXiddID0gZm4kMVsnKCspJ10gPSBmbiQxWycoLSknXSA9IGZuJDEuc3ltbWV0cmljRGlmZmVyZW5jZSA9IGZuJDEuc3ltZGlmZiA9IGZuJDEueG9yO1xuZm4kMS5mbkZpbHRlciA9IGZuJDEuZmlsdGVyRm4gPSBmbiQxLnN0ZEZpbHRlciA9IGZuJDEuZmlsdGVyO1xuZm4kMS5jb21wbGVtZW50ID0gZm4kMS5hYnNjb21wID0gZm4kMS5hYnNvbHV0ZUNvbXBsZW1lbnQ7XG5cbnZhciBlbGVzZm4kNyA9IHtcbiAgaXNOb2RlOiBmdW5jdGlvbiBpc05vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXAoKSA9PT0gJ25vZGVzJztcbiAgfSxcbiAgaXNFZGdlOiBmdW5jdGlvbiBpc0VkZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXAoKSA9PT0gJ2VkZ2VzJztcbiAgfSxcbiAgaXNMb29wOiBmdW5jdGlvbiBpc0xvb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNFZGdlKCkgJiYgdGhpcy5zb3VyY2UoKVswXSA9PT0gdGhpcy50YXJnZXQoKVswXTtcbiAgfSxcbiAgaXNTaW1wbGU6IGZ1bmN0aW9uIGlzU2ltcGxlKCkge1xuICAgIHJldHVybiB0aGlzLmlzRWRnZSgpICYmIHRoaXMuc291cmNlKClbMF0gIT09IHRoaXMudGFyZ2V0KClbMF07XG4gIH0sXG4gIGdyb3VwOiBmdW5jdGlvbiBncm91cCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuZ3JvdXA7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqICBFbGVtZW50cyBhcmUgZHJhd24gaW4gYSBzcGVjaWZpYyBvcmRlciBiYXNlZCBvbiBjb21wb3VuZCBkZXB0aCAobG93IHRvIGhpZ2gpLCB0aGUgZWxlbWVudCB0eXBlIChub2RlcyBhYm92ZSBlZGdlcyksXG4gKiAgYW5kIHotaW5kZXggKGxvdyB0byBoaWdoKS4gIFRoZXNlIHN0eWxlcyBhZmZlY3QgaG93IHRoaXMgYXBwbGllczpcbiAqXG4gKiAgei1jb21wb3VuZC1kZXB0aDogTWF5IGJlIGBib3R0b20gfCBvcnBoYW4gfCBhdXRvIHwgdG9wYC4gIFRoZSBmaXJzdCBkcmF3biBpcyBgYm90dG9tYCwgdGhlbiBgb3JwaGFuYCB3aGljaCBpcyB0aGVcbiAqICAgICAgc2FtZSBkZXB0aCBhcyB0aGUgcm9vdCBvZiB0aGUgY29tcG91bmQgZ3JhcGgsIGZvbGxvd2VkIGJ5IHRoZSBkZWZhdWx0IHZhbHVlIGBhdXRvYCB3aGljaCBkcmF3cyBpbiBvcmRlciBmcm9tXG4gKiAgICAgIHJvb3QgdG8gbGVhdmVzIG9mIHRoZSBjb21wb3VuZCBncmFwaC4gIFRoZSBsYXN0IGRyYXduIGlzIGB0b3BgLlxuICogIHotaW5kZXgtY29tcGFyZTogTWF5IGJlIGBhdXRvIHwgbWFudWFsYC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGBhdXRvYCB3aGljaCBhbHdheXMgZHJhd3MgZWRnZXMgdW5kZXIgbm9kZXMuXG4gKiAgICAgIGBtYW51YWxgIGlnbm9yZXMgdGhpcyBjb252ZW50aW9uIGFuZCBkcmF3cyBiYXNlZCBvbiB0aGUgYHotaW5kZXhgIHZhbHVlIHNldHRpbmcuXG4gKiAgei1pbmRleDogQW4gaW50ZWdlciB2YWx1ZSB0aGF0IGFmZmVjdHMgdGhlIHJlbGF0aXZlIGRyYXcgb3JkZXIgb2YgZWxlbWVudHMuICBJbiBnZW5lcmFsLCBhbiBlbGVtZW50IHdpdGggYSBoaWdoZXJcbiAqICAgICAgYHotaW5kZXhgIHdpbGwgYmUgZHJhd24gb24gdG9wIG9mIGFuIGVsZW1lbnQgd2l0aCBhIGxvd2VyIGB6LWluZGV4YC5cbiAqL1xuXG52YXIgekluZGV4U29ydCA9IGZ1bmN0aW9uIHpJbmRleFNvcnQoYSwgYikge1xuICB2YXIgY3kgPSBhLmN5KCk7XG4gIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuXG4gIGZ1bmN0aW9uIGdldERlcHRoKGVsZSkge1xuICAgIHZhciBzdHlsZSA9IGVsZS5wc3R5bGUoJ3otY29tcG91bmQtZGVwdGgnKTtcblxuICAgIGlmIChzdHlsZS52YWx1ZSA9PT0gJ2F1dG8nKSB7XG4gICAgICByZXR1cm4gaGFzQ29tcG91bmROb2RlcyA/IGVsZS56RGVwdGgoKSA6IDA7XG4gICAgfSBlbHNlIGlmIChzdHlsZS52YWx1ZSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2UgaWYgKHN0eWxlLnZhbHVlID09PSAndG9wJykge1xuICAgICAgcmV0dXJuIE1BWF9JTlQkMTtcbiAgICB9IC8vICdvcnBoYW4nXG5cblxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIGRlcHRoRGlmZiA9IGdldERlcHRoKGEpIC0gZ2V0RGVwdGgoYik7XG5cbiAgaWYgKGRlcHRoRGlmZiAhPT0gMCkge1xuICAgIHJldHVybiBkZXB0aERpZmY7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFbGVEZXB0aChlbGUpIHtcbiAgICB2YXIgc3R5bGUgPSBlbGUucHN0eWxlKCd6LWluZGV4LWNvbXBhcmUnKTtcblxuICAgIGlmIChzdHlsZS52YWx1ZSA9PT0gJ2F1dG8nKSB7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpID8gMSA6IDA7XG4gICAgfSAvLyAnbWFudWFsJ1xuXG5cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBlbGVEaWZmID0gZ2V0RWxlRGVwdGgoYSkgLSBnZXRFbGVEZXB0aChiKTtcblxuICBpZiAoZWxlRGlmZiAhPT0gMCkge1xuICAgIHJldHVybiBlbGVEaWZmO1xuICB9XG5cbiAgdmFyIHpEaWZmID0gYS5wc3R5bGUoJ3otaW5kZXgnKS52YWx1ZSAtIGIucHN0eWxlKCd6LWluZGV4JykudmFsdWU7XG5cbiAgaWYgKHpEaWZmICE9PSAwKSB7XG4gICAgcmV0dXJuIHpEaWZmO1xuICB9IC8vIGNvbXBhcmUgaW5kaWNlcyBpbiB0aGUgY29yZSAob3JkZXIgYWRkZWQgdG8gZ3JhcGggdy8gbGFzdCBvbiB0b3ApXG5cblxuICByZXR1cm4gYS5wb29sSW5kZXgoKSAtIGIucG9vbEluZGV4KCk7XG59O1xuXG52YXIgZWxlc2ZuJDYgPSB7XG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goZm4sIHRoaXNBcmcpIHtcbiAgICBpZiAoZm4kNihmbikpIHtcbiAgICAgIHZhciBOID0gdGhpcy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICB2YXIgcmV0ID0gdGhpc0FyZyA/IGZuLmFwcGx5KHRoaXNBcmcsIFtlbGUsIGksIHRoaXNdKSA6IGZuKGVsZSwgaSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSAvLyBleGl0IGVhY2ggZWFybHkgb24gcmV0dXJuIGZhbHNlXG5cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyYXkucHVzaCh0aGlzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH0sXG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgdmFyIHRoaXNTaXplID0gdGhpcy5sZW5ndGg7XG5cbiAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgIGVuZCA9IHRoaXNTaXplO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA9PSBudWxsKSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgc3RhcnQgPSB0aGlzU2l6ZSArIHN0YXJ0O1xuICAgIH1cblxuICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICBlbmQgPSB0aGlzU2l6ZSArIGVuZDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPj0gMCAmJiBpIDwgZW5kICYmIGkgPCB0aGlzU2l6ZTsgaSsrKSB7XG4gICAgICBhcnJheS5wdXNoKHRoaXNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKGFycmF5KTtcbiAgfSxcbiAgc2l6ZTogZnVuY3Rpb24gc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gIH0sXG4gIGVxOiBmdW5jdGlvbiBlcShpKSB7XG4gICAgcmV0dXJuIHRoaXNbaV0gfHwgdGhpcy5zcGF3bigpO1xuICB9LFxuICBmaXJzdDogZnVuY3Rpb24gZmlyc3QoKSB7XG4gICAgcmV0dXJuIHRoaXNbMF0gfHwgdGhpcy5zcGF3bigpO1xuICB9LFxuICBsYXN0OiBmdW5jdGlvbiBsYXN0KCkge1xuICAgIHJldHVybiB0aGlzW3RoaXMubGVuZ3RoIC0gMV0gfHwgdGhpcy5zcGF3bigpO1xuICB9LFxuICBlbXB0eTogZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAwO1xuICB9LFxuICBub25lbXB0eTogZnVuY3Rpb24gbm9uZW1wdHkoKSB7XG4gICAgcmV0dXJuICF0aGlzLmVtcHR5KCk7XG4gIH0sXG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoc29ydEZuKSB7XG4gICAgaWYgKCFmbiQ2KHNvcnRGbikpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBzb3J0ZWQgPSB0aGlzLnRvQXJyYXkoKS5zb3J0KHNvcnRGbik7XG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oc29ydGVkKTtcbiAgfSxcbiAgc29ydEJ5WkluZGV4OiBmdW5jdGlvbiBzb3J0QnlaSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc29ydCh6SW5kZXhTb3J0KTtcbiAgfSxcbiAgekRlcHRoOiBmdW5jdGlvbiB6RGVwdGgoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoIWVsZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IC8vIGxldCBjeSA9IGVsZS5jeSgpO1xuXG5cbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIGdyb3VwID0gX3AuZ3JvdXA7XG5cbiAgICBpZiAoZ3JvdXAgPT09ICdub2RlcycpIHtcbiAgICAgIHZhciBkZXB0aCA9IF9wLmRhdGEucGFyZW50ID8gZWxlLnBhcmVudHMoKS5zaXplKCkgOiAwO1xuXG4gICAgICBpZiAoIWVsZS5pc1BhcmVudCgpKSB7XG4gICAgICAgIHJldHVybiBNQVhfSU5UJDEgLSAxOyAvLyBjaGlsZGxlc3Mgbm9kZXMgYWx3YXlzIG9uIHRvcFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVwdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgICB2YXIgdGd0ID0gX3AudGFyZ2V0O1xuICAgICAgdmFyIHNyY0RlcHRoID0gc3JjLnpEZXB0aCgpO1xuICAgICAgdmFyIHRndERlcHRoID0gdGd0LnpEZXB0aCgpO1xuICAgICAgcmV0dXJuIE1hdGgubWF4KHNyY0RlcHRoLCB0Z3REZXB0aCwgMCk7IC8vIGRlcHRoIG9mIGRlZXBlc3QgcGFyZW50XG4gICAgfVxuICB9XG59O1xuZWxlc2ZuJDYuZWFjaCA9IGVsZXNmbiQ2LmZvckVhY2g7XG5cbnZhciBkZWZpbmVTeW1ib2xJdGVyYXRvciA9IGZ1bmN0aW9uIGRlZmluZVN5bWJvbEl0ZXJhdG9yKCkge1xuICB2YXIgdHlwZW9mVW5kZWYgPSBcInVuZGVmaW5lZFwiIDtcbiAgdmFyIGlzSXRlcmF0b3JTdXBwb3J0ZWQgPSAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKFN5bWJvbCkpICE9IHR5cGVvZlVuZGVmICYmIF90eXBlb2YoU3ltYm9sLml0ZXJhdG9yKSAhPSB0eXBlb2ZVbmRlZjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIGlmIChpc0l0ZXJhdG9yU3VwcG9ydGVkKSB7XG4gICAgZWxlc2ZuJDZbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICByZXR1cm4gX2RlZmluZVByb3BlcnR5KHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICBpZiAoaSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgZW50cnkudmFsdWUgPSBfdGhpc1tpKytdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbnRyeS52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGVudHJ5LmRvbmUgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgICAgfVxuICAgICAgfSwgU3ltYm9sLml0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG59O1xuXG5kZWZpbmVTeW1ib2xJdGVyYXRvcigpO1xuXG52YXIgZ2V0TGF5b3V0RGltZW5zaW9uT3B0aW9ucyA9IGRlZmF1bHRzJGcoe1xuICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlXG59KTtcbnZhciBlbGVzZm4kNSA9IHtcbiAgLy8gQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyBub2RlIGRpbWVuc2lvbnMgeyB4LCB5IH0gYmFzZWQgb24gb3B0aW9ucyBnaXZlblxuICBsYXlvdXREaW1lbnNpb25zOiBmdW5jdGlvbiBsYXlvdXREaW1lbnNpb25zKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gZ2V0TGF5b3V0RGltZW5zaW9uT3B0aW9ucyhvcHRpb25zKTtcbiAgICB2YXIgZGltcztcblxuICAgIGlmICghdGhpcy50YWtlc1VwU3BhY2UoKSkge1xuICAgICAgZGltcyA9IHtcbiAgICAgICAgdzogMCxcbiAgICAgICAgaDogMFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMubm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzKSB7XG4gICAgICB2YXIgYmJEaW0gPSB0aGlzLmJvdW5kaW5nQm94KCk7XG4gICAgICBkaW1zID0ge1xuICAgICAgICB3OiBiYkRpbS53LFxuICAgICAgICBoOiBiYkRpbS5oXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkaW1zID0ge1xuICAgICAgICB3OiB0aGlzLm91dGVyV2lkdGgoKSxcbiAgICAgICAgaDogdGhpcy5vdXRlckhlaWdodCgpXG4gICAgICB9O1xuICAgIH0gLy8gc2FuaXRpc2UgdGhlIGRpbWVuc2lvbnMgZm9yIGV4dGVybmFsIGxheW91dHMgKGF2b2lkIGRpdmlzaW9uIGJ5IHplcm8pXG5cblxuICAgIGlmIChkaW1zLncgPT09IDAgfHwgZGltcy5oID09PSAwKSB7XG4gICAgICBkaW1zLncgPSBkaW1zLmggPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBkaW1zO1xuICB9LFxuICAvLyB1c2luZyBzdGFuZGFyZCBsYXlvdXQgb3B0aW9ucywgYXBwbHkgcG9zaXRpb24gZnVuY3Rpb24gKHcvIG9yIHcvbyBhbmltYXRpb24pXG4gIGxheW91dFBvc2l0aW9uczogZnVuY3Rpb24gbGF5b3V0UG9zaXRpb25zKGxheW91dCwgb3B0aW9ucywgZm4pIHtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCkuZmlsdGVyKGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gIW4uaXNQYXJlbnQoKTtcbiAgICB9KTtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIGxheW91dEVsZXMgPSBvcHRpb25zLmVsZXM7IC8vIG5vZGVzICYgZWRnZXNcblxuICAgIHZhciBnZXRNZW1vaXplS2V5ID0gZnVuY3Rpb24gZ2V0TWVtb2l6ZUtleShub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5pZCgpO1xuICAgIH07XG5cbiAgICB2YXIgZm5NZW0gPSBtZW1vaXplKGZuLCBnZXRNZW1vaXplS2V5KTsgLy8gbWVtb2l6ZWQgdmVyc2lvbiBvZiBwb3NpdGlvbiBmdW5jdGlvblxuXG4gICAgbGF5b3V0LmVtaXQoe1xuICAgICAgdHlwZTogJ2xheW91dHN0YXJ0JyxcbiAgICAgIGxheW91dDogbGF5b3V0XG4gICAgfSk7XG4gICAgbGF5b3V0LmFuaW1hdGlvbnMgPSBbXTtcblxuICAgIHZhciBjYWxjdWxhdGVTcGFjaW5nID0gZnVuY3Rpb24gY2FsY3VsYXRlU3BhY2luZyhzcGFjaW5nLCBub2Rlc0JiLCBwb3MpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB7XG4gICAgICAgIHg6IG5vZGVzQmIueDEgKyBub2Rlc0JiLncgLyAyLFxuICAgICAgICB5OiBub2Rlc0JiLnkxICsgbm9kZXNCYi5oIC8gMlxuICAgICAgfTtcbiAgICAgIHZhciBzcGFjaW5nVmVjdG9yID0ge1xuICAgICAgICAvLyBzY2FsZSBmcm9tIGNlbnRlciBvZiBib3VuZGluZyBib3ggKG5vdCBuZWNlc3NhcmlseSAwLDApXG4gICAgICAgIHg6IChwb3MueCAtIGNlbnRlci54KSAqIHNwYWNpbmcsXG4gICAgICAgIHk6IChwb3MueSAtIGNlbnRlci55KSAqIHNwYWNpbmdcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBjZW50ZXIueCArIHNwYWNpbmdWZWN0b3IueCxcbiAgICAgICAgeTogY2VudGVyLnkgKyBzcGFjaW5nVmVjdG9yLnlcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciB1c2VTcGFjaW5nRmFjdG9yID0gb3B0aW9ucy5zcGFjaW5nRmFjdG9yICYmIG9wdGlvbnMuc3BhY2luZ0ZhY3RvciAhPT0gMTtcblxuICAgIHZhciBzcGFjaW5nQmIgPSBmdW5jdGlvbiBzcGFjaW5nQmIoKSB7XG4gICAgICBpZiAoIXVzZVNwYWNpbmdGYWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciBwb3MgPSBmbk1lbShub2RlLCBpKTtcbiAgICAgICAgZXhwYW5kQm91bmRpbmdCb3hCeVBvaW50KGJiLCBwb3MueCwgcG9zLnkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmI7XG4gICAgfTtcblxuICAgIHZhciBiYiA9IHNwYWNpbmdCYigpO1xuICAgIHZhciBnZXRGaW5hbFBvcyA9IG1lbW9pemUoZnVuY3Rpb24gKG5vZGUsIGkpIHtcbiAgICAgIHZhciBuZXdQb3MgPSBmbk1lbShub2RlLCBpKTtcblxuICAgICAgaWYgKHVzZVNwYWNpbmdGYWN0b3IpIHtcbiAgICAgICAgdmFyIHNwYWNpbmcgPSBNYXRoLmFicyhvcHRpb25zLnNwYWNpbmdGYWN0b3IpO1xuICAgICAgICBuZXdQb3MgPSBjYWxjdWxhdGVTcGFjaW5nKHNwYWNpbmcsIGJiLCBuZXdQb3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy50cmFuc2Zvcm0gIT0gbnVsbCkge1xuICAgICAgICBuZXdQb3MgPSBvcHRpb25zLnRyYW5zZm9ybShub2RlLCBuZXdQb3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3UG9zO1xuICAgIH0sIGdldE1lbW9pemVLZXkpO1xuXG4gICAgaWYgKG9wdGlvbnMuYW5pbWF0ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgbmV3UG9zID0gZ2V0RmluYWxQb3Mobm9kZSwgaSk7XG4gICAgICAgIHZhciBhbmltYXRlTm9kZSA9IG9wdGlvbnMuYW5pbWF0ZUZpbHRlciA9PSBudWxsIHx8IG9wdGlvbnMuYW5pbWF0ZUZpbHRlcihub2RlLCBpKTtcblxuICAgICAgICBpZiAoYW5pbWF0ZU5vZGUpIHtcbiAgICAgICAgICB2YXIgYW5pID0gbm9kZS5hbmltYXRpb24oe1xuICAgICAgICAgICAgcG9zaXRpb246IG5ld1BvcyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICAgICAgZWFzaW5nOiBvcHRpb25zLmFuaW1hdGlvbkVhc2luZ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxheW91dC5hbmltYXRpb25zLnB1c2goYW5pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnBvc2l0aW9uKG5ld1Bvcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuZml0KSB7XG4gICAgICAgIHZhciBmaXRBbmkgPSBjeS5hbmltYXRpb24oe1xuICAgICAgICAgIGZpdDoge1xuICAgICAgICAgICAgYm91bmRpbmdCb3g6IGxheW91dEVsZXMuYm91bmRpbmdCb3hBdChnZXRGaW5hbFBvcyksXG4gICAgICAgICAgICBwYWRkaW5nOiBvcHRpb25zLnBhZGRpbmdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZzogb3B0aW9ucy5hbmltYXRpb25FYXNpbmdcbiAgICAgICAgfSk7XG4gICAgICAgIGxheW91dC5hbmltYXRpb25zLnB1c2goZml0QW5pKTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5wYW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgem9vbVBhbkFuaSA9IGN5LmFuaW1hdGlvbih7XG4gICAgICAgICAgem9vbTogb3B0aW9ucy56b29tLFxuICAgICAgICAgIHBhbjogb3B0aW9ucy5wYW4sXG4gICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgICAgZWFzaW5nOiBvcHRpb25zLmFuaW1hdGlvbkVhc2luZ1xuICAgICAgICB9KTtcbiAgICAgICAgbGF5b3V0LmFuaW1hdGlvbnMucHVzaCh6b29tUGFuQW5pKTtcbiAgICAgIH1cblxuICAgICAgbGF5b3V0LmFuaW1hdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYW5pKSB7XG4gICAgICAgIHJldHVybiBhbmkucGxheSgpO1xuICAgICAgfSk7XG4gICAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgbGF5b3V0LmVtaXQoe1xuICAgICAgICB0eXBlOiAnbGF5b3V0cmVhZHknLFxuICAgICAgICBsYXlvdXQ6IGxheW91dFxuICAgICAgfSk7XG4gICAgICBQcm9taXNlJDEuYWxsKGxheW91dC5hbmltYXRpb25zLm1hcChmdW5jdGlvbiAoYW5pKSB7XG4gICAgICAgIHJldHVybiBhbmkucHJvbWlzZSgpO1xuICAgICAgfSkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgICAgbGF5b3V0LmVtaXQoe1xuICAgICAgICAgIHR5cGU6ICdsYXlvdXRzdG9wJyxcbiAgICAgICAgICBsYXlvdXQ6IGxheW91dFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2Rlcy5wb3NpdGlvbnMoZ2V0RmluYWxQb3MpO1xuXG4gICAgICBpZiAob3B0aW9ucy5maXQpIHtcbiAgICAgICAgY3kuZml0KG9wdGlvbnMuZWxlcywgb3B0aW9ucy5wYWRkaW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuem9vbSAhPSBudWxsKSB7XG4gICAgICAgIGN5Lnpvb20ob3B0aW9ucy56b29tKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMucGFuKSB7XG4gICAgICAgIGN5LnBhbihvcHRpb25zLnBhbik7XG4gICAgICB9XG5cbiAgICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICBsYXlvdXQuZW1pdCh7XG4gICAgICAgIHR5cGU6ICdsYXlvdXRyZWFkeScsXG4gICAgICAgIGxheW91dDogbGF5b3V0XG4gICAgICB9KTtcbiAgICAgIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICAgICAgbGF5b3V0LmVtaXQoe1xuICAgICAgICB0eXBlOiAnbGF5b3V0c3RvcCcsXG4gICAgICAgIGxheW91dDogbGF5b3V0XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgbGF5b3V0OiBmdW5jdGlvbiBsYXlvdXQob3B0aW9ucykge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICByZXR1cm4gY3kubWFrZUxheW91dChleHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgIGVsZXM6IHRoaXNcbiAgICB9KSk7XG4gIH1cbn07IC8vIGFsaWFzZXM6XG5cbmVsZXNmbiQ1LmNyZWF0ZUxheW91dCA9IGVsZXNmbiQ1Lm1ha2VMYXlvdXQgPSBlbGVzZm4kNS5sYXlvdXQ7XG5cbmZ1bmN0aW9uIHN0eWxlQ2FjaGUoa2V5LCBmbiwgZWxlKSB7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIGNhY2hlID0gX3Auc3R5bGVDYWNoZSA9IF9wLnN0eWxlQ2FjaGUgfHwgW107XG4gIHZhciB2YWw7XG5cbiAgaWYgKCh2YWwgPSBjYWNoZVtrZXldKSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBjYWNoZVtrZXldID0gZm4oZWxlKTtcbiAgICByZXR1cm4gdmFsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhY2hlU3R5bGVGdW5jdGlvbihrZXksIGZuKSB7XG4gIGtleSA9IGhhc2hTdHJpbmcoa2V5KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNhY2hlZFN0eWxlRnVuY3Rpb24oZWxlKSB7XG4gICAgcmV0dXJuIHN0eWxlQ2FjaGUoa2V5LCBmbiwgZWxlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2FjaGVQcm90b3R5cGVTdHlsZUZ1bmN0aW9uKGtleSwgZm4pIHtcbiAga2V5ID0gaGFzaFN0cmluZyhrZXkpO1xuXG4gIHZhciBzZWxmRm4gPSBmdW5jdGlvbiBzZWxmRm4oZWxlKSB7XG4gICAgcmV0dXJuIGZuLmNhbGwoZWxlKTtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24gY2FjaGVkUHJvdG90eXBlU3R5bGVGdW5jdGlvbigpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBzdHlsZUNhY2hlKGtleSwgc2VsZkZuLCBlbGUpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGVsZXNmbiQ0ID0ge1xuICByZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGU6IGZ1bmN0aW9uIHJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSh1c2VDYWNoZSkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgcmVuZGVyZXIgPSBjeS5yZW5kZXJlcigpO1xuICAgIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5zdHlsZUVuYWJsZWQoKTtcblxuICAgIGlmIChyZW5kZXJlciAmJiBzdHlsZUVuYWJsZWQpIHtcbiAgICAgIHJlbmRlcmVyLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSh0aGlzLCB1c2VDYWNoZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGRpcnR5U3R5bGVDYWNoZTogZnVuY3Rpb24gZGlydHlTdHlsZUNhY2hlKCkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIHZhciBkaXJ0eSA9IGZ1bmN0aW9uIGRpcnR5KGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5zdHlsZUNhY2hlID0gbnVsbDtcbiAgICB9O1xuXG4gICAgaWYgKGN5Lmhhc0NvbXBvdW5kTm9kZXMoKSkge1xuICAgICAgdmFyIGVsZXM7XG4gICAgICBlbGVzID0gdGhpcy5zcGF3blNlbGYoKS5tZXJnZSh0aGlzLmRlc2NlbmRhbnRzKCkpLm1lcmdlKHRoaXMucGFyZW50cygpKTtcbiAgICAgIGVsZXMubWVyZ2UoZWxlcy5jb25uZWN0ZWRFZGdlcygpKTtcbiAgICAgIGVsZXMuZm9yRWFjaChkaXJ0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIGRpcnR5KGVsZSk7XG4gICAgICAgIGVsZS5jb25uZWN0ZWRFZGdlcygpLmZvckVhY2goZGlydHkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIGZ1bGx5IHVwZGF0ZXMgKHJlY2FsY3VsYXRlcykgdGhlIHN0eWxlIGZvciB0aGUgZWxlbWVudHNcbiAgdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5vdGlmeVJlbmRlcmVyKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChjeS5iYXRjaGluZygpKSB7XG4gICAgICB2YXIgYkVsZXMgPSBjeS5fcHJpdmF0ZS5iYXRjaFN0eWxlRWxlcztcbiAgICAgIGJFbGVzLm1lcmdlKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nIGFuZCBleGl0IGVhcmx5IHdoZW4gYmF0Y2hpbmdcbiAgICB9XG5cbiAgICB2YXIgaGFzQ29tcG91bmRzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICAgIHZhciB1cGRhdGVkRWxlcyA9IHRoaXM7XG4gICAgbm90aWZ5UmVuZGVyZXIgPSBub3RpZnlSZW5kZXJlciB8fCBub3RpZnlSZW5kZXJlciA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgaWYgKGhhc0NvbXBvdW5kcykge1xuICAgICAgLy8gdGhlbiBhZGQgZXZlcnl0aGluZyB1cCBhbmQgZG93biBmb3IgY29tcG91bmQgc2VsZWN0b3IgY2hlY2tzXG4gICAgICB1cGRhdGVkRWxlcyA9IHRoaXMuc3Bhd25TZWxmKCkubWVyZ2UodGhpcy5kZXNjZW5kYW50cygpKS5tZXJnZSh0aGlzLnBhcmVudHMoKSk7XG4gICAgfSAvLyBsZXQgY2hhbmdlZEVsZXMgPSBzdHlsZS5hcHBseSggdXBkYXRlZEVsZXMgKTtcblxuXG4gICAgdmFyIGNoYW5nZWRFbGVzID0gdXBkYXRlZEVsZXM7XG5cbiAgICBpZiAobm90aWZ5UmVuZGVyZXIpIHtcbiAgICAgIGNoYW5nZWRFbGVzLmVtaXRBbmROb3RpZnkoJ3N0eWxlJyk7IC8vIGxldCByZW5kZXJlciBrbm93IHdlIGNoYW5nZWQgc3R5bGVcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhbmdlZEVsZXMuZW1pdCgnc3R5bGUnKTsgLy8ganVzdCBmaXJlIHRoZSBldmVudFxuICAgIH1cblxuICAgIHVwZGF0ZWRFbGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5zdHlsZURpcnR5ID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgLy8gcHJpdmF0ZTogY2xlYXJzIGRpcnR5IGZsYWcgYW5kIHJlY2FsY3VsYXRlcyBzdHlsZVxuICBjbGVhblN0eWxlOiBmdW5jdGlvbiBjbGVhblN0eWxlKCkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuXG4gICAgICBpZiAoZWxlLl9wcml2YXRlLnN0eWxlRGlydHkpIHtcbiAgICAgICAgLy8gbi5iLiB0aGlzIGZsYWcgc2hvdWxkIGJlIHNldCBiZWZvcmUgYXBwbHkoKSB0byBhdm9pZCBwb3RlbnRpYWwgaW5maW5pdGUgcmVjdXJzaW9uXG4gICAgICAgIGVsZS5fcHJpdmF0ZS5zdHlsZURpcnR5ID0gZmFsc2U7XG4gICAgICAgIGN5LnN0eWxlKCkuYXBwbHkoZWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8vIGdldCB0aGUgaW50ZXJuYWwgcGFyc2VkIHN0eWxlIG9iamVjdCBmb3IgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eVxuICBwYXJzZWRTdHlsZTogZnVuY3Rpb24gcGFyc2VkU3R5bGUocHJvcGVydHkpIHtcbiAgICB2YXIgaW5jbHVkZU5vbkRlZmF1bHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIGN5ID0gZWxlLmN5KCk7XG5cbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsZSkge1xuICAgICAgdGhpcy5jbGVhblN0eWxlKCk7XG4gICAgICB2YXIgb3ZlcnJpZGRlblN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlW3Byb3BlcnR5XTtcblxuICAgICAgaWYgKG92ZXJyaWRkZW5TdHlsZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBvdmVycmlkZGVuU3R5bGU7XG4gICAgICB9IGVsc2UgaWYgKGluY2x1ZGVOb25EZWZhdWx0KSB7XG4gICAgICAgIHJldHVybiBjeS5zdHlsZSgpLmdldERlZmF1bHRQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG51bWVyaWNTdHlsZTogZnVuY3Rpb24gbnVtZXJpY1N0eWxlKHByb3BlcnR5KSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoIWVsZS5jeSgpLnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsZSkge1xuICAgICAgdmFyIHBzdHlsZSA9IGVsZS5wc3R5bGUocHJvcGVydHkpO1xuICAgICAgcmV0dXJuIHBzdHlsZS5wZlZhbHVlICE9PSB1bmRlZmluZWQgPyBwc3R5bGUucGZWYWx1ZSA6IHBzdHlsZS52YWx1ZTtcbiAgICB9XG4gIH0sXG4gIG51bWVyaWNTdHlsZVVuaXRzOiBmdW5jdGlvbiBudW1lcmljU3R5bGVVbml0cyhwcm9wZXJ0eSkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKCFlbGUuY3koKS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUucHN0eWxlKHByb3BlcnR5KS51bml0cztcbiAgICB9XG4gIH0sXG4gIC8vIGdldCB0aGUgc3BlY2lmaWVkIGNzcyBwcm9wZXJ0eSBhcyBhIHJlbmRlcmVkIHZhbHVlIChpLmUuIG9uLXNjcmVlbiB2YWx1ZSlcbiAgLy8gb3IgZ2V0IHRoZSB3aG9sZSByZW5kZXJlZCBzdHlsZSBpZiBubyBwcm9wZXJ0eSBzcGVjaWZpZWQgKE5CIGRvZXNuJ3QgYWxsb3cgc2V0dGluZylcbiAgcmVuZGVyZWRTdHlsZTogZnVuY3Rpb24gcmVuZGVyZWRTdHlsZShwcm9wZXJ0eSkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGN5LnN0eWxlKCkuZ2V0UmVuZGVyZWRTdHlsZShlbGUsIHByb3BlcnR5KTtcbiAgICB9XG4gIH0sXG4gIC8vIHJlYWQgdGhlIGNhbGN1bGF0ZWQgY3NzIHN0eWxlIG9mIHRoZSBlbGVtZW50IG9yIG92ZXJyaWRlIHRoZSBzdHlsZSAodmlhIGEgYnlwYXNzKVxuICBzdHlsZTogZnVuY3Rpb24gc3R5bGUobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlVHJhbnNpdGlvbnMgPSBmYWxzZTtcbiAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuXG4gICAgaWYgKHBsYWluT2JqZWN0KG5hbWUpKSB7XG4gICAgICAvLyB0aGVuIGV4dGVuZCB0aGUgYnlwYXNzXG4gICAgICB2YXIgcHJvcHMgPSBuYW1lO1xuICAgICAgc3R5bGUuYXBwbHlCeXBhc3ModGhpcywgcHJvcHMsIHVwZGF0ZVRyYW5zaXRpb25zKTtcbiAgICAgIHRoaXMuZW1pdEFuZE5vdGlmeSgnc3R5bGUnKTsgLy8gbGV0IHRoZSByZW5kZXJlciBrbm93IHdlJ3ZlIHVwZGF0ZWQgc3R5bGVcbiAgICB9IGVsc2UgaWYgKHN0cmluZyhuYW1lKSkge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdGhlbiBnZXQgdGhlIHByb3BlcnR5IGZyb20gdGhlIHN0eWxlXG4gICAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gc3R5bGUuZ2V0U3R5bGVQcm9wZXJ0eVZhbHVlKGVsZSwgbmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZW1wdHkgY29sbGVjdGlvbiA9PiBjYW4ndCBnZXQgYW55IHZhbHVlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGVuIHNldCB0aGUgYnlwYXNzIHdpdGggdGhlIHByb3BlcnR5IHZhbHVlXG4gICAgICAgIHN0eWxlLmFwcGx5QnlwYXNzKHRoaXMsIG5hbWUsIHZhbHVlLCB1cGRhdGVUcmFuc2l0aW9ucyk7XG4gICAgICAgIHRoaXMuZW1pdEFuZE5vdGlmeSgnc3R5bGUnKTsgLy8gbGV0IHRoZSByZW5kZXJlciBrbm93IHdlJ3ZlIHVwZGF0ZWQgc3R5bGVcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIF9lbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiAoX2VsZSkge1xuICAgICAgICByZXR1cm4gc3R5bGUuZ2V0UmF3U3R5bGUoX2VsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlbXB0eSBjb2xsZWN0aW9uID0+IGNhbid0IGdldCBhbnkgdmFsdWVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICByZW1vdmVTdHlsZTogZnVuY3Rpb24gcmVtb3ZlU3R5bGUobmFtZXMpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlVHJhbnNpdGlvbnMgPSBmYWxzZTtcbiAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgIGlmIChuYW1lcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIHN0eWxlLnJlbW92ZUFsbEJ5cGFzc2VzKGVsZSwgdXBkYXRlVHJhbnNpdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lcyA9IG5hbWVzLnNwbGl0KC9cXHMrLyk7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBlbGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgX2VsZTIgPSBlbGVzW19pXTtcbiAgICAgICAgc3R5bGUucmVtb3ZlQnlwYXNzZXMoX2VsZTIsIG5hbWVzLCB1cGRhdGVUcmFuc2l0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0QW5kTm90aWZ5KCdzdHlsZScpOyAvLyBsZXQgdGhlIHJlbmRlcmVyIGtub3cgd2UndmUgdXBkYXRlZCBzdHlsZVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHNob3c6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgdGhpcy5jc3MoJ2Rpc3BsYXknLCAnZWxlbWVudCcpO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgIHRoaXMuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgZWZmZWN0aXZlT3BhY2l0eTogZnVuY3Rpb24gZWZmZWN0aXZlT3BhY2l0eSgpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBwYXJlbnRPcGFjaXR5ID0gZWxlLnBzdHlsZSgnb3BhY2l0eScpLnZhbHVlO1xuXG4gICAgICBpZiAoIWhhc0NvbXBvdW5kTm9kZXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudE9wYWNpdHk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJlbnRzID0gIV9wLmRhdGEucGFyZW50ID8gbnVsbCA6IGVsZS5wYXJlbnRzKCk7XG5cbiAgICAgIGlmIChwYXJlbnRzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2ldO1xuICAgICAgICAgIHZhciBvcGFjaXR5ID0gcGFyZW50LnBzdHlsZSgnb3BhY2l0eScpLnZhbHVlO1xuICAgICAgICAgIHBhcmVudE9wYWNpdHkgPSBvcGFjaXR5ICogcGFyZW50T3BhY2l0eTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyZW50T3BhY2l0eTtcbiAgICB9XG4gIH0sXG4gIHRyYW5zcGFyZW50OiBmdW5jdGlvbiB0cmFuc3BhcmVudCgpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBlbGUuY3koKS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICBpZiAoIWhhc0NvbXBvdW5kTm9kZXMpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5wc3R5bGUoJ29wYWNpdHknKS52YWx1ZSA9PT0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlbGUuZWZmZWN0aXZlT3BhY2l0eSgpID09PSAwO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYmFja2dyb3VuZGluZzogZnVuY3Rpb24gYmFja2dyb3VuZGluZygpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5iYWNrZ3JvdW5kaW5nID8gdHJ1ZSA6IGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjaGVja0NvbXBvdW5kKGVsZSwgcGFyZW50T2spIHtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcGFyZW50cyA9IF9wLmRhdGEucGFyZW50ID8gZWxlLnBhcmVudHMoKSA6IG51bGw7XG5cbiAgaWYgKHBhcmVudHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2ldO1xuXG4gICAgICBpZiAoIXBhcmVudE9rKHBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVEZXJpdmVkU3RhdGVGdW5jdGlvbihzcGVjcykge1xuICB2YXIgb2sgPSBzcGVjcy5vaztcbiAgdmFyIGVkZ2VPa1ZpYU5vZGUgPSBzcGVjcy5lZGdlT2tWaWFOb2RlIHx8IHNwZWNzLm9rO1xuICB2YXIgcGFyZW50T2sgPSBzcGVjcy5wYXJlbnRPayB8fCBzcGVjcy5vaztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcblxuICAgICAgaWYgKCFvayhlbGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICByZXR1cm4gIWhhc0NvbXBvdW5kTm9kZXMgfHwgY2hlY2tDb21wb3VuZChlbGUsIHBhcmVudE9rKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgICAgIHJldHVybiBlZGdlT2tWaWFOb2RlKHNyYykgJiYgKCFoYXNDb21wb3VuZE5vZGVzIHx8IGNoZWNrQ29tcG91bmQoc3JjLCBlZGdlT2tWaWFOb2RlKSkgJiYgKHNyYyA9PT0gdGd0IHx8IGVkZ2VPa1ZpYU5vZGUodGd0KSAmJiAoIWhhc0NvbXBvdW5kTm9kZXMgfHwgY2hlY2tDb21wb3VuZCh0Z3QsIGVkZ2VPa1ZpYU5vZGUpKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgZWxlVGFrZXNVcFNwYWNlID0gY2FjaGVTdHlsZUZ1bmN0aW9uKCdlbGVUYWtlc1VwU3BhY2UnLCBmdW5jdGlvbiAoZWxlKSB7XG4gIHJldHVybiBlbGUucHN0eWxlKCdkaXNwbGF5JykudmFsdWUgPT09ICdlbGVtZW50JyAmJiBlbGUud2lkdGgoKSAhPT0gMCAmJiAoZWxlLmlzTm9kZSgpID8gZWxlLmhlaWdodCgpICE9PSAwIDogdHJ1ZSk7XG59KTtcbmVsZXNmbiQ0LnRha2VzVXBTcGFjZSA9IGNhY2hlUHJvdG90eXBlU3R5bGVGdW5jdGlvbigndGFrZXNVcFNwYWNlJywgZGVmaW5lRGVyaXZlZFN0YXRlRnVuY3Rpb24oe1xuICBvazogZWxlVGFrZXNVcFNwYWNlXG59KSk7XG52YXIgZWxlSW50ZXJhY3RpdmUgPSBjYWNoZVN0eWxlRnVuY3Rpb24oJ2VsZUludGVyYWN0aXZlJywgZnVuY3Rpb24gKGVsZSkge1xuICByZXR1cm4gZWxlLnBzdHlsZSgnZXZlbnRzJykudmFsdWUgPT09ICd5ZXMnICYmIGVsZS5wc3R5bGUoJ3Zpc2liaWxpdHknKS52YWx1ZSA9PT0gJ3Zpc2libGUnICYmIGVsZVRha2VzVXBTcGFjZShlbGUpO1xufSk7XG52YXIgcGFyZW50SW50ZXJhY3RpdmUgPSBjYWNoZVN0eWxlRnVuY3Rpb24oJ3BhcmVudEludGVyYWN0aXZlJywgZnVuY3Rpb24gKHBhcmVudCkge1xuICByZXR1cm4gcGFyZW50LnBzdHlsZSgndmlzaWJpbGl0eScpLnZhbHVlID09PSAndmlzaWJsZScgJiYgZWxlVGFrZXNVcFNwYWNlKHBhcmVudCk7XG59KTtcbmVsZXNmbiQ0LmludGVyYWN0aXZlID0gY2FjaGVQcm90b3R5cGVTdHlsZUZ1bmN0aW9uKCdpbnRlcmFjdGl2ZScsIGRlZmluZURlcml2ZWRTdGF0ZUZ1bmN0aW9uKHtcbiAgb2s6IGVsZUludGVyYWN0aXZlLFxuICBwYXJlbnRPazogcGFyZW50SW50ZXJhY3RpdmUsXG4gIGVkZ2VPa1ZpYU5vZGU6IGVsZVRha2VzVXBTcGFjZVxufSkpO1xuXG5lbGVzZm4kNC5ub25pbnRlcmFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgaWYgKGVsZSkge1xuICAgIHJldHVybiAhZWxlLmludGVyYWN0aXZlKCk7XG4gIH1cbn07XG5cbnZhciBlbGVWaXNpYmxlID0gY2FjaGVTdHlsZUZ1bmN0aW9uKCdlbGVWaXNpYmxlJywgZnVuY3Rpb24gKGVsZSkge1xuICByZXR1cm4gZWxlLnBzdHlsZSgndmlzaWJpbGl0eScpLnZhbHVlID09PSAndmlzaWJsZScgJiYgZWxlLnBzdHlsZSgnb3BhY2l0eScpLnBmVmFsdWUgIT09IDAgJiYgZWxlVGFrZXNVcFNwYWNlKGVsZSk7XG59KTtcbnZhciBlZGdlVmlzaWJsZVZpYU5vZGUgPSBlbGVUYWtlc1VwU3BhY2U7XG5lbGVzZm4kNC52aXNpYmxlID0gY2FjaGVQcm90b3R5cGVTdHlsZUZ1bmN0aW9uKCd2aXNpYmxlJywgZGVmaW5lRGVyaXZlZFN0YXRlRnVuY3Rpb24oe1xuICBvazogZWxlVmlzaWJsZSxcbiAgZWRnZU9rVmlhTm9kZTogZWRnZVZpc2libGVWaWFOb2RlXG59KSk7XG5cbmVsZXNmbiQ0LmhpZGRlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgaWYgKGVsZSkge1xuICAgIHJldHVybiAhZWxlLnZpc2libGUoKTtcbiAgfVxufTtcblxuZWxlc2ZuJDQuaXNCdW5kbGVkQmV6aWVyID0gY2FjaGVQcm90b3R5cGVTdHlsZUZ1bmN0aW9uKCdpc0J1bmRsZWRCZXppZXInLCBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5jeSgpLnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICF0aGlzLnJlbW92ZWQoKSAmJiB0aGlzLnBzdHlsZSgnY3VydmUtc3R5bGUnKS52YWx1ZSA9PT0gJ2JlemllcicgJiYgdGhpcy50YWtlc1VwU3BhY2UoKTtcbn0pO1xuZWxlc2ZuJDQuYnlwYXNzID0gZWxlc2ZuJDQuY3NzID0gZWxlc2ZuJDQuc3R5bGU7XG5lbGVzZm4kNC5yZW5kZXJlZENzcyA9IGVsZXNmbiQ0LnJlbmRlcmVkU3R5bGU7XG5lbGVzZm4kNC5yZW1vdmVCeXBhc3MgPSBlbGVzZm4kNC5yZW1vdmVDc3MgPSBlbGVzZm4kNC5yZW1vdmVTdHlsZTtcbmVsZXNmbiQ0LnBzdHlsZSA9IGVsZXNmbiQ0LnBhcnNlZFN0eWxlO1xuXG52YXIgZWxlc2ZuJDMgPSB7fTtcblxuZnVuY3Rpb24gZGVmaW5lU3dpdGNoRnVuY3Rpb24ocGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIGNoYW5nZWRFbGVzID0gW107IC8vIGUuZy4gY3kubm9kZXMoKS5zZWxlY3QoIGRhdGEsIGhhbmRsZXIgKVxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgZGF0YSA9IGFyZ3NbMF07XG4gICAgICB2YXIgaGFuZGxlciA9IGFyZ3NbMV07XG4gICAgICB0aGlzLm9uKHBhcmFtcy5ldmVudCwgZGF0YSwgaGFuZGxlcik7XG4gICAgfSAvLyBlLmcuIGN5Lm5vZGVzKCkuc2VsZWN0KCBoYW5kbGVyIClcbiAgICBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBmbiQ2KGFyZ3NbMF0pKSB7XG4gICAgICB2YXIgX2hhbmRsZXIgPSBhcmdzWzBdO1xuICAgICAgdGhpcy5vbihwYXJhbXMuZXZlbnQsIF9oYW5kbGVyKTtcbiAgICB9IC8vIGUuZy4gY3kubm9kZXMoKS5zZWxlY3QoKVxuICAgIC8vIGUuZy4gKHByaXZhdGUpIGN5Lm5vZGVzKCkuc2VsZWN0KFsndGFwc2VsZWN0J10pXG4gICAgZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDAgfHwgYXJncy5sZW5ndGggPT09IDEgJiYgYXJyYXkoYXJnc1swXSkpIHtcbiAgICAgIHZhciBhZGRsRXZlbnRzID0gYXJncy5sZW5ndGggPT09IDEgPyBhcmdzWzBdIDogbnVsbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICB2YXIgYWJsZSA9ICFwYXJhbXMuYWJsZUZpZWxkIHx8IGVsZS5fcHJpdmF0ZVtwYXJhbXMuYWJsZUZpZWxkXTtcbiAgICAgICAgdmFyIGNoYW5nZWQgPSBlbGUuX3ByaXZhdGVbcGFyYW1zLmZpZWxkXSAhPSBwYXJhbXMudmFsdWU7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5vdmVycmlkZUFibGUpIHtcbiAgICAgICAgICB2YXIgb3ZlcnJpZGVBYmxlID0gcGFyYW1zLm92ZXJyaWRlQWJsZShlbGUpO1xuXG4gICAgICAgICAgaWYgKG92ZXJyaWRlQWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhYmxlID0gb3ZlcnJpZGVBYmxlO1xuXG4gICAgICAgICAgICBpZiAoIW92ZXJyaWRlQWJsZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gLy8gdG8gc2F2ZSBjeWNsZXMgYXNzdW1lIG5vdCBhYmxlIGZvciBhbGwgb24gb3ZlcnJpZGVcblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhYmxlKSB7XG4gICAgICAgICAgZWxlLl9wcml2YXRlW3BhcmFtcy5maWVsZF0gPSBwYXJhbXMudmFsdWU7XG5cbiAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgY2hhbmdlZEVsZXMucHVzaChlbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY2hhbmdlZENvbGwgPSB0aGlzLnNwYXduKGNoYW5nZWRFbGVzKTtcbiAgICAgIGNoYW5nZWRDb2xsLnVwZGF0ZVN0eWxlKCk7IC8vIGNoYW5nZSBvZiBzdGF0ZSA9PiBwb3NzaWJsZSBjaGFuZ2Ugb2Ygc3R5bGVcblxuICAgICAgY2hhbmdlZENvbGwuZW1pdChwYXJhbXMuZXZlbnQpO1xuXG4gICAgICBpZiAoYWRkbEV2ZW50cykge1xuICAgICAgICBjaGFuZ2VkQ29sbC5lbWl0KGFkZGxFdmVudHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkZWZpbmVTd2l0Y2hTZXQocGFyYW1zKSB7XG4gIGVsZXNmbiQzW3BhcmFtcy5maWVsZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICBpZiAocGFyYW1zLm92ZXJyaWRlRmllbGQpIHtcbiAgICAgICAgdmFyIHZhbCA9IHBhcmFtcy5vdmVycmlkZUZpZWxkKGVsZSk7XG5cbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlW3BhcmFtcy5maWVsZF07XG4gICAgfVxuICB9O1xuXG4gIGVsZXNmbiQzW3BhcmFtcy5vbl0gPSBkZWZpbmVTd2l0Y2hGdW5jdGlvbih7XG4gICAgZXZlbnQ6IHBhcmFtcy5vbixcbiAgICBmaWVsZDogcGFyYW1zLmZpZWxkLFxuICAgIGFibGVGaWVsZDogcGFyYW1zLmFibGVGaWVsZCxcbiAgICBvdmVycmlkZUFibGU6IHBhcmFtcy5vdmVycmlkZUFibGUsXG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIGVsZXNmbiQzW3BhcmFtcy5vZmZdID0gZGVmaW5lU3dpdGNoRnVuY3Rpb24oe1xuICAgIGV2ZW50OiBwYXJhbXMub2ZmLFxuICAgIGZpZWxkOiBwYXJhbXMuZmllbGQsXG4gICAgYWJsZUZpZWxkOiBwYXJhbXMuYWJsZUZpZWxkLFxuICAgIG92ZXJyaWRlQWJsZTogcGFyYW1zLm92ZXJyaWRlQWJsZSxcbiAgICB2YWx1ZTogZmFsc2VcbiAgfSk7XG59XG5cbmRlZmluZVN3aXRjaFNldCh7XG4gIGZpZWxkOiAnbG9ja2VkJyxcbiAgb3ZlcnJpZGVGaWVsZDogZnVuY3Rpb24gb3ZlcnJpZGVGaWVsZChlbGUpIHtcbiAgICByZXR1cm4gZWxlLmN5KCkuYXV0b2xvY2soKSA/IHRydWUgOiB1bmRlZmluZWQ7XG4gIH0sXG4gIG9uOiAnbG9jaycsXG4gIG9mZjogJ3VubG9jaydcbn0pO1xuZGVmaW5lU3dpdGNoU2V0KHtcbiAgZmllbGQ6ICdncmFiYmFibGUnLFxuICBvdmVycmlkZUZpZWxkOiBmdW5jdGlvbiBvdmVycmlkZUZpZWxkKGVsZSkge1xuICAgIHJldHVybiBlbGUuY3koKS5hdXRvdW5ncmFiaWZ5KCkgfHwgZWxlLnBhbm5hYmxlKCkgPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgfSxcbiAgb246ICdncmFiaWZ5JyxcbiAgb2ZmOiAndW5ncmFiaWZ5J1xufSk7XG5kZWZpbmVTd2l0Y2hTZXQoe1xuICBmaWVsZDogJ3NlbGVjdGVkJyxcbiAgYWJsZUZpZWxkOiAnc2VsZWN0YWJsZScsXG4gIG92ZXJyaWRlQWJsZTogZnVuY3Rpb24gb3ZlcnJpZGVBYmxlKGVsZSkge1xuICAgIHJldHVybiBlbGUuY3koKS5hdXRvdW5zZWxlY3RpZnkoKSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICB9LFxuICBvbjogJ3NlbGVjdCcsXG4gIG9mZjogJ3Vuc2VsZWN0J1xufSk7XG5kZWZpbmVTd2l0Y2hTZXQoe1xuICBmaWVsZDogJ3NlbGVjdGFibGUnLFxuICBvdmVycmlkZUZpZWxkOiBmdW5jdGlvbiBvdmVycmlkZUZpZWxkKGVsZSkge1xuICAgIHJldHVybiBlbGUuY3koKS5hdXRvdW5zZWxlY3RpZnkoKSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICB9LFxuICBvbjogJ3NlbGVjdGlmeScsXG4gIG9mZjogJ3Vuc2VsZWN0aWZ5J1xufSk7XG5lbGVzZm4kMy5kZXNlbGVjdCA9IGVsZXNmbiQzLnVuc2VsZWN0O1xuXG5lbGVzZm4kMy5ncmFiYmVkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlID0gdGhpc1swXTtcblxuICBpZiAoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5ncmFiYmVkO1xuICB9XG59O1xuXG5kZWZpbmVTd2l0Y2hTZXQoe1xuICBmaWVsZDogJ2FjdGl2ZScsXG4gIG9uOiAnYWN0aXZhdGUnLFxuICBvZmY6ICd1bmFjdGl2YXRlJ1xufSk7XG5kZWZpbmVTd2l0Y2hTZXQoe1xuICBmaWVsZDogJ3Bhbm5hYmxlJyxcbiAgb246ICdwYW5pZnknLFxuICBvZmY6ICd1bnBhbmlmeSdcbn0pO1xuXG5lbGVzZm4kMy5pbmFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgaWYgKGVsZSkge1xuICAgIHJldHVybiAhZWxlLl9wcml2YXRlLmFjdGl2ZTtcbiAgfVxufTtcblxudmFyIGVsZXNmbiQyID0ge307IC8vIERBRyBmdW5jdGlvbnNcbi8vLy8vLy8vLy8vLy8vLy9cblxudmFyIGRlZmluZURhZ0V4dHJlbWl0eSA9IGZ1bmN0aW9uIGRlZmluZURhZ0V4dHJlbWl0eShwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGRhZ0V4dHJlbWl0eUltcGwoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIHJldCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgaWYgKCFlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXNxdWFsaWZpZWQgPSBmYWxzZTtcbiAgICAgIHZhciBlZGdlcyA9IGVsZS5jb25uZWN0ZWRFZGdlcygpO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbal07XG4gICAgICAgIHZhciBzcmMgPSBlZGdlLnNvdXJjZSgpO1xuICAgICAgICB2YXIgdGd0ID0gZWRnZS50YXJnZXQoKTtcblxuICAgICAgICBpZiAocGFyYW1zLm5vSW5jb21pbmdFZGdlcyAmJiB0Z3QgPT09IGVsZSAmJiBzcmMgIT09IGVsZSB8fCBwYXJhbXMubm9PdXRnb2luZ0VkZ2VzICYmIHNyYyA9PT0gZWxlICYmIHRndCAhPT0gZWxlKSB7XG4gICAgICAgICAgZGlzcXVhbGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWRpc3F1YWxpZmllZCkge1xuICAgICAgICByZXQucHVzaChlbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKHJldCwgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfTtcbn07XG5cbnZhciBkZWZpbmVEYWdPbmVIb3AgPSBmdW5jdGlvbiBkZWZpbmVEYWdPbmVIb3AocGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIG9FbGVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgICBpZiAoIWVsZS5pc05vZGUoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVkZ2VzID0gZWxlLmNvbm5lY3RlZEVkZ2VzKCk7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tqXTtcbiAgICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKCk7XG4gICAgICAgIHZhciB0Z3QgPSBlZGdlLnRhcmdldCgpO1xuXG4gICAgICAgIGlmIChwYXJhbXMub3V0Z29pbmcgJiYgc3JjID09PSBlbGUpIHtcbiAgICAgICAgICBvRWxlcy5wdXNoKGVkZ2UpO1xuICAgICAgICAgIG9FbGVzLnB1c2godGd0KTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMuaW5jb21pbmcgJiYgdGd0ID09PSBlbGUpIHtcbiAgICAgICAgICBvRWxlcy5wdXNoKGVkZ2UpO1xuICAgICAgICAgIG9FbGVzLnB1c2goc3JjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKG9FbGVzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9O1xufTtcblxudmFyIGRlZmluZURhZ0FsbEhvcHMgPSBmdW5jdGlvbiBkZWZpbmVEYWdBbGxIb3BzKHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciBzRWxlcyA9IFtdO1xuICAgIHZhciBzRWxlc0lkcyA9IHt9O1xuXG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIG5leHQgPSBwYXJhbXMub3V0Z29pbmcgPyBlbGVzLm91dGdvZXJzKCkgOiBlbGVzLmluY29tZXJzKCk7XG5cbiAgICAgIGlmIChuZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gZG9uZSBpZiBub25lIGxlZnRcblxuXG4gICAgICB2YXIgbmV3TmV4dCA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG4gPSBuZXh0W2ldO1xuICAgICAgICB2YXIgbmlkID0gbi5pZCgpO1xuXG4gICAgICAgIGlmICghc0VsZXNJZHNbbmlkXSkge1xuICAgICAgICAgIHNFbGVzSWRzW25pZF0gPSB0cnVlO1xuICAgICAgICAgIHNFbGVzLnB1c2gobik7XG4gICAgICAgICAgbmV3TmV4dCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFuZXdOZXh0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBkb25lIGlmIHRvdWNoZWQgYWxsIG91dGdvZXJzIGFscmVhZHlcblxuXG4gICAgICBlbGVzID0gbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3bihzRWxlcywgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfTtcbn07XG5cbmVsZXNmbiQyLmNsZWFyVHJhdmVyc2FsQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXNbaV0uX3ByaXZhdGUudHJhdmVyc2FsQ2FjaGUgPSBudWxsO1xuICB9XG59O1xuXG5leHRlbmQoZWxlc2ZuJDIsIHtcbiAgLy8gZ2V0IHRoZSByb290IG5vZGVzIGluIHRoZSBEQUdcbiAgcm9vdHM6IGRlZmluZURhZ0V4dHJlbWl0eSh7XG4gICAgbm9JbmNvbWluZ0VkZ2VzOiB0cnVlXG4gIH0pLFxuICAvLyBnZXQgdGhlIGxlYWYgbm9kZXMgaW4gdGhlIERBR1xuICBsZWF2ZXM6IGRlZmluZURhZ0V4dHJlbWl0eSh7XG4gICAgbm9PdXRnb2luZ0VkZ2VzOiB0cnVlXG4gIH0pLFxuICAvLyBub3JtYWxseSBjYWxsZWQgY2hpbGRyZW4gaW4gZ3JhcGggdGhlb3J5XG4gIC8vIHRoZXNlIG5vZGVzID1lZGdlcz0+IG91dGdvaW5nIG5vZGVzXG4gIG91dGdvZXJzOiBjYWNoZShkZWZpbmVEYWdPbmVIb3Aoe1xuICAgIG91dGdvaW5nOiB0cnVlXG4gIH0pLCAnb3V0Z29lcnMnKSxcbiAgLy8gYWthIERBRyBkZXNjZW5kYW50c1xuICBzdWNjZXNzb3JzOiBkZWZpbmVEYWdBbGxIb3BzKHtcbiAgICBvdXRnb2luZzogdHJ1ZVxuICB9KSxcbiAgLy8gbm9ybWFsbHkgY2FsbGVkIHBhcmVudHMgaW4gZ3JhcGggdGhlb3J5XG4gIC8vIHRoZXNlIG5vZGVzIDw9ZWRnZXM9IGluY29taW5nIG5vZGVzXG4gIGluY29tZXJzOiBjYWNoZShkZWZpbmVEYWdPbmVIb3Aoe1xuICAgIGluY29taW5nOiB0cnVlXG4gIH0pLCAnaW5jb21lcnMnKSxcbiAgLy8gYWthIERBRyBhbmNlc3RvcnNcbiAgcHJlZGVjZXNzb3JzOiBkZWZpbmVEYWdBbGxIb3BzKHtcbiAgICBpbmNvbWluZzogdHJ1ZVxuICB9KVxufSk7IC8vIE5laWdoYm91cmhvb2QgZnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHRlbmQoZWxlc2ZuJDIsIHtcbiAgbmVpZ2hib3Job29kOiBjYWNoZShmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBmb3IgYWxsIG5vZGVzXG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gbm9kZS5jb25uZWN0ZWRFZGdlcygpOyAvLyBmb3IgZWFjaCBjb25uZWN0ZWQgZWRnZSwgYWRkIHRoZSBlZGdlIGFuZCB0aGUgb3RoZXIgbm9kZVxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbm5lY3RlZEVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBlZGdlID0gY29ubmVjdGVkRWRnZXNbal07XG4gICAgICAgIHZhciBzcmMgPSBlZGdlLnNvdXJjZSgpO1xuICAgICAgICB2YXIgdGd0ID0gZWRnZS50YXJnZXQoKTtcbiAgICAgICAgdmFyIG90aGVyTm9kZSA9IG5vZGUgPT09IHNyYyA/IHRndCA6IHNyYzsgLy8gbmVlZCBjaGVjayBpbiBjYXNlIG9mIGxvb3BcblxuICAgICAgICBpZiAob3RoZXJOb2RlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKG90aGVyTm9kZVswXSk7IC8vIGFkZCBub2RlIDEgaG9wIGF3YXlcbiAgICAgICAgfSAvLyBhZGQgY29ubmVjdGVkIGVkZ2VcblxuXG4gICAgICAgIGVsZW1lbnRzLnB1c2goZWRnZVswXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oZWxlbWVudHMsIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sICduZWlnaGJvcmhvb2QnKSxcbiAgY2xvc2VkTmVpZ2hib3Job29kOiBmdW5jdGlvbiBjbG9zZWROZWlnaGJvcmhvb2Qoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5uZWlnaGJvcmhvb2QoKS5hZGQodGhpcykuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgb3Blbk5laWdoYm9yaG9vZDogZnVuY3Rpb24gb3Blbk5laWdoYm9yaG9vZChzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLm5laWdoYm9yaG9vZChzZWxlY3Rvcik7XG4gIH1cbn0pOyAvLyBhbGlhc2VzXG5cbmVsZXNmbiQyLm5laWdoYm91cmhvb2QgPSBlbGVzZm4kMi5uZWlnaGJvcmhvb2Q7XG5lbGVzZm4kMi5jbG9zZWROZWlnaGJvdXJob29kID0gZWxlc2ZuJDIuY2xvc2VkTmVpZ2hib3Job29kO1xuZWxlc2ZuJDIub3Blbk5laWdoYm91cmhvb2QgPSBlbGVzZm4kMi5vcGVuTmVpZ2hib3Job29kOyAvLyBFZGdlIGZ1bmN0aW9uc1xuLy8vLy8vLy8vLy8vLy8vLy9cblxuZXh0ZW5kKGVsZXNmbiQyLCB7XG4gIHNvdXJjZTogY2FjaGUoZnVuY3Rpb24gc291cmNlSW1wbChzZWxlY3Rvcikge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBzcmM7XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICBzcmMgPSBlbGUuX3ByaXZhdGUuc291cmNlIHx8IGVsZS5jeSgpLmNvbGxlY3Rpb24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3JjICYmIHNlbGVjdG9yID8gc3JjLmZpbHRlcihzZWxlY3RvcikgOiBzcmM7XG4gIH0sICdzb3VyY2UnKSxcbiAgdGFyZ2V0OiBjYWNoZShmdW5jdGlvbiB0YXJnZXRJbXBsKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIHRndDtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHRndCA9IGVsZS5fcHJpdmF0ZS50YXJnZXQgfHwgZWxlLmN5KCkuY29sbGVjdGlvbigpO1xuICAgIH1cblxuICAgIHJldHVybiB0Z3QgJiYgc2VsZWN0b3IgPyB0Z3QuZmlsdGVyKHNlbGVjdG9yKSA6IHRndDtcbiAgfSwgJ3RhcmdldCcpLFxuICBzb3VyY2VzOiBkZWZpbmVTb3VyY2VGdW5jdGlvbih7XG4gICAgYXR0cjogJ3NvdXJjZSdcbiAgfSksXG4gIHRhcmdldHM6IGRlZmluZVNvdXJjZUZ1bmN0aW9uKHtcbiAgICBhdHRyOiAndGFyZ2V0J1xuICB9KVxufSk7XG5cbmZ1bmN0aW9uIGRlZmluZVNvdXJjZUZ1bmN0aW9uKHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24gc291cmNlSW1wbChzZWxlY3Rvcikge1xuICAgIHZhciBzb3VyY2VzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIHNyYyA9IGVsZS5fcHJpdmF0ZVtwYXJhbXMuYXR0cl07XG5cbiAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgc291cmNlcy5wdXNoKHNyYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oc291cmNlcywgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfTtcbn1cblxuZXh0ZW5kKGVsZXNmbiQyLCB7XG4gIGVkZ2VzV2l0aDogY2FjaGUoZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24oKSwgJ2VkZ2VzV2l0aCcpLFxuICBlZGdlc1RvOiBjYWNoZShkZWZpbmVFZGdlc1dpdGhGdW5jdGlvbih7XG4gICAgdGhpc0lzU3JjOiB0cnVlXG4gIH0pLCAnZWRnZXNUbycpXG59KTtcblxuZnVuY3Rpb24gZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24ocGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBlZGdlc1dpdGhJbXBsKG90aGVyTm9kZXMpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciBwID0gcGFyYW1zIHx8IHt9OyAvLyBnZXQgZWxlbWVudHMgaWYgYSBzZWxlY3RvciBpcyBzcGVjaWZpZWRcblxuICAgIGlmIChzdHJpbmcob3RoZXJOb2RlcykpIHtcbiAgICAgIG90aGVyTm9kZXMgPSBjeS4kKG90aGVyTm9kZXMpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGggPSAwOyBoIDwgb3RoZXJOb2Rlcy5sZW5ndGg7IGgrKykge1xuICAgICAgdmFyIGVkZ2VzID0gb3RoZXJOb2Rlc1toXS5fcHJpdmF0ZS5lZGdlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgICAgICB2YXIgZWRnZURhdGEgPSBlZGdlLl9wcml2YXRlLmRhdGE7XG4gICAgICAgIHZhciB0aGlzVG9PdGhlciA9IHRoaXMuaGFzRWxlbWVudFdpdGhJZChlZGdlRGF0YS5zb3VyY2UpICYmIG90aGVyTm9kZXMuaGFzRWxlbWVudFdpdGhJZChlZGdlRGF0YS50YXJnZXQpO1xuICAgICAgICB2YXIgb3RoZXJUb1RoaXMgPSBvdGhlck5vZGVzLmhhc0VsZW1lbnRXaXRoSWQoZWRnZURhdGEuc291cmNlKSAmJiB0aGlzLmhhc0VsZW1lbnRXaXRoSWQoZWRnZURhdGEudGFyZ2V0KTtcbiAgICAgICAgdmFyIGVkZ2VDb25uZWN0c1RoaXNBbmRPdGhlciA9IHRoaXNUb090aGVyIHx8IG90aGVyVG9UaGlzO1xuXG4gICAgICAgIGlmICghZWRnZUNvbm5lY3RzVGhpc0FuZE90aGVyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocC50aGlzSXNTcmMgfHwgcC50aGlzSXNUZ3QpIHtcbiAgICAgICAgICBpZiAocC50aGlzSXNTcmMgJiYgIXRoaXNUb090aGVyKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocC50aGlzSXNUZ3QgJiYgIW90aGVyVG9UaGlzKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50cy5wdXNoKGVkZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKGVsZW1lbnRzLCB0cnVlKTtcbiAgfTtcbn1cblxuZXh0ZW5kKGVsZXNmbiQyLCB7XG4gIGNvbm5lY3RlZEVkZ2VzOiBjYWNoZShmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICB2YXIgcmV0RWxlcyA9IFtdO1xuICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBlbGVzW2ldO1xuXG4gICAgICBpZiAoIW5vZGUuaXNOb2RlKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBlZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tqXTtcbiAgICAgICAgcmV0RWxlcy5wdXNoKGVkZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKHJldEVsZXMsIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sICdjb25uZWN0ZWRFZGdlcycpLFxuICBjb25uZWN0ZWROb2RlczogY2FjaGUoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgdmFyIHJldEVsZXMgPSBbXTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlZGdlID0gZWxlc1tpXTtcblxuICAgICAgaWYgKCFlZGdlLmlzRWRnZSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICByZXRFbGVzLnB1c2goZWRnZS5zb3VyY2UoKVswXSk7XG4gICAgICByZXRFbGVzLnB1c2goZWRnZS50YXJnZXQoKVswXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24ocmV0RWxlcywgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSwgJ2Nvbm5lY3RlZE5vZGVzJyksXG4gIHBhcmFsbGVsRWRnZXM6IGNhY2hlKGRlZmluZVBhcmFsbGVsRWRnZXNGdW5jdGlvbigpLCAncGFyYWxsZWxFZGdlcycpLFxuICBjb2RpcmVjdGVkRWRnZXM6IGNhY2hlKGRlZmluZVBhcmFsbGVsRWRnZXNGdW5jdGlvbih7XG4gICAgY29kaXJlY3RlZDogdHJ1ZVxuICB9KSwgJ2NvZGlyZWN0ZWRFZGdlcycpXG59KTtcblxuZnVuY3Rpb24gZGVmaW5lUGFyYWxsZWxFZGdlc0Z1bmN0aW9uKHBhcmFtcykge1xuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgY29kaXJlY3RlZDogZmFsc2VcbiAgfTtcbiAgcGFyYW1zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHBhcmFsbGVsRWRnZXNJbXBsKHNlbGVjdG9yKSB7XG4gICAgLy8gbWljcm8tb3B0aW1pc2VkIGZvciByZW5kZXJlclxuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKTtcbiAgICB2YXIgcCA9IHBhcmFtczsgLy8gbG9vayBhdCBhbGwgdGhlIGVkZ2VzIGluIHRoZSBjb2xsZWN0aW9uXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWRnZTEgPSBlZGdlc1tpXTtcbiAgICAgIHZhciBlZGdlMV9wID0gZWRnZTEuX3ByaXZhdGU7XG4gICAgICB2YXIgc3JjMSA9IGVkZ2UxX3Auc291cmNlO1xuICAgICAgdmFyIHNyY2lkMSA9IHNyYzEuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgIHZhciB0Z3RpZDEgPSBlZGdlMV9wLmRhdGEudGFyZ2V0O1xuICAgICAgdmFyIHNyY0VkZ2VzMSA9IHNyYzEuX3ByaXZhdGUuZWRnZXM7IC8vIGxvb2sgYXQgZWRnZXMgY29ubmVjdGVkIHRvIHRoZSBzcmMgbm9kZSBvZiB0aGlzIGVkZ2VcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzcmNFZGdlczEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGVkZ2UyID0gc3JjRWRnZXMxW2pdO1xuICAgICAgICB2YXIgZWRnZTJkYXRhID0gZWRnZTIuX3ByaXZhdGUuZGF0YTtcbiAgICAgICAgdmFyIHRndGlkMiA9IGVkZ2UyZGF0YS50YXJnZXQ7XG4gICAgICAgIHZhciBzcmNpZDIgPSBlZGdlMmRhdGEuc291cmNlO1xuICAgICAgICB2YXIgY29kaXJlY3RlZCA9IHRndGlkMiA9PT0gdGd0aWQxICYmIHNyY2lkMiA9PT0gc3JjaWQxO1xuICAgICAgICB2YXIgb3BwZGlyZWN0ZWQgPSBzcmNpZDEgPT09IHRndGlkMiAmJiB0Z3RpZDEgPT09IHNyY2lkMjtcblxuICAgICAgICBpZiAocC5jb2RpcmVjdGVkICYmIGNvZGlyZWN0ZWQgfHwgIXAuY29kaXJlY3RlZCAmJiAoY29kaXJlY3RlZCB8fCBvcHBkaXJlY3RlZCkpIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVkZ2UyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKGVsZW1lbnRzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9O1xufSAvLyBNaXNjIGZ1bmN0aW9uc1xuLy8vLy8vLy8vLy8vLy8vLy9cblxuXG5leHRlbmQoZWxlc2ZuJDIsIHtcbiAgY29tcG9uZW50czogZnVuY3Rpb24gY29tcG9uZW50cyhyb290KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjeSA9IHNlbGYuY3koKTtcbiAgICB2YXIgdmlzaXRlZCA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICB2YXIgdW52aXNpdGVkID0gcm9vdCA9PSBudWxsID8gc2VsZi5ub2RlcygpIDogcm9vdC5ub2RlcygpO1xuICAgIHZhciBjb21wb25lbnRzID0gW107XG5cbiAgICBpZiAocm9vdCAhPSBudWxsICYmIHVudmlzaXRlZC5lbXB0eSgpKSB7XG4gICAgICAvLyByb290IG1heSBjb250YWluIG9ubHkgZWRnZXNcbiAgICAgIHVudmlzaXRlZCA9IHJvb3Quc291cmNlcygpOyAvLyBkb2Vzbid0IG1hdHRlciB3aGljaCBub2RlIHRvIHVzZSAodW5kaXJlY3RlZCksIHNvIGp1c3QgdXNlIHRoZSBzb3VyY2Ugc2lkZXNcbiAgICB9XG5cbiAgICB2YXIgdmlzaXRJbkNvbXBvbmVudCA9IGZ1bmN0aW9uIHZpc2l0SW5Db21wb25lbnQobm9kZSwgY29tcG9uZW50KSB7XG4gICAgICB2aXNpdGVkLm1lcmdlKG5vZGUpO1xuICAgICAgdW52aXNpdGVkLnVubWVyZ2Uobm9kZSk7XG4gICAgICBjb21wb25lbnQubWVyZ2Uobm9kZSk7XG4gICAgfTtcblxuICAgIGlmICh1bnZpc2l0ZWQuZW1wdHkoKSkge1xuICAgICAgcmV0dXJuIHNlbGYuc3Bhd24oKTtcbiAgICB9XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIC8vIGVhY2ggaXRlcmF0aW9uIHlpZWxkcyBhIGNvbXBvbmVudFxuICAgICAgdmFyIGNtcHQgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICBjb21wb25lbnRzLnB1c2goY21wdCk7XG4gICAgICB2YXIgcm9vdCA9IHVudmlzaXRlZFswXTtcbiAgICAgIHZpc2l0SW5Db21wb25lbnQocm9vdCwgY21wdCk7XG4gICAgICBzZWxmLmJmcyh7XG4gICAgICAgIGRpcmVjdGVkOiBmYWxzZSxcbiAgICAgICAgcm9vdHM6IHJvb3QsXG4gICAgICAgIHZpc2l0OiBmdW5jdGlvbiB2aXNpdCh2KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0SW5Db21wb25lbnQodiwgY21wdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY21wdC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIG5vZGUuY29ubmVjdGVkRWRnZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgLy8gY29ubmVjdGVkRWRnZXMoKSB1c3VhbGx5IGNhY2hlZFxuICAgICAgICAgIGlmIChzZWxmLmhhcyhlKSAmJiBjbXB0LmhhcyhlLnNvdXJjZSgpKSAmJiBjbXB0LmhhcyhlLnRhcmdldCgpKSkge1xuICAgICAgICAgICAgLy8gaGFzKCkgaXMgY2hlYXBcbiAgICAgICAgICAgIGNtcHQubWVyZ2UoZSk7IC8vIGZvckVhY2goKSBvbmx5IGNvbnNpZGVycyBub2RlcyAtLSBzZXRzIE4gYXQgY2FsbCB0aW1lXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBkbyB7XG4gICAgICBfbG9vcCgpO1xuICAgIH0gd2hpbGUgKHVudmlzaXRlZC5sZW5ndGggPiAwKTtcblxuICAgIHJldHVybiBjb21wb25lbnRzO1xuICB9LFxuICBjb21wb25lbnQ6IGZ1bmN0aW9uIGNvbXBvbmVudCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICByZXR1cm4gZWxlLmN5KCkubXV0YWJsZUVsZW1lbnRzKCkuY29tcG9uZW50cyhlbGUpWzBdO1xuICB9XG59KTtcbmVsZXNmbiQyLmNvbXBvbmVudHNPZiA9IGVsZXNmbiQyLmNvbXBvbmVudHM7XG5cbnZhciBDb2xsZWN0aW9uID0gZnVuY3Rpb24gQ29sbGVjdGlvbihjeSwgZWxlbWVudHMpIHtcbiAgdmFyIHVuaXF1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gIHZhciByZW1vdmVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcblxuICBpZiAoY3kgPT09IHVuZGVmaW5lZCkge1xuICAgIGVycm9yKCdBIGNvbGxlY3Rpb24gbXVzdCBoYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBjb3JlJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1hcCA9IG5ldyBNYXAkMSgpO1xuICB2YXIgY3JlYXRlZEVsZW1lbnRzID0gZmFsc2U7XG5cbiAgaWYgKCFlbGVtZW50cykge1xuICAgIGVsZW1lbnRzID0gW107XG4gIH0gZWxzZSBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCAmJiBwbGFpbk9iamVjdChlbGVtZW50c1swXSkgJiYgIWVsZW1lbnQoZWxlbWVudHNbMF0pKSB7XG4gICAgY3JlYXRlZEVsZW1lbnRzID0gdHJ1ZTsgLy8gbWFrZSBlbGVtZW50cyBmcm9tIGpzb24gYW5kIHJlc3RvcmUgYWxsIGF0IG9uY2UgbGF0ZXJcblxuICAgIHZhciBlbGVzID0gW107XG4gICAgdmFyIGVsZXNJZHMgPSBuZXcgU2V0JDEoKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIganNvbiA9IGVsZW1lbnRzW2ldO1xuXG4gICAgICBpZiAoanNvbi5kYXRhID09IG51bGwpIHtcbiAgICAgICAganNvbi5kYXRhID0ge307XG4gICAgICB9XG5cbiAgICAgIHZhciBfZGF0YSA9IGpzb24uZGF0YTsgLy8gbWFrZSBzdXJlIG5ld2x5IGNyZWF0ZWQgZWxlbWVudHMgaGF2ZSB2YWxpZCBpZHNcblxuICAgICAgaWYgKF9kYXRhLmlkID09IG51bGwpIHtcbiAgICAgICAgX2RhdGEuaWQgPSB1dWlkKCk7XG4gICAgICB9IGVsc2UgaWYgKGN5Lmhhc0VsZW1lbnRXaXRoSWQoX2RhdGEuaWQpIHx8IGVsZXNJZHMuaGFzKF9kYXRhLmlkKSkge1xuICAgICAgICBjb250aW51ZTsgLy8gY2FuJ3QgY3JlYXRlIGVsZW1lbnQgaWYgcHJpb3IgaWQgYWxyZWFkeSBleGlzdHNcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZSA9IG5ldyBFbGVtZW50KGN5LCBqc29uLCBmYWxzZSk7XG4gICAgICBlbGVzLnB1c2goZWxlKTtcbiAgICAgIGVsZXNJZHMuYWRkKF9kYXRhLmlkKTtcbiAgICB9XG5cbiAgICBlbGVtZW50cyA9IGVsZXM7XG4gIH1cblxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgZm9yICh2YXIgX2kgPSAwLCBfbCA9IGVsZW1lbnRzLmxlbmd0aDsgX2kgPCBfbDsgX2krKykge1xuICAgIHZhciBlbGVtZW50JDEgPSBlbGVtZW50c1tfaV1bMF07IC8vIFswXSBpbiBjYXNlIGVsZW1lbnRzIGlzIGFuIGFycmF5IG9mIGNvbGxlY3Rpb25zLCByYXRoZXIgdGhhbiBhcnJheSBvZiBlbGVtZW50c1xuXG4gICAgaWYgKGVsZW1lbnQkMSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgaWQgPSBlbGVtZW50JDEuX3ByaXZhdGUuZGF0YS5pZDtcblxuICAgIGlmICghdW5pcXVlIHx8ICFtYXAuaGFzKGlkKSkge1xuICAgICAgaWYgKHVuaXF1ZSkge1xuICAgICAgICBtYXAuc2V0KGlkLCB7XG4gICAgICAgICAgaW5kZXg6IHRoaXMubGVuZ3RoLFxuICAgICAgICAgIGVsZTogZWxlbWVudCQxXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzW3RoaXMubGVuZ3RoXSA9IGVsZW1lbnQkMTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICBlbGVzOiB0aGlzLFxuICAgIGN5OiBjeSxcblxuICAgIGdldCBtYXAoKSB7XG4gICAgICBpZiAodGhpcy5sYXp5TWFwID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5yZWJ1aWxkTWFwKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmxhenlNYXA7XG4gICAgfSxcblxuICAgIHNldCBtYXAobSkge1xuICAgICAgdGhpcy5sYXp5TWFwID0gbTtcbiAgICB9LFxuXG4gICAgcmVidWlsZE1hcDogZnVuY3Rpb24gcmVidWlsZE1hcCgpIHtcbiAgICAgIHZhciBtID0gdGhpcy5sYXp5TWFwID0gbmV3IE1hcCQxKCk7XG4gICAgICB2YXIgZWxlcyA9IHRoaXMuZWxlcztcblxuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgZWxlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciBfZWxlID0gZWxlc1tfaTJdO1xuICAgICAgICBtLnNldChfZWxlLmlkKCksIHtcbiAgICAgICAgICBpbmRleDogX2kyLFxuICAgICAgICAgIGVsZTogX2VsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaWYgKHVuaXF1ZSkge1xuICAgIHRoaXMuX3ByaXZhdGUubWFwID0gbWFwO1xuICB9IC8vIHJlc3RvcmUgdGhlIGVsZW1lbnRzIGlmIHdlIGNyZWF0ZWQgdGhlbSBmcm9tIGpzb25cblxuXG4gIGlmIChjcmVhdGVkRWxlbWVudHMgJiYgIXJlbW92ZWQpIHtcbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgfVxufTsgLy8gRnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBrZWVwIHRoZSBwcm90b3R5cGVzIGluIHN5bmMgKGFuIGVsZW1lbnQgaGFzIHRoZSBzYW1lIGZ1bmN0aW9ucyBhcyBhIGNvbGxlY3Rpb24pXG4vLyBhbmQgdXNlIGVsZWZuIGFuZCBlbGVzZm4gYXMgc2hvcnRoYW5kcyB0byB0aGUgcHJvdG90eXBlc1xuXG5cbnZhciBlbGVzZm4kMSA9IEVsZW1lbnQucHJvdG90eXBlID0gQ29sbGVjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFycmF5LnByb3RvdHlwZSk7XG5cbmVsZXNmbiQxLmluc3RhbmNlU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ2NvbGxlY3Rpb24nO1xufTtcblxuZWxlc2ZuJDEuc3Bhd24gPSBmdW5jdGlvbiAoZWxlcywgdW5pcXVlKSB7XG4gIHJldHVybiBuZXcgQ29sbGVjdGlvbih0aGlzLmN5KCksIGVsZXMsIHVuaXF1ZSk7XG59O1xuXG5lbGVzZm4kMS5zcGF3blNlbGYgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNwYXduKHRoaXMpO1xufTtcblxuZWxlc2ZuJDEuY3kgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9wcml2YXRlLmN5O1xufTtcblxuZWxlc2ZuJDEucmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9wcml2YXRlLmN5LnJlbmRlcmVyKCk7XG59O1xuXG5lbGVzZm4kMS5lbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpc1swXTtcbn07XG5cbmVsZXNmbiQxLmNvbGxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChjb2xsZWN0aW9uKHRoaXMpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gZWxzZSB7XG4gICAgLy8gYW4gZWxlbWVudFxuICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbih0aGlzLl9wcml2YXRlLmN5LCBbdGhpc10pO1xuICB9XG59O1xuXG5lbGVzZm4kMS51bmlxdWUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgQ29sbGVjdGlvbih0aGlzLl9wcml2YXRlLmN5LCB0aGlzLCB0cnVlKTtcbn07XG5cbmVsZXNmbiQxLmhhc0VsZW1lbnRXaXRoSWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgaWQgPSAnJyArIGlkOyAvLyBpZCBtdXN0IGJlIHN0cmluZ1xuXG4gIHJldHVybiB0aGlzLl9wcml2YXRlLm1hcC5oYXMoaWQpO1xufTtcblxuZWxlc2ZuJDEuZ2V0RWxlbWVudEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgaWQgPSAnJyArIGlkOyAvLyBpZCBtdXN0IGJlIHN0cmluZ1xuXG4gIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgdmFyIGVudHJ5ID0gdGhpcy5fcHJpdmF0ZS5tYXAuZ2V0KGlkKTtcblxuICByZXR1cm4gZW50cnkgPyBlbnRyeS5lbGUgOiBuZXcgQ29sbGVjdGlvbihjeSk7IC8vIGdldCBlbGUgb3IgZW1wdHkgY29sbGVjdGlvblxufTtcblxuZWxlc2ZuJDEuJGlkID0gZWxlc2ZuJDEuZ2V0RWxlbWVudEJ5SWQ7XG5cbmVsZXNmbiQxLnBvb2xJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgdmFyIGVsZXMgPSBjeS5fcHJpdmF0ZS5lbGVtZW50cztcbiAgdmFyIGlkID0gdGhpc1swXS5fcHJpdmF0ZS5kYXRhLmlkO1xuICByZXR1cm4gZWxlcy5fcHJpdmF0ZS5tYXAuZ2V0KGlkKS5pbmRleDtcbn07XG5cbmVsZXNmbiQxLmluZGV4T2YgPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHZhciBpZCA9IGVsZVswXS5fcHJpdmF0ZS5kYXRhLmlkO1xuICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5tYXAuZ2V0KGlkKS5pbmRleDtcbn07XG5cbmVsZXNmbiQxLmluZGV4T2ZJZCA9IGZ1bmN0aW9uIChpZCkge1xuICBpZCA9ICcnICsgaWQ7IC8vIGlkIG11c3QgYmUgc3RyaW5nXG5cbiAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubWFwLmdldChpZCkuaW5kZXg7XG59O1xuXG5lbGVzZm4kMS5qc29uID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgZWxlID0gdGhpcy5lbGVtZW50KCk7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICBpZiAoZWxlID09IG51bGwgJiYgb2JqKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gY2FuJ3Qgc2V0IHRvIG5vIGVsZXNcblxuXG4gIGlmIChlbGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gLy8gY2FuJ3QgZ2V0IGZyb20gbm8gZWxlc1xuXG5cbiAgdmFyIHAgPSBlbGUuX3ByaXZhdGU7XG5cbiAgaWYgKHBsYWluT2JqZWN0KG9iaikpIHtcbiAgICAvLyBzZXRcbiAgICBjeS5zdGFydEJhdGNoKCk7XG5cbiAgICBpZiAob2JqLmRhdGEpIHtcbiAgICAgIGVsZS5kYXRhKG9iai5kYXRhKTtcbiAgICAgIHZhciBfZGF0YTIgPSBwLmRhdGE7XG5cbiAgICAgIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICAgICAgLy8gc291cmNlIGFuZCB0YXJnZXQgYXJlIGltbXV0YWJsZSB2aWEgZGF0YSgpXG4gICAgICAgIHZhciBtb3ZlID0gZmFsc2U7XG4gICAgICAgIHZhciBzcGVjID0ge307XG4gICAgICAgIHZhciBzcmMgPSBvYmouZGF0YS5zb3VyY2U7XG4gICAgICAgIHZhciB0Z3QgPSBvYmouZGF0YS50YXJnZXQ7XG5cbiAgICAgICAgaWYgKHNyYyAhPSBudWxsICYmIHNyYyAhPSBfZGF0YTIuc291cmNlKSB7XG4gICAgICAgICAgc3BlYy5zb3VyY2UgPSAnJyArIHNyYzsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcblxuICAgICAgICAgIG1vdmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRndCAhPSBudWxsICYmIHRndCAhPSBfZGF0YTIudGFyZ2V0KSB7XG4gICAgICAgICAgc3BlYy50YXJnZXQgPSAnJyArIHRndDsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcblxuICAgICAgICAgIG1vdmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vdmUpIHtcbiAgICAgICAgICBlbGUgPSBlbGUubW92ZShzcGVjKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcGFyZW50IGlzIGltbXV0YWJsZSB2aWEgZGF0YSgpXG4gICAgICAgIHZhciBuZXdQYXJlbnRWYWxTcGVjZCA9ICgncGFyZW50JyBpbiBvYmouZGF0YSk7XG4gICAgICAgIHZhciBwYXJlbnQgPSBvYmouZGF0YS5wYXJlbnQ7XG5cbiAgICAgICAgaWYgKG5ld1BhcmVudFZhbFNwZWNkICYmIChwYXJlbnQgIT0gbnVsbCB8fCBfZGF0YTIucGFyZW50ICE9IG51bGwpICYmIHBhcmVudCAhPSBfZGF0YTIucGFyZW50KSB7XG4gICAgICAgICAgaWYgKHBhcmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBjYW4ndCBzZXQgdW5kZWZpbmVkIGltcGVyYXRpdmVseSwgc28gdXNlIG51bGxcbiAgICAgICAgICAgIHBhcmVudCA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSAnJyArIHBhcmVudDsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbGUgPSBlbGUubW92ZSh7XG4gICAgICAgICAgICBwYXJlbnQ6IHBhcmVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9iai5wb3NpdGlvbikge1xuICAgICAgZWxlLnBvc2l0aW9uKG9iai5wb3NpdGlvbik7XG4gICAgfSAvLyBpZ25vcmUgZ3JvdXAgLS0gaW1tdXRhYmxlXG5cblxuICAgIHZhciBjaGVja1N3aXRjaCA9IGZ1bmN0aW9uIGNoZWNrU3dpdGNoKGssIHRydWVGbk5hbWUsIGZhbHNlRm5OYW1lKSB7XG4gICAgICB2YXIgb2JqX2sgPSBvYmpba107XG5cbiAgICAgIGlmIChvYmpfayAhPSBudWxsICYmIG9ial9rICE9PSBwW2tdKSB7XG4gICAgICAgIGlmIChvYmpfaykge1xuICAgICAgICAgIGVsZVt0cnVlRm5OYW1lXSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZVtmYWxzZUZuTmFtZV0oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjaGVja1N3aXRjaCgncmVtb3ZlZCcsICdyZW1vdmUnLCAncmVzdG9yZScpO1xuICAgIGNoZWNrU3dpdGNoKCdzZWxlY3RlZCcsICdzZWxlY3QnLCAndW5zZWxlY3QnKTtcbiAgICBjaGVja1N3aXRjaCgnc2VsZWN0YWJsZScsICdzZWxlY3RpZnknLCAndW5zZWxlY3RpZnknKTtcbiAgICBjaGVja1N3aXRjaCgnbG9ja2VkJywgJ2xvY2snLCAndW5sb2NrJyk7XG4gICAgY2hlY2tTd2l0Y2goJ2dyYWJiYWJsZScsICdncmFiaWZ5JywgJ3VuZ3JhYmlmeScpO1xuICAgIGNoZWNrU3dpdGNoKCdwYW5uYWJsZScsICdwYW5pZnknLCAndW5wYW5pZnknKTtcblxuICAgIGlmIChvYmouY2xhc3NlcyAhPSBudWxsKSB7XG4gICAgICBlbGUuY2xhc3NlcyhvYmouY2xhc3Nlcyk7XG4gICAgfVxuXG4gICAgY3kuZW5kQmF0Y2goKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGdldFxuICAgIHZhciBqc29uID0ge1xuICAgICAgZGF0YTogY29weShwLmRhdGEpLFxuICAgICAgcG9zaXRpb246IGNvcHkocC5wb3NpdGlvbiksXG4gICAgICBncm91cDogcC5ncm91cCxcbiAgICAgIHJlbW92ZWQ6IHAucmVtb3ZlZCxcbiAgICAgIHNlbGVjdGVkOiBwLnNlbGVjdGVkLFxuICAgICAgc2VsZWN0YWJsZTogcC5zZWxlY3RhYmxlLFxuICAgICAgbG9ja2VkOiBwLmxvY2tlZCxcbiAgICAgIGdyYWJiYWJsZTogcC5ncmFiYmFibGUsXG4gICAgICBwYW5uYWJsZTogcC5wYW5uYWJsZSxcbiAgICAgIGNsYXNzZXM6IG51bGxcbiAgICB9O1xuICAgIGpzb24uY2xhc3NlcyA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICBwLmNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7XG4gICAgICByZXR1cm4ganNvbi5jbGFzc2VzICs9IGkrKyA9PT0gMCA/IGNscyA6ICcgJyArIGNscztcbiAgICB9KTtcbiAgICByZXR1cm4ganNvbjtcbiAgfVxufTtcblxuZWxlc2ZuJDEuanNvbnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBqc29ucyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgIHZhciBqc29uID0gZWxlLmpzb24oKTtcbiAgICBqc29ucy5wdXNoKGpzb24pO1xuICB9XG5cbiAgcmV0dXJuIGpzb25zO1xufTtcblxuZWxlc2ZuJDEuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgdmFyIGVsZXNBcnIgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICB2YXIganNvbiA9IGVsZS5qc29uKCk7XG4gICAgdmFyIGNsb25lID0gbmV3IEVsZW1lbnQoY3ksIGpzb24sIGZhbHNlKTsgLy8gTkIgbm8gcmVzdG9yZVxuXG4gICAgZWxlc0Fyci5wdXNoKGNsb25lKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgQ29sbGVjdGlvbihjeSwgZWxlc0Fycik7XG59O1xuXG5lbGVzZm4kMS5jb3B5ID0gZWxlc2ZuJDEuY2xvbmU7XG5cbmVsZXNmbiQxLnJlc3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub3RpZnlSZW5kZXJlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgdmFyIGFkZFRvUG9vbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY3kgPSBzZWxmLmN5KCk7XG4gIHZhciBjeV9wID0gY3kuX3ByaXZhdGU7IC8vIGNyZWF0ZSBhcnJheXMgb2Ygbm9kZXMgYW5kIGVkZ2VzLCBzaW5jZSB3ZSBuZWVkIHRvXG4gIC8vIHJlc3RvcmUgdGhlIG5vZGVzIGZpcnN0XG5cbiAgdmFyIG5vZGVzID0gW107XG4gIHZhciBlZGdlcyA9IFtdO1xuICB2YXIgZWxlbWVudHM7XG5cbiAgZm9yICh2YXIgX2kzID0gMCwgbCA9IHNlbGYubGVuZ3RoOyBfaTMgPCBsOyBfaTMrKykge1xuICAgIHZhciBlbGUgPSBzZWxmW19pM107XG5cbiAgICBpZiAoYWRkVG9Qb29sICYmICFlbGUucmVtb3ZlZCgpKSB7XG4gICAgICAvLyBkb24ndCBuZWVkIHRvIGhhbmRsZSB0aGlzIGVsZVxuICAgICAgY29udGludWU7XG4gICAgfSAvLyBrZWVwIG5vZGVzIGZpcnN0IGluIHRoZSBhcnJheSBhbmQgZWRnZXMgYWZ0ZXJcblxuXG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgLy8gcHV0IHRvIGZyb250IG9mIGFycmF5IGlmIG5vZGVcbiAgICAgIG5vZGVzLnB1c2goZWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcHV0IHRvIGVuZCBvZiBhcnJheSBpZiBlZGdlXG4gICAgICBlZGdlcy5wdXNoKGVsZSk7XG4gICAgfVxuICB9XG5cbiAgZWxlbWVudHMgPSBub2Rlcy5jb25jYXQoZWRnZXMpO1xuICB2YXIgaTtcblxuICB2YXIgcmVtb3ZlRnJvbUVsZW1lbnRzID0gZnVuY3Rpb24gcmVtb3ZlRnJvbUVsZW1lbnRzKCkge1xuICAgIGVsZW1lbnRzLnNwbGljZShpLCAxKTtcbiAgICBpLS07XG4gIH07IC8vIG5vdywgcmVzdG9yZSBlYWNoIGVsZW1lbnRcblxuXG4gIGZvciAoaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfZWxlMiA9IGVsZW1lbnRzW2ldO1xuICAgIHZhciBfcHJpdmF0ZSA9IF9lbGUyLl9wcml2YXRlO1xuICAgIHZhciBfZGF0YTMgPSBfcHJpdmF0ZS5kYXRhOyAvLyB0aGUgdHJhdmVyc2FsIGNhY2hlIHNob3VsZCBzdGFydCBmcmVzaCB3aGVuIGVsZSBpcyBhZGRlZFxuXG4gICAgX2VsZTIuY2xlYXJUcmF2ZXJzYWxDYWNoZSgpOyAvLyBzZXQgaWQgYW5kIHZhbGlkYXRlXG5cblxuICAgIGlmICghYWRkVG9Qb29sICYmICFfcHJpdmF0ZS5yZW1vdmVkKSA7IGVsc2UgaWYgKF9kYXRhMy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBfZGF0YTMuaWQgPSB1dWlkKCk7XG4gICAgfSBlbHNlIGlmIChudW1iZXIkMShfZGF0YTMuaWQpKSB7XG4gICAgICBfZGF0YTMuaWQgPSAnJyArIF9kYXRhMy5pZDsgLy8gbm93IGl0J3MgYSBzdHJpbmdcbiAgICB9IGVsc2UgaWYgKGVtcHR5U3RyaW5nKF9kYXRhMy5pZCkgfHwgIXN0cmluZyhfZGF0YTMuaWQpKSB7XG4gICAgICBlcnJvcignQ2FuIG5vdCBjcmVhdGUgZWxlbWVudCB3aXRoIGludmFsaWQgc3RyaW5nIElEIGAnICsgX2RhdGEzLmlkICsgJ2AnKTsgLy8gY2FuJ3QgY3JlYXRlIGVsZW1lbnQgaWYgaXQgaGFzIGVtcHR5IHN0cmluZyBhcyBpZCBvciBub24tc3RyaW5nIGlkXG5cbiAgICAgIHJlbW92ZUZyb21FbGVtZW50cygpO1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChjeS5oYXNFbGVtZW50V2l0aElkKF9kYXRhMy5pZCkpIHtcbiAgICAgIGVycm9yKCdDYW4gbm90IGNyZWF0ZSBzZWNvbmQgZWxlbWVudCB3aXRoIElEIGAnICsgX2RhdGEzLmlkICsgJ2AnKTsgLy8gY2FuJ3QgY3JlYXRlIGVsZW1lbnQgaWYgb25lIGFscmVhZHkgaGFzIHRoYXQgaWRcblxuICAgICAgcmVtb3ZlRnJvbUVsZW1lbnRzKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgaWQgPSBfZGF0YTMuaWQ7IC8vIGlkIGlzIGZpbmFsaXNlZCwgbm93IGxldCdzIGtlZXAgYSByZWZcblxuICAgIGlmIChfZWxlMi5pc05vZGUoKSkge1xuICAgICAgLy8gZXh0cmEgY2hlY2tzIGZvciBub2Rlc1xuICAgICAgdmFyIHBvcyA9IF9wcml2YXRlLnBvc2l0aW9uOyAvLyBtYWtlIHN1cmUgdGhlIG5vZGVzIGhhdmUgYSBkZWZpbmVkIHBvc2l0aW9uXG5cbiAgICAgIGlmIChwb3MueCA9PSBudWxsKSB7XG4gICAgICAgIHBvcy54ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvcy55ID09IG51bGwpIHtcbiAgICAgICAgcG9zLnkgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChfZWxlMi5pc0VkZ2UoKSkge1xuICAgICAgLy8gZXh0cmEgY2hlY2tzIGZvciBlZGdlc1xuICAgICAgdmFyIGVkZ2UgPSBfZWxlMjtcbiAgICAgIHZhciBmaWVsZHMgPSBbJ3NvdXJjZScsICd0YXJnZXQnXTtcbiAgICAgIHZhciBmaWVsZHNMZW5ndGggPSBmaWVsZHMubGVuZ3RoO1xuICAgICAgdmFyIGJhZFNvdXJjZU9yVGFyZ2V0ID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmllbGRzTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2pdO1xuICAgICAgICB2YXIgdmFsID0gX2RhdGEzW2ZpZWxkXTtcblxuICAgICAgICBpZiAobnVtYmVyJDEodmFsKSkge1xuICAgICAgICAgIHZhbCA9IF9kYXRhM1tmaWVsZF0gPSAnJyArIF9kYXRhM1tmaWVsZF07IC8vIG5vdyBzdHJpbmdcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCB8fCB2YWwgPT09ICcnKSB7XG4gICAgICAgICAgLy8gY2FuJ3QgY3JlYXRlIGlmIHNvdXJjZSBvciB0YXJnZXQgaXMgbm90IGRlZmluZWQgcHJvcGVybHlcbiAgICAgICAgICBlcnJvcignQ2FuIG5vdCBjcmVhdGUgZWRnZSBgJyArIGlkICsgJ2Agd2l0aCB1bnNwZWNpZmllZCAnICsgZmllbGQpO1xuICAgICAgICAgIGJhZFNvdXJjZU9yVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghY3kuaGFzRWxlbWVudFdpdGhJZCh2YWwpKSB7XG4gICAgICAgICAgLy8gY2FuJ3QgY3JlYXRlIGVkZ2UgaWYgb25lIG9mIGl0cyBub2RlcyBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgZXJyb3IoJ0NhbiBub3QgY3JlYXRlIGVkZ2UgYCcgKyBpZCArICdgIHdpdGggbm9uZXhpc3RhbnQgJyArIGZpZWxkICsgJyBgJyArIHZhbCArICdgJyk7XG4gICAgICAgICAgYmFkU291cmNlT3JUYXJnZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChiYWRTb3VyY2VPclRhcmdldCkge1xuICAgICAgICByZW1vdmVGcm9tRWxlbWVudHMoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIGNhbid0IGNyZWF0ZSB0aGlzXG5cblxuICAgICAgdmFyIHNyYyA9IGN5LmdldEVsZW1lbnRCeUlkKF9kYXRhMy5zb3VyY2UpO1xuICAgICAgdmFyIHRndCA9IGN5LmdldEVsZW1lbnRCeUlkKF9kYXRhMy50YXJnZXQpOyAvLyBvbmx5IG9uZSBlZGdlIGluIG5vZGUgaWYgbG9vcFxuXG4gICAgICBpZiAoc3JjLnNhbWUodGd0KSkge1xuICAgICAgICBzcmMuX3ByaXZhdGUuZWRnZXMucHVzaChlZGdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNyYy5fcHJpdmF0ZS5lZGdlcy5wdXNoKGVkZ2UpO1xuXG4gICAgICAgIHRndC5fcHJpdmF0ZS5lZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgfVxuXG4gICAgICBlZGdlLl9wcml2YXRlLnNvdXJjZSA9IHNyYztcbiAgICAgIGVkZ2UuX3ByaXZhdGUudGFyZ2V0ID0gdGd0O1xuICAgIH0gLy8gaWYgaXMgZWRnZVxuICAgIC8vIGNyZWF0ZSBtb2NrIGlkcyAvIGluZGV4ZXMgbWFwcyBmb3IgZWxlbWVudCBzbyBpdCBjYW4gYmUgdXNlZCBsaWtlIGNvbGxlY3Rpb25zXG5cblxuICAgIF9wcml2YXRlLm1hcCA9IG5ldyBNYXAkMSgpO1xuXG4gICAgX3ByaXZhdGUubWFwLnNldChpZCwge1xuICAgICAgZWxlOiBfZWxlMixcbiAgICAgIGluZGV4OiAwXG4gICAgfSk7XG5cbiAgICBfcHJpdmF0ZS5yZW1vdmVkID0gZmFsc2U7XG5cbiAgICBpZiAoYWRkVG9Qb29sKSB7XG4gICAgICBjeS5hZGRUb1Bvb2woX2VsZTIpO1xuICAgIH1cbiAgfSAvLyBmb3IgZWFjaCBlbGVtZW50XG4gIC8vIGRvIGNvbXBvdW5kIG5vZGUgc2FuaXR5IGNoZWNrc1xuXG5cbiAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbm9kZXMubGVuZ3RoOyBfaTQrKykge1xuICAgIC8vIGVhY2ggbm9kZVxuICAgIHZhciBub2RlID0gbm9kZXNbX2k0XTtcbiAgICB2YXIgX2RhdGE0ID0gbm9kZS5fcHJpdmF0ZS5kYXRhO1xuXG4gICAgaWYgKG51bWJlciQxKF9kYXRhNC5wYXJlbnQpKSB7XG4gICAgICAvLyB0aGVuIGF1dG9tYWtlIHN0cmluZ1xuICAgICAgX2RhdGE0LnBhcmVudCA9ICcnICsgX2RhdGE0LnBhcmVudDtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50SWQgPSBfZGF0YTQucGFyZW50O1xuICAgIHZhciBzcGVjaWZpZWRQYXJlbnQgPSBwYXJlbnRJZCAhPSBudWxsO1xuXG4gICAgaWYgKHNwZWNpZmllZFBhcmVudCB8fCBub2RlLl9wcml2YXRlLnBhcmVudCkge1xuICAgICAgdmFyIHBhcmVudCA9IG5vZGUuX3ByaXZhdGUucGFyZW50ID8gY3kuY29sbGVjdGlvbigpLm1lcmdlKG5vZGUuX3ByaXZhdGUucGFyZW50KSA6IGN5LmdldEVsZW1lbnRCeUlkKHBhcmVudElkKTtcblxuICAgICAgaWYgKHBhcmVudC5lbXB0eSgpKSB7XG4gICAgICAgIC8vIG5vbi1leGlzdGFudCBwYXJlbnQ7IGp1c3QgcmVtb3ZlIGl0XG4gICAgICAgIF9kYXRhNC5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2UgaWYgKHBhcmVudFswXS5yZW1vdmVkKCkpIHtcbiAgICAgICAgd2FybignTm9kZSBhZGRlZCB3aXRoIG1pc3NpbmcgcGFyZW50LCByZWZlcmVuY2UgdG8gcGFyZW50IHJlbW92ZWQnKTtcbiAgICAgICAgX2RhdGE0LnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbm9kZS5fcHJpdmF0ZS5wYXJlbnQgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNlbGZBc1BhcmVudCA9IGZhbHNlO1xuICAgICAgICB2YXIgYW5jZXN0b3IgPSBwYXJlbnQ7XG5cbiAgICAgICAgd2hpbGUgKCFhbmNlc3Rvci5lbXB0eSgpKSB7XG4gICAgICAgICAgaWYgKG5vZGUuc2FtZShhbmNlc3RvcikpIHtcbiAgICAgICAgICAgIC8vIG1hcmsgc2VsZiBhcyBwYXJlbnQgYW5kIHJlbW92ZSBmcm9tIGRhdGFcbiAgICAgICAgICAgIHNlbGZBc1BhcmVudCA9IHRydWU7XG4gICAgICAgICAgICBfZGF0YTQucGFyZW50ID0gdW5kZWZpbmVkOyAvLyByZW1vdmUgcGFyZW50IHJlZmVyZW5jZVxuICAgICAgICAgICAgLy8gZXhpdCBvciB3ZSBsb29wIGZvcmV2ZXJcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2VsZkFzUGFyZW50KSB7XG4gICAgICAgICAgLy8gY29ubmVjdCB3aXRoIGNoaWxkcmVuXG4gICAgICAgICAgcGFyZW50WzBdLl9wcml2YXRlLmNoaWxkcmVuLnB1c2gobm9kZSk7XG5cbiAgICAgICAgICBub2RlLl9wcml2YXRlLnBhcmVudCA9IHBhcmVudFswXTsgLy8gbGV0IHRoZSBjb3JlIGtub3cgd2UgaGF2ZSBhIGNvbXBvdW5kIGdyYXBoXG5cbiAgICAgICAgICBjeV9wLmhhc0NvbXBvdW5kTm9kZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIGVsc2VcblxuICAgIH0gLy8gaWYgc3BlY2lmaWVkIHBhcmVudFxuXG4gIH0gLy8gZm9yIGVhY2ggbm9kZVxuXG5cbiAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgcmVzdG9yZWQgPSBlbGVtZW50cy5sZW5ndGggPT09IHNlbGYubGVuZ3RoID8gc2VsZiA6IG5ldyBDb2xsZWN0aW9uKGN5LCBlbGVtZW50cyk7XG5cbiAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCByZXN0b3JlZC5sZW5ndGg7IF9pNSsrKSB7XG4gICAgICB2YXIgX2VsZTMgPSByZXN0b3JlZFtfaTVdO1xuXG4gICAgICBpZiAoX2VsZTMuaXNOb2RlKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIGFkZGluZyBhbiBlZGdlIGludmFsaWRhdGVzIHRoZSB0cmF2ZXJzYWwgY2FjaGVzIGZvciB0aGUgcGFyYWxsZWwgZWRnZXNcblxuXG4gICAgICBfZWxlMy5wYXJhbGxlbEVkZ2VzKCkuY2xlYXJUcmF2ZXJzYWxDYWNoZSgpOyAvLyBhZGRpbmcgYW4gZWRnZSBpbnZhbGlkYXRlcyB0aGUgdHJhdmVyc2FsIGNhY2hlIGZvciB0aGUgY29ubmVjdGVkIG5vZGVzXG5cblxuICAgICAgX2VsZTMuc291cmNlKCkuY2xlYXJUcmF2ZXJzYWxDYWNoZSgpO1xuXG4gICAgICBfZWxlMy50YXJnZXQoKS5jbGVhclRyYXZlcnNhbENhY2hlKCk7XG4gICAgfVxuXG4gICAgdmFyIHRvVXBkYXRlU3R5bGU7XG5cbiAgICBpZiAoY3lfcC5oYXNDb21wb3VuZE5vZGVzKSB7XG4gICAgICB0b1VwZGF0ZVN0eWxlID0gY3kuY29sbGVjdGlvbigpLm1lcmdlKHJlc3RvcmVkKS5tZXJnZShyZXN0b3JlZC5jb25uZWN0ZWROb2RlcygpKS5tZXJnZShyZXN0b3JlZC5wYXJlbnQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvVXBkYXRlU3R5bGUgPSByZXN0b3JlZDtcbiAgICB9XG5cbiAgICB0b1VwZGF0ZVN0eWxlLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpLnVwZGF0ZVN0eWxlKG5vdGlmeVJlbmRlcmVyKTtcblxuICAgIGlmIChub3RpZnlSZW5kZXJlcikge1xuICAgICAgcmVzdG9yZWQuZW1pdEFuZE5vdGlmeSgnYWRkJyk7XG4gICAgfSBlbHNlIGlmIChhZGRUb1Bvb2wpIHtcbiAgICAgIHJlc3RvcmVkLmVtaXQoJ2FkZCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmOyAvLyBjaGFpbmFiaWxpdHlcbn07XG5cbmVsZXNmbiQxLnJlbW92ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbGUgPSB0aGlzWzBdO1xuICByZXR1cm4gZWxlICYmIGVsZS5fcHJpdmF0ZS5yZW1vdmVkO1xufTtcblxuZWxlc2ZuJDEuaW5zaWRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlID0gdGhpc1swXTtcbiAgcmV0dXJuIGVsZSAmJiAhZWxlLl9wcml2YXRlLnJlbW92ZWQ7XG59O1xuXG5lbGVzZm4kMS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub3RpZnlSZW5kZXJlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgdmFyIHJlbW92ZUZyb21Qb29sID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBlbGVzVG9SZW1vdmUgPSBbXTtcbiAgdmFyIGVsZXNUb1JlbW92ZUlkcyA9IHt9O1xuICB2YXIgY3kgPSBzZWxmLl9wcml2YXRlLmN5OyAvLyBhZGQgY29ubmVjdGVkIGVkZ2VzXG5cbiAgZnVuY3Rpb24gYWRkQ29ubmVjdGVkRWRnZXMobm9kZSkge1xuICAgIHZhciBlZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhZGQoZWRnZXNbaV0pO1xuICAgIH1cbiAgfSAvLyBhZGQgZGVzY2VuZGFudCBub2Rlc1xuXG5cbiAgZnVuY3Rpb24gYWRkQ2hpbGRyZW4obm9kZSkge1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuX3ByaXZhdGUuY2hpbGRyZW47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhZGQoY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZChlbGUpIHtcbiAgICB2YXIgYWxyZWFkeUFkZGVkID0gZWxlc1RvUmVtb3ZlSWRzW2VsZS5pZCgpXTtcblxuICAgIGlmIChyZW1vdmVGcm9tUG9vbCAmJiBlbGUucmVtb3ZlZCgpIHx8IGFscmVhZHlBZGRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVzVG9SZW1vdmVJZHNbZWxlLmlkKCldID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICBlbGVzVG9SZW1vdmUucHVzaChlbGUpOyAvLyBub2RlcyBhcmUgcmVtb3ZlZCBsYXN0XG5cbiAgICAgIGFkZENvbm5lY3RlZEVkZ2VzKGVsZSk7XG4gICAgICBhZGRDaGlsZHJlbihlbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVzVG9SZW1vdmUudW5zaGlmdChlbGUpOyAvLyBlZGdlcyBhcmUgcmVtb3ZlZCBmaXJzdFxuICAgIH1cbiAgfSAvLyBtYWtlIHRoZSBsaXN0IG9mIGVsZW1lbnRzIHRvIHJlbW92ZVxuICAvLyAobWF5IGJlIHJlbW92aW5nIG1vcmUgdGhhbiBzcGVjaWZpZWQgZHVlIHRvIGNvbm5lY3RlZCBlZGdlcyBldGMpXG5cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHNlbGYubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IHNlbGZbaV07XG4gICAgYWRkKGVsZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVFZGdlUmVmKG5vZGUsIGVkZ2UpIHtcbiAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBub2RlLl9wcml2YXRlLmVkZ2VzO1xuICAgIHJlbW92ZUZyb21BcnJheShjb25uZWN0ZWRFZGdlcywgZWRnZSk7IC8vIHJlbW92aW5nIGFuIGVkZ2VzIGludmFsaWRhdGVzIHRoZSB0cmF2ZXJzYWwgY2FjaGUgZm9yIGl0cyBub2Rlc1xuXG4gICAgbm9kZS5jbGVhclRyYXZlcnNhbENhY2hlKCk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVQYXJhbGxlbFJlZihwbGxFZGdlKSB7XG4gICAgLy8gcmVtb3ZpbmcgYW4gZWRnZSBpbnZhbGlkYXRlcyB0aGUgdHJhdmVyc2FsIGNhY2hlcyBmb3IgdGhlIHBhcmFsbGVsIGVkZ2VzXG4gICAgcGxsRWRnZS5jbGVhclRyYXZlcnNhbENhY2hlKCk7XG4gIH1cblxuICB2YXIgYWx0ZXJlZFBhcmVudHMgPSBbXTtcbiAgYWx0ZXJlZFBhcmVudHMuaWRzID0ge307XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQ2hpbGRSZWYocGFyZW50LCBlbGUpIHtcbiAgICBlbGUgPSBlbGVbMF07XG4gICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudC5fcHJpdmF0ZS5jaGlsZHJlbjtcbiAgICB2YXIgcGlkID0gcGFyZW50LmlkKCk7XG4gICAgcmVtb3ZlRnJvbUFycmF5KGNoaWxkcmVuLCBlbGUpOyAvLyByZW1vdmUgcGFyZW50ID0+IGNoaWxkIHJlZlxuXG4gICAgZWxlLl9wcml2YXRlLnBhcmVudCA9IG51bGw7IC8vIHJlbW92ZSBjaGlsZCA9PiBwYXJlbnQgcmVmXG5cbiAgICBpZiAoIWFsdGVyZWRQYXJlbnRzLmlkc1twaWRdKSB7XG4gICAgICBhbHRlcmVkUGFyZW50cy5pZHNbcGlkXSA9IHRydWU7XG4gICAgICBhbHRlcmVkUGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgfVxuICB9XG5cbiAgc2VsZi5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcblxuICBpZiAocmVtb3ZlRnJvbVBvb2wpIHtcbiAgICBjeS5yZW1vdmVGcm9tUG9vbChlbGVzVG9SZW1vdmUpOyAvLyByZW1vdmUgZnJvbSBjb3JlIHBvb2xcbiAgfVxuXG4gIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IGVsZXNUb1JlbW92ZS5sZW5ndGg7IF9pNisrKSB7XG4gICAgdmFyIF9lbGU0ID0gZWxlc1RvUmVtb3ZlW19pNl07XG5cbiAgICBpZiAoX2VsZTQuaXNFZGdlKCkpIHtcbiAgICAgIC8vIHJlbW92ZSByZWZlcmVuY2VzIHRvIHRoaXMgZWRnZSBpbiBpdHMgY29ubmVjdGVkIG5vZGVzXG4gICAgICB2YXIgc3JjID0gX2VsZTQuc291cmNlKClbMF07XG5cbiAgICAgIHZhciB0Z3QgPSBfZWxlNC50YXJnZXQoKVswXTtcblxuICAgICAgcmVtb3ZlRWRnZVJlZihzcmMsIF9lbGU0KTtcbiAgICAgIHJlbW92ZUVkZ2VSZWYodGd0LCBfZWxlNCk7XG5cbiAgICAgIHZhciBwbGxFZGdlcyA9IF9lbGU0LnBhcmFsbGVsRWRnZXMoKTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwbGxFZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgcGxsRWRnZSA9IHBsbEVkZ2VzW2pdO1xuICAgICAgICByZW1vdmVQYXJhbGxlbFJlZihwbGxFZGdlKTtcblxuICAgICAgICBpZiAocGxsRWRnZS5pc0J1bmRsZWRCZXppZXIoKSkge1xuICAgICAgICAgIHBsbEVkZ2UuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byBwYXJlbnRcbiAgICAgIHZhciBwYXJlbnQgPSBfZWxlNC5wYXJlbnQoKTtcblxuICAgICAgaWYgKHBhcmVudC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcmVtb3ZlQ2hpbGRSZWYocGFyZW50LCBfZWxlNCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlbW92ZUZyb21Qb29sKSB7XG4gICAgICAvLyBtYXJrIGFzIHJlbW92ZWRcbiAgICAgIF9lbGU0Ll9wcml2YXRlLnJlbW92ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSAvLyBjaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIGNvbXBvdW5kIGdyYXBoIG9yIG5vdFxuXG5cbiAgdmFyIGVsZXNTdGlsbEluc2lkZSA9IGN5Ll9wcml2YXRlLmVsZW1lbnRzO1xuICBjeS5fcHJpdmF0ZS5oYXNDb21wb3VuZE5vZGVzID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgX2k3ID0gMDsgX2k3IDwgZWxlc1N0aWxsSW5zaWRlLmxlbmd0aDsgX2k3KyspIHtcbiAgICB2YXIgX2VsZTUgPSBlbGVzU3RpbGxJbnNpZGVbX2k3XTtcblxuICAgIGlmIChfZWxlNS5pc1BhcmVudCgpKSB7XG4gICAgICBjeS5fcHJpdmF0ZS5oYXNDb21wb3VuZE5vZGVzID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZW1vdmVkRWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbih0aGlzLmN5KCksIGVsZXNUb1JlbW92ZSk7XG5cbiAgaWYgKHJlbW92ZWRFbGVtZW50cy5zaXplKCkgPiAwKSB7XG4gICAgLy8gbXVzdCBtYW51YWxseSBub3RpZnkgc2luY2UgdHJpZ2dlciB3b24ndCBkbyB0aGlzIGF1dG9tYXRpY2FsbHkgb25jZSByZW1vdmVkXG4gICAgaWYgKG5vdGlmeVJlbmRlcmVyKSB7XG4gICAgICByZW1vdmVkRWxlbWVudHMuZW1pdEFuZE5vdGlmeSgncmVtb3ZlJyk7XG4gICAgfSBlbHNlIGlmIChyZW1vdmVGcm9tUG9vbCkge1xuICAgICAgcmVtb3ZlZEVsZW1lbnRzLmVtaXQoJ3JlbW92ZScpO1xuICAgIH1cbiAgfSAvLyB0aGUgcGFyZW50cyB3aG8gd2VyZSBtb2RpZmllZCBieSB0aGUgcmVtb3ZhbCBuZWVkIHRoZWlyIHN0eWxlIHVwZGF0ZWRcblxuXG4gIGZvciAodmFyIF9pOCA9IDA7IF9pOCA8IGFsdGVyZWRQYXJlbnRzLmxlbmd0aDsgX2k4KyspIHtcbiAgICB2YXIgX2VsZTYgPSBhbHRlcmVkUGFyZW50c1tfaThdO1xuXG4gICAgaWYgKCFyZW1vdmVGcm9tUG9vbCB8fCAhX2VsZTYucmVtb3ZlZCgpKSB7XG4gICAgICBfZWxlNi51cGRhdGVTdHlsZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZW1vdmVkRWxlbWVudHM7XG59O1xuXG5lbGVzZm4kMS5tb3ZlID0gZnVuY3Rpb24gKHN0cnVjdCkge1xuICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICB2YXIgZWxlcyA9IHRoaXM7IC8vIGp1c3QgY2xlYW4gdXAgcmVmcywgY2FjaGVzLCBldGMuIGluIHRoZSBzYW1lIHdheSBhcyB3aGVuIHJlbW92aW5nIGFuZCB0aGVuIHJlc3RvcmluZ1xuICAvLyAob3VyIGNhbGxzIHRvIHJlbW92ZS9yZXN0b3JlIGRvIG5vdCByZW1vdmUgZnJvbSB0aGUgZ3JhcGggb3IgbWFrZSBldmVudHMpXG5cbiAgdmFyIG5vdGlmeVJlbmRlcmVyID0gZmFsc2U7XG4gIHZhciBtb2RpZnlQb29sID0gZmFsc2U7XG5cbiAgdmFyIHRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoaWQpIHtcbiAgICByZXR1cm4gaWQgPT0gbnVsbCA/IGlkIDogJycgKyBpZDtcbiAgfTsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcblxuXG4gIGlmIChzdHJ1Y3Quc291cmNlICE9PSB1bmRlZmluZWQgfHwgc3RydWN0LnRhcmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHNyY0lkID0gdG9TdHJpbmcoc3RydWN0LnNvdXJjZSk7XG4gICAgdmFyIHRndElkID0gdG9TdHJpbmcoc3RydWN0LnRhcmdldCk7XG4gICAgdmFyIHNyY0V4aXN0cyA9IHNyY0lkICE9IG51bGwgJiYgY3kuaGFzRWxlbWVudFdpdGhJZChzcmNJZCk7XG4gICAgdmFyIHRndEV4aXN0cyA9IHRndElkICE9IG51bGwgJiYgY3kuaGFzRWxlbWVudFdpdGhJZCh0Z3RJZCk7XG5cbiAgICBpZiAoc3JjRXhpc3RzIHx8IHRndEV4aXN0cykge1xuICAgICAgY3kuYmF0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBhdm9pZCBkdXBsaWNhdGUgc3R5bGUgdXBkYXRlc1xuICAgICAgICBlbGVzLnJlbW92ZShub3RpZnlSZW5kZXJlciwgbW9kaWZ5UG9vbCk7IC8vIGNsZWFuIHVwIHJlZnMgZXRjLlxuXG4gICAgICAgIGVsZXMuZW1pdEFuZE5vdGlmeSgnbW92ZW91dCcpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICAgIHZhciBfZGF0YTUgPSBlbGUuX3ByaXZhdGUuZGF0YTtcblxuICAgICAgICAgIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICAgICAgICAgIGlmIChzcmNFeGlzdHMpIHtcbiAgICAgICAgICAgICAgX2RhdGE1LnNvdXJjZSA9IHNyY0lkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGd0RXhpc3RzKSB7XG4gICAgICAgICAgICAgIF9kYXRhNS50YXJnZXQgPSB0Z3RJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlbGVzLnJlc3RvcmUobm90aWZ5UmVuZGVyZXIsIG1vZGlmeVBvb2wpOyAvLyBtYWtlIG5ldyByZWZzLCBzdHlsZSwgZXRjLlxuICAgICAgfSk7XG4gICAgICBlbGVzLmVtaXRBbmROb3RpZnkoJ21vdmUnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc3RydWN0LnBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gbW92ZSBub2RlIHRvIG5ldyBwYXJlbnRcbiAgICB2YXIgcGFyZW50SWQgPSB0b1N0cmluZyhzdHJ1Y3QucGFyZW50KTtcbiAgICB2YXIgcGFyZW50RXhpc3RzID0gcGFyZW50SWQgPT09IG51bGwgfHwgY3kuaGFzRWxlbWVudFdpdGhJZChwYXJlbnRJZCk7XG5cbiAgICBpZiAocGFyZW50RXhpc3RzKSB7XG4gICAgICB2YXIgcGlkVG9Bc3NpZ24gPSBwYXJlbnRJZCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHBhcmVudElkO1xuICAgICAgY3kuYmF0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBhdm9pZCBkdXBsaWNhdGUgc3R5bGUgdXBkYXRlc1xuICAgICAgICB2YXIgdXBkYXRlZCA9IGVsZXMucmVtb3ZlKG5vdGlmeVJlbmRlcmVyLCBtb2RpZnlQb29sKTsgLy8gY2xlYW4gdXAgcmVmcyBldGMuXG5cbiAgICAgICAgdXBkYXRlZC5lbWl0QW5kTm90aWZ5KCdtb3Zlb3V0Jyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgICAgdmFyIF9kYXRhNiA9IGVsZS5fcHJpdmF0ZS5kYXRhO1xuXG4gICAgICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICAgICAgX2RhdGE2LnBhcmVudCA9IHBpZFRvQXNzaWduO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZWQucmVzdG9yZShub3RpZnlSZW5kZXJlciwgbW9kaWZ5UG9vbCk7IC8vIG1ha2UgbmV3IHJlZnMsIHN0eWxlLCBldGMuXG4gICAgICB9KTtcbiAgICAgIGVsZXMuZW1pdEFuZE5vdGlmeSgnbW92ZScpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuW2VsZXNmbiRqLCBlbGVzZm4kaSwgZWxlc2ZuJGgsIGVsZXNmbiRnLCBlbGVzZm4kZiwgZGF0YSwgZWxlc2ZuJGQsIGRpbWVuc2lvbnMsIGVsZXNmbiQ5LCBlbGVzZm4kOCwgZWxlc2ZuJDcsIGVsZXNmbiQ2LCBlbGVzZm4kNSwgZWxlc2ZuJDQsIGVsZXNmbiQzLCBlbGVzZm4kMl0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgZXh0ZW5kKGVsZXNmbiQxLCBwcm9wcyk7XG59KTtcblxudmFyIGNvcmVmbiQ5ID0ge1xuICBhZGQ6IGZ1bmN0aW9uIGFkZChvcHRzKSB7XG4gICAgdmFyIGVsZW1lbnRzO1xuICAgIHZhciBjeSA9IHRoaXM7IC8vIGFkZCB0aGUgZWxlbWVudHNcblxuICAgIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKG9wdHMpKSB7XG4gICAgICB2YXIgZWxlcyA9IG9wdHM7XG5cbiAgICAgIGlmIChlbGVzLl9wcml2YXRlLmN5ID09PSBjeSkge1xuICAgICAgICAvLyBzYW1lIGluc3RhbmNlID0+IGp1c3QgcmVzdG9yZVxuICAgICAgICBlbGVtZW50cyA9IGVsZXMucmVzdG9yZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBjb3B5IGZyb20ganNvblxuICAgICAgICB2YXIganNvbnMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgICBqc29ucy5wdXNoKGVsZS5qc29uKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbihjeSwganNvbnMpO1xuICAgICAgfVxuICAgIH0gLy8gc3BlY2lmeSBhbiBhcnJheSBvZiBvcHRpb25zXG4gICAgZWxzZSBpZiAoYXJyYXkob3B0cykpIHtcbiAgICAgIHZhciBfanNvbnMgPSBvcHRzO1xuICAgICAgZWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbihjeSwgX2pzb25zKTtcbiAgICB9IC8vIHNwZWNpZnkgdmlhIG9wdHMubm9kZXMgYW5kIG9wdHMuZWRnZXNcbiAgICBlbHNlIGlmIChwbGFpbk9iamVjdChvcHRzKSAmJiAoYXJyYXkob3B0cy5ub2RlcykgfHwgYXJyYXkob3B0cy5lZGdlcykpKSB7XG4gICAgICB2YXIgZWxlc0J5R3JvdXAgPSBvcHRzO1xuICAgICAgdmFyIF9qc29uczIgPSBbXTtcbiAgICAgIHZhciBncnMgPSBbJ25vZGVzJywgJ2VkZ2VzJ107XG5cbiAgICAgIGZvciAodmFyIF9pID0gMCwgaWwgPSBncnMubGVuZ3RoOyBfaSA8IGlsOyBfaSsrKSB7XG4gICAgICAgIHZhciBncm91cCA9IGdyc1tfaV07XG4gICAgICAgIHZhciBlbGVzQXJyYXkgPSBlbGVzQnlHcm91cFtncm91cF07XG5cbiAgICAgICAgaWYgKGFycmF5KGVsZXNBcnJheSkpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgamwgPSBlbGVzQXJyYXkubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgICAgICAgdmFyIGpzb24gPSBleHRlbmQoe1xuICAgICAgICAgICAgICBncm91cDogZ3JvdXBcbiAgICAgICAgICAgIH0sIGVsZXNBcnJheVtqXSk7XG5cbiAgICAgICAgICAgIF9qc29uczIucHVzaChqc29uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbihjeSwgX2pzb25zMik7XG4gICAgfSAvLyBzcGVjaWZ5IG9wdGlvbnMgZm9yIG9uZSBlbGVtZW50XG4gICAgZWxzZSB7XG4gICAgICB2YXIgX2pzb24gPSBvcHRzO1xuICAgICAgZWxlbWVudHMgPSBuZXcgRWxlbWVudChjeSwgX2pzb24pLmNvbGxlY3Rpb24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudHM7XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGNvbGxlY3Rpb24pIHtcbiAgICBpZiAoZWxlbWVudE9yQ29sbGVjdGlvbihjb2xsZWN0aW9uKSkgOyBlbHNlIGlmIChzdHJpbmcoY29sbGVjdGlvbikpIHtcbiAgICAgIHZhciBzZWxlY3RvciA9IGNvbGxlY3Rpb247XG4gICAgICBjb2xsZWN0aW9uID0gdGhpcy4kKHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29sbGVjdGlvbi5yZW1vdmUoKTtcbiAgfVxufTtcblxuLyogZ2xvYmFsIEZsb2F0MzJBcnJheSAqL1xuXG4vKiEgQmV6aWVyIGN1cnZlIGZ1bmN0aW9uIGdlbmVyYXRvci4gQ29weXJpZ2h0IEdhZXRhbiBSZW5hdWRlYXUuIE1JVCBMaWNlbnNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01JVF9MaWNlbnNlICovXG5mdW5jdGlvbiBnZW5lcmF0ZUN1YmljQmV6aWVyKG1YMSwgbVkxLCBtWDIsIG1ZMikge1xuICB2YXIgTkVXVE9OX0lURVJBVElPTlMgPSA0LFxuICAgICAgTkVXVE9OX01JTl9TTE9QRSA9IDAuMDAxLFxuICAgICAgU1VCRElWSVNJT05fUFJFQ0lTSU9OID0gMC4wMDAwMDAxLFxuICAgICAgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMgPSAxMCxcbiAgICAgIGtTcGxpbmVUYWJsZVNpemUgPSAxMSxcbiAgICAgIGtTYW1wbGVTdGVwU2l6ZSA9IDEuMCAvIChrU3BsaW5lVGFibGVTaXplIC0gMS4wKSxcbiAgICAgIGZsb2F0MzJBcnJheVN1cHBvcnRlZCA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnO1xuICAvKiBNdXN0IGNvbnRhaW4gZm91ciBhcmd1bWVudHMuICovXG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyogQXJndW1lbnRzIG11c3QgYmUgbnVtYmVycy4gKi9cblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbaV0gIT09IFwibnVtYmVyXCIgfHwgaXNOYU4oYXJndW1lbnRzW2ldKSB8fCAhaXNGaW5pdGUoYXJndW1lbnRzW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvKiBYIHZhbHVlcyBtdXN0IGJlIGluIHRoZSBbMCwgMV0gcmFuZ2UuICovXG5cblxuICBtWDEgPSBNYXRoLm1pbihtWDEsIDEpO1xuICBtWDIgPSBNYXRoLm1pbihtWDIsIDEpO1xuICBtWDEgPSBNYXRoLm1heChtWDEsIDApO1xuICBtWDIgPSBNYXRoLm1heChtWDIsIDApO1xuICB2YXIgbVNhbXBsZVZhbHVlcyA9IGZsb2F0MzJBcnJheVN1cHBvcnRlZCA/IG5ldyBGbG9hdDMyQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSkgOiBuZXcgQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSk7XG5cbiAgZnVuY3Rpb24gQShhQTEsIGFBMikge1xuICAgIHJldHVybiAxLjAgLSAzLjAgKiBhQTIgKyAzLjAgKiBhQTE7XG4gIH1cblxuICBmdW5jdGlvbiBCKGFBMSwgYUEyKSB7XG4gICAgcmV0dXJuIDMuMCAqIGFBMiAtIDYuMCAqIGFBMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEMoYUExKSB7XG4gICAgcmV0dXJuIDMuMCAqIGFBMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGNCZXppZXIoYVQsIGFBMSwgYUEyKSB7XG4gICAgcmV0dXJuICgoQShhQTEsIGFBMikgKiBhVCArIEIoYUExLCBhQTIpKSAqIGFUICsgQyhhQTEpKSAqIGFUO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U2xvcGUoYVQsIGFBMSwgYUEyKSB7XG4gICAgcmV0dXJuIDMuMCAqIEEoYUExLCBhQTIpICogYVQgKiBhVCArIDIuMCAqIEIoYUExLCBhQTIpICogYVQgKyBDKGFBMSk7XG4gIH1cblxuICBmdW5jdGlvbiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgYUd1ZXNzVCkge1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBORVdUT05fSVRFUkFUSU9OUzsgKytfaSkge1xuICAgICAgdmFyIGN1cnJlbnRTbG9wZSA9IGdldFNsb3BlKGFHdWVzc1QsIG1YMSwgbVgyKTtcblxuICAgICAgaWYgKGN1cnJlbnRTbG9wZSA9PT0gMC4wKSB7XG4gICAgICAgIHJldHVybiBhR3Vlc3NUO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VycmVudFggPSBjYWxjQmV6aWVyKGFHdWVzc1QsIG1YMSwgbVgyKSAtIGFYO1xuICAgICAgYUd1ZXNzVCAtPSBjdXJyZW50WCAvIGN1cnJlbnRTbG9wZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYUd1ZXNzVDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGNTYW1wbGVWYWx1ZXMoKSB7XG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwga1NwbGluZVRhYmxlU2l6ZTsgKytfaTIpIHtcbiAgICAgIG1TYW1wbGVWYWx1ZXNbX2kyXSA9IGNhbGNCZXppZXIoX2kyICoga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYmluYXJ5U3ViZGl2aWRlKGFYLCBhQSwgYUIpIHtcbiAgICB2YXIgY3VycmVudFgsXG4gICAgICAgIGN1cnJlbnRULFxuICAgICAgICBpID0gMDtcblxuICAgIGRvIHtcbiAgICAgIGN1cnJlbnRUID0gYUEgKyAoYUIgLSBhQSkgLyAyLjA7XG4gICAgICBjdXJyZW50WCA9IGNhbGNCZXppZXIoY3VycmVudFQsIG1YMSwgbVgyKSAtIGFYO1xuXG4gICAgICBpZiAoY3VycmVudFggPiAwLjApIHtcbiAgICAgICAgYUIgPSBjdXJyZW50VDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFBID0gY3VycmVudFQ7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoTWF0aC5hYnMoY3VycmVudFgpID4gU1VCRElWSVNJT05fUFJFQ0lTSU9OICYmICsraSA8IFNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TKTtcblxuICAgIHJldHVybiBjdXJyZW50VDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRGb3JYKGFYKSB7XG4gICAgdmFyIGludGVydmFsU3RhcnQgPSAwLjAsXG4gICAgICAgIGN1cnJlbnRTYW1wbGUgPSAxLFxuICAgICAgICBsYXN0U2FtcGxlID0ga1NwbGluZVRhYmxlU2l6ZSAtIDE7XG5cbiAgICBmb3IgKDsgY3VycmVudFNhbXBsZSAhPT0gbGFzdFNhbXBsZSAmJiBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdIDw9IGFYOyArK2N1cnJlbnRTYW1wbGUpIHtcbiAgICAgIGludGVydmFsU3RhcnQgKz0ga1NhbXBsZVN0ZXBTaXplO1xuICAgIH1cblxuICAgIC0tY3VycmVudFNhbXBsZTtcbiAgICB2YXIgZGlzdCA9IChhWCAtIG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pIC8gKG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZSArIDFdIC0gbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSksXG4gICAgICAgIGd1ZXNzRm9yVCA9IGludGVydmFsU3RhcnQgKyBkaXN0ICoga1NhbXBsZVN0ZXBTaXplLFxuICAgICAgICBpbml0aWFsU2xvcGUgPSBnZXRTbG9wZShndWVzc0ZvclQsIG1YMSwgbVgyKTtcblxuICAgIGlmIChpbml0aWFsU2xvcGUgPj0gTkVXVE9OX01JTl9TTE9QRSkge1xuICAgICAgcmV0dXJuIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBndWVzc0ZvclQpO1xuICAgIH0gZWxzZSBpZiAoaW5pdGlhbFNsb3BlID09PSAwLjApIHtcbiAgICAgIHJldHVybiBndWVzc0ZvclQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBiaW5hcnlTdWJkaXZpZGUoYVgsIGludGVydmFsU3RhcnQsIGludGVydmFsU3RhcnQgKyBrU2FtcGxlU3RlcFNpemUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfcHJlY29tcHV0ZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBwcmVjb21wdXRlKCkge1xuICAgIF9wcmVjb21wdXRlZCA9IHRydWU7XG5cbiAgICBpZiAobVgxICE9PSBtWTEgfHwgbVgyICE9PSBtWTIpIHtcbiAgICAgIGNhbGNTYW1wbGVWYWx1ZXMoKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZiA9IGZ1bmN0aW9uIGYoYVgpIHtcbiAgICBpZiAoIV9wcmVjb21wdXRlZCkge1xuICAgICAgcHJlY29tcHV0ZSgpO1xuICAgIH1cblxuICAgIGlmIChtWDEgPT09IG1ZMSAmJiBtWDIgPT09IG1ZMikge1xuICAgICAgcmV0dXJuIGFYO1xuICAgIH1cblxuICAgIGlmIChhWCA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKGFYID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FsY0JlemllcihnZXRURm9yWChhWCksIG1ZMSwgbVkyKTtcbiAgfTtcblxuICBmLmdldENvbnRyb2xQb2ludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFt7XG4gICAgICB4OiBtWDEsXG4gICAgICB5OiBtWTFcbiAgICB9LCB7XG4gICAgICB4OiBtWDIsXG4gICAgICB5OiBtWTJcbiAgICB9XTtcbiAgfTtcblxuICB2YXIgc3RyID0gXCJnZW5lcmF0ZUJlemllcihcIiArIFttWDEsIG1ZMSwgbVgyLCBtWTJdICsgXCIpXCI7XG5cbiAgZi50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIHJldHVybiBmO1xufVxuXG4vKiEgUnVuZ2UtS3V0dGEgc3ByaW5nIHBoeXNpY3MgZnVuY3Rpb24gZ2VuZXJhdG9yLiBBZGFwdGVkIGZyb20gRnJhbWVyLmpzLCBjb3B5cmlnaHQgS29lbiBCb2suIE1JVCBMaWNlbnNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01JVF9MaWNlbnNlICovXG5cbi8qIEdpdmVuIGEgdGVuc2lvbiwgZnJpY3Rpb24sIGFuZCBkdXJhdGlvbiwgYSBzaW11bGF0aW9uIGF0IDYwRlBTIHdpbGwgZmlyc3QgcnVuIHdpdGhvdXQgYSBkZWZpbmVkIGR1cmF0aW9uIGluIG9yZGVyIHRvIGNhbGN1bGF0ZSB0aGUgZnVsbCBwYXRoLiBBIHNlY29uZCBwYXNzXG4gICB0aGVuIGFkanVzdHMgdGhlIHRpbWUgZGVsdGEgLS0gdXNpbmcgdGhlIHJlbGF0aW9uIGJldHdlZW4gYWN0dWFsIHRpbWUgYW5kIGR1cmF0aW9uIC0tIHRvIGNhbGN1bGF0ZSB0aGUgcGF0aCBmb3IgdGhlIGR1cmF0aW9uLWNvbnN0cmFpbmVkIGFuaW1hdGlvbi4gKi9cbnZhciBnZW5lcmF0ZVNwcmluZ1JLNCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gc3ByaW5nQWNjZWxlcmF0aW9uRm9yU3RhdGUoc3RhdGUpIHtcbiAgICByZXR1cm4gLXN0YXRlLnRlbnNpb24gKiBzdGF0ZS54IC0gc3RhdGUuZnJpY3Rpb24gKiBzdGF0ZS52O1xuICB9XG5cbiAgZnVuY3Rpb24gc3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKGluaXRpYWxTdGF0ZSwgZHQsIGRlcml2YXRpdmUpIHtcbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICB4OiBpbml0aWFsU3RhdGUueCArIGRlcml2YXRpdmUuZHggKiBkdCxcbiAgICAgIHY6IGluaXRpYWxTdGF0ZS52ICsgZGVyaXZhdGl2ZS5kdiAqIGR0LFxuICAgICAgdGVuc2lvbjogaW5pdGlhbFN0YXRlLnRlbnNpb24sXG4gICAgICBmcmljdGlvbjogaW5pdGlhbFN0YXRlLmZyaWN0aW9uXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgZHg6IHN0YXRlLnYsXG4gICAgICBkdjogc3ByaW5nQWNjZWxlcmF0aW9uRm9yU3RhdGUoc3RhdGUpXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNwcmluZ0ludGVncmF0ZVN0YXRlKHN0YXRlLCBkdCkge1xuICAgIHZhciBhID0ge1xuICAgICAgZHg6IHN0YXRlLnYsXG4gICAgICBkdjogc3ByaW5nQWNjZWxlcmF0aW9uRm9yU3RhdGUoc3RhdGUpXG4gICAgfSxcbiAgICAgICAgYiA9IHNwcmluZ0V2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZShzdGF0ZSwgZHQgKiAwLjUsIGEpLFxuICAgICAgICBjID0gc3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKHN0YXRlLCBkdCAqIDAuNSwgYiksXG4gICAgICAgIGQgPSBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoc3RhdGUsIGR0LCBjKSxcbiAgICAgICAgZHhkdCA9IDEuMCAvIDYuMCAqIChhLmR4ICsgMi4wICogKGIuZHggKyBjLmR4KSArIGQuZHgpLFxuICAgICAgICBkdmR0ID0gMS4wIC8gNi4wICogKGEuZHYgKyAyLjAgKiAoYi5kdiArIGMuZHYpICsgZC5kdik7XG4gICAgc3RhdGUueCA9IHN0YXRlLnggKyBkeGR0ICogZHQ7XG4gICAgc3RhdGUudiA9IHN0YXRlLnYgKyBkdmR0ICogZHQ7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHNwcmluZ1JLNEZhY3RvcnkodGVuc2lvbiwgZnJpY3Rpb24sIGR1cmF0aW9uKSB7XG4gICAgdmFyIGluaXRTdGF0ZSA9IHtcbiAgICAgIHg6IC0xLFxuICAgICAgdjogMCxcbiAgICAgIHRlbnNpb246IG51bGwsXG4gICAgICBmcmljdGlvbjogbnVsbFxuICAgIH0sXG4gICAgICAgIHBhdGggPSBbMF0sXG4gICAgICAgIHRpbWVfbGFwc2VkID0gMCxcbiAgICAgICAgdG9sZXJhbmNlID0gMSAvIDEwMDAwLFxuICAgICAgICBEVCA9IDE2IC8gMTAwMCxcbiAgICAgICAgaGF2ZV9kdXJhdGlvbixcbiAgICAgICAgZHQsXG4gICAgICAgIGxhc3Rfc3RhdGU7XG4gICAgdGVuc2lvbiA9IHBhcnNlRmxvYXQodGVuc2lvbikgfHwgNTAwO1xuICAgIGZyaWN0aW9uID0gcGFyc2VGbG9hdChmcmljdGlvbikgfHwgMjA7XG4gICAgZHVyYXRpb24gPSBkdXJhdGlvbiB8fCBudWxsO1xuICAgIGluaXRTdGF0ZS50ZW5zaW9uID0gdGVuc2lvbjtcbiAgICBpbml0U3RhdGUuZnJpY3Rpb24gPSBmcmljdGlvbjtcbiAgICBoYXZlX2R1cmF0aW9uID0gZHVyYXRpb24gIT09IG51bGw7XG4gICAgLyogQ2FsY3VsYXRlIHRoZSBhY3R1YWwgdGltZSBpdCB0YWtlcyBmb3IgdGhpcyBhbmltYXRpb24gdG8gY29tcGxldGUgd2l0aCB0aGUgcHJvdmlkZWQgY29uZGl0aW9ucy4gKi9cblxuICAgIGlmIChoYXZlX2R1cmF0aW9uKSB7XG4gICAgICAvKiBSdW4gdGhlIHNpbXVsYXRpb24gd2l0aG91dCBhIGR1cmF0aW9uLiAqL1xuICAgICAgdGltZV9sYXBzZWQgPSBzcHJpbmdSSzRGYWN0b3J5KHRlbnNpb24sIGZyaWN0aW9uKTtcbiAgICAgIC8qIENvbXB1dGUgdGhlIGFkanVzdGVkIHRpbWUgZGVsdGEuICovXG5cbiAgICAgIGR0ID0gdGltZV9sYXBzZWQgLyBkdXJhdGlvbiAqIERUO1xuICAgIH0gZWxzZSB7XG4gICAgICBkdCA9IERUO1xuICAgIH1cblxuICAgIGZvciAoOzspIHtcbiAgICAgIC8qIE5leHQvc3RlcCBmdW5jdGlvbiAuKi9cbiAgICAgIGxhc3Rfc3RhdGUgPSBzcHJpbmdJbnRlZ3JhdGVTdGF0ZShsYXN0X3N0YXRlIHx8IGluaXRTdGF0ZSwgZHQpO1xuICAgICAgLyogU3RvcmUgdGhlIHBvc2l0aW9uLiAqL1xuXG4gICAgICBwYXRoLnB1c2goMSArIGxhc3Rfc3RhdGUueCk7XG4gICAgICB0aW1lX2xhcHNlZCArPSAxNjtcbiAgICAgIC8qIElmIHRoZSBjaGFuZ2UgdGhyZXNob2xkIGlzIHJlYWNoZWQsIGJyZWFrLiAqL1xuXG4gICAgICBpZiAoIShNYXRoLmFicyhsYXN0X3N0YXRlLngpID4gdG9sZXJhbmNlICYmIE1hdGguYWJzKGxhc3Rfc3RhdGUudikgPiB0b2xlcmFuY2UpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiBkdXJhdGlvbiBpcyBub3QgZGVmaW5lZCwgcmV0dXJuIHRoZSBhY3R1YWwgdGltZSByZXF1aXJlZCBmb3IgY29tcGxldGluZyB0aGlzIGFuaW1hdGlvbi4gT3RoZXJ3aXNlLCByZXR1cm4gYSBjbG9zdXJlIHRoYXQgaG9sZHMgdGhlXG4gICAgICAgY29tcHV0ZWQgcGF0aCBhbmQgcmV0dXJucyBhIHNuYXBzaG90IG9mIHRoZSBwb3NpdGlvbiBhY2NvcmRpbmcgdG8gYSBnaXZlbiBwZXJjZW50Q29tcGxldGUuICovXG5cblxuICAgIHJldHVybiAhaGF2ZV9kdXJhdGlvbiA/IHRpbWVfbGFwc2VkIDogZnVuY3Rpb24gKHBlcmNlbnRDb21wbGV0ZSkge1xuICAgICAgcmV0dXJuIHBhdGhbcGVyY2VudENvbXBsZXRlICogKHBhdGgubGVuZ3RoIC0gMSkgfCAwXTtcbiAgICB9O1xuICB9O1xufSgpO1xuXG52YXIgY3ViaWNCZXppZXIgPSBmdW5jdGlvbiBjdWJpY0Jlemllcih0MSwgcDEsIHQyLCBwMikge1xuICB2YXIgYmV6aWVyID0gZ2VuZXJhdGVDdWJpY0Jlemllcih0MSwgcDEsIHQyLCBwMik7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgcGVyY2VudCkge1xuICAgIHJldHVybiBzdGFydCArIChlbmQgLSBzdGFydCkgKiBiZXppZXIocGVyY2VudCk7XG4gIH07XG59O1xuXG52YXIgZWFzaW5ncyA9IHtcbiAgJ2xpbmVhcic6IGZ1bmN0aW9uIGxpbmVhcihzdGFydCwgZW5kLCBwZXJjZW50KSB7XG4gICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIHBlcmNlbnQ7XG4gIH0sXG4gIC8vIGRlZmF1bHQgZWFzaW5nc1xuICAnZWFzZSc6IGN1YmljQmV6aWVyKDAuMjUsIDAuMSwgMC4yNSwgMSksXG4gICdlYXNlLWluJzogY3ViaWNCZXppZXIoMC40MiwgMCwgMSwgMSksXG4gICdlYXNlLW91dCc6IGN1YmljQmV6aWVyKDAsIDAsIDAuNTgsIDEpLFxuICAnZWFzZS1pbi1vdXQnOiBjdWJpY0JlemllcigwLjQyLCAwLCAwLjU4LCAxKSxcbiAgLy8gc2luZVxuICAnZWFzZS1pbi1zaW5lJzogY3ViaWNCZXppZXIoMC40NywgMCwgMC43NDUsIDAuNzE1KSxcbiAgJ2Vhc2Utb3V0LXNpbmUnOiBjdWJpY0JlemllcigwLjM5LCAwLjU3NSwgMC41NjUsIDEpLFxuICAnZWFzZS1pbi1vdXQtc2luZSc6IGN1YmljQmV6aWVyKDAuNDQ1LCAwLjA1LCAwLjU1LCAwLjk1KSxcbiAgLy8gcXVhZFxuICAnZWFzZS1pbi1xdWFkJzogY3ViaWNCZXppZXIoMC41NSwgMC4wODUsIDAuNjgsIDAuNTMpLFxuICAnZWFzZS1vdXQtcXVhZCc6IGN1YmljQmV6aWVyKDAuMjUsIDAuNDYsIDAuNDUsIDAuOTQpLFxuICAnZWFzZS1pbi1vdXQtcXVhZCc6IGN1YmljQmV6aWVyKDAuNDU1LCAwLjAzLCAwLjUxNSwgMC45NTUpLFxuICAvLyBjdWJpY1xuICAnZWFzZS1pbi1jdWJpYyc6IGN1YmljQmV6aWVyKDAuNTUsIDAuMDU1LCAwLjY3NSwgMC4xOSksXG4gICdlYXNlLW91dC1jdWJpYyc6IGN1YmljQmV6aWVyKDAuMjE1LCAwLjYxLCAwLjM1NSwgMSksXG4gICdlYXNlLWluLW91dC1jdWJpYyc6IGN1YmljQmV6aWVyKDAuNjQ1LCAwLjA0NSwgMC4zNTUsIDEpLFxuICAvLyBxdWFydFxuICAnZWFzZS1pbi1xdWFydCc6IGN1YmljQmV6aWVyKDAuODk1LCAwLjAzLCAwLjY4NSwgMC4yMiksXG4gICdlYXNlLW91dC1xdWFydCc6IGN1YmljQmV6aWVyKDAuMTY1LCAwLjg0LCAwLjQ0LCAxKSxcbiAgJ2Vhc2UtaW4tb3V0LXF1YXJ0JzogY3ViaWNCZXppZXIoMC43NywgMCwgMC4xNzUsIDEpLFxuICAvLyBxdWludFxuICAnZWFzZS1pbi1xdWludCc6IGN1YmljQmV6aWVyKDAuNzU1LCAwLjA1LCAwLjg1NSwgMC4wNiksXG4gICdlYXNlLW91dC1xdWludCc6IGN1YmljQmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpLFxuICAnZWFzZS1pbi1vdXQtcXVpbnQnOiBjdWJpY0JlemllcigwLjg2LCAwLCAwLjA3LCAxKSxcbiAgLy8gZXhwb1xuICAnZWFzZS1pbi1leHBvJzogY3ViaWNCZXppZXIoMC45NSwgMC4wNSwgMC43OTUsIDAuMDM1KSxcbiAgJ2Vhc2Utb3V0LWV4cG8nOiBjdWJpY0JlemllcigwLjE5LCAxLCAwLjIyLCAxKSxcbiAgJ2Vhc2UtaW4tb3V0LWV4cG8nOiBjdWJpY0JlemllcigxLCAwLCAwLCAxKSxcbiAgLy8gY2lyY1xuICAnZWFzZS1pbi1jaXJjJzogY3ViaWNCZXppZXIoMC42LCAwLjA0LCAwLjk4LCAwLjMzNSksXG4gICdlYXNlLW91dC1jaXJjJzogY3ViaWNCZXppZXIoMC4wNzUsIDAuODIsIDAuMTY1LCAxKSxcbiAgJ2Vhc2UtaW4tb3V0LWNpcmMnOiBjdWJpY0JlemllcigwLjc4NSwgMC4xMzUsIDAuMTUsIDAuODYpLFxuICAvLyB1c2VyIHBhcmFtIGVhc2luZ3MuLi5cbiAgJ3NwcmluZyc6IGZ1bmN0aW9uIHNwcmluZyh0ZW5zaW9uLCBmcmljdGlvbiwgZHVyYXRpb24pIHtcbiAgICBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICAgIC8vIGNhbid0IGdldCBhIHNwcmluZyB3LyBkdXJhdGlvbiAwXG4gICAgICByZXR1cm4gZWFzaW5ncy5saW5lYXI7IC8vIGR1cmF0aW9uIDAgPT4ganVtcCB0byBlbmQgc28gaW1wbCBkb2Vzbid0IG1hdHRlclxuICAgIH1cblxuICAgIHZhciBzcHJpbmcgPSBnZW5lcmF0ZVNwcmluZ1JLNCh0ZW5zaW9uLCBmcmljdGlvbiwgZHVyYXRpb24pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgcGVyY2VudCkge1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIHNwcmluZyhwZXJjZW50KTtcbiAgICB9O1xuICB9LFxuICAnY3ViaWMtYmV6aWVyJzogY3ViaWNCZXppZXJcbn07XG5cbmZ1bmN0aW9uIGdldEVhc2VkVmFsdWUodHlwZSwgc3RhcnQsIGVuZCwgcGVyY2VudCwgZWFzaW5nRm4pIHtcbiAgaWYgKHBlcmNlbnQgPT09IDEpIHtcbiAgICByZXR1cm4gZW5kO1xuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICByZXR1cm4gZW5kO1xuICB9XG5cbiAgdmFyIHZhbCA9IGVhc2luZ0ZuKHN0YXJ0LCBlbmQsIHBlcmNlbnQpO1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgaWYgKHR5cGUucm91bmRWYWx1ZSB8fCB0eXBlLmNvbG9yKSB7XG4gICAgdmFsID0gTWF0aC5yb3VuZCh2YWwpO1xuICB9XG5cbiAgaWYgKHR5cGUubWluICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWwgPSBNYXRoLm1heCh2YWwsIHR5cGUubWluKTtcbiAgfVxuXG4gIGlmICh0eXBlLm1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsID0gTWF0aC5taW4odmFsLCB0eXBlLm1heCk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZShwcm9wLCBzcGVjKSB7XG4gIGlmIChwcm9wLnBmVmFsdWUgIT0gbnVsbCB8fCBwcm9wLnZhbHVlICE9IG51bGwpIHtcbiAgICBpZiAocHJvcC5wZlZhbHVlICE9IG51bGwgJiYgKHNwZWMgPT0gbnVsbCB8fCBzcGVjLnR5cGUudW5pdHMgIT09ICclJykpIHtcbiAgICAgIHJldHVybiBwcm9wLnBmVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwcm9wLnZhbHVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJvcDtcbiAgfVxufVxuXG5mdW5jdGlvbiBlYXNlKHN0YXJ0UHJvcCwgZW5kUHJvcCwgcGVyY2VudCwgZWFzaW5nRm4sIHByb3BTcGVjKSB7XG4gIHZhciB0eXBlID0gcHJvcFNwZWMgIT0gbnVsbCA/IHByb3BTcGVjLnR5cGUgOiBudWxsO1xuXG4gIGlmIChwZXJjZW50IDwgMCkge1xuICAgIHBlcmNlbnQgPSAwO1xuICB9IGVsc2UgaWYgKHBlcmNlbnQgPiAxKSB7XG4gICAgcGVyY2VudCA9IDE7XG4gIH1cblxuICB2YXIgc3RhcnQgPSBnZXRWYWx1ZShzdGFydFByb3AsIHByb3BTcGVjKTtcbiAgdmFyIGVuZCA9IGdldFZhbHVlKGVuZFByb3AsIHByb3BTcGVjKTtcblxuICBpZiAobnVtYmVyJDEoc3RhcnQpICYmIG51bWJlciQxKGVuZCkpIHtcbiAgICByZXR1cm4gZ2V0RWFzZWRWYWx1ZSh0eXBlLCBzdGFydCwgZW5kLCBwZXJjZW50LCBlYXNpbmdGbik7XG4gIH0gZWxzZSBpZiAoYXJyYXkoc3RhcnQpICYmIGFycmF5KGVuZCkpIHtcbiAgICB2YXIgZWFzZWRBcnIgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2kgPSBzdGFydFtpXTtcbiAgICAgIHZhciBlaSA9IGVuZFtpXTtcblxuICAgICAgaWYgKHNpICE9IG51bGwgJiYgZWkgIT0gbnVsbCkge1xuICAgICAgICB2YXIgdmFsID0gZ2V0RWFzZWRWYWx1ZSh0eXBlLCBzaSwgZWksIHBlcmNlbnQsIGVhc2luZ0ZuKTtcbiAgICAgICAgZWFzZWRBcnIucHVzaCh2YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWFzZWRBcnIucHVzaChlaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVhc2VkQXJyO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gc3RlcCQxKHNlbGYsIGFuaSwgbm93LCBpc0NvcmUpIHtcbiAgdmFyIGlzRWxlcyA9ICFpc0NvcmU7XG4gIHZhciBfcCA9IHNlbGYuX3ByaXZhdGU7XG4gIHZhciBhbmlfcCA9IGFuaS5fcHJpdmF0ZTtcbiAgdmFyIHBFYXNpbmcgPSBhbmlfcC5lYXNpbmc7XG4gIHZhciBzdGFydFRpbWUgPSBhbmlfcC5zdGFydFRpbWU7XG4gIHZhciBjeSA9IGlzQ29yZSA/IHNlbGYgOiBzZWxmLmN5KCk7XG4gIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG5cbiAgaWYgKCFhbmlfcC5lYXNpbmdJbXBsKSB7XG4gICAgaWYgKHBFYXNpbmcgPT0gbnVsbCkge1xuICAgICAgLy8gdXNlIGRlZmF1bHRcbiAgICAgIGFuaV9wLmVhc2luZ0ltcGwgPSBlYXNpbmdzWydsaW5lYXInXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGhlbiBkZWZpbmUgdy8gbmFtZVxuICAgICAgdmFyIGVhc2luZ1ZhbHM7XG5cbiAgICAgIGlmIChzdHJpbmcocEVhc2luZykpIHtcbiAgICAgICAgdmFyIGVhc2luZ1Byb3AgPSBzdHlsZS5wYXJzZSgndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nLCBwRWFzaW5nKTtcbiAgICAgICAgZWFzaW5nVmFscyA9IGVhc2luZ1Byb3AudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGVuIGFzc3VtZSBwcmVwYXJzZWQgYXJyYXlcbiAgICAgICAgZWFzaW5nVmFscyA9IHBFYXNpbmc7XG4gICAgICB9XG5cbiAgICAgIHZhciBuYW1lLCBhcmdzO1xuXG4gICAgICBpZiAoc3RyaW5nKGVhc2luZ1ZhbHMpKSB7XG4gICAgICAgIG5hbWUgPSBlYXNpbmdWYWxzO1xuICAgICAgICBhcmdzID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lID0gZWFzaW5nVmFsc1sxXTtcbiAgICAgICAgYXJncyA9IGVhc2luZ1ZhbHMuc2xpY2UoMikubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgcmV0dXJuICtuO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBjcmVhdGUgd2l0aCBhcmdzXG4gICAgICAgIGlmIChuYW1lID09PSAnc3ByaW5nJykge1xuICAgICAgICAgIGFyZ3MucHVzaChhbmlfcC5kdXJhdGlvbik7IC8vIG5lZWQgZHVyYXRpb24gdG8gZ2VuZXJhdGUgc3ByaW5nXG4gICAgICAgIH1cblxuICAgICAgICBhbmlfcC5lYXNpbmdJbXBsID0gZWFzaW5nc1tuYW1lXS5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHN0YXRpYyBpbXBsIGJ5IG5hbWVcbiAgICAgICAgYW5pX3AuZWFzaW5nSW1wbCA9IGVhc2luZ3NbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGVhc2luZyA9IGFuaV9wLmVhc2luZ0ltcGw7XG4gIHZhciBwZXJjZW50O1xuXG4gIGlmIChhbmlfcC5kdXJhdGlvbiA9PT0gMCkge1xuICAgIHBlcmNlbnQgPSAxO1xuICB9IGVsc2Uge1xuICAgIHBlcmNlbnQgPSAobm93IC0gc3RhcnRUaW1lKSAvIGFuaV9wLmR1cmF0aW9uO1xuICB9XG5cbiAgaWYgKGFuaV9wLmFwcGx5aW5nKSB7XG4gICAgcGVyY2VudCA9IGFuaV9wLnByb2dyZXNzO1xuICB9XG5cbiAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgcGVyY2VudCA9IDA7XG4gIH0gZWxzZSBpZiAocGVyY2VudCA+IDEpIHtcbiAgICBwZXJjZW50ID0gMTtcbiAgfVxuXG4gIGlmIChhbmlfcC5kZWxheSA9PSBudWxsKSB7XG4gICAgLy8gdGhlbiB1cGRhdGVcbiAgICB2YXIgc3RhcnRQb3MgPSBhbmlfcC5zdGFydFBvc2l0aW9uO1xuICAgIHZhciBlbmRQb3MgPSBhbmlfcC5wb3NpdGlvbjtcblxuICAgIGlmIChlbmRQb3MgJiYgaXNFbGVzICYmICFzZWxmLmxvY2tlZCgpKSB7XG4gICAgICB2YXIgbmV3UG9zID0ge307XG5cbiAgICAgIGlmICh2YWxpZChzdGFydFBvcy54LCBlbmRQb3MueCkpIHtcbiAgICAgICAgbmV3UG9zLnggPSBlYXNlKHN0YXJ0UG9zLngsIGVuZFBvcy54LCBwZXJjZW50LCBlYXNpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsaWQoc3RhcnRQb3MueSwgZW5kUG9zLnkpKSB7XG4gICAgICAgIG5ld1Bvcy55ID0gZWFzZShzdGFydFBvcy55LCBlbmRQb3MueSwgcGVyY2VudCwgZWFzaW5nKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5wb3NpdGlvbihuZXdQb3MpO1xuICAgIH1cblxuICAgIHZhciBzdGFydFBhbiA9IGFuaV9wLnN0YXJ0UGFuO1xuICAgIHZhciBlbmRQYW4gPSBhbmlfcC5wYW47XG4gICAgdmFyIHBhbiA9IF9wLnBhbjtcbiAgICB2YXIgYW5pbWF0aW5nUGFuID0gZW5kUGFuICE9IG51bGwgJiYgaXNDb3JlO1xuXG4gICAgaWYgKGFuaW1hdGluZ1Bhbikge1xuICAgICAgaWYgKHZhbGlkKHN0YXJ0UGFuLngsIGVuZFBhbi54KSkge1xuICAgICAgICBwYW4ueCA9IGVhc2Uoc3RhcnRQYW4ueCwgZW5kUGFuLngsIHBlcmNlbnQsIGVhc2luZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWxpZChzdGFydFBhbi55LCBlbmRQYW4ueSkpIHtcbiAgICAgICAgcGFuLnkgPSBlYXNlKHN0YXJ0UGFuLnksIGVuZFBhbi55LCBwZXJjZW50LCBlYXNpbmcpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLmVtaXQoJ3BhbicpO1xuICAgIH1cblxuICAgIHZhciBzdGFydFpvb20gPSBhbmlfcC5zdGFydFpvb207XG4gICAgdmFyIGVuZFpvb20gPSBhbmlfcC56b29tO1xuICAgIHZhciBhbmltYXRpbmdab29tID0gZW5kWm9vbSAhPSBudWxsICYmIGlzQ29yZTtcblxuICAgIGlmIChhbmltYXRpbmdab29tKSB7XG4gICAgICBpZiAodmFsaWQoc3RhcnRab29tLCBlbmRab29tKSkge1xuICAgICAgICBfcC56b29tID0gYm91bmQoX3AubWluWm9vbSwgZWFzZShzdGFydFpvb20sIGVuZFpvb20sIHBlcmNlbnQsIGVhc2luZyksIF9wLm1heFpvb20pO1xuICAgICAgfVxuXG4gICAgICBzZWxmLmVtaXQoJ3pvb20nKTtcbiAgICB9XG5cbiAgICBpZiAoYW5pbWF0aW5nUGFuIHx8IGFuaW1hdGluZ1pvb20pIHtcbiAgICAgIHNlbGYuZW1pdCgndmlld3BvcnQnKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcHMgPSBhbmlfcC5zdHlsZTtcblxuICAgIGlmIChwcm9wcyAmJiBwcm9wcy5sZW5ndGggPiAwICYmIGlzRWxlcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgICB2YXIgX25hbWUgPSBwcm9wLm5hbWU7XG4gICAgICAgIHZhciBlbmQgPSBwcm9wO1xuICAgICAgICB2YXIgc3RhcnQgPSBhbmlfcC5zdGFydFN0eWxlW19uYW1lXTtcbiAgICAgICAgdmFyIHByb3BTcGVjID0gc3R5bGUucHJvcGVydGllc1tzdGFydC5uYW1lXTtcbiAgICAgICAgdmFyIGVhc2VkVmFsID0gZWFzZShzdGFydCwgZW5kLCBwZXJjZW50LCBlYXNpbmcsIHByb3BTcGVjKTtcbiAgICAgICAgc3R5bGUub3ZlcnJpZGVCeXBhc3Moc2VsZiwgX25hbWUsIGVhc2VkVmFsKTtcbiAgICAgIH0gLy8gZm9yIHByb3BzXG5cblxuICAgICAgc2VsZi5lbWl0KCdzdHlsZScpO1xuICAgIH0gLy8gaWZcblxuICB9XG5cbiAgYW5pX3AucHJvZ3Jlc3MgPSBwZXJjZW50O1xuICByZXR1cm4gcGVyY2VudDtcbn1cblxuZnVuY3Rpb24gdmFsaWQoc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT0gbnVsbCB8fCBlbmQgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChudW1iZXIkMShzdGFydCkgJiYgbnVtYmVyJDEoZW5kKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKHN0YXJ0ICYmIGVuZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzdGFydEFuaW1hdGlvbihzZWxmLCBhbmksIG5vdywgaXNDb3JlKSB7XG4gIHZhciBhbmlfcCA9IGFuaS5fcHJpdmF0ZTtcbiAgYW5pX3Auc3RhcnRlZCA9IHRydWU7XG4gIGFuaV9wLnN0YXJ0VGltZSA9IG5vdyAtIGFuaV9wLnByb2dyZXNzICogYW5pX3AuZHVyYXRpb247XG59XG5cbmZ1bmN0aW9uIHN0ZXBBbGwobm93LCBjeSkge1xuICB2YXIgZWxlcyA9IGN5Ll9wcml2YXRlLmFuaUVsZXM7XG4gIHZhciBkb25lRWxlcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIHN0ZXBPbmUoZWxlLCBpc0NvcmUpIHtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIGN1cnJlbnQgPSBfcC5hbmltYXRpb24uY3VycmVudDtcbiAgICB2YXIgcXVldWUgPSBfcC5hbmltYXRpb24ucXVldWU7XG4gICAgdmFyIHJhbkFuaXMgPSBmYWxzZTsgLy8gaWYgbm90aGluZyBjdXJyZW50bHkgYW5pbWF0aW5nLCBnZXQgc29tZXRoaW5nIGZyb20gdGhlIHF1ZXVlXG5cbiAgICBpZiAoY3VycmVudC5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhciBuZXh0ID0gcXVldWUuc2hpZnQoKTtcblxuICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgY3VycmVudC5wdXNoKG5leHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjYWxsYmFja3MgPSBmdW5jdGlvbiBjYWxsYmFja3MoX2NhbGxiYWNrcykge1xuICAgICAgZm9yICh2YXIgaiA9IF9jYWxsYmFja3MubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgdmFyIGNiID0gX2NhbGxiYWNrc1tqXTtcbiAgICAgICAgY2IoKTtcbiAgICAgIH1cblxuICAgICAgX2NhbGxiYWNrcy5zcGxpY2UoMCwgX2NhbGxiYWNrcy5sZW5ndGgpO1xuICAgIH07IC8vIHN0ZXAgYW5kIHJlbW92ZSBpZiBkb25lXG5cblxuICAgIGZvciAodmFyIGkgPSBjdXJyZW50Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYW5pID0gY3VycmVudFtpXTtcbiAgICAgIHZhciBhbmlfcCA9IGFuaS5fcHJpdmF0ZTtcblxuICAgICAgaWYgKGFuaV9wLnN0b3BwZWQpIHtcbiAgICAgICAgY3VycmVudC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGFuaV9wLmhvb2tlZCA9IGZhbHNlO1xuICAgICAgICBhbmlfcC5wbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIGFuaV9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgY2FsbGJhY2tzKGFuaV9wLmZyYW1lcyk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFuaV9wLnBsYXlpbmcgJiYgIWFuaV9wLmFwcGx5aW5nKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBhbiBhcHBseSgpIHdoaWxlIHBsYXlpbmcgc2hvdWxkbid0IGRvIGFueXRoaW5nXG5cblxuICAgICAgaWYgKGFuaV9wLnBsYXlpbmcgJiYgYW5pX3AuYXBwbHlpbmcpIHtcbiAgICAgICAgYW5pX3AuYXBwbHlpbmcgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhbmlfcC5zdGFydGVkKSB7XG4gICAgICAgIHN0YXJ0QW5pbWF0aW9uKGVsZSwgYW5pLCBub3cpO1xuICAgICAgfVxuXG4gICAgICBzdGVwJDEoZWxlLCBhbmksIG5vdywgaXNDb3JlKTtcblxuICAgICAgaWYgKGFuaV9wLmFwcGx5aW5nKSB7XG4gICAgICAgIGFuaV9wLmFwcGx5aW5nID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrcyhhbmlfcC5mcmFtZXMpO1xuXG4gICAgICBpZiAoYW5pX3Auc3RlcCAhPSBudWxsKSB7XG4gICAgICAgIGFuaV9wLnN0ZXAobm93KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFuaS5jb21wbGV0ZWQoKSkge1xuICAgICAgICBjdXJyZW50LnNwbGljZShpLCAxKTtcbiAgICAgICAgYW5pX3AuaG9va2VkID0gZmFsc2U7XG4gICAgICAgIGFuaV9wLnBsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgYW5pX3Auc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBjYWxsYmFja3MoYW5pX3AuY29tcGxldGVzKTtcbiAgICAgIH1cblxuICAgICAgcmFuQW5pcyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFpc0NvcmUgJiYgY3VycmVudC5sZW5ndGggPT09IDAgJiYgcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICBkb25lRWxlcy5wdXNoKGVsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbkFuaXM7XG4gIH0gLy8gc3RlcEVsZW1lbnRcbiAgLy8gaGFuZGxlIGFsbCBlbGVzXG5cblxuICB2YXIgcmFuRWxlQW5pID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgZSA9IDA7IGUgPCBlbGVzLmxlbmd0aDsgZSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbZV07XG4gICAgdmFyIGhhbmRsZWRUaGlzRWxlID0gc3RlcE9uZShlbGUpO1xuICAgIHJhbkVsZUFuaSA9IHJhbkVsZUFuaSB8fCBoYW5kbGVkVGhpc0VsZTtcbiAgfSAvLyBlYWNoIGVsZW1lbnRcblxuXG4gIHZhciByYW5Db3JlQW5pID0gc3RlcE9uZShjeSwgdHJ1ZSk7IC8vIG5vdGlmeSByZW5kZXJlclxuXG4gIGlmIChyYW5FbGVBbmkgfHwgcmFuQ29yZUFuaSkge1xuICAgIGlmIChlbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGN5Lm5vdGlmeSgnZHJhdycsIGVsZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjeS5ub3RpZnkoJ2RyYXcnKTtcbiAgICB9XG4gIH0gLy8gcmVtb3ZlIGVsZW1lbnRzIGZyb20gbGlzdCBvZiBjdXJyZW50bHkgYW5pbWF0aW5nIGlmIGl0cyBxdWV1ZXMgYXJlIGVtcHR5XG5cblxuICBlbGVzLnVubWVyZ2UoZG9uZUVsZXMpO1xuICBjeS5lbWl0KCdzdGVwJyk7XG59IC8vIHN0ZXBBbGxcblxudmFyIGNvcmVmbiQ4ID0ge1xuICAvLyBwdWxsIGluIGFuaW1hdGlvbiBmdW5jdGlvbnNcbiAgYW5pbWF0ZTogZGVmaW5lLmFuaW1hdGUoKSxcbiAgYW5pbWF0aW9uOiBkZWZpbmUuYW5pbWF0aW9uKCksXG4gIGFuaW1hdGVkOiBkZWZpbmUuYW5pbWF0ZWQoKSxcbiAgY2xlYXJRdWV1ZTogZGVmaW5lLmNsZWFyUXVldWUoKSxcbiAgZGVsYXk6IGRlZmluZS5kZWxheSgpLFxuICBkZWxheUFuaW1hdGlvbjogZGVmaW5lLmRlbGF5QW5pbWF0aW9uKCksXG4gIHN0b3A6IGRlZmluZS5zdG9wKCksXG4gIGFkZFRvQW5pbWF0aW9uUG9vbDogZnVuY3Rpb24gYWRkVG9BbmltYXRpb25Qb29sKGVsZXMpIHtcbiAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gc2F2ZSBjeWNsZXMgd2hlbiBubyBzdHlsZSB1c2VkXG5cblxuICAgIGN5Ll9wcml2YXRlLmFuaUVsZXMubWVyZ2UoZWxlcyk7XG4gIH0sXG4gIHN0b3BBbmltYXRpb25Mb29wOiBmdW5jdGlvbiBzdG9wQW5pbWF0aW9uTG9vcCgpIHtcbiAgICB0aGlzLl9wcml2YXRlLmFuaW1hdGlvbnNSdW5uaW5nID0gZmFsc2U7XG4gIH0sXG4gIHN0YXJ0QW5pbWF0aW9uTG9vcDogZnVuY3Rpb24gc3RhcnRBbmltYXRpb25Mb29wKCkge1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgY3kuX3ByaXZhdGUuYW5pbWF0aW9uc1J1bm5pbmcgPSB0cnVlO1xuXG4gICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gc2F2ZSBjeWNsZXMgd2hlbiBubyBzdHlsZSB1c2VkXG4gICAgLy8gTkIgdGhlIGFuaW1hdGlvbiBsb29wIHdpbGwgZXhlYyBpbiBoZWFkbGVzcyBlbnZpcm9ubWVudHMgaWYgc3R5bGUgZW5hYmxlZFxuICAgIC8vIGFuZCBleHBsaWNpdCBjeS5kZXN0cm95KCkgaXMgbmVjZXNzYXJ5IHRvIHN0b3AgdGhlIGxvb3BcblxuXG4gICAgZnVuY3Rpb24gaGVhZGxlc3NTdGVwKCkge1xuICAgICAgaWYgKCFjeS5fcHJpdmF0ZS5hbmltYXRpb25zUnVubmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBhbmltYXRpb25TdGVwKG5vdykge1xuICAgICAgICBzdGVwQWxsKG5vdywgY3kpO1xuICAgICAgICBoZWFkbGVzc1N0ZXAoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciByZW5kZXJlciA9IGN5LnJlbmRlcmVyKCk7XG5cbiAgICBpZiAocmVuZGVyZXIgJiYgcmVuZGVyZXIuYmVmb3JlUmVuZGVyKSB7XG4gICAgICAvLyBsZXQgdGhlIHJlbmRlcmVyIHNjaGVkdWxlIGFuaW1hdGlvbnNcbiAgICAgIHJlbmRlcmVyLmJlZm9yZVJlbmRlcihmdW5jdGlvbiByZW5kZXJlckFuaW1hdGlvblN0ZXAod2lsbERyYXcsIG5vdykge1xuICAgICAgICBzdGVwQWxsKG5vdywgY3kpO1xuICAgICAgfSwgcmVuZGVyZXIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcy5hbmltYXRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbWFuYWdlIHRoZSBhbmltYXRpb24gbG9vcCBvdXJzZWx2ZXNcbiAgICAgIGhlYWRsZXNzU3RlcCgpOyAvLyBmaXJzdCBjYWxsXG4gICAgfVxuICB9XG59O1xuXG52YXIgZW1pdHRlck9wdGlvbnMgPSB7XG4gIHF1YWxpZmllckNvbXBhcmU6IGZ1bmN0aW9uIHF1YWxpZmllckNvbXBhcmUoc2VsZWN0b3IxLCBzZWxlY3RvcjIpIHtcbiAgICBpZiAoc2VsZWN0b3IxID09IG51bGwgfHwgc2VsZWN0b3IyID09IG51bGwpIHtcbiAgICAgIHJldHVybiBzZWxlY3RvcjEgPT0gbnVsbCAmJiBzZWxlY3RvcjIgPT0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNlbGVjdG9yMS5zYW1lVGV4dChzZWxlY3RvcjIpO1xuICAgIH1cbiAgfSxcbiAgZXZlbnRNYXRjaGVzOiBmdW5jdGlvbiBldmVudE1hdGNoZXMoY3ksIGxpc3RlbmVyLCBldmVudE9iaikge1xuICAgIHZhciBzZWxlY3RvciA9IGxpc3RlbmVyLnF1YWxpZmllcjtcblxuICAgIGlmIChzZWxlY3RvciAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gY3kgIT09IGV2ZW50T2JqLnRhcmdldCAmJiBlbGVtZW50KGV2ZW50T2JqLnRhcmdldCkgJiYgc2VsZWN0b3IubWF0Y2hlcyhldmVudE9iai50YXJnZXQpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBhZGRFdmVudEZpZWxkczogZnVuY3Rpb24gYWRkRXZlbnRGaWVsZHMoY3ksIGV2dCkge1xuICAgIGV2dC5jeSA9IGN5O1xuICAgIGV2dC50YXJnZXQgPSBjeTtcbiAgfSxcbiAgY2FsbGJhY2tDb250ZXh0OiBmdW5jdGlvbiBjYWxsYmFja0NvbnRleHQoY3ksIGxpc3RlbmVyLCBldmVudE9iaikge1xuICAgIHJldHVybiBsaXN0ZW5lci5xdWFsaWZpZXIgIT0gbnVsbCA/IGV2ZW50T2JqLnRhcmdldCA6IGN5O1xuICB9XG59O1xuXG52YXIgYXJnU2VsZWN0b3IgPSBmdW5jdGlvbiBhcmdTZWxlY3RvcihhcmcpIHtcbiAgaWYgKHN0cmluZyhhcmcpKSB7XG4gICAgcmV0dXJuIG5ldyBTZWxlY3RvcihhcmcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhcmc7XG4gIH1cbn07XG5cbnZhciBlbGVzZm4gPSB7XG4gIGNyZWF0ZUVtaXR0ZXI6IGZ1bmN0aW9uIGNyZWF0ZUVtaXR0ZXIoKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmICghX3AuZW1pdHRlcikge1xuICAgICAgX3AuZW1pdHRlciA9IG5ldyBFbWl0dGVyKGVtaXR0ZXJPcHRpb25zLCB0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW1pdHRlcjogZnVuY3Rpb24gZW1pdHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbWl0dGVyO1xuICB9LFxuICBvbjogZnVuY3Rpb24gb24oZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmVtaXR0ZXIoKS5vbihldmVudHMsIGFyZ1NlbGVjdG9yKHNlbGVjdG9yKSwgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZW1vdmVMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmVtaXR0ZXIoKS5yZW1vdmVMaXN0ZW5lcihldmVudHMsIGFyZ1NlbGVjdG9yKHNlbGVjdG9yKSwgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZW1vdmVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICB0aGlzLmVtaXR0ZXIoKS5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgb25lOiBmdW5jdGlvbiBvbmUoZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmVtaXR0ZXIoKS5vbmUoZXZlbnRzLCBhcmdTZWxlY3RvcihzZWxlY3RvciksIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgb25jZTogZnVuY3Rpb24gb25jZShldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgIHRoaXMuZW1pdHRlcigpLm9uZShldmVudHMsIGFyZ1NlbGVjdG9yKHNlbGVjdG9yKSwgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBlbWl0OiBmdW5jdGlvbiBlbWl0KGV2ZW50cywgZXh0cmFQYXJhbXMpIHtcbiAgICB0aGlzLmVtaXR0ZXIoKS5lbWl0KGV2ZW50cywgZXh0cmFQYXJhbXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBlbWl0QW5kTm90aWZ5OiBmdW5jdGlvbiBlbWl0QW5kTm90aWZ5KGV2ZW50LCBlbGVzKSB7XG4gICAgdGhpcy5lbWl0KGV2ZW50KTtcbiAgICB0aGlzLm5vdGlmeShldmVudCwgZWxlcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5kZWZpbmUuZXZlbnRBbGlhc2VzT24oZWxlc2ZuKTtcblxudmFyIGNvcmVmbiQ3ID0ge1xuICBwbmc6IGZ1bmN0aW9uIHBuZyhvcHRpb25zKSB7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gcmVuZGVyZXIucG5nKG9wdGlvbnMpO1xuICB9LFxuICBqcGc6IGZ1bmN0aW9uIGpwZyhvcHRpb25zKSB7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmJnID0gb3B0aW9ucy5iZyB8fCAnI2ZmZic7XG4gICAgcmV0dXJuIHJlbmRlcmVyLmpwZyhvcHRpb25zKTtcbiAgfVxufTtcbmNvcmVmbiQ3LmpwZWcgPSBjb3JlZm4kNy5qcGc7XG5cbnZhciBjb3JlZm4kNiA9IHtcbiAgbGF5b3V0OiBmdW5jdGlvbiBsYXlvdXQob3B0aW9ucykge1xuICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICBlcnJvcignTGF5b3V0IG9wdGlvbnMgbXVzdCBiZSBzcGVjaWZpZWQgdG8gbWFrZSBhIGxheW91dCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm5hbWUgPT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0EgYG5hbWVgIG11c3QgYmUgc3BlY2lmaWVkIHRvIG1ha2UgYSBsYXlvdXQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgICB2YXIgTGF5b3V0ID0gY3kuZXh0ZW5zaW9uKCdsYXlvdXQnLCBuYW1lKTtcblxuICAgIGlmIChMYXlvdXQgPT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ05vIHN1Y2ggbGF5b3V0IGAnICsgbmFtZSArICdgIGZvdW5kLiAgRGlkIHlvdSBmb3JnZXQgdG8gaW1wb3J0IGl0IGFuZCBgY3l0b3NjYXBlLnVzZSgpYCBpdD8nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZWxlcztcblxuICAgIGlmIChzdHJpbmcob3B0aW9ucy5lbGVzKSkge1xuICAgICAgZWxlcyA9IGN5LiQob3B0aW9ucy5lbGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlcyA9IG9wdGlvbnMuZWxlcyAhPSBudWxsID8gb3B0aW9ucy5lbGVzIDogY3kuJCgpO1xuICAgIH1cblxuICAgIHZhciBsYXlvdXQgPSBuZXcgTGF5b3V0KGV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgY3k6IGN5LFxuICAgICAgZWxlczogZWxlc1xuICAgIH0pKTtcbiAgICByZXR1cm4gbGF5b3V0O1xuICB9XG59O1xuY29yZWZuJDYuY3JlYXRlTGF5b3V0ID0gY29yZWZuJDYubWFrZUxheW91dCA9IGNvcmVmbiQ2LmxheW91dDtcblxudmFyIGNvcmVmbiQ1ID0ge1xuICBub3RpZnk6IGZ1bmN0aW9uIG5vdGlmeShldmVudE5hbWUsIGV2ZW50RWxlcykge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiAodGhpcy5iYXRjaGluZygpKSB7XG4gICAgICBfcC5iYXRjaE5vdGlmaWNhdGlvbnMgPSBfcC5iYXRjaE5vdGlmaWNhdGlvbnMgfHwge307XG4gICAgICB2YXIgZWxlcyA9IF9wLmJhdGNoTm90aWZpY2F0aW9uc1tldmVudE5hbWVdID0gX3AuYmF0Y2hOb3RpZmljYXRpb25zW2V2ZW50TmFtZV0gfHwgdGhpcy5jb2xsZWN0aW9uKCk7XG5cbiAgICAgIGlmIChldmVudEVsZXMgIT0gbnVsbCkge1xuICAgICAgICBlbGVzLm1lcmdlKGV2ZW50RWxlcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjsgLy8gbm90aWZpY2F0aW9ucyBhcmUgZGlzYWJsZWQgZHVyaW5nIGJhdGNoaW5nXG4gICAgfVxuXG4gICAgaWYgKCFfcC5ub3RpZmljYXRpb25zRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gZXhpdCBvbiBkaXNhYmxlZFxuXG5cbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyKCk7IC8vIGV4aXQgaWYgZGVzdHJveSgpIGNhbGxlZCBvbiBjb3JlIG9yIHJlbmRlcmVyIGluIGJldHdlZW4gZnJhbWVzICMxNDk5ICMxNTI4XG5cbiAgICBpZiAodGhpcy5kZXN0cm95ZWQoKSB8fCAhcmVuZGVyZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZW5kZXJlci5ub3RpZnkoZXZlbnROYW1lLCBldmVudEVsZXMpO1xuICB9LFxuICBub3RpZmljYXRpb25zOiBmdW5jdGlvbiBub3RpZmljYXRpb25zKGJvb2wpIHtcbiAgICB2YXIgcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiAoYm9vbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcC5ub3RpZmljYXRpb25zRW5hYmxlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcC5ub3RpZmljYXRpb25zRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG5vTm90aWZpY2F0aW9uczogZnVuY3Rpb24gbm9Ob3RpZmljYXRpb25zKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5ub3RpZmljYXRpb25zKGZhbHNlKTtcbiAgICBjYWxsYmFjaygpO1xuICAgIHRoaXMubm90aWZpY2F0aW9ucyh0cnVlKTtcbiAgfSxcbiAgYmF0Y2hpbmc6IGZ1bmN0aW9uIGJhdGNoaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmJhdGNoQ291bnQgPiAwO1xuICB9LFxuICBzdGFydEJhdGNoOiBmdW5jdGlvbiBzdGFydEJhdGNoKCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiAoX3AuYmF0Y2hDb3VudCA9PSBudWxsKSB7XG4gICAgICBfcC5iYXRjaENvdW50ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoX3AuYmF0Y2hDb3VudCA9PT0gMCkge1xuICAgICAgX3AuYmF0Y2hTdHlsZUVsZXMgPSB0aGlzLmNvbGxlY3Rpb24oKTtcbiAgICAgIF9wLmJhdGNoTm90aWZpY2F0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIF9wLmJhdGNoQ291bnQrKztcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW5kQmF0Y2g6IGZ1bmN0aW9uIGVuZEJhdGNoKCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiAoX3AuYmF0Y2hDb3VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgX3AuYmF0Y2hDb3VudC0tO1xuXG4gICAgaWYgKF9wLmJhdGNoQ291bnQgPT09IDApIHtcbiAgICAgIC8vIHVwZGF0ZSBzdHlsZSBmb3IgZGlydHkgZWxlc1xuICAgICAgX3AuYmF0Y2hTdHlsZUVsZXMudXBkYXRlU3R5bGUoKTtcblxuICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcigpOyAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIG9mIHF1ZXVlZCBlbGVzIGFuZCBldmVudCB0eXBlc1xuXG4gICAgICBPYmplY3Qua2V5cyhfcC5iYXRjaE5vdGlmaWNhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICB2YXIgZWxlcyA9IF9wLmJhdGNoTm90aWZpY2F0aW9uc1tldmVudE5hbWVdO1xuXG4gICAgICAgIGlmIChlbGVzLmVtcHR5KCkpIHtcbiAgICAgICAgICByZW5kZXJlci5ub3RpZnkoZXZlbnROYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW5kZXJlci5ub3RpZnkoZXZlbnROYW1lLCBlbGVzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGJhdGNoOiBmdW5jdGlvbiBiYXRjaChjYWxsYmFjaykge1xuICAgIHRoaXMuc3RhcnRCYXRjaCgpO1xuICAgIGNhbGxiYWNrKCk7XG4gICAgdGhpcy5lbmRCYXRjaCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgYmF0Y2hEYXRhOiBmdW5jdGlvbiBiYXRjaERhdGEobWFwKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICByZXR1cm4gdGhpcy5iYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaWRzID0gT2JqZWN0LmtleXMobWFwKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlkID0gaWRzW2ldO1xuICAgICAgICB2YXIgZGF0YSA9IG1hcFtpZF07XG4gICAgICAgIHZhciBlbGUgPSBjeS5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgIGVsZS5kYXRhKGRhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgcmVuZGVyZXJEZWZhdWx0cyA9IGRlZmF1bHRzJGcoe1xuICBoaWRlRWRnZXNPblZpZXdwb3J0OiBmYWxzZSxcbiAgdGV4dHVyZU9uVmlld3BvcnQ6IGZhbHNlLFxuICBtb3Rpb25CbHVyOiBmYWxzZSxcbiAgbW90aW9uQmx1ck9wYWNpdHk6IDAuMDUsXG4gIHBpeGVsUmF0aW86IHVuZGVmaW5lZCxcbiAgZGVza3RvcFRhcFRocmVzaG9sZDogNCxcbiAgdG91Y2hUYXBUaHJlc2hvbGQ6IDgsXG4gIHdoZWVsU2Vuc2l0aXZpdHk6IDEsXG4gIGRlYnVnOiBmYWxzZSxcbiAgc2hvd0ZwczogZmFsc2Vcbn0pO1xudmFyIGNvcmVmbiQ0ID0ge1xuICByZW5kZXJUbzogZnVuY3Rpb24gcmVuZGVyVG8oY29udGV4dCwgem9vbSwgcGFuLCBweFJhdGlvKSB7XG4gICAgdmFyIHIgPSB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuICAgIHIucmVuZGVyVG8oY29udGV4dCwgem9vbSwgcGFuLCBweFJhdGlvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVuZGVyZXI6IGZ1bmN0aW9uIHJlbmRlcmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuICB9LFxuICBmb3JjZVJlbmRlcjogZnVuY3Rpb24gZm9yY2VSZW5kZXIoKSB7XG4gICAgdGhpcy5ub3RpZnkoJ2RyYXcnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVzaXplOiBmdW5jdGlvbiByZXNpemUoKSB7XG4gICAgdGhpcy5pbnZhbGlkYXRlU2l6ZSgpO1xuICAgIHRoaXMuZW1pdEFuZE5vdGlmeSgncmVzaXplJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGluaXRSZW5kZXJlcjogZnVuY3Rpb24gaW5pdFJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIHZhciBSZW5kZXJlclByb3RvID0gY3kuZXh0ZW5zaW9uKCdyZW5kZXJlcicsIG9wdGlvbnMubmFtZSk7XG5cbiAgICBpZiAoUmVuZGVyZXJQcm90byA9PSBudWxsKSB7XG4gICAgICBlcnJvcihcIkNhbiBub3QgaW5pdGlhbGlzZTogTm8gc3VjaCByZW5kZXJlciBgXCIuY29uY2F0KG9wdGlvbnMubmFtZSwgXCJgIGZvdW5kLiBEaWQgeW91IGZvcmdldCB0byBpbXBvcnQgaXQgYW5kIGBjeXRvc2NhcGUudXNlKClgIGl0P1wiKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMud2hlZWxTZW5zaXRpdml0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB3YXJuKFwiWW91IGhhdmUgc2V0IGEgY3VzdG9tIHdoZWVsIHNlbnNpdGl2aXR5LiAgVGhpcyB3aWxsIG1ha2UgeW91ciBhcHAgem9vbSB1bm5hdHVyYWxseSB3aGVuIHVzaW5nIG1haW5zdHJlYW0gbWljZS4gIFlvdSBzaG91bGQgY2hhbmdlIHRoaXMgdmFsdWUgZnJvbSB0aGUgZGVmYXVsdCBvbmx5IGlmIHlvdSBjYW4gZ3VhcmFudGVlIHRoYXQgYWxsIHlvdXIgdXNlcnMgd2lsbCB1c2UgdGhlIHNhbWUgaGFyZHdhcmUgYW5kIE9TIGNvbmZpZ3VyYXRpb24gYXMgeW91ciBjdXJyZW50IG1hY2hpbmUuXCIpO1xuICAgIH1cblxuICAgIHZhciByT3B0cyA9IHJlbmRlcmVyRGVmYXVsdHMob3B0aW9ucyk7XG4gICAgck9wdHMuY3kgPSBjeTtcbiAgICBjeS5fcHJpdmF0ZS5yZW5kZXJlciA9IG5ldyBSZW5kZXJlclByb3RvKHJPcHRzKTtcbiAgICB0aGlzLm5vdGlmeSgnaW5pdCcpO1xuICB9LFxuICBkZXN0cm95UmVuZGVyZXI6IGZ1bmN0aW9uIGRlc3Ryb3lSZW5kZXJlcigpIHtcbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIGN5Lm5vdGlmeSgnZGVzdHJveScpOyAvLyBkZXN0cm95IHRoZSByZW5kZXJlclxuXG4gICAgdmFyIGRvbUVsZSA9IGN5LmNvbnRhaW5lcigpO1xuXG4gICAgaWYgKGRvbUVsZSkge1xuICAgICAgZG9tRWxlLl9jeXJlZyA9IG51bGw7XG5cbiAgICAgIHdoaWxlIChkb21FbGUuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRvbUVsZS5yZW1vdmVDaGlsZChkb21FbGUuY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3kuX3ByaXZhdGUucmVuZGVyZXIgPSBudWxsOyAvLyB0byBiZSBleHRyYSBzYWZlLCByZW1vdmUgdGhlIHJlZlxuXG4gICAgY3kubXV0YWJsZUVsZW1lbnRzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICBfcC5yc2NyYXRjaCA9IHt9O1xuICAgICAgX3AucnN0eWxlID0ge307XG4gICAgICBfcC5hbmltYXRpb24uY3VycmVudCA9IFtdO1xuICAgICAgX3AuYW5pbWF0aW9uLnF1ZXVlID0gW107XG4gICAgfSk7XG4gIH0sXG4gIG9uUmVuZGVyOiBmdW5jdGlvbiBvblJlbmRlcihmbikge1xuICAgIHJldHVybiB0aGlzLm9uKCdyZW5kZXInLCBmbik7XG4gIH0sXG4gIG9mZlJlbmRlcjogZnVuY3Rpb24gb2ZmUmVuZGVyKGZuKSB7XG4gICAgcmV0dXJuIHRoaXMub2ZmKCdyZW5kZXInLCBmbik7XG4gIH1cbn07XG5jb3JlZm4kNC5pbnZhbGlkYXRlRGltZW5zaW9ucyA9IGNvcmVmbiQ0LnJlc2l6ZTtcblxudmFyIGNvcmVmbiQzID0ge1xuICAvLyBnZXQgYSBjb2xsZWN0aW9uXG4gIC8vIC0gZW1wdHkgY29sbGVjdGlvbiBvbiBubyBhcmdzXG4gIC8vIC0gY29sbGVjdGlvbiBvZiBlbGVtZW50cyBpbiB0aGUgZ3JhcGggb24gc2VsZWN0b3IgYXJnXG4gIC8vIC0gZ3VhcmFudGVlIGEgcmV0dXJuZWQgY29sbGVjdGlvbiB3aGVuIGVsZW1lbnRzIG9yIGNvbGxlY3Rpb24gc3BlY2lmaWVkXG4gIGNvbGxlY3Rpb246IGZ1bmN0aW9uIGNvbGxlY3Rpb24oZWxlcywgb3B0cykge1xuICAgIGlmIChzdHJpbmcoZWxlcykpIHtcbiAgICAgIHJldHVybiB0aGlzLiQoZWxlcyk7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKGVsZXMpKSB7XG4gICAgICByZXR1cm4gZWxlcy5jb2xsZWN0aW9uKCk7XG4gICAgfSBlbHNlIGlmIChhcnJheShlbGVzKSkge1xuICAgICAgaWYgKCFvcHRzKSB7XG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKHRoaXMsIGVsZXMsIG9wdHMudW5pcXVlLCBvcHRzLnJlbW92ZWQpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbih0aGlzKTtcbiAgfSxcbiAgbm9kZXM6IGZ1bmN0aW9uIG5vZGVzKHNlbGVjdG9yKSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy4kKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNOb2RlKCk7XG4gICAgfSk7XG5cbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBub2Rlcy5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlcztcbiAgfSxcbiAgZWRnZXM6IGZ1bmN0aW9uIGVkZ2VzKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy4kKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNFZGdlKCk7XG4gICAgfSk7XG5cbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBlZGdlcy5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH1cblxuICAgIHJldHVybiBlZGdlcztcbiAgfSxcbiAgLy8gc2VhcmNoIHRoZSBncmFwaCBsaWtlIGpRdWVyeVxuICAkOiBmdW5jdGlvbiAkKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsZXMgPSB0aGlzLl9wcml2YXRlLmVsZW1lbnRzO1xuXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gZWxlcy5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZWxlcy5zcGF3blNlbGYoKTtcbiAgICB9XG4gIH0sXG4gIG11dGFibGVFbGVtZW50czogZnVuY3Rpb24gbXV0YWJsZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVsZW1lbnRzO1xuICB9XG59OyAvLyBhbGlhc2VzXG5cbmNvcmVmbiQzLmVsZW1lbnRzID0gY29yZWZuJDMuZmlsdGVyID0gY29yZWZuJDMuJDtcblxudmFyIHN0eWZuJDggPSB7fTsgLy8ga2V5cyBmb3Igc3R5bGUgYmxvY2tzLCBlLmcuIHR0ZmZ0dFxuXG52YXIgVFJVRSA9ICd0JztcbnZhciBGQUxTRSA9ICdmJzsgLy8gKHBvdGVudGlhbGx5IGV4cGVuc2l2ZSBjYWxjdWxhdGlvbilcbi8vIGFwcGx5IHRoZSBzdHlsZSB0byB0aGUgZWxlbWVudCBiYXNlZCBvblxuLy8gLSBpdHMgYnlwYXNzXG4vLyAtIHdoYXQgc2VsZWN0b3JzIG1hdGNoIGl0XG5cbnN0eWZuJDguYXBwbHkgPSBmdW5jdGlvbiAoZWxlcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBfcCA9IHNlbGYuX3ByaXZhdGU7XG4gIHZhciBjeSA9IF9wLmN5O1xuICB2YXIgdXBkYXRlZEVsZXMgPSBjeS5jb2xsZWN0aW9uKCk7XG5cbiAgZm9yICh2YXIgaWUgPSAwOyBpZSA8IGVsZXMubGVuZ3RoOyBpZSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaWVdO1xuICAgIHZhciBjeHRNZXRhID0gc2VsZi5nZXRDb250ZXh0TWV0YShlbGUpO1xuXG4gICAgaWYgKGN4dE1ldGEuZW1wdHkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBjeHRTdHlsZSA9IHNlbGYuZ2V0Q29udGV4dFN0eWxlKGN4dE1ldGEpO1xuICAgIHZhciBhcHAgPSBzZWxmLmFwcGx5Q29udGV4dFN0eWxlKGN4dE1ldGEsIGN4dFN0eWxlLCBlbGUpO1xuXG4gICAgaWYgKGVsZS5fcHJpdmF0ZS5hcHBsaWVkSW5pdFN0eWxlKSB7XG4gICAgICBzZWxmLnVwZGF0ZVRyYW5zaXRpb25zKGVsZSwgYXBwLmRpZmZQcm9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZS5fcHJpdmF0ZS5hcHBsaWVkSW5pdFN0eWxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaGludHNEaWZmID0gc2VsZi51cGRhdGVTdHlsZUhpbnRzKGVsZSk7XG5cbiAgICBpZiAoaGludHNEaWZmKSB7XG4gICAgICB1cGRhdGVkRWxlcy5wdXNoKGVsZSk7XG4gICAgfVxuICB9IC8vIGZvciBlbGVtZW50c1xuXG5cbiAgcmV0dXJuIHVwZGF0ZWRFbGVzO1xufTtcblxuc3R5Zm4kOC5nZXRQcm9wZXJ0aWVzRGlmZiA9IGZ1bmN0aW9uIChvbGRDeHRLZXksIG5ld0N4dEtleSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjYWNoZSA9IHNlbGYuX3ByaXZhdGUucHJvcERpZmZzID0gc2VsZi5fcHJpdmF0ZS5wcm9wRGlmZnMgfHwge307XG4gIHZhciBkdWFsQ3h0S2V5ID0gb2xkQ3h0S2V5ICsgJy0nICsgbmV3Q3h0S2V5O1xuICB2YXIgY2FjaGVkVmFsID0gY2FjaGVbZHVhbEN4dEtleV07XG5cbiAgaWYgKGNhY2hlZFZhbCkge1xuICAgIHJldHVybiBjYWNoZWRWYWw7XG4gIH1cblxuICB2YXIgZGlmZlByb3BzID0gW107XG4gIHZhciBhZGRlZFByb3AgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY3h0ID0gc2VsZltpXTtcbiAgICB2YXIgb2xkSGFzQ3h0ID0gb2xkQ3h0S2V5W2ldID09PSBUUlVFO1xuICAgIHZhciBuZXdIYXNDeHQgPSBuZXdDeHRLZXlbaV0gPT09IFRSVUU7XG4gICAgdmFyIGN4dEhhc0RpZmZlZCA9IG9sZEhhc0N4dCAhPT0gbmV3SGFzQ3h0O1xuICAgIHZhciBjeHRIYXNNYXBwZWRQcm9wcyA9IGN4dC5tYXBwZWRQcm9wZXJ0aWVzLmxlbmd0aCA+IDA7XG5cbiAgICBpZiAoY3h0SGFzRGlmZmVkIHx8IG5ld0hhc0N4dCAmJiBjeHRIYXNNYXBwZWRQcm9wcykge1xuICAgICAgdmFyIHByb3BzID0gdm9pZCAwO1xuXG4gICAgICBpZiAoY3h0SGFzRGlmZmVkICYmIGN4dEhhc01hcHBlZFByb3BzKSB7XG4gICAgICAgIHByb3BzID0gY3h0LnByb3BlcnRpZXM7IC8vIHN1ZmZpY2VzIGIvYyBtYXBwZWRQcm9wZXJ0aWVzIGlzIGEgc3Vic2V0IG9mIHByb3BlcnRpZXNcbiAgICAgIH0gZWxzZSBpZiAoY3h0SGFzRGlmZmVkKSB7XG4gICAgICAgIHByb3BzID0gY3h0LnByb3BlcnRpZXM7IC8vIG5lZWQgdG8gY2hlY2sgdGhlbSBhbGxcbiAgICAgIH0gZWxzZSBpZiAoY3h0SGFzTWFwcGVkUHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBjeHQubWFwcGVkUHJvcGVydGllczsgLy8gb25seSBuZWVkIHRvIGNoZWNrIG1hcHBlZFxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbal07XG4gICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lOyAvLyBpZiBhIGxhdGVyIGNvbnRleHQgb3ZlcnJpZGVzIHRoaXMgcHJvcGVydHksIHRoZW4gdGhlIGZhY3QgdGhhdCB0aGlzIGNvbnRleHQgaGFzIHN3aXRjaGVkL2RpZmZlZCBkb2Vzbid0IG1hdHRlclxuICAgICAgICAvLyAoc2VtaSBleHBlbnNpdmUgY2hlY2sgc2luY2UgaXQgbWFrZXMgdGhpcyBmdW5jdGlvbiBPKG5eMikgb24gY29udGV4dCBsZW5ndGgsIGJ1dCB3b3J0aCBpdCBzaW5jZSBvdmVyYWxsIHJlc3VsdFxuICAgICAgICAvLyBpcyBjYWNoZWQpXG5cbiAgICAgICAgdmFyIGxhdGVyQ3h0T3ZlcnJpZGVzID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgayA9IGkgKyAxOyBrIDwgc2VsZi5sZW5ndGg7IGsrKykge1xuICAgICAgICAgIHZhciBsYXRlckN4dCA9IHNlbGZba107XG4gICAgICAgICAgdmFyIGhhc0xhdGVyQ3h0ID0gbmV3Q3h0S2V5W2tdID09PSBUUlVFO1xuXG4gICAgICAgICAgaWYgKCFoYXNMYXRlckN4dCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSAvLyBjYW4ndCBvdmVycmlkZSB1bmxlc3MgdGhlIGNvbnRleHQgaXMgYWN0aXZlXG5cblxuICAgICAgICAgIGxhdGVyQ3h0T3ZlcnJpZGVzID0gbGF0ZXJDeHQucHJvcGVydGllc1twcm9wLm5hbWVdICE9IG51bGw7XG5cbiAgICAgICAgICBpZiAobGF0ZXJDeHRPdmVycmlkZXMpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gLy8gZXhpdCBlYXJseSBhcyBsb25nIGFzIG9uZSBsYXRlciBjb250ZXh0IG92ZXJyaWRlc1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFkZGVkUHJvcFtuYW1lXSAmJiAhbGF0ZXJDeHRPdmVycmlkZXMpIHtcbiAgICAgICAgICBhZGRlZFByb3BbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgIGRpZmZQcm9wcy5wdXNoKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGZvciBwcm9wc1xuXG4gICAgfSAvLyBpZlxuXG4gIH0gLy8gZm9yIGNvbnRleHRzXG5cblxuICBjYWNoZVtkdWFsQ3h0S2V5XSA9IGRpZmZQcm9wcztcbiAgcmV0dXJuIGRpZmZQcm9wcztcbn07XG5cbnN0eWZuJDguZ2V0Q29udGV4dE1ldGEgPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGN4dEtleSA9ICcnO1xuICB2YXIgZGlmZlByb3BzO1xuICB2YXIgcHJldktleSA9IGVsZS5fcHJpdmF0ZS5zdHlsZUN4dEtleSB8fCAnJzsgLy8gZ2V0IHRoZSBjeHQga2V5XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvbnRleHQgPSBzZWxmW2ldO1xuICAgIHZhciBjb250ZXh0U2VsZWN0b3JNYXRjaGVzID0gY29udGV4dC5zZWxlY3RvciAmJiBjb250ZXh0LnNlbGVjdG9yLm1hdGNoZXMoZWxlKTsgLy8gTkI6IGNvbnRleHQuc2VsZWN0b3IgbWF5IGJlIG51bGwgZm9yICdjb3JlJ1xuXG4gICAgaWYgKGNvbnRleHRTZWxlY3Rvck1hdGNoZXMpIHtcbiAgICAgIGN4dEtleSArPSBUUlVFO1xuICAgIH0gZWxzZSB7XG4gICAgICBjeHRLZXkgKz0gRkFMU0U7XG4gICAgfVxuICB9IC8vIGZvciBjb250ZXh0XG5cblxuICBkaWZmUHJvcHMgPSBzZWxmLmdldFByb3BlcnRpZXNEaWZmKHByZXZLZXksIGN4dEtleSk7XG4gIGVsZS5fcHJpdmF0ZS5zdHlsZUN4dEtleSA9IGN4dEtleTtcbiAgcmV0dXJuIHtcbiAgICBrZXk6IGN4dEtleSxcbiAgICBkaWZmUHJvcE5hbWVzOiBkaWZmUHJvcHMsXG4gICAgZW1wdHk6IGRpZmZQcm9wcy5sZW5ndGggPT09IDBcbiAgfTtcbn07IC8vIGdldHMgYSBjb21wdXRlZCBlbGUgc3R5bGUgb2JqZWN0IGJhc2VkIG9uIG1hdGNoZWQgY29udGV4dHNcblxuXG5zdHlmbiQ4LmdldENvbnRleHRTdHlsZSA9IGZ1bmN0aW9uIChjeHRNZXRhKSB7XG4gIHZhciBjeHRLZXkgPSBjeHRNZXRhLmtleTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY3h0U3R5bGVzID0gdGhpcy5fcHJpdmF0ZS5jb250ZXh0U3R5bGVzID0gdGhpcy5fcHJpdmF0ZS5jb250ZXh0U3R5bGVzIHx8IHt9OyAvLyBpZiBhbHJlYWR5IGNvbXB1dGVkIHN0eWxlLCByZXR1cm5lZCBjYWNoZWQgY29weVxuXG4gIGlmIChjeHRTdHlsZXNbY3h0S2V5XSkge1xuICAgIHJldHVybiBjeHRTdHlsZXNbY3h0S2V5XTtcbiAgfVxuXG4gIHZhciBzdHlsZSA9IHtcbiAgICBfcHJpdmF0ZToge1xuICAgICAga2V5OiBjeHRLZXlcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGN4dCA9IHNlbGZbaV07XG4gICAgdmFyIGhhc0N4dCA9IGN4dEtleVtpXSA9PT0gVFJVRTtcblxuICAgIGlmICghaGFzQ3h0KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGN4dC5wcm9wZXJ0aWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcHJvcCA9IGN4dC5wcm9wZXJ0aWVzW2pdO1xuICAgICAgc3R5bGVbcHJvcC5uYW1lXSA9IHByb3A7XG4gICAgfVxuICB9XG5cbiAgY3h0U3R5bGVzW2N4dEtleV0gPSBzdHlsZTtcbiAgcmV0dXJuIHN0eWxlO1xufTtcblxuc3R5Zm4kOC5hcHBseUNvbnRleHRTdHlsZSA9IGZ1bmN0aW9uIChjeHRNZXRhLCBjeHRTdHlsZSwgZWxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGRpZmZQcm9wcyA9IGN4dE1ldGEuZGlmZlByb3BOYW1lcztcbiAgdmFyIHJldERpZmZQcm9wcyA9IHt9O1xuICB2YXIgdHlwZXMgPSBzZWxmLnR5cGVzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZlByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRpZmZQcm9wTmFtZSA9IGRpZmZQcm9wc1tpXTtcbiAgICB2YXIgY3h0UHJvcCA9IGN4dFN0eWxlW2RpZmZQcm9wTmFtZV07XG4gICAgdmFyIGVsZVByb3AgPSBlbGUucHN0eWxlKGRpZmZQcm9wTmFtZSk7XG5cbiAgICBpZiAoIWN4dFByb3ApIHtcbiAgICAgIC8vIG5vIGNvbnRleHQgcHJvcCBtZWFucyBkZWxldGVcbiAgICAgIGlmICghZWxlUHJvcCkge1xuICAgICAgICBjb250aW51ZTsgLy8gbm8gZXhpc3RpbmcgcHJvcCBtZWFucyBub3RoaW5nIG5lZWRzIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgLy8gbmIgYWZmZWN0cyBpbml0aWFsIGFwcGxpY2F0aW9uIG9uIG1hcHBlZCB2YWx1ZXMgbGlrZSBjb250cm9sLXBvaW50LWRpc3RhbmNlc1xuICAgICAgfSBlbHNlIGlmIChlbGVQcm9wLmJ5cGFzcykge1xuICAgICAgICBjeHRQcm9wID0ge1xuICAgICAgICAgIG5hbWU6IGRpZmZQcm9wTmFtZSxcbiAgICAgICAgICBkZWxldGVCeXBhc3NlZDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3h0UHJvcCA9IHtcbiAgICAgICAgICBuYW1lOiBkaWZmUHJvcE5hbWUsXG4gICAgICAgICAgXCJkZWxldGVcIjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gLy8gc2F2ZSBjeWNsZXMgd2hlbiB0aGUgY29udGV4dCBwcm9wIGRvZXNuJ3QgbmVlZCB0byBiZSBhcHBsaWVkXG5cblxuICAgIGlmIChlbGVQcm9wID09PSBjeHRQcm9wKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIHNhdmUgY3ljbGVzIHdoZW4gYSBtYXBwZWQgY29udGV4dCBwcm9wIGRvZXNuJ3QgbmVlZCB0byBiZSBhcHBsaWVkXG5cblxuICAgIGlmIChjeHRQcm9wLm1hcHBlZCA9PT0gdHlwZXMuZm4gLy8gY29udGV4dCBwcm9wIGlzIGZ1bmN0aW9uIG1hcHBlclxuICAgICYmIGVsZVByb3AgIT0gbnVsbCAvLyBzb21lIHByb3BzIGNhbiBiZSBudWxsIGV2ZW4gYnkgZGVmYXVsdCAoZS5nLiBhIHByb3AgdGhhdCBvdmVycmlkZXMgYW5vdGhlciBvbmUpXG4gICAgJiYgZWxlUHJvcC5tYXBwaW5nICE9IG51bGwgLy8gZWxlIHByb3AgaXMgYSBjb25jcmV0ZSB2YWx1ZSBmcm9tIGZyb20gYSBtYXBwZXJcbiAgICAmJiBlbGVQcm9wLm1hcHBpbmcudmFsdWUgPT09IGN4dFByb3AudmFsdWUgLy8gdGhlIGN1cnJlbnQgcHJvcCBvbiB0aGUgZWxlIGlzIGEgZmxhdCBwcm9wIHZhbHVlIGZvciB0aGUgZnVuY3Rpb24gbWFwcGVyXG4gICAgKSB7XG4gICAgICAvLyBOQiBkb24ndCB3cml0ZSB0byBjeHRQcm9wLCBhcyBpdCdzIHNoYXJlZCBhbW9uZyBlbGVzIChzdG9yZWQgaW4gc3R5bGVzaGVldClcbiAgICAgIHZhciBtYXBwaW5nID0gZWxlUHJvcC5tYXBwaW5nOyAvLyBjYW4gd3JpdGUgdG8gbWFwcGluZywgYXMgaXQncyBhIHBlci1lbGUgY29weVxuXG4gICAgICB2YXIgZm5WYWx1ZSA9IG1hcHBpbmcuZm5WYWx1ZSA9IGN4dFByb3AudmFsdWUoZWxlKTsgLy8gdGVtcG9yYXJpbHkgY2FjaGUgdGhlIHZhbHVlIGluIGNhc2Ugb2YgYSBtaXNzXG5cbiAgICAgIGlmIChmblZhbHVlID09PSBtYXBwaW5nLnByZXZGblZhbHVlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXREaWZmUHJvcCA9IHJldERpZmZQcm9wc1tkaWZmUHJvcE5hbWVdID0ge1xuICAgICAgcHJldjogZWxlUHJvcFxuICAgIH07XG4gICAgc2VsZi5hcHBseVBhcnNlZFByb3BlcnR5KGVsZSwgY3h0UHJvcCk7XG4gICAgcmV0RGlmZlByb3AubmV4dCA9IGVsZS5wc3R5bGUoZGlmZlByb3BOYW1lKTtcblxuICAgIGlmIChyZXREaWZmUHJvcC5uZXh0ICYmIHJldERpZmZQcm9wLm5leHQuYnlwYXNzKSB7XG4gICAgICByZXREaWZmUHJvcC5uZXh0ID0gcmV0RGlmZlByb3AubmV4dC5ieXBhc3NlZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRpZmZQcm9wczogcmV0RGlmZlByb3BzXG4gIH07XG59O1xuXG5zdHlmbiQ4LnVwZGF0ZVN0eWxlSGludHMgPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcHJvcE5hbWVzID0gc2VsZi5wcm9wZXJ0eUdyb3VwTmFtZXM7XG4gIHZhciBwcm9wR3JLZXlzID0gc2VsZi5wcm9wZXJ0eUdyb3VwS2V5cztcblxuICB2YXIgcHJvcEhhc2ggPSBmdW5jdGlvbiBwcm9wSGFzaChlbGUsIHByb3BOYW1lcywgc2VlZEtleSkge1xuICAgIHJldHVybiBzZWxmLmdldFByb3BlcnRpZXNIYXNoKGVsZSwgcHJvcE5hbWVzLCBzZWVkS2V5KTtcbiAgfTtcblxuICB2YXIgb2xkU3R5bGVLZXkgPSBfcC5zdHlsZUtleTtcblxuICBpZiAoZWxlLnJlbW92ZWQoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBpc05vZGUgPSBfcC5ncm91cCA9PT0gJ25vZGVzJzsgLy8gZ2V0IHRoZSBzdHlsZSBrZXkgaGFzaGVzIHBlciBwcm9wIGdyb3VwXG4gIC8vIGJ1dCBsYXppbHkgLS0gb25seSB1c2Ugbm9uLWRlZmF1bHQgcHJvcCB2YWx1ZXMgdG8gcmVkdWNlIHRoZSBudW1iZXIgb2YgaGFzaGVzXG4gIC8vXG5cbiAgdmFyIG92ZXJyaWRkZW5TdHlsZXMgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gIHByb3BOYW1lcyA9IE9iamVjdC5rZXlzKG92ZXJyaWRkZW5TdHlsZXMpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEdyS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBncktleSA9IHByb3BHcktleXNbaV07XG4gICAgX3Auc3R5bGVLZXlzW2dyS2V5XSA9IFtERUZBVUxUX0hBU0hfU0VFRCwgREVGQVVMVF9IQVNIX1NFRURfQUxUXTtcbiAgfVxuXG4gIHZhciB1cGRhdGVHcktleTEgPSBmdW5jdGlvbiB1cGRhdGVHcktleTEodmFsLCBncktleSkge1xuICAgIHJldHVybiBfcC5zdHlsZUtleXNbZ3JLZXldWzBdID0gaGFzaEludCh2YWwsIF9wLnN0eWxlS2V5c1tncktleV1bMF0pO1xuICB9O1xuXG4gIHZhciB1cGRhdGVHcktleTIgPSBmdW5jdGlvbiB1cGRhdGVHcktleTIodmFsLCBncktleSkge1xuICAgIHJldHVybiBfcC5zdHlsZUtleXNbZ3JLZXldWzFdID0gaGFzaEludEFsdCh2YWwsIF9wLnN0eWxlS2V5c1tncktleV1bMV0pO1xuICB9O1xuXG4gIHZhciB1cGRhdGVHcktleSA9IGZ1bmN0aW9uIHVwZGF0ZUdyS2V5KHZhbCwgZ3JLZXkpIHtcbiAgICB1cGRhdGVHcktleTEodmFsLCBncktleSk7XG4gICAgdXBkYXRlR3JLZXkyKHZhbCwgZ3JLZXkpO1xuICB9O1xuXG4gIHZhciB1cGRhdGVHcktleVdTdHIgPSBmdW5jdGlvbiB1cGRhdGVHcktleVdTdHIoc3RyVmFsLCBncktleSkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RyVmFsLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgY2ggPSBzdHJWYWwuY2hhckNvZGVBdChqKTtcbiAgICAgIHVwZGF0ZUdyS2V5MShjaCwgZ3JLZXkpO1xuICAgICAgdXBkYXRlR3JLZXkyKGNoLCBncktleSk7XG4gICAgfVxuICB9OyAvLyAtIGhhc2hpbmcgd29ya3Mgb24gMzIgYml0IGludHMgYi9jIHdlIHVzZSBiaXR3aXNlIG9wc1xuICAvLyAtIHNtYWxsIG51bWJlcnMgZ2V0IGN1dCBvZmYgKGUuZy4gMC4xMjMgaXMgc2VlbiBhcyAwIGJ5IHRoZSBoYXNoaW5nIGZ1bmN0aW9uKVxuICAvLyAtIHJhaXNlIHVwIHNtYWxsIG51bWJlcnMgc28gbW9yZSBzaWduaWZpY2FudCBkaWdpdHMgYXJlIHNlZW4gYnkgaGFzaGluZ1xuICAvLyAtIG1ha2Ugc21hbGwgbnVtYmVycyBsYXJnZXIgdGhhbiBhIG5vcm1hbCB2YWx1ZSB0byBhdm9pZCBjb2xsaXNpb25zXG4gIC8vIC0gd29ya3MgaW4gcHJhY3RpY2UgYW5kIGl0J3MgcmVsYXRpdmVseSBjaGVhcFxuXG5cbiAgdmFyIE4gPSAyMDAwMDAwMDAwO1xuXG4gIHZhciBjbGVhbk51bSA9IGZ1bmN0aW9uIGNsZWFuTnVtKHZhbCkge1xuICAgIHJldHVybiAtMTI4IDwgdmFsICYmIHZhbCA8IDEyOCAmJiBNYXRoLmZsb29yKHZhbCkgIT09IHZhbCA/IE4gLSAodmFsICogMTAyNCB8IDApIDogdmFsO1xuICB9O1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBwcm9wTmFtZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIG5hbWUgPSBwcm9wTmFtZXNbX2ldO1xuICAgIHZhciBwYXJzZWRQcm9wID0gb3ZlcnJpZGRlblN0eWxlc1tuYW1lXTtcblxuICAgIGlmIChwYXJzZWRQcm9wID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wSW5mbyA9IHRoaXMucHJvcGVydGllc1tuYW1lXTtcbiAgICB2YXIgdHlwZSA9IHByb3BJbmZvLnR5cGU7XG4gICAgdmFyIF9ncktleSA9IHByb3BJbmZvLmdyb3VwS2V5O1xuICAgIHZhciBub3JtYWxpemVkTnVtYmVyVmFsID0gdm9pZCAwO1xuXG4gICAgaWYgKHByb3BJbmZvLmhhc2hPdmVycmlkZSAhPSBudWxsKSB7XG4gICAgICBub3JtYWxpemVkTnVtYmVyVmFsID0gcHJvcEluZm8uaGFzaE92ZXJyaWRlKGVsZSwgcGFyc2VkUHJvcCk7XG4gICAgfSBlbHNlIGlmIChwYXJzZWRQcm9wLnBmVmFsdWUgIT0gbnVsbCkge1xuICAgICAgbm9ybWFsaXplZE51bWJlclZhbCA9IHBhcnNlZFByb3AucGZWYWx1ZTtcbiAgICB9IC8vIG1pZ2h0IG5vdCBiZSBhIG51bWJlciBpZiBpdCBhbGxvd3MgZW51bXNcblxuXG4gICAgdmFyIG51bWJlclZhbCA9IHByb3BJbmZvLmVudW1zID09IG51bGwgPyBwYXJzZWRQcm9wLnZhbHVlIDogbnVsbDtcbiAgICB2YXIgaGF2ZU5vcm1OdW0gPSBub3JtYWxpemVkTnVtYmVyVmFsICE9IG51bGw7XG4gICAgdmFyIGhhdmVVbml0ZWROdW0gPSBudW1iZXJWYWwgIT0gbnVsbDtcbiAgICB2YXIgaGF2ZU51bSA9IGhhdmVOb3JtTnVtIHx8IGhhdmVVbml0ZWROdW07XG4gICAgdmFyIHVuaXRzID0gcGFyc2VkUHJvcC51bml0czsgLy8gbnVtYmVycyBhcmUgY2hlYXBlciB0byBoYXNoIHRoYW4gc3RyaW5nc1xuICAgIC8vIDEgaGFzaCBvcCB2cyBuIGhhc2ggb3BzIChmb3IgbGVuZ3RoIG4gc3RyaW5nKVxuXG4gICAgaWYgKHR5cGUubnVtYmVyICYmIGhhdmVOdW0gJiYgIXR5cGUubXVsdGlwbGUpIHtcbiAgICAgIHZhciB2ID0gaGF2ZU5vcm1OdW0gPyBub3JtYWxpemVkTnVtYmVyVmFsIDogbnVtYmVyVmFsO1xuICAgICAgdXBkYXRlR3JLZXkoY2xlYW5OdW0odiksIF9ncktleSk7XG5cbiAgICAgIGlmICghaGF2ZU5vcm1OdW0gJiYgdW5pdHMgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVHcktleVdTdHIodW5pdHMsIF9ncktleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZUdyS2V5V1N0cihwYXJzZWRQcm9wLnN0clZhbHVlLCBfZ3JLZXkpO1xuICAgIH1cbiAgfSAvLyBvdmVyYWxsIHN0eWxlIGtleVxuICAvL1xuXG5cbiAgdmFyIGhhc2ggPSBbREVGQVVMVF9IQVNIX1NFRUQsIERFRkFVTFRfSEFTSF9TRUVEX0FMVF07XG5cbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcHJvcEdyS2V5cy5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIF9ncktleTIgPSBwcm9wR3JLZXlzW19pMl07XG4gICAgdmFyIGdySGFzaCA9IF9wLnN0eWxlS2V5c1tfZ3JLZXkyXTtcbiAgICBoYXNoWzBdID0gaGFzaEludChnckhhc2hbMF0sIGhhc2hbMF0pO1xuICAgIGhhc2hbMV0gPSBoYXNoSW50QWx0KGdySGFzaFsxXSwgaGFzaFsxXSk7XG4gIH1cblxuICBfcC5zdHlsZUtleSA9IGNvbWJpbmVIYXNoZXMoaGFzaFswXSwgaGFzaFsxXSk7IC8vIGxhYmVsIGRpbXNcbiAgLy9cblxuICB2YXIgc2sgPSBfcC5zdHlsZUtleXM7XG4gIF9wLmxhYmVsRGltc0tleSA9IGNvbWJpbmVIYXNoZXNBcnJheShzay5sYWJlbERpbWVuc2lvbnMpO1xuICB2YXIgbGFiZWxLZXlzID0gcHJvcEhhc2goZWxlLCBbJ2xhYmVsJ10sIHNrLmxhYmVsRGltZW5zaW9ucyk7XG4gIF9wLmxhYmVsS2V5ID0gY29tYmluZUhhc2hlc0FycmF5KGxhYmVsS2V5cyk7XG4gIF9wLmxhYmVsU3R5bGVLZXkgPSBjb21iaW5lSGFzaGVzQXJyYXkoaGFzaEFycmF5cyhzay5jb21tb25MYWJlbCwgbGFiZWxLZXlzKSk7XG5cbiAgaWYgKCFpc05vZGUpIHtcbiAgICB2YXIgc291cmNlTGFiZWxLZXlzID0gcHJvcEhhc2goZWxlLCBbJ3NvdXJjZS1sYWJlbCddLCBzay5sYWJlbERpbWVuc2lvbnMpO1xuICAgIF9wLnNvdXJjZUxhYmVsS2V5ID0gY29tYmluZUhhc2hlc0FycmF5KHNvdXJjZUxhYmVsS2V5cyk7XG4gICAgX3Auc291cmNlTGFiZWxTdHlsZUtleSA9IGNvbWJpbmVIYXNoZXNBcnJheShoYXNoQXJyYXlzKHNrLmNvbW1vbkxhYmVsLCBzb3VyY2VMYWJlbEtleXMpKTtcbiAgICB2YXIgdGFyZ2V0TGFiZWxLZXlzID0gcHJvcEhhc2goZWxlLCBbJ3RhcmdldC1sYWJlbCddLCBzay5sYWJlbERpbWVuc2lvbnMpO1xuICAgIF9wLnRhcmdldExhYmVsS2V5ID0gY29tYmluZUhhc2hlc0FycmF5KHRhcmdldExhYmVsS2V5cyk7XG4gICAgX3AudGFyZ2V0TGFiZWxTdHlsZUtleSA9IGNvbWJpbmVIYXNoZXNBcnJheShoYXNoQXJyYXlzKHNrLmNvbW1vbkxhYmVsLCB0YXJnZXRMYWJlbEtleXMpKTtcbiAgfSAvLyBub2RlXG4gIC8vXG5cblxuICBpZiAoaXNOb2RlKSB7XG4gICAgdmFyIF9wJHN0eWxlS2V5cyA9IF9wLnN0eWxlS2V5cyxcbiAgICAgICAgbm9kZUJvZHkgPSBfcCRzdHlsZUtleXMubm9kZUJvZHksXG4gICAgICAgIG5vZGVCb3JkZXIgPSBfcCRzdHlsZUtleXMubm9kZUJvcmRlcixcbiAgICAgICAgYmFja2dyb3VuZEltYWdlID0gX3Akc3R5bGVLZXlzLmJhY2tncm91bmRJbWFnZSxcbiAgICAgICAgY29tcG91bmQgPSBfcCRzdHlsZUtleXMuY29tcG91bmQsXG4gICAgICAgIHBpZSA9IF9wJHN0eWxlS2V5cy5waWU7XG4gICAgdmFyIG5vZGVLZXlzID0gW25vZGVCb2R5LCBub2RlQm9yZGVyLCBiYWNrZ3JvdW5kSW1hZ2UsIGNvbXBvdW5kLCBwaWVdLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgcmV0dXJuIGsgIT0gbnVsbDtcbiAgICB9KS5yZWR1Y2UoaGFzaEFycmF5cywgW0RFRkFVTFRfSEFTSF9TRUVELCBERUZBVUxUX0hBU0hfU0VFRF9BTFRdKTtcbiAgICBfcC5ub2RlS2V5ID0gY29tYmluZUhhc2hlc0FycmF5KG5vZGVLZXlzKTtcbiAgICBfcC5oYXNQaWUgPSBwaWUgIT0gbnVsbCAmJiBwaWVbMF0gIT09IERFRkFVTFRfSEFTSF9TRUVEICYmIHBpZVsxXSAhPT0gREVGQVVMVF9IQVNIX1NFRURfQUxUO1xuICB9XG5cbiAgcmV0dXJuIG9sZFN0eWxlS2V5ICE9PSBfcC5zdHlsZUtleTtcbn07XG5cbnN0eWZuJDguY2xlYXJTdHlsZUhpbnRzID0gZnVuY3Rpb24gKGVsZSkge1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIF9wLnN0eWxlQ3h0S2V5ID0gJyc7XG4gIF9wLnN0eWxlS2V5cyA9IHt9O1xuICBfcC5zdHlsZUtleSA9IG51bGw7XG4gIF9wLmxhYmVsS2V5ID0gbnVsbDtcbiAgX3AubGFiZWxTdHlsZUtleSA9IG51bGw7XG4gIF9wLnNvdXJjZUxhYmVsS2V5ID0gbnVsbDtcbiAgX3Auc291cmNlTGFiZWxTdHlsZUtleSA9IG51bGw7XG4gIF9wLnRhcmdldExhYmVsS2V5ID0gbnVsbDtcbiAgX3AudGFyZ2V0TGFiZWxTdHlsZUtleSA9IG51bGw7XG4gIF9wLm5vZGVLZXkgPSBudWxsO1xuICBfcC5oYXNQaWUgPSBudWxsO1xufTsgLy8gYXBwbHkgYSBwcm9wZXJ0eSB0byB0aGUgc3R5bGUgKGZvciBpbnRlcm5hbCB1c2UpXG4vLyByZXR1cm5zIHdoZXRoZXIgYXBwbGljYXRpb24gd2FzIHN1Y2Nlc3NmdWxcbi8vXG4vLyBub3csIHRoaXMgZnVuY3Rpb24gZmxhdHRlbnMgdGhlIHByb3BlcnR5LCBhbmQgaGVyZSdzIGhvdzpcbi8vXG4vLyBmb3IgcGFyc2VkUHJvcDp7IGJ5cGFzczogdHJ1ZSwgZGVsZXRlQnlwYXNzOiB0cnVlIH1cbi8vIG5vIHByb3BlcnR5IGlzIGdlbmVyYXRlZCwgaW5zdGVhZCB0aGUgYnlwYXNzIHByb3BlcnR5IGluIHRoZVxuLy8gZWxlbWVudCdzIHN0eWxlIGlzIHJlcGxhY2VkIGJ5IHdoYXQncyBwb2ludGVkIHRvIGJ5IHRoZSBgYnlwYXNzZWRgXG4vLyBmaWVsZCBpbiB0aGUgYnlwYXNzIHByb3BlcnR5IChpLmUuIHJlc3RvcmluZyB0aGUgcHJvcGVydHkgdGhlXG4vLyBieXBhc3Mgd2FzIG92ZXJyaWRpbmcpXG4vL1xuLy8gZm9yIHBhcnNlZFByb3A6eyBtYXBwZWQ6IHRydXRoeSB9XG4vLyB0aGUgZ2VuZXJhdGVkIGZsYXR0ZW5lZFByb3A6eyBtYXBwaW5nOiBwcm9wIH1cbi8vXG4vLyBmb3IgcGFyc2VkUHJvcDp7IGJ5cGFzczogdHJ1ZSB9XG4vLyB0aGUgZ2VuZXJhdGVkIGZsYXR0ZW5lZFByb3A6eyBieXBhc3NlZDogcGFyc2VkUHJvcCB9XG5cblxuc3R5Zm4kOC5hcHBseVBhcnNlZFByb3BlcnR5ID0gZnVuY3Rpb24gKGVsZSwgcGFyc2VkUHJvcCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwcm9wID0gcGFyc2VkUHJvcDtcbiAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICB2YXIgZmxhdFByb3A7XG4gIHZhciB0eXBlcyA9IHNlbGYudHlwZXM7XG4gIHZhciB0eXBlID0gc2VsZi5wcm9wZXJ0aWVzW3Byb3AubmFtZV0udHlwZTtcbiAgdmFyIHByb3BJc0J5cGFzcyA9IHByb3AuYnlwYXNzO1xuICB2YXIgb3JpZ1Byb3AgPSBzdHlsZVtwcm9wLm5hbWVdO1xuICB2YXIgb3JpZ1Byb3BJc0J5cGFzcyA9IG9yaWdQcm9wICYmIG9yaWdQcm9wLmJ5cGFzcztcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgZmxhdFByb3BNYXBwaW5nID0gJ21hcHBpbmcnO1xuXG4gIHZhciBnZXRWYWwgPSBmdW5jdGlvbiBnZXRWYWwocCkge1xuICAgIGlmIChwID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAocC5wZlZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBwLnBmVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwLnZhbHVlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY2hlY2tUcmlnZ2VycyA9IGZ1bmN0aW9uIGNoZWNrVHJpZ2dlcnMoKSB7XG4gICAgdmFyIGZyb21WYWwgPSBnZXRWYWwob3JpZ1Byb3ApO1xuICAgIHZhciB0b1ZhbCA9IGdldFZhbChwcm9wKTtcbiAgICBzZWxmLmNoZWNrVHJpZ2dlcnMoZWxlLCBwcm9wLm5hbWUsIGZyb21WYWwsIHRvVmFsKTtcbiAgfTtcblxuICBpZiAocHJvcCAmJiBwcm9wLm5hbWUuc3Vic3RyKDAsIDMpID09PSAncGllJykge1xuICAgIHdhcm4oJ1RoZSBwaWUgc3R5bGUgcHJvcGVydGllcyBhcmUgZGVwcmVjYXRlZC4gIENyZWF0ZSBjaGFydHMgdXNpbmcgYmFja2dyb3VuZCBpbWFnZXMgaW5zdGVhZC4nKTtcbiAgfSAvLyBlZGdlIHNhbml0eSBjaGVja3MgdG8gcHJldmVudCB0aGUgY2xpZW50IGZyb20gbWFraW5nIHNlcmlvdXMgbWlzdGFrZXNcblxuXG4gIGlmIChwYXJzZWRQcm9wLm5hbWUgPT09ICdjdXJ2ZS1zdHlsZScgJiYgZWxlLmlzRWRnZSgpICYmICggLy8gbG9vcHMgbXVzdCBiZSBidW5kbGVkIGJlemllcnNcbiAgcGFyc2VkUHJvcC52YWx1ZSAhPT0gJ2JlemllcicgJiYgZWxlLmlzTG9vcCgpIHx8IC8vIGVkZ2VzIGNvbm5lY3RlZCB0byBjb21wb3VuZCBub2RlcyBjYW4gbm90IGJlIGhheXN0YWNrc1xuICBwYXJzZWRQcm9wLnZhbHVlID09PSAnaGF5c3RhY2snICYmIChlbGUuc291cmNlKCkuaXNQYXJlbnQoKSB8fCBlbGUudGFyZ2V0KCkuaXNQYXJlbnQoKSkpKSB7XG4gICAgcHJvcCA9IHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKHBhcnNlZFByb3AubmFtZSwgJ2JlemllcicsIHByb3BJc0J5cGFzcyk7XG4gIH1cblxuICBpZiAocHJvcFtcImRlbGV0ZVwiXSkge1xuICAgIC8vIGRlbGV0ZSB0aGUgcHJvcGVydHkgYW5kIHVzZSB0aGUgZGVmYXVsdCB2YWx1ZSBvbiBmYWxzZXkgdmFsdWVcbiAgICBzdHlsZVtwcm9wLm5hbWVdID0gdW5kZWZpbmVkO1xuICAgIGNoZWNrVHJpZ2dlcnMoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChwcm9wLmRlbGV0ZUJ5cGFzc2VkKSB7XG4gICAgLy8gZGVsZXRlIHRoZSBwcm9wZXJ0eSB0aGF0IHRoZVxuICAgIGlmICghb3JpZ1Byb3ApIHtcbiAgICAgIGNoZWNrVHJpZ2dlcnMoKTtcbiAgICAgIHJldHVybiB0cnVlOyAvLyBjYW4ndCBkZWxldGUgaWYgbm8gcHJvcFxuICAgIH0gZWxzZSBpZiAob3JpZ1Byb3AuYnlwYXNzKSB7XG4gICAgICAvLyBkZWxldGUgYnlwYXNzZWRcbiAgICAgIG9yaWdQcm9wLmJ5cGFzc2VkID0gdW5kZWZpbmVkO1xuICAgICAgY2hlY2tUcmlnZ2VycygpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gd2UncmUgdW5zdWNjZXNzZnVsIGRlbGV0aW5nIHRoZSBieXBhc3NlZFxuICAgIH1cbiAgfSAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGUgY3VycmVudCBieXBhc3NcblxuXG4gIGlmIChwcm9wLmRlbGV0ZUJ5cGFzcykge1xuICAgIC8vIHRoZW4gdGhpcyBwcm9wZXJ0eSBpcyBqdXN0IGhlcmUgdG8gaW5kaWNhdGUgd2UgbmVlZCB0byBkZWxldGVcbiAgICBpZiAoIW9yaWdQcm9wKSB7XG4gICAgICBjaGVja1RyaWdnZXJzKCk7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gcHJvcGVydHkgaXMgYWxyZWFkeSBub3QgZGVmaW5lZFxuICAgIH0gZWxzZSBpZiAob3JpZ1Byb3AuYnlwYXNzKSB7XG4gICAgICAvLyB0aGVuIHJlcGxhY2UgdGhlIGJ5cGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBvcmlnaW5hbFxuICAgICAgLy8gYmVjYXVzZSB0aGUgYnlwYXNzZWQgcHJvcGVydHkgd2FzIGFscmVhZHkgYXBwbGllZCAoYW5kIHRoZXJlZm9yZSBwYXJzZWQpLCB3ZSBjYW4ganVzdCByZXBsYWNlIGl0IChubyByZWFwcGx5aW5nIG5lY2Vzc2FyeSlcbiAgICAgIHN0eWxlW3Byb3AubmFtZV0gPSBvcmlnUHJvcC5ieXBhc3NlZDtcbiAgICAgIGNoZWNrVHJpZ2dlcnMoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIHdlJ3JlIHVuc3VjY2Vzc2Z1bCBkZWxldGluZyB0aGUgYnlwYXNzXG4gICAgfVxuICB9XG5cbiAgdmFyIHByaW50TWFwcGluZ0VyciA9IGZ1bmN0aW9uIHByaW50TWFwcGluZ0VycigpIHtcbiAgICB3YXJuKCdEbyBub3QgYXNzaWduIG1hcHBpbmdzIHRvIGVsZW1lbnRzIHdpdGhvdXQgY29ycmVzcG9uZGluZyBkYXRhIChpLmUuIGVsZSBgJyArIGVsZS5pZCgpICsgJ2AgaGFzIG5vIG1hcHBpbmcgZm9yIHByb3BlcnR5IGAnICsgcHJvcC5uYW1lICsgJ2Agd2l0aCBkYXRhIGZpZWxkIGAnICsgcHJvcC5maWVsZCArICdgKTsgdHJ5IGEgYFsnICsgcHJvcC5maWVsZCArICddYCBzZWxlY3RvciB0byBsaW1pdCBzY29wZSB0byBlbGVtZW50cyB3aXRoIGAnICsgcHJvcC5maWVsZCArICdgIGRlZmluZWQnKTtcbiAgfTsgLy8gcHV0IHRoZSBwcm9wZXJ0eSBpbiB0aGUgc3R5bGUgb2JqZWN0c1xuXG5cbiAgc3dpdGNoIChwcm9wLm1hcHBlZCkge1xuICAgIC8vIGZsYXR0ZW4gdGhlIHByb3BlcnR5IGlmIG1hcHBlZFxuICAgIGNhc2UgdHlwZXMubWFwRGF0YTpcbiAgICAgIHtcbiAgICAgICAgLy8gZmxhdHRlbiB0aGUgZmllbGQgKGUuZy4gZGF0YS5mb28uYmFyKVxuICAgICAgICB2YXIgZmllbGRzID0gcHJvcC5maWVsZC5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgZmllbGRWYWwgPSBfcC5kYXRhO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aCAmJiBmaWVsZFZhbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICAgIGZpZWxkVmFsID0gZmllbGRWYWxbZmllbGRdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpZWxkVmFsID09IG51bGwpIHtcbiAgICAgICAgICBwcmludE1hcHBpbmdFcnIoKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGVyY2VudDtcblxuICAgICAgICBpZiAoIW51bWJlciQxKGZpZWxkVmFsKSkge1xuICAgICAgICAgIC8vIHRoZW4gZG9uJ3QgYXBwbHkgYW5kIGZhbGwgYmFjayBvbiB0aGUgZXhpc3Rpbmcgc3R5bGVcbiAgICAgICAgICB3YXJuKCdEbyBub3QgdXNlIGNvbnRpbnVvdXMgbWFwcGVycyB3aXRob3V0IHNwZWNpZnlpbmcgbnVtZXJpYyBkYXRhIChpLmUuIGAnICsgcHJvcC5maWVsZCArICc6ICcgKyBmaWVsZFZhbCArICdgIGZvciBgJyArIGVsZS5pZCgpICsgJ2AgaXMgbm9uLW51bWVyaWMpJyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBmaWVsZFdpZHRoID0gcHJvcC5maWVsZE1heCAtIHByb3AuZmllbGRNaW47XG5cbiAgICAgICAgICBpZiAoZmllbGRXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gc2FmZXR5IGNoZWNrIC0tIG5vdCBzdHJpY3RseSBuZWNlc3NhcnkgYXMgbm8gcHJvcHMgb2YgemVybyByYW5nZSBzaG91bGQgYmUgcGFzc2VkIGhlcmVcbiAgICAgICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZXJjZW50ID0gKGZpZWxkVmFsIC0gcHJvcC5maWVsZE1pbikgLyBmaWVsZFdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBtYWtlIHN1cmUgdG8gYm91bmQgcGVyY2VudCB2YWx1ZVxuXG5cbiAgICAgICAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgcGVyY2VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAocGVyY2VudCA+IDEpIHtcbiAgICAgICAgICBwZXJjZW50ID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlLmNvbG9yKSB7XG4gICAgICAgICAgdmFyIHIxID0gcHJvcC52YWx1ZU1pblswXTtcbiAgICAgICAgICB2YXIgcjIgPSBwcm9wLnZhbHVlTWF4WzBdO1xuICAgICAgICAgIHZhciBnMSA9IHByb3AudmFsdWVNaW5bMV07XG4gICAgICAgICAgdmFyIGcyID0gcHJvcC52YWx1ZU1heFsxXTtcbiAgICAgICAgICB2YXIgYjEgPSBwcm9wLnZhbHVlTWluWzJdO1xuICAgICAgICAgIHZhciBiMiA9IHByb3AudmFsdWVNYXhbMl07XG4gICAgICAgICAgdmFyIGExID0gcHJvcC52YWx1ZU1pblszXSA9PSBudWxsID8gMSA6IHByb3AudmFsdWVNaW5bM107XG4gICAgICAgICAgdmFyIGEyID0gcHJvcC52YWx1ZU1heFszXSA9PSBudWxsID8gMSA6IHByb3AudmFsdWVNYXhbM107XG4gICAgICAgICAgdmFyIGNsciA9IFtNYXRoLnJvdW5kKHIxICsgKHIyIC0gcjEpICogcGVyY2VudCksIE1hdGgucm91bmQoZzEgKyAoZzIgLSBnMSkgKiBwZXJjZW50KSwgTWF0aC5yb3VuZChiMSArIChiMiAtIGIxKSAqIHBlcmNlbnQpLCBNYXRoLnJvdW5kKGExICsgKGEyIC0gYTEpICogcGVyY2VudCldO1xuICAgICAgICAgIGZsYXRQcm9wID0ge1xuICAgICAgICAgICAgLy8gY29sb3VycyBhcmUgc2ltcGxlLCBzbyBqdXN0IGNyZWF0ZSB0aGUgZmxhdCBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGV4cGVuc2l2ZSBzdHJpbmcgcGFyc2luZ1xuICAgICAgICAgICAgYnlwYXNzOiBwcm9wLmJ5cGFzcyxcbiAgICAgICAgICAgIC8vIHdlJ3JlIGEgYnlwYXNzIGlmIHRoZSBtYXBwaW5nIHByb3BlcnR5IGlzIGEgYnlwYXNzXG4gICAgICAgICAgICBuYW1lOiBwcm9wLm5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogY2xyLFxuICAgICAgICAgICAgc3RyVmFsdWU6ICdyZ2IoJyArIGNsclswXSArICcsICcgKyBjbHJbMV0gKyAnLCAnICsgY2xyWzJdICsgJyknXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlLm51bWJlcikge1xuICAgICAgICAgIHZhciBjYWxjVmFsdWUgPSBwcm9wLnZhbHVlTWluICsgKHByb3AudmFsdWVNYXggLSBwcm9wLnZhbHVlTWluKSAqIHBlcmNlbnQ7XG4gICAgICAgICAgZmxhdFByb3AgPSB0aGlzLnBhcnNlKHByb3AubmFtZSwgY2FsY1ZhbHVlLCBwcm9wLmJ5cGFzcywgZmxhdFByb3BNYXBwaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGNhbiBvbmx5IG1hcCB0byBjb2xvdXJzIGFuZCBudW1iZXJzXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZsYXRQcm9wKSB7XG4gICAgICAgICAgLy8gaWYgd2UgY2FuJ3QgZmxhdHRlbiB0aGUgcHJvcGVydHksIHRoZW4gZG9uJ3QgYXBwbHkgdGhlIHByb3BlcnR5IGFuZCBmYWxsIGJhY2sgb24gdGhlIGV4aXN0aW5nIHN0eWxlXG4gICAgICAgICAgcHJpbnRNYXBwaW5nRXJyKCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZmxhdFByb3AubWFwcGluZyA9IHByb3A7IC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG1hcHBpbmdcblxuICAgICAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgLy8gZGlyZWN0IG1hcHBpbmdcblxuICAgIGNhc2UgdHlwZXMuZGF0YTpcbiAgICAgIHtcbiAgICAgICAgLy8gZmxhdHRlbiB0aGUgZmllbGQgKGUuZy4gZGF0YS5mb28uYmFyKVxuICAgICAgICB2YXIgX2ZpZWxkcyA9IHByb3AuZmllbGQuc3BsaXQoJy4nKTtcblxuICAgICAgICB2YXIgX2ZpZWxkVmFsID0gX3AuZGF0YTtcblxuICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBfZmllbGRzLmxlbmd0aCAmJiBfZmllbGRWYWw7IF9pMysrKSB7XG4gICAgICAgICAgdmFyIF9maWVsZCA9IF9maWVsZHNbX2kzXTtcbiAgICAgICAgICBfZmllbGRWYWwgPSBfZmllbGRWYWxbX2ZpZWxkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfZmllbGRWYWwgIT0gbnVsbCkge1xuICAgICAgICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZShwcm9wLm5hbWUsIF9maWVsZFZhbCwgcHJvcC5ieXBhc3MsIGZsYXRQcm9wTWFwcGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZsYXRQcm9wKSB7XG4gICAgICAgICAgLy8gaWYgd2UgY2FuJ3QgZmxhdHRlbiB0aGUgcHJvcGVydHksIHRoZW4gZG9uJ3QgYXBwbHkgYW5kIGZhbGwgYmFjayBvbiB0aGUgZXhpc3Rpbmcgc3R5bGVcbiAgICAgICAgICBwcmludE1hcHBpbmdFcnIoKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmbGF0UHJvcC5tYXBwaW5nID0gcHJvcDsgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgbWFwcGluZ1xuXG4gICAgICAgIHByb3AgPSBmbGF0UHJvcDsgLy8gdGhlIGZsYXR0ZW5lZCAobWFwcGVkKSBwcm9wZXJ0eSBpcyB0aGUgb25lIHdlIHdhbnRcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgdHlwZXMuZm46XG4gICAgICB7XG4gICAgICAgIHZhciBmbiA9IHByb3AudmFsdWU7XG4gICAgICAgIHZhciBmblJldFZhbCA9IHByb3AuZm5WYWx1ZSAhPSBudWxsID8gcHJvcC5mblZhbHVlIDogZm4oZWxlKTsgLy8gY2hlY2sgZm9yIGNhY2hlZCB2YWx1ZSBiZWZvcmUgY2FsbGluZyBmdW5jdGlvblxuXG4gICAgICAgIHByb3AucHJldkZuVmFsdWUgPSBmblJldFZhbDtcblxuICAgICAgICBpZiAoZm5SZXRWYWwgPT0gbnVsbCkge1xuICAgICAgICAgIHdhcm4oJ0N1c3RvbSBmdW5jdGlvbiBtYXBwZXJzIG1heSBub3QgcmV0dXJuIG51bGwgKGkuZS4gYCcgKyBwcm9wLm5hbWUgKyAnYCBmb3IgZWxlIGAnICsgZWxlLmlkKCkgKyAnYCBpcyBudWxsKScpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZShwcm9wLm5hbWUsIGZuUmV0VmFsLCBwcm9wLmJ5cGFzcywgZmxhdFByb3BNYXBwaW5nKTtcblxuICAgICAgICBpZiAoIWZsYXRQcm9wKSB7XG4gICAgICAgICAgd2FybignQ3VzdG9tIGZ1bmN0aW9uIG1hcHBlcnMgbWF5IG5vdCByZXR1cm4gaW52YWxpZCB2YWx1ZXMgZm9yIHRoZSBwcm9wZXJ0eSB0eXBlIChpLmUuIGAnICsgcHJvcC5uYW1lICsgJ2AgZm9yIGVsZSBgJyArIGVsZS5pZCgpICsgJ2AgaXMgaW52YWxpZCknKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmbGF0UHJvcC5tYXBwaW5nID0gY29weShwcm9wKTsgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgbWFwcGluZ1xuXG4gICAgICAgIHByb3AgPSBmbGF0UHJvcDsgLy8gdGhlIGZsYXR0ZW5lZCAobWFwcGVkKSBwcm9wZXJ0eSBpcyB0aGUgb25lIHdlIHdhbnRcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgYnJlYWs7XG4gICAgLy8ganVzdCBzZXQgdGhlIHByb3BlcnR5XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIG5vdCBhIHZhbGlkIG1hcHBpbmdcbiAgfSAvLyBpZiB0aGUgcHJvcGVydHkgaXMgYSBieXBhc3MgcHJvcGVydHksIHRoZW4gbGluayB0aGUgcmVzdWx0YW50IHByb3BlcnR5IHRvIHRoZSBvcmlnaW5hbCBvbmVcblxuXG4gIGlmIChwcm9wSXNCeXBhc3MpIHtcbiAgICBpZiAob3JpZ1Byb3BJc0J5cGFzcykge1xuICAgICAgLy8gdGhlbiB0aGlzIGJ5cGFzcyBvdmVycmlkZXMgdGhlIGV4aXN0aW5nIG9uZVxuICAgICAgcHJvcC5ieXBhc3NlZCA9IG9yaWdQcm9wLmJ5cGFzc2VkOyAvLyBzdGVhbCBieXBhc3NlZCBwcm9wIGZyb20gb2xkIGJ5cGFzc1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aGVuIGxpbmsgdGhlIG9yaWcgcHJvcCB0byB0aGUgbmV3IGJ5cGFzc1xuICAgICAgcHJvcC5ieXBhc3NlZCA9IG9yaWdQcm9wO1xuICAgIH1cblxuICAgIHN0eWxlW3Byb3AubmFtZV0gPSBwcm9wOyAvLyBhbmQgc2V0XG4gIH0gZWxzZSB7XG4gICAgLy8gcHJvcCBpcyBub3QgYnlwYXNzXG4gICAgaWYgKG9yaWdQcm9wSXNCeXBhc3MpIHtcbiAgICAgIC8vIHRoZW4ga2VlcCB0aGUgb3JpZyBwcm9wIChzaW5jZSBpdCdzIGEgYnlwYXNzKSBhbmQgbGluayB0byB0aGUgbmV3IHByb3BcbiAgICAgIG9yaWdQcm9wLmJ5cGFzc2VkID0gcHJvcDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGhlbiBqdXN0IHJlcGxhY2UgdGhlIG9sZCBwcm9wIHdpdGggdGhlIG5ldyBvbmVcbiAgICAgIHN0eWxlW3Byb3AubmFtZV0gPSBwcm9wO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrVHJpZ2dlcnMoKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5zdHlmbiQ4LmNsZWFuRWxlbWVudHMgPSBmdW5jdGlvbiAoZWxlcywga2VlcEJ5cGFzc2VzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIHRoaXMuY2xlYXJTdHlsZUhpbnRzKGVsZSk7XG4gICAgZWxlLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuICAgIGVsZS5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUoKTtcblxuICAgIGlmICgha2VlcEJ5cGFzc2VzKSB7XG4gICAgICBlbGUuX3ByaXZhdGUuc3R5bGUgPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICAgICAgdmFyIHByb3BOYW1lcyA9IE9iamVjdC5rZXlzKHN0eWxlKTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm9wTmFtZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHByb3BOYW1lID0gcHJvcE5hbWVzW2pdO1xuICAgICAgICB2YXIgZWxlUHJvcCA9IHN0eWxlW3Byb3BOYW1lXTtcblxuICAgICAgICBpZiAoZWxlUHJvcCAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKGVsZVByb3AuYnlwYXNzKSB7XG4gICAgICAgICAgICBlbGVQcm9wLmJ5cGFzc2VkID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3R5bGVbcHJvcE5hbWVdID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07IC8vIHVwZGF0ZXMgdGhlIHZpc3VhbCBzdHlsZSBmb3IgYWxsIGVsZW1lbnRzICh1c2VmdWwgZm9yIG1hbnVhbCBzdHlsZSBtb2RpZmljYXRpb24gYWZ0ZXIgaW5pdClcblxuXG5zdHlmbiQ4LnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgdmFyIGVsZXMgPSBjeS5tdXRhYmxlRWxlbWVudHMoKTtcbiAgZWxlcy51cGRhdGVTdHlsZSgpO1xufTsgLy8gZGlmZlByb3BzIDogeyBuYW1lID0+IHsgcHJldiwgbmV4dCB9IH1cblxuXG5zdHlmbiQ4LnVwZGF0ZVRyYW5zaXRpb25zID0gZnVuY3Rpb24gKGVsZSwgZGlmZlByb3BzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcHJvcHMgPSBlbGUucHN0eWxlKCd0cmFuc2l0aW9uLXByb3BlcnR5JykudmFsdWU7XG4gIHZhciBkdXJhdGlvbiA9IGVsZS5wc3R5bGUoJ3RyYW5zaXRpb24tZHVyYXRpb24nKS5wZlZhbHVlO1xuICB2YXIgZGVsYXkgPSBlbGUucHN0eWxlKCd0cmFuc2l0aW9uLWRlbGF5JykucGZWYWx1ZTtcblxuICBpZiAocHJvcHMubGVuZ3RoID4gMCAmJiBkdXJhdGlvbiA+IDApIHtcbiAgICB2YXIgc3R5bGUgPSB7fTsgLy8gYnVpbGQgdXAgdGhlIHN0eWxlIHRvIGFuaW1hdGUgdG93YXJkc1xuXG4gICAgdmFyIGFueVByZXYgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICB2YXIgc3R5UHJvcCA9IGVsZS5wc3R5bGUocHJvcCk7XG4gICAgICB2YXIgZGlmZlByb3AgPSBkaWZmUHJvcHNbcHJvcF07XG5cbiAgICAgIGlmICghZGlmZlByb3ApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2UHJvcCA9IGRpZmZQcm9wLnByZXY7XG4gICAgICB2YXIgZnJvbVByb3AgPSBwcmV2UHJvcDtcbiAgICAgIHZhciB0b1Byb3AgPSBkaWZmUHJvcC5uZXh0ICE9IG51bGwgPyBkaWZmUHJvcC5uZXh0IDogc3R5UHJvcDtcbiAgICAgIHZhciBkaWZmID0gZmFsc2U7XG4gICAgICB2YXIgaW5pdFZhbCA9IHZvaWQgMDtcbiAgICAgIHZhciBpbml0RHQgPSAwLjAwMDAwMTsgLy8gZGVsdGEgdGltZSAlIHZhbHVlIGZvciBpbml0VmFsIChhbGxvd3MgYW5pbWF0aW5nIG91dCBvZiBpbml0IHplcm8gb3BhY2l0eSlcblxuICAgICAgaWYgKCFmcm9tUHJvcCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gY29uc2lkZXIgcHggdmFsdWVzXG5cblxuICAgICAgaWYgKG51bWJlciQxKGZyb21Qcm9wLnBmVmFsdWUpICYmIG51bWJlciQxKHRvUHJvcC5wZlZhbHVlKSkge1xuICAgICAgICBkaWZmID0gdG9Qcm9wLnBmVmFsdWUgLSBmcm9tUHJvcC5wZlZhbHVlOyAvLyBub256ZXJvIGlzIHRydXRoeVxuXG4gICAgICAgIGluaXRWYWwgPSBmcm9tUHJvcC5wZlZhbHVlICsgaW5pdER0ICogZGlmZjsgLy8gY29uc2lkZXIgbnVtZXJpY2FsIHZhbHVlc1xuICAgICAgfSBlbHNlIGlmIChudW1iZXIkMShmcm9tUHJvcC52YWx1ZSkgJiYgbnVtYmVyJDEodG9Qcm9wLnZhbHVlKSkge1xuICAgICAgICBkaWZmID0gdG9Qcm9wLnZhbHVlIC0gZnJvbVByb3AudmFsdWU7IC8vIG5vbnplcm8gaXMgdHJ1dGh5XG5cbiAgICAgICAgaW5pdFZhbCA9IGZyb21Qcm9wLnZhbHVlICsgaW5pdER0ICogZGlmZjsgLy8gY29uc2lkZXIgY29sb3VyIHZhbHVlc1xuICAgICAgfSBlbHNlIGlmIChhcnJheShmcm9tUHJvcC52YWx1ZSkgJiYgYXJyYXkodG9Qcm9wLnZhbHVlKSkge1xuICAgICAgICBkaWZmID0gZnJvbVByb3AudmFsdWVbMF0gIT09IHRvUHJvcC52YWx1ZVswXSB8fCBmcm9tUHJvcC52YWx1ZVsxXSAhPT0gdG9Qcm9wLnZhbHVlWzFdIHx8IGZyb21Qcm9wLnZhbHVlWzJdICE9PSB0b1Byb3AudmFsdWVbMl07XG4gICAgICAgIGluaXRWYWwgPSBmcm9tUHJvcC5zdHJWYWx1ZTtcbiAgICAgIH0gLy8gdGhlIHByZXZpb3VzIHZhbHVlIGlzIGdvb2QgZm9yIGFuIGFuaW1hdGlvbiBvbmx5IGlmIGl0J3MgZGlmZmVyZW50XG5cblxuICAgICAgaWYgKGRpZmYpIHtcbiAgICAgICAgc3R5bGVbcHJvcF0gPSB0b1Byb3Auc3RyVmFsdWU7IC8vIHRvIHZhbFxuXG4gICAgICAgIHRoaXMuYXBwbHlCeXBhc3MoZWxlLCBwcm9wLCBpbml0VmFsKTsgLy8gZnJvbSB2YWxcblxuICAgICAgICBhbnlQcmV2ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IC8vIGVuZCBpZiBwcm9wcyBhbGxvdyBhbmlcbiAgICAvLyBjYW4ndCB0cmFuc2l0aW9uIGlmIHRoZXJlJ3Mgbm90aGluZyBwcmV2aW91cyB0byB0cmFuc2l0aW9uIGZyb21cblxuXG4gICAgaWYgKCFhbnlQcmV2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX3AudHJhbnNpdGlvbmluZyA9IHRydWU7XG4gICAgbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgaWYgKGRlbGF5ID4gMCkge1xuICAgICAgICBlbGUuZGVsYXlBbmltYXRpb24oZGVsYXkpLnBsYXkoKS5wcm9taXNlKCkudGhlbihyZXNvbHZlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBlbGUuYW5pbWF0aW9uKHtcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIGVhc2luZzogZWxlLnBzdHlsZSgndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nKS52YWx1ZSxcbiAgICAgICAgcXVldWU6IGZhbHNlXG4gICAgICB9KS5wbGF5KCkucHJvbWlzZSgpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgLy8gaWYoICFpc0J5cGFzcyApe1xuICAgICAgc2VsZi5yZW1vdmVCeXBhc3NlcyhlbGUsIHByb3BzKTtcbiAgICAgIGVsZS5lbWl0QW5kTm90aWZ5KCdzdHlsZScpOyAvLyB9XG5cbiAgICAgIF9wLnRyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChfcC50cmFuc2l0aW9uaW5nKSB7XG4gICAgdGhpcy5yZW1vdmVCeXBhc3NlcyhlbGUsIHByb3BzKTtcbiAgICBlbGUuZW1pdEFuZE5vdGlmeSgnc3R5bGUnKTtcbiAgICBfcC50cmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gIH1cbn07XG5cbnN0eWZuJDguY2hlY2tUcmlnZ2VyID0gZnVuY3Rpb24gKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlLCBnZXRUcmlnZ2VyLCBvblRyaWdnZXIpIHtcbiAgdmFyIHByb3AgPSB0aGlzLnByb3BlcnRpZXNbbmFtZV07XG4gIHZhciB0cmlnZ2VyQ2hlY2sgPSBnZXRUcmlnZ2VyKHByb3ApO1xuXG4gIGlmICh0cmlnZ2VyQ2hlY2sgIT0gbnVsbCAmJiB0cmlnZ2VyQ2hlY2soZnJvbVZhbHVlLCB0b1ZhbHVlKSkge1xuICAgIG9uVHJpZ2dlcihwcm9wKTtcbiAgfVxufTtcblxuc3R5Zm4kOC5jaGVja1pPcmRlclRyaWdnZXIgPSBmdW5jdGlvbiAoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLmNoZWNrVHJpZ2dlcihlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSwgZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gcHJvcC50cmlnZ2Vyc1pPcmRlcjtcbiAgfSwgZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLl9wcml2YXRlLmN5Lm5vdGlmeSgnem9yZGVyJywgZWxlKTtcbiAgfSk7XG59O1xuXG5zdHlmbiQ4LmNoZWNrQm91bmRzVHJpZ2dlciA9IGZ1bmN0aW9uIChlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSkge1xuICB0aGlzLmNoZWNrVHJpZ2dlcihlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSwgZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gcHJvcC50cmlnZ2Vyc0JvdW5kcztcbiAgfSwgZnVuY3Rpb24gKHByb3ApIHtcbiAgICBlbGUuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG4gICAgZWxlLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpOyAvLyBpZiB0aGUgcHJvcCBjaGFuZ2UgbWFrZXMgdGhlIGJiIG9mIHBsbCBiZXppZXIgZWRnZXMgaW52YWxpZCxcbiAgICAvLyB0aGVuIGRpcnR5IHRoZSBwbGwgZWRnZSBiYiBjYWNoZSBhcyB3ZWxsXG5cbiAgICBpZiAoIC8vIG9ubHkgZm9yIGJlemllcnMgLS0gc28gcGVyZm9ybWFuY2Ugb2Ygb3RoZXIgZWRnZXMgaXNuJ3QgYWZmZWN0ZWRcbiAgICBwcm9wLnRyaWdnZXJzQm91bmRzT2ZQYXJhbGxlbEJlemllcnMgJiYgKG5hbWUgPT09ICdjdXJ2ZS1zdHlsZScgJiYgKGZyb21WYWx1ZSA9PT0gJ2JlemllcicgfHwgdG9WYWx1ZSA9PT0gJ2JlemllcicpIHx8IG5hbWUgPT09ICdkaXNwbGF5JyAmJiAoZnJvbVZhbHVlID09PSAnbm9uZScgfHwgdG9WYWx1ZSA9PT0gJ25vbmUnKSkpIHtcbiAgICAgIGVsZS5wYXJhbGxlbEVkZ2VzKCkuZm9yRWFjaChmdW5jdGlvbiAocGxsRWRnZSkge1xuICAgICAgICBpZiAocGxsRWRnZS5pc0J1bmRsZWRCZXppZXIoKSkge1xuICAgICAgICAgIHBsbEVkZ2UuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG5zdHlmbiQ4LmNoZWNrVHJpZ2dlcnMgPSBmdW5jdGlvbiAoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUpIHtcbiAgZWxlLmRpcnR5U3R5bGVDYWNoZSgpO1xuICB0aGlzLmNoZWNrWk9yZGVyVHJpZ2dlcihlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSk7XG4gIHRoaXMuY2hlY2tCb3VuZHNUcmlnZ2VyKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlKTtcbn07XG5cbnZhciBzdHlmbiQ3ID0ge307IC8vIGJ5cGFzc2VzIGFyZSBhcHBsaWVkIHRvIGFuIGV4aXN0aW5nIHN0eWxlIG9uIGFuIGVsZW1lbnQsIGFuZCBqdXN0IHRhY2tlZCBvbiB0ZW1wb3JhcmlseVxuLy8gcmV0dXJucyB0cnVlIGlmZiBhcHBsaWNhdGlvbiB3YXMgc3VjY2Vzc2Z1bCBmb3IgYXQgbGVhc3QgMSBzcGVjaWZpZWQgcHJvcGVydHlcblxuc3R5Zm4kNy5hcHBseUJ5cGFzcyA9IGZ1bmN0aW9uIChlbGVzLCBuYW1lLCB2YWx1ZSwgdXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcHJvcHMgPSBbXTtcbiAgdmFyIGlzQnlwYXNzID0gdHJ1ZTsgLy8gcHV0IGFsbCB0aGUgcHJvcGVydGllcyAoY2FuIHNwZWNpZnkgb25lIG9yIG1hbnkpIGluIGFuIGFycmF5IGFmdGVyIHBhcnNpbmcgdGhlbVxuXG4gIGlmIChuYW1lID09PSAnKicgfHwgbmFtZSA9PT0gJyoqJykge1xuICAgIC8vIGFwcGx5IHRvIGFsbCBwcm9wZXJ0eSBuYW1lc1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1tpXTtcbiAgICAgICAgdmFyIF9uYW1lID0gcHJvcC5uYW1lO1xuICAgICAgICB2YXIgcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UoX25hbWUsIHZhbHVlLCB0cnVlKTtcblxuICAgICAgICBpZiAocGFyc2VkUHJvcCkge1xuICAgICAgICAgIHByb3BzLnB1c2gocGFyc2VkUHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoc3RyaW5nKG5hbWUpKSB7XG4gICAgLy8gdGhlbiBwYXJzZSB0aGUgc2luZ2xlIHByb3BlcnR5XG4gICAgdmFyIF9wYXJzZWRQcm9wID0gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZSwgdHJ1ZSk7XG5cbiAgICBpZiAoX3BhcnNlZFByb3ApIHtcbiAgICAgIHByb3BzLnB1c2goX3BhcnNlZFByb3ApO1xuICAgIH1cbiAgfSBlbHNlIGlmIChwbGFpbk9iamVjdChuYW1lKSkge1xuICAgIC8vIHRoZW4gcGFyc2UgZWFjaCBwcm9wZXJ0eVxuICAgIHZhciBzcGVjaWZpZWRQcm9wcyA9IG5hbWU7XG4gICAgdXBkYXRlVHJhbnNpdGlvbnMgPSB2YWx1ZTtcbiAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhzcGVjaWZpZWRQcm9wcyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbmFtZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX25hbWUyID0gbmFtZXNbX2ldO1xuICAgICAgdmFyIF92YWx1ZSA9IHNwZWNpZmllZFByb3BzW19uYW1lMl07XG5cbiAgICAgIGlmIChfdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyB0cnkgY2FtZWwgY2FzZSBuYW1lIHRvb1xuICAgICAgICBfdmFsdWUgPSBzcGVjaWZpZWRQcm9wc1tkYXNoMmNhbWVsKF9uYW1lMildO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIF9wYXJzZWRQcm9wMiA9IHRoaXMucGFyc2UoX25hbWUyLCBfdmFsdWUsIHRydWUpO1xuXG4gICAgICAgIGlmIChfcGFyc2VkUHJvcDIpIHtcbiAgICAgICAgICBwcm9wcy5wdXNoKF9wYXJzZWRQcm9wMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gY2FuJ3QgZG8gYW55dGhpbmcgd2l0aG91dCB3ZWxsIGRlZmluZWQgcHJvcGVydGllc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyB3ZSd2ZSBmYWlsZWQgaWYgdGhlcmUgYXJlIG5vIHZhbGlkIHByb3BlcnRpZXNcblxuXG4gIGlmIChwcm9wcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gbm93LCBhcHBseSB0aGUgYnlwYXNzIHByb3BlcnRpZXMgb24gdGhlIGVsZW1lbnRzXG5cblxuICB2YXIgcmV0ID0gZmFsc2U7IC8vIHJldHVybiB0cnVlIGlmIGF0IGxlYXN0IG9uZSBzdWNjZXNmdWwgYnlwYXNzIGFwcGxpZWRcblxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBlbGVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAvLyBmb3IgZWFjaCBlbGVcbiAgICB2YXIgZWxlID0gZWxlc1tfaTJdO1xuICAgIHZhciBkaWZmUHJvcHMgPSB7fTtcbiAgICB2YXIgZGlmZlByb3AgPSB2b2lkIDA7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICAvLyBmb3IgZWFjaCBwcm9wXG4gICAgICB2YXIgX3Byb3AgPSBwcm9wc1tqXTtcblxuICAgICAgaWYgKHVwZGF0ZVRyYW5zaXRpb25zKSB7XG4gICAgICAgIHZhciBwcmV2UHJvcCA9IGVsZS5wc3R5bGUoX3Byb3AubmFtZSk7XG4gICAgICAgIGRpZmZQcm9wID0gZGlmZlByb3BzW19wcm9wLm5hbWVdID0ge1xuICAgICAgICAgIHByZXY6IHByZXZQcm9wXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldCA9IHRoaXMuYXBwbHlQYXJzZWRQcm9wZXJ0eShlbGUsIGNvcHkoX3Byb3ApKSB8fCByZXQ7XG5cbiAgICAgIGlmICh1cGRhdGVUcmFuc2l0aW9ucykge1xuICAgICAgICBkaWZmUHJvcC5uZXh0ID0gZWxlLnBzdHlsZShfcHJvcC5uYW1lKTtcbiAgICAgIH1cbiAgICB9IC8vIGZvciBwcm9wc1xuXG5cbiAgICBpZiAocmV0KSB7XG4gICAgICB0aGlzLnVwZGF0ZVN0eWxlSGludHMoZWxlKTtcbiAgICB9XG5cbiAgICBpZiAodXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgICAgIHRoaXMudXBkYXRlVHJhbnNpdGlvbnMoZWxlLCBkaWZmUHJvcHMsIGlzQnlwYXNzKTtcbiAgICB9XG4gIH0gLy8gZm9yIGVsZXNcblxuXG4gIHJldHVybiByZXQ7XG59OyAvLyBvbmx5IHVzZWZ1bCBpbiBzcGVjaWZpYyBjYXNlcyBsaWtlIGFuaW1hdGlvblxuXG5cbnN0eWZuJDcub3ZlcnJpZGVCeXBhc3MgPSBmdW5jdGlvbiAoZWxlcywgbmFtZSwgdmFsdWUpIHtcbiAgbmFtZSA9IGNhbWVsMmRhc2gobmFtZSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgdmFyIHByb3AgPSBlbGUuX3ByaXZhdGUuc3R5bGVbbmFtZV07XG4gICAgdmFyIHR5cGUgPSB0aGlzLnByb3BlcnRpZXNbbmFtZV0udHlwZTtcbiAgICB2YXIgaXNDb2xvciA9IHR5cGUuY29sb3I7XG4gICAgdmFyIGlzTXVsdGkgPSB0eXBlLm11dGlwbGU7XG4gICAgdmFyIG9sZFZhbHVlID0gIXByb3AgPyBudWxsIDogcHJvcC5wZlZhbHVlICE9IG51bGwgPyBwcm9wLnBmVmFsdWUgOiBwcm9wLnZhbHVlO1xuXG4gICAgaWYgKCFwcm9wIHx8ICFwcm9wLmJ5cGFzcykge1xuICAgICAgLy8gbmVlZCBhIGJ5cGFzcyBpZiBvbmUgZG9lc24ndCBleGlzdFxuICAgICAgdGhpcy5hcHBseUJ5cGFzcyhlbGUsIG5hbWUsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcC52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICBpZiAocHJvcC5wZlZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcHJvcC5wZlZhbHVlID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0NvbG9yKSB7XG4gICAgICAgIHByb3Auc3RyVmFsdWUgPSAncmdiKCcgKyB2YWx1ZS5qb2luKCcsJykgKyAnKSc7XG4gICAgICB9IGVsc2UgaWYgKGlzTXVsdGkpIHtcbiAgICAgICAgcHJvcC5zdHJWYWx1ZSA9IHZhbHVlLmpvaW4oJyAnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3Auc3RyVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZVN0eWxlSGludHMoZWxlKTtcbiAgICB9XG5cbiAgICB0aGlzLmNoZWNrVHJpZ2dlcnMoZWxlLCBuYW1lLCBvbGRWYWx1ZSwgdmFsdWUpO1xuICB9XG59O1xuXG5zdHlmbiQ3LnJlbW92ZUFsbEJ5cGFzc2VzID0gZnVuY3Rpb24gKGVsZXMsIHVwZGF0ZVRyYW5zaXRpb25zKSB7XG4gIHJldHVybiB0aGlzLnJlbW92ZUJ5cGFzc2VzKGVsZXMsIHRoaXMucHJvcGVydHlOYW1lcywgdXBkYXRlVHJhbnNpdGlvbnMpO1xufTtcblxuc3R5Zm4kNy5yZW1vdmVCeXBhc3NlcyA9IGZ1bmN0aW9uIChlbGVzLCBwcm9wcywgdXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgdmFyIGlzQnlwYXNzID0gdHJ1ZTtcblxuICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZXMubGVuZ3RoOyBqKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tqXTtcbiAgICB2YXIgZGlmZlByb3BzID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IHByb3BzW2ldO1xuICAgICAgdmFyIHByb3AgPSB0aGlzLnByb3BlcnRpZXNbbmFtZV07XG4gICAgICB2YXIgcHJldlByb3AgPSBlbGUucHN0eWxlKHByb3AubmFtZSk7XG5cbiAgICAgIGlmICghcHJldlByb3AgfHwgIXByZXZQcm9wLmJ5cGFzcykge1xuICAgICAgICAvLyBpZiBhIGJ5cGFzcyBkb2Vzbid0IGV4aXN0IGZvciB0aGUgcHJvcCwgbm90aGluZyBuZWVkcyB0byBiZSByZW1vdmVkXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSAnJzsgLy8gZW1wdHkgPT4gcmVtb3ZlIGJ5cGFzc1xuXG4gICAgICB2YXIgcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgdmFsdWUsIHRydWUpO1xuICAgICAgdmFyIGRpZmZQcm9wID0gZGlmZlByb3BzW3Byb3AubmFtZV0gPSB7XG4gICAgICAgIHByZXY6IHByZXZQcm9wXG4gICAgICB9O1xuICAgICAgdGhpcy5hcHBseVBhcnNlZFByb3BlcnR5KGVsZSwgcGFyc2VkUHJvcCk7XG4gICAgICBkaWZmUHJvcC5uZXh0ID0gZWxlLnBzdHlsZShwcm9wLm5hbWUpO1xuICAgIH0gLy8gZm9yIHByb3BzXG5cblxuICAgIHRoaXMudXBkYXRlU3R5bGVIaW50cyhlbGUpO1xuXG4gICAgaWYgKHVwZGF0ZVRyYW5zaXRpb25zKSB7XG4gICAgICB0aGlzLnVwZGF0ZVRyYW5zaXRpb25zKGVsZSwgZGlmZlByb3BzLCBpc0J5cGFzcyk7XG4gICAgfVxuICB9IC8vIGZvciBlbGVzXG5cbn07XG5cbnZhciBzdHlmbiQ2ID0ge307IC8vIGdldHMgd2hhdCBhbiBlbSBzaXplIGNvcnJlc3BvbmRzIHRvIGluIHBpeGVscyByZWxhdGl2ZSB0byBhIGRvbSBlbGVtZW50XG5cbnN0eWZuJDYuZ2V0RW1TaXplSW5QaXhlbHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBweCA9IHRoaXMuY29udGFpbmVyQ3NzKCdmb250LXNpemUnKTtcblxuICBpZiAocHggIT0gbnVsbCkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHB4KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMTsgLy8gZm9yIGhlYWRsZXNzXG4gIH1cbn07IC8vIGdldHMgY3NzIHByb3BlcnR5IGZyb20gdGhlIGNvcmUgY29udGFpbmVyXG5cblxuc3R5Zm4kNi5jb250YWluZXJDc3MgPSBmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgdmFyIGRvbUVsZW1lbnQgPSBjeS5jb250YWluZXIoKTtcbiAgdmFyIGNvbnRhaW5lcldpbmRvdyA9IGN5LndpbmRvdygpO1xuXG4gIGlmIChjb250YWluZXJXaW5kb3cgJiYgZG9tRWxlbWVudCAmJiBjb250YWluZXJXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgIHJldHVybiBjb250YWluZXJXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb21FbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BOYW1lKTtcbiAgfVxufTtcblxudmFyIHN0eWZuJDUgPSB7fTsgLy8gZ2V0cyB0aGUgcmVuZGVyZWQgc3R5bGUgZm9yIGFuIGVsZW1lbnRcblxuc3R5Zm4kNS5nZXRSZW5kZXJlZFN0eWxlID0gZnVuY3Rpb24gKGVsZSwgcHJvcCkge1xuICBpZiAocHJvcCkge1xuICAgIHJldHVybiB0aGlzLmdldFN0eWxlUHJvcGVydHlWYWx1ZShlbGUsIHByb3AsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLmdldFJhd1N0eWxlKGVsZSwgdHJ1ZSk7XG4gIH1cbn07IC8vIGdldHMgdGhlIHJhdyBzdHlsZSBmb3IgYW4gZWxlbWVudFxuXG5cbnN0eWZuJDUuZ2V0UmF3U3R5bGUgPSBmdW5jdGlvbiAoZWxlLCBpc1JlbmRlcmVkVmFsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZWxlID0gZWxlWzBdOyAvLyBpbnN1cmUgaXQncyBhbiBlbGVtZW50XG5cbiAgaWYgKGVsZSkge1xuICAgIHZhciByc3R5bGUgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1tpXTtcbiAgICAgIHZhciB2YWwgPSBzZWxmLmdldFN0eWxlUHJvcGVydHlWYWx1ZShlbGUsIHByb3AubmFtZSwgaXNSZW5kZXJlZFZhbCk7XG5cbiAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICByc3R5bGVbcHJvcC5uYW1lXSA9IHZhbDtcbiAgICAgICAgcnN0eWxlW2Rhc2gyY2FtZWwocHJvcC5uYW1lKV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJzdHlsZTtcbiAgfVxufTtcblxuc3R5Zm4kNS5nZXRJbmRleGVkU3R5bGUgPSBmdW5jdGlvbiAoZWxlLCBwcm9wZXJ0eSwgc3VicHJvcGVydHksIGluZGV4KSB7XG4gIHZhciBwc3R5bGUgPSBlbGUucHN0eWxlKHByb3BlcnR5KVtzdWJwcm9wZXJ0eV1baW5kZXhdO1xuICByZXR1cm4gcHN0eWxlICE9IG51bGwgPyBwc3R5bGUgOiBlbGUuY3koKS5zdHlsZSgpLmdldERlZmF1bHRQcm9wZXJ0eShwcm9wZXJ0eSlbc3VicHJvcGVydHldWzBdO1xufTtcblxuc3R5Zm4kNS5nZXRTdHlsZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbiAoZWxlLCBwcm9wTmFtZSwgaXNSZW5kZXJlZFZhbCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGVsZSA9IGVsZVswXTsgLy8gaW5zdXJlIGl0J3MgYW4gZWxlbWVudFxuXG4gIGlmIChlbGUpIHtcbiAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1twcm9wTmFtZV07XG5cbiAgICBpZiAocHJvcC5hbGlhcykge1xuICAgICAgcHJvcCA9IHByb3AucG9pbnRzVG87XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gICAgdmFyIHN0eWxlUHJvcCA9IGVsZS5wc3R5bGUocHJvcC5uYW1lKTtcblxuICAgIGlmIChzdHlsZVByb3ApIHtcbiAgICAgIHZhciB2YWx1ZSA9IHN0eWxlUHJvcC52YWx1ZSxcbiAgICAgICAgICB1bml0cyA9IHN0eWxlUHJvcC51bml0cyxcbiAgICAgICAgICBzdHJWYWx1ZSA9IHN0eWxlUHJvcC5zdHJWYWx1ZTtcblxuICAgICAgaWYgKGlzUmVuZGVyZWRWYWwgJiYgdHlwZS5udW1iZXIgJiYgdmFsdWUgIT0gbnVsbCAmJiBudW1iZXIkMSh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIHpvb20gPSBlbGUuY3koKS56b29tKCk7XG5cbiAgICAgICAgdmFyIGdldFJlbmRlcmVkVmFsdWUgPSBmdW5jdGlvbiBnZXRSZW5kZXJlZFZhbHVlKHZhbCkge1xuICAgICAgICAgIHJldHVybiB2YWwgKiB6b29tO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRWYWx1ZVN0cmluZ1dpdGhVbml0cyA9IGZ1bmN0aW9uIGdldFZhbHVlU3RyaW5nV2l0aFVuaXRzKHZhbCwgdW5pdHMpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0UmVuZGVyZWRWYWx1ZSh2YWwpICsgdW5pdHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGlzQXJyYXlWYWx1ZSA9IGFycmF5KHZhbHVlKTtcbiAgICAgICAgdmFyIGhhdmVVbml0cyA9IGlzQXJyYXlWYWx1ZSA/IHVuaXRzLmV2ZXJ5KGZ1bmN0aW9uICh1KSB7XG4gICAgICAgICAgcmV0dXJuIHUgIT0gbnVsbDtcbiAgICAgICAgfSkgOiB1bml0cyAhPSBudWxsO1xuXG4gICAgICAgIGlmIChoYXZlVW5pdHMpIHtcbiAgICAgICAgICBpZiAoaXNBcnJheVZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRWYWx1ZVN0cmluZ1dpdGhVbml0cyh2LCB1bml0c1tpXSk7XG4gICAgICAgICAgICB9KS5qb2luKCcgJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRWYWx1ZVN0cmluZ1dpdGhVbml0cyh2YWx1ZSwgdW5pdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNBcnJheVZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgIHJldHVybiBzdHJpbmcodikgPyB2IDogJycgKyBnZXRSZW5kZXJlZFZhbHVlKHYpO1xuICAgICAgICAgICAgfSkuam9pbignICcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJycgKyBnZXRSZW5kZXJlZFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc3RyVmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbnN0eWZuJDUuZ2V0QW5pbWF0aW9uU3RhcnRTdHlsZSA9IGZ1bmN0aW9uIChlbGUsIGFuaVByb3BzKSB7XG4gIHZhciByc3R5bGUgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaVByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGFuaVByb3AgPSBhbmlQcm9wc1tpXTtcbiAgICB2YXIgbmFtZSA9IGFuaVByb3AubmFtZTtcbiAgICB2YXIgc3R5bGVQcm9wID0gZWxlLnBzdHlsZShuYW1lKTtcblxuICAgIGlmIChzdHlsZVByb3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gdGhlbiBtYWtlIGEgcHJvcCBvZiBpdFxuICAgICAgaWYgKHBsYWluT2JqZWN0KHN0eWxlUHJvcCkpIHtcbiAgICAgICAgc3R5bGVQcm9wID0gdGhpcy5wYXJzZShuYW1lLCBzdHlsZVByb3Auc3RyVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGVQcm9wID0gdGhpcy5wYXJzZShuYW1lLCBzdHlsZVByb3ApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHlsZVByb3ApIHtcbiAgICAgIHJzdHlsZVtuYW1lXSA9IHN0eWxlUHJvcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnN0eWxlO1xufTtcblxuc3R5Zm4kNS5nZXRQcm9wc0xpc3QgPSBmdW5jdGlvbiAocHJvcHNPYmopIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcnN0eWxlID0gW107XG4gIHZhciBzdHlsZSA9IHByb3BzT2JqO1xuICB2YXIgcHJvcHMgPSBzZWxmLnByb3BlcnRpZXM7XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXMoc3R5bGUpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgIHZhciB2YWwgPSBzdHlsZVtuYW1lXTtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbbmFtZV0gfHwgcHJvcHNbY2FtZWwyZGFzaChuYW1lKV07XG4gICAgICB2YXIgc3R5bGVQcm9wID0gdGhpcy5wYXJzZShwcm9wLm5hbWUsIHZhbCk7XG5cbiAgICAgIGlmIChzdHlsZVByb3ApIHtcbiAgICAgICAgcnN0eWxlLnB1c2goc3R5bGVQcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnN0eWxlO1xufTtcblxuc3R5Zm4kNS5nZXROb25EZWZhdWx0UHJvcGVydGllc0hhc2ggPSBmdW5jdGlvbiAoZWxlLCBwcm9wTmFtZXMsIHNlZWQpIHtcbiAgdmFyIGhhc2ggPSBzZWVkLnNsaWNlKCk7XG4gIHZhciBuYW1lLCB2YWwsIHN0clZhbCwgY2hWYWw7XG4gIHZhciBpLCBqO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBwcm9wTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICBuYW1lID0gcHJvcE5hbWVzW2ldO1xuICAgIHZhbCA9IGVsZS5wc3R5bGUobmFtZSwgZmFsc2UpO1xuXG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKHZhbC5wZlZhbHVlICE9IG51bGwpIHtcbiAgICAgIGhhc2hbMF0gPSBoYXNoSW50KGNoVmFsLCBoYXNoWzBdKTtcbiAgICAgIGhhc2hbMV0gPSBoYXNoSW50QWx0KGNoVmFsLCBoYXNoWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyVmFsID0gdmFsLnN0clZhbHVlO1xuXG4gICAgICBmb3IgKGogPSAwOyBqIDwgc3RyVmFsLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNoVmFsID0gc3RyVmFsLmNoYXJDb2RlQXQoaik7XG4gICAgICAgIGhhc2hbMF0gPSBoYXNoSW50KGNoVmFsLCBoYXNoWzBdKTtcbiAgICAgICAgaGFzaFsxXSA9IGhhc2hJbnRBbHQoY2hWYWwsIGhhc2hbMV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoYXNoO1xufTtcblxuc3R5Zm4kNS5nZXRQcm9wZXJ0aWVzSGFzaCA9IHN0eWZuJDUuZ2V0Tm9uRGVmYXVsdFByb3BlcnRpZXNIYXNoO1xuXG52YXIgc3R5Zm4kNCA9IHt9O1xuXG5zdHlmbiQ0LmFwcGVuZEZyb21Kc29uID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgdmFyIHN0eWxlID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGpzb24ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29udGV4dCA9IGpzb25baV07XG4gICAgdmFyIHNlbGVjdG9yID0gY29udGV4dC5zZWxlY3RvcjtcbiAgICB2YXIgcHJvcHMgPSBjb250ZXh0LnN0eWxlIHx8IGNvbnRleHQuY3NzO1xuICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKHByb3BzKTtcbiAgICBzdHlsZS5zZWxlY3RvcihzZWxlY3Rvcik7IC8vIGFwcGx5IHNlbGVjdG9yXG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5hbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbmFtZSA9IG5hbWVzW2pdO1xuICAgICAgdmFyIHZhbHVlID0gcHJvcHNbbmFtZV07XG4gICAgICBzdHlsZS5jc3MobmFtZSwgdmFsdWUpOyAvLyBhcHBseSBwcm9wZXJ0eVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn07IC8vIGFjY2Vzc2libGUgY3kuc3R5bGUoKSBmdW5jdGlvblxuXG5cbnN0eWZuJDQuZnJvbUpzb24gPSBmdW5jdGlvbiAoanNvbikge1xuICB2YXIgc3R5bGUgPSB0aGlzO1xuICBzdHlsZS5yZXNldFRvRGVmYXVsdCgpO1xuICBzdHlsZS5hcHBlbmRGcm9tSnNvbihqc29uKTtcbiAgcmV0dXJuIHN0eWxlO1xufTsgLy8gZ2V0IGpzb24gZnJvbSBjeS5zdHlsZSgpIGFwaVxuXG5cbnN0eWZuJDQuanNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGpzb24gPSBbXTtcblxuICBmb3IgKHZhciBpID0gdGhpcy5kZWZhdWx0TGVuZ3RoOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjeHQgPSB0aGlzW2ldO1xuICAgIHZhciBzZWxlY3RvciA9IGN4dC5zZWxlY3RvcjtcbiAgICB2YXIgcHJvcHMgPSBjeHQucHJvcGVydGllcztcbiAgICB2YXIgY3NzID0ge307XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2pdO1xuICAgICAgY3NzW3Byb3AubmFtZV0gPSBwcm9wLnN0clZhbHVlO1xuICAgIH1cblxuICAgIGpzb24ucHVzaCh7XG4gICAgICBzZWxlY3RvcjogIXNlbGVjdG9yID8gJ2NvcmUnIDogc2VsZWN0b3IudG9TdHJpbmcoKSxcbiAgICAgIHN0eWxlOiBjc3NcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBqc29uO1xufTtcblxudmFyIHN0eWZuJDMgPSB7fTtcblxuc3R5Zm4kMy5hcHBlbmRGcm9tU3RyaW5nID0gZnVuY3Rpb24gKHN0cmluZykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzdHlsZSA9IHRoaXM7XG4gIHZhciByZW1haW5pbmcgPSAnJyArIHN0cmluZztcbiAgdmFyIHNlbEFuZEJsb2NrU3RyO1xuICB2YXIgYmxvY2tSZW07XG4gIHZhciBwcm9wQW5kVmFsU3RyOyAvLyByZW1vdmUgY29tbWVudHMgZnJvbSB0aGUgc3R5bGUgc3RyaW5nXG5cbiAgcmVtYWluaW5nID0gcmVtYWluaW5nLnJlcGxhY2UoL1svXVsqXShcXHN8LikrP1sqXVsvXS9nLCAnJyk7XG5cbiAgZnVuY3Rpb24gcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCkge1xuICAgIC8vIHJlbW92ZSB0aGUgcGFyc2VkIHNlbGVjdG9yIGFuZCBibG9jayBmcm9tIHRoZSByZW1haW5pbmcgdGV4dCB0byBwYXJzZVxuICAgIGlmIChyZW1haW5pbmcubGVuZ3RoID4gc2VsQW5kQmxvY2tTdHIubGVuZ3RoKSB7XG4gICAgICByZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyKHNlbEFuZEJsb2NrU3RyLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbWFpbmluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCkge1xuICAgIC8vIHJlbW92ZSB0aGUgcGFyc2VkIHByb3BlcnR5IGFuZCB2YWx1ZSBmcm9tIHRoZSByZW1haW5pbmcgYmxvY2sgdGV4dCB0byBwYXJzZVxuICAgIGlmIChibG9ja1JlbS5sZW5ndGggPiBwcm9wQW5kVmFsU3RyLmxlbmd0aCkge1xuICAgICAgYmxvY2tSZW0gPSBibG9ja1JlbS5zdWJzdHIocHJvcEFuZFZhbFN0ci5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBibG9ja1JlbSA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOzspIHtcbiAgICB2YXIgbm90aGluZ0xlZnRUb1BhcnNlID0gcmVtYWluaW5nLm1hdGNoKC9eXFxzKiQvKTtcblxuICAgIGlmIChub3RoaW5nTGVmdFRvUGFyc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBzZWxBbmRCbG9jayA9IHJlbWFpbmluZy5tYXRjaCgvXlxccyooKD86LnxcXHMpKz8pXFxzKlxceygoPzoufFxccykrPylcXH0vKTtcblxuICAgIGlmICghc2VsQW5kQmxvY2spIHtcbiAgICAgIHdhcm4oJ0hhbHRpbmcgc3R5bGVzaGVldCBwYXJzaW5nOiBTdHJpbmcgc3R5bGVzaGVldCBjb250YWlucyBtb3JlIHRvIHBhcnNlIGJ1dCBubyBzZWxlY3RvciBhbmQgYmxvY2sgZm91bmQgaW46ICcgKyByZW1haW5pbmcpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgc2VsQW5kQmxvY2tTdHIgPSBzZWxBbmRCbG9ja1swXTsgLy8gcGFyc2UgdGhlIHNlbGVjdG9yXG5cbiAgICB2YXIgc2VsZWN0b3JTdHIgPSBzZWxBbmRCbG9ja1sxXTtcblxuICAgIGlmIChzZWxlY3RvclN0ciAhPT0gJ2NvcmUnKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBuZXcgU2VsZWN0b3Ioc2VsZWN0b3JTdHIpO1xuXG4gICAgICBpZiAoc2VsZWN0b3IuaW52YWxpZCkge1xuICAgICAgICB3YXJuKCdTa2lwcGluZyBwYXJzaW5nIG9mIGJsb2NrOiBJbnZhbGlkIHNlbGVjdG9yIGZvdW5kIGluIHN0cmluZyBzdHlsZXNoZWV0OiAnICsgc2VsZWN0b3JTdHIpOyAvLyBza2lwIHRoaXMgc2VsZWN0b3IgYW5kIGJsb2NrXG5cbiAgICAgICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH0gLy8gcGFyc2UgdGhlIGJsb2NrIG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlc1xuXG5cbiAgICB2YXIgYmxvY2tTdHIgPSBzZWxBbmRCbG9ja1syXTtcbiAgICB2YXIgaW52YWxpZEJsb2NrID0gZmFsc2U7XG4gICAgYmxvY2tSZW0gPSBibG9ja1N0cjtcbiAgICB2YXIgcHJvcHMgPSBbXTtcblxuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciBfbm90aGluZ0xlZnRUb1BhcnNlID0gYmxvY2tSZW0ubWF0Y2goL15cXHMqJC8pO1xuXG4gICAgICBpZiAoX25vdGhpbmdMZWZ0VG9QYXJzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3BBbmRWYWwgPSBibG9ja1JlbS5tYXRjaCgvXlxccyooLis/KVxccyo6XFxzKiguKz8pKD86XFxzKjt8XFxzKiQpLyk7XG5cbiAgICAgIGlmICghcHJvcEFuZFZhbCkge1xuICAgICAgICB3YXJuKCdTa2lwcGluZyBwYXJzaW5nIG9mIGJsb2NrOiBJbnZhbGlkIGZvcm1hdHRpbmcgb2Ygc3R5bGUgcHJvcGVydHkgYW5kIHZhbHVlIGRlZmluaXRpb25zIGZvdW5kIGluOicgKyBibG9ja1N0cik7XG4gICAgICAgIGludmFsaWRCbG9jayA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBwcm9wQW5kVmFsU3RyID0gcHJvcEFuZFZhbFswXTtcbiAgICAgIHZhciBwcm9wU3RyID0gcHJvcEFuZFZhbFsxXTtcbiAgICAgIHZhciB2YWxTdHIgPSBwcm9wQW5kVmFsWzJdO1xuICAgICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnRpZXNbcHJvcFN0cl07XG5cbiAgICAgIGlmICghcHJvcCkge1xuICAgICAgICB3YXJuKCdTa2lwcGluZyBwcm9wZXJ0eTogSW52YWxpZCBwcm9wZXJ0eSBuYW1lIGluOiAnICsgcHJvcEFuZFZhbFN0cik7IC8vIHNraXAgdGhpcyBwcm9wZXJ0eSBpbiB0aGUgYmxvY2tcblxuICAgICAgICByZW1vdmVQcm9wQW5kVmFsRnJvbVJlbSgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcnNlZFByb3AgPSBzdHlsZS5wYXJzZShwcm9wU3RyLCB2YWxTdHIpO1xuXG4gICAgICBpZiAoIXBhcnNlZFByb3ApIHtcbiAgICAgICAgd2FybignU2tpcHBpbmcgcHJvcGVydHk6IEludmFsaWQgcHJvcGVydHkgZGVmaW5pdGlvbiBpbjogJyArIHByb3BBbmRWYWxTdHIpOyAvLyBza2lwIHRoaXMgcHJvcGVydHkgaW4gdGhlIGJsb2NrXG5cbiAgICAgICAgcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHByb3BzLnB1c2goe1xuICAgICAgICBuYW1lOiBwcm9wU3RyLFxuICAgICAgICB2YWw6IHZhbFN0clxuICAgICAgfSk7XG4gICAgICByZW1vdmVQcm9wQW5kVmFsRnJvbVJlbSgpO1xuICAgIH1cblxuICAgIGlmIChpbnZhbGlkQmxvY2spIHtcbiAgICAgIHJlbW92ZVNlbEFuZEJsb2NrRnJvbVJlbWFpbmluZygpO1xuICAgICAgYnJlYWs7XG4gICAgfSAvLyBwdXQgdGhlIHBhcnNlZCBibG9jayBpbiB0aGUgc3R5bGVcblxuXG4gICAgc3R5bGUuc2VsZWN0b3Ioc2VsZWN0b3JTdHIpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9wcm9wID0gcHJvcHNbaV07XG4gICAgICBzdHlsZS5jc3MoX3Byb3AubmFtZSwgX3Byb3AudmFsKTtcbiAgICB9XG5cbiAgICByZW1vdmVTZWxBbmRCbG9ja0Zyb21SZW1haW5pbmcoKTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn07XG5cbnN0eWZuJDMuZnJvbVN0cmluZyA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgdmFyIHN0eWxlID0gdGhpcztcbiAgc3R5bGUucmVzZXRUb0RlZmF1bHQoKTtcbiAgc3R5bGUuYXBwZW5kRnJvbVN0cmluZyhzdHJpbmcpO1xuICByZXR1cm4gc3R5bGU7XG59O1xuXG52YXIgc3R5Zm4kMiA9IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuICB2YXIgbnVtYmVyJDEgPSBudW1iZXI7XG4gIHZhciByZ2JhID0gcmdiYU5vQmFja1JlZnM7XG4gIHZhciBoc2xhID0gaHNsYU5vQmFja1JlZnM7XG4gIHZhciBoZXgzJDEgPSBoZXgzO1xuICB2YXIgaGV4NiQxID0gaGV4NjtcblxuICB2YXIgZGF0YSA9IGZ1bmN0aW9uIGRhdGEocHJlZml4KSB7XG4gICAgcmV0dXJuICdeJyArIHByZWZpeCArICdcXFxccypcXFxcKFxcXFxzKihbXFxcXHdcXFxcLl0rKVxcXFxzKlxcXFwpJCc7XG4gIH07XG5cbiAgdmFyIG1hcERhdGEgPSBmdW5jdGlvbiBtYXBEYXRhKHByZWZpeCkge1xuICAgIHZhciBtYXBBcmcgPSBudW1iZXIkMSArICd8XFxcXHcrfCcgKyByZ2JhICsgJ3wnICsgaHNsYSArICd8JyArIGhleDMkMSArICd8JyArIGhleDYkMTtcbiAgICByZXR1cm4gJ14nICsgcHJlZml4ICsgJ1xcXFxzKlxcXFwoKFtcXFxcd1xcXFwuXSspXFxcXHMqXFxcXCxcXFxccyooJyArIG51bWJlciQxICsgJylcXFxccypcXFxcLFxcXFxzKignICsgbnVtYmVyJDEgKyAnKVxcXFxzKixcXFxccyooJyArIG1hcEFyZyArICcpXFxcXHMqXFxcXCxcXFxccyooJyArIG1hcEFyZyArICcpXFxcXCkkJztcbiAgfTtcblxuICB2YXIgdXJsUmVnZXhlcyA9IFsnXnVybFxcXFxzKlxcXFwoXFxcXHMqW1xcJ1wiXT8oLis/KVtcXCdcIl0/XFxcXHMqXFxcXCkkJywgJ14obm9uZSkkJywgJ14oLispJCddOyAvLyBlYWNoIHZpc3VhbCBzdHlsZSBwcm9wZXJ0eSBoYXMgYSB0eXBlIGFuZCBuZWVkcyB0byBiZSB2YWxpZGF0ZWQgYWNjb3JkaW5nIHRvIGl0XG5cbiAgc3R5Zm4kMi50eXBlcyA9IHtcbiAgICB0aW1lOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICB1bml0czogJ3N8bXMnLFxuICAgICAgaW1wbGljaXRVbml0czogJ21zJ1xuICAgIH0sXG4gICAgcGVyY2VudDoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgbWF4OiAxMDAsXG4gICAgICB1bml0czogJyUnLFxuICAgICAgaW1wbGljaXRVbml0czogJyUnXG4gICAgfSxcbiAgICBwZXJjZW50YWdlczoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgbWF4OiAxMDAsXG4gICAgICB1bml0czogJyUnLFxuICAgICAgaW1wbGljaXRVbml0czogJyUnLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIHplcm9PbmVOdW1iZXI6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIG1heDogMSxcbiAgICAgIHVuaXRsZXNzOiB0cnVlXG4gICAgfSxcbiAgICB6ZXJvT25lTnVtYmVyczoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgbWF4OiAxLFxuICAgICAgdW5pdGxlc3M6IHRydWUsXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgbk9uZU9uZU51bWJlcjoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAtMSxcbiAgICAgIG1heDogMSxcbiAgICAgIHVuaXRsZXNzOiB0cnVlXG4gICAgfSxcbiAgICBub25OZWdhdGl2ZUludDoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgaW50ZWdlcjogdHJ1ZSxcbiAgICAgIHVuaXRsZXNzOiB0cnVlXG4gICAgfSxcbiAgICBwb3NpdGlvbjoge1xuICAgICAgZW51bXM6IFsncGFyZW50JywgJ29yaWdpbiddXG4gICAgfSxcbiAgICBub2RlU2l6ZToge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgZW51bXM6IFsnbGFiZWwnXVxuICAgIH0sXG4gICAgbnVtYmVyOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICB1bml0bGVzczogdHJ1ZVxuICAgIH0sXG4gICAgbnVtYmVyczoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgdW5pdGxlc3M6IHRydWUsXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgcG9zaXRpdmVOdW1iZXI6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIHVuaXRsZXNzOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgc3RyaWN0TWluOiB0cnVlXG4gICAgfSxcbiAgICBzaXplOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDBcbiAgICB9LFxuICAgIGJpZGlyZWN0aW9uYWxTaXplOiB7XG4gICAgICBudW1iZXI6IHRydWVcbiAgICB9LFxuICAgIC8vIGFsbG93cyBuZWdhdGl2ZVxuICAgIGJpZGlyZWN0aW9uYWxTaXplTWF5YmVQZXJjZW50OiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBhbGxvd1BlcmNlbnQ6IHRydWVcbiAgICB9LFxuICAgIC8vIGFsbG93cyBuZWdhdGl2ZVxuICAgIGJpZGlyZWN0aW9uYWxTaXplczoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIC8vIGFsbG93cyBuZWdhdGl2ZVxuICAgIHNpemVNYXliZVBlcmNlbnQ6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIGFsbG93UGVyY2VudDogdHJ1ZVxuICAgIH0sXG4gICAgYXhpc0RpcmVjdGlvbjoge1xuICAgICAgZW51bXM6IFsnaG9yaXpvbnRhbCcsICdsZWZ0d2FyZCcsICdyaWdodHdhcmQnLCAndmVydGljYWwnLCAndXB3YXJkJywgJ2Rvd253YXJkJywgJ2F1dG8nXVxuICAgIH0sXG4gICAgcGFkZGluZ1JlbGF0aXZlVG86IHtcbiAgICAgIGVudW1zOiBbJ3dpZHRoJywgJ2hlaWdodCcsICdhdmVyYWdlJywgJ21pbicsICdtYXgnXVxuICAgIH0sXG4gICAgYmdXSDoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgYWxsb3dQZXJjZW50OiB0cnVlLFxuICAgICAgZW51bXM6IFsnYXV0byddLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGJnUG9zOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBhbGxvd1BlcmNlbnQ6IHRydWUsXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgYmdSZWxhdGl2ZVRvOiB7XG4gICAgICBlbnVtczogWydpbm5lcicsICdpbmNsdWRlLXBhZGRpbmcnXSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBiZ1JlcGVhdDoge1xuICAgICAgZW51bXM6IFsncmVwZWF0JywgJ3JlcGVhdC14JywgJ3JlcGVhdC15JywgJ25vLXJlcGVhdCddLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGJnRml0OiB7XG4gICAgICBlbnVtczogWydub25lJywgJ2NvbnRhaW4nLCAnY292ZXInXSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBiZ0Nyb3NzT3JpZ2luOiB7XG4gICAgICBlbnVtczogWydhbm9ueW1vdXMnLCAndXNlLWNyZWRlbnRpYWxzJywgJ251bGwnXSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBiZ0NsaXA6IHtcbiAgICAgIGVudW1zOiBbJ25vbmUnLCAnbm9kZSddLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGJnQ29udGFpbm1lbnQ6IHtcbiAgICAgIGVudW1zOiBbJ2luc2lkZScsICdvdmVyJ10sXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgY29sb3I6IHtcbiAgICAgIGNvbG9yOiB0cnVlXG4gICAgfSxcbiAgICBjb2xvcnM6IHtcbiAgICAgIGNvbG9yOiB0cnVlLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGZpbGw6IHtcbiAgICAgIGVudW1zOiBbJ3NvbGlkJywgJ2xpbmVhci1ncmFkaWVudCcsICdyYWRpYWwtZ3JhZGllbnQnXVxuICAgIH0sXG4gICAgYm9vbDoge1xuICAgICAgZW51bXM6IFsneWVzJywgJ25vJ11cbiAgICB9LFxuICAgIGJvb2xzOiB7XG4gICAgICBlbnVtczogWyd5ZXMnLCAnbm8nXSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBsaW5lU3R5bGU6IHtcbiAgICAgIGVudW1zOiBbJ3NvbGlkJywgJ2RvdHRlZCcsICdkYXNoZWQnXVxuICAgIH0sXG4gICAgbGluZUNhcDoge1xuICAgICAgZW51bXM6IFsnYnV0dCcsICdyb3VuZCcsICdzcXVhcmUnXVxuICAgIH0sXG4gICAgYm9yZGVyU3R5bGU6IHtcbiAgICAgIGVudW1zOiBbJ3NvbGlkJywgJ2RvdHRlZCcsICdkYXNoZWQnLCAnZG91YmxlJ11cbiAgICB9LFxuICAgIGN1cnZlU3R5bGU6IHtcbiAgICAgIGVudW1zOiBbJ2JlemllcicsICd1bmJ1bmRsZWQtYmV6aWVyJywgJ2hheXN0YWNrJywgJ3NlZ21lbnRzJywgJ3N0cmFpZ2h0JywgJ3N0cmFpZ2h0LXRyaWFuZ2xlJywgJ3RheGknXVxuICAgIH0sXG4gICAgZm9udEZhbWlseToge1xuICAgICAgcmVnZXg6ICdeKFtcXFxcdy0gXFxcXFwiXSsoPzpcXFxccyosXFxcXHMqW1xcXFx3LSBcXFxcXCJdKykqKSQnXG4gICAgfSxcbiAgICBmb250U3R5bGU6IHtcbiAgICAgIGVudW1zOiBbJ2l0YWxpYycsICdub3JtYWwnLCAnb2JsaXF1ZSddXG4gICAgfSxcbiAgICBmb250V2VpZ2h0OiB7XG4gICAgICBlbnVtczogWydub3JtYWwnLCAnYm9sZCcsICdib2xkZXInLCAnbGlnaHRlcicsICcxMDAnLCAnMjAwJywgJzMwMCcsICc0MDAnLCAnNTAwJywgJzYwMCcsICc4MDAnLCAnOTAwJywgMTAwLCAyMDAsIDMwMCwgNDAwLCA1MDAsIDYwMCwgNzAwLCA4MDAsIDkwMF1cbiAgICB9LFxuICAgIHRleHREZWNvcmF0aW9uOiB7XG4gICAgICBlbnVtczogWydub25lJywgJ3VuZGVybGluZScsICdvdmVybGluZScsICdsaW5lLXRocm91Z2gnXVxuICAgIH0sXG4gICAgdGV4dFRyYW5zZm9ybToge1xuICAgICAgZW51bXM6IFsnbm9uZScsICd1cHBlcmNhc2UnLCAnbG93ZXJjYXNlJ11cbiAgICB9LFxuICAgIHRleHRXcmFwOiB7XG4gICAgICBlbnVtczogWydub25lJywgJ3dyYXAnLCAnZWxsaXBzaXMnXVxuICAgIH0sXG4gICAgdGV4dE92ZXJmbG93V3JhcDoge1xuICAgICAgZW51bXM6IFsnd2hpdGVzcGFjZScsICdhbnl3aGVyZSddXG4gICAgfSxcbiAgICB0ZXh0QmFja2dyb3VuZFNoYXBlOiB7XG4gICAgICBlbnVtczogWydyZWN0YW5nbGUnLCAncm91bmRyZWN0YW5nbGUnLCAncm91bmQtcmVjdGFuZ2xlJ11cbiAgICB9LFxuICAgIG5vZGVTaGFwZToge1xuICAgICAgZW51bXM6IFsncmVjdGFuZ2xlJywgJ3JvdW5kcmVjdGFuZ2xlJywgJ3JvdW5kLXJlY3RhbmdsZScsICdjdXRyZWN0YW5nbGUnLCAnY3V0LXJlY3RhbmdsZScsICdib3R0b21yb3VuZHJlY3RhbmdsZScsICdib3R0b20tcm91bmQtcmVjdGFuZ2xlJywgJ2JhcnJlbCcsICdlbGxpcHNlJywgJ3RyaWFuZ2xlJywgJ3JvdW5kLXRyaWFuZ2xlJywgJ3NxdWFyZScsICdwZW50YWdvbicsICdyb3VuZC1wZW50YWdvbicsICdoZXhhZ29uJywgJ3JvdW5kLWhleGFnb24nLCAnY29uY2F2ZWhleGFnb24nLCAnY29uY2F2ZS1oZXhhZ29uJywgJ2hlcHRhZ29uJywgJ3JvdW5kLWhlcHRhZ29uJywgJ29jdGFnb24nLCAncm91bmQtb2N0YWdvbicsICd0YWcnLCAncm91bmQtdGFnJywgJ3N0YXInLCAnZGlhbW9uZCcsICdyb3VuZC1kaWFtb25kJywgJ3ZlZScsICdyaG9tYm9pZCcsICdyaWdodC1yaG9tYm9pZCcsICdwb2x5Z29uJ11cbiAgICB9LFxuICAgIG92ZXJsYXlTaGFwZToge1xuICAgICAgZW51bXM6IFsncm91bmRyZWN0YW5nbGUnLCAncm91bmQtcmVjdGFuZ2xlJywgJ2VsbGlwc2UnXVxuICAgIH0sXG4gICAgY29tcG91bmRJbmNsdWRlTGFiZWxzOiB7XG4gICAgICBlbnVtczogWydpbmNsdWRlJywgJ2V4Y2x1ZGUnXVxuICAgIH0sXG4gICAgYXJyb3dTaGFwZToge1xuICAgICAgZW51bXM6IFsndGVlJywgJ3RyaWFuZ2xlJywgJ3RyaWFuZ2xlLXRlZScsICdjaXJjbGUtdHJpYW5nbGUnLCAndHJpYW5nbGUtY3Jvc3MnLCAndHJpYW5nbGUtYmFja2N1cnZlJywgJ3ZlZScsICdzcXVhcmUnLCAnY2lyY2xlJywgJ2RpYW1vbmQnLCAnY2hldnJvbicsICdub25lJ11cbiAgICB9LFxuICAgIGFycm93RmlsbDoge1xuICAgICAgZW51bXM6IFsnZmlsbGVkJywgJ2hvbGxvdyddXG4gICAgfSxcbiAgICBkaXNwbGF5OiB7XG4gICAgICBlbnVtczogWydlbGVtZW50JywgJ25vbmUnXVxuICAgIH0sXG4gICAgdmlzaWJpbGl0eToge1xuICAgICAgZW51bXM6IFsnaGlkZGVuJywgJ3Zpc2libGUnXVxuICAgIH0sXG4gICAgekNvbXBvdW5kRGVwdGg6IHtcbiAgICAgIGVudW1zOiBbJ2JvdHRvbScsICdvcnBoYW4nLCAnYXV0bycsICd0b3AnXVxuICAgIH0sXG4gICAgekluZGV4Q29tcGFyZToge1xuICAgICAgZW51bXM6IFsnYXV0bycsICdtYW51YWwnXVxuICAgIH0sXG4gICAgdmFsaWduOiB7XG4gICAgICBlbnVtczogWyd0b3AnLCAnY2VudGVyJywgJ2JvdHRvbSddXG4gICAgfSxcbiAgICBoYWxpZ246IHtcbiAgICAgIGVudW1zOiBbJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0J11cbiAgICB9LFxuICAgIGp1c3RpZmljYXRpb246IHtcbiAgICAgIGVudW1zOiBbJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0JywgJ2F1dG8nXVxuICAgIH0sXG4gICAgdGV4dDoge1xuICAgICAgc3RyaW5nOiB0cnVlXG4gICAgfSxcbiAgICBkYXRhOiB7XG4gICAgICBtYXBwaW5nOiB0cnVlLFxuICAgICAgcmVnZXg6IGRhdGEoJ2RhdGEnKVxuICAgIH0sXG4gICAgbGF5b3V0RGF0YToge1xuICAgICAgbWFwcGluZzogdHJ1ZSxcbiAgICAgIHJlZ2V4OiBkYXRhKCdsYXlvdXREYXRhJylcbiAgICB9LFxuICAgIHNjcmF0Y2g6IHtcbiAgICAgIG1hcHBpbmc6IHRydWUsXG4gICAgICByZWdleDogZGF0YSgnc2NyYXRjaCcpXG4gICAgfSxcbiAgICBtYXBEYXRhOiB7XG4gICAgICBtYXBwaW5nOiB0cnVlLFxuICAgICAgcmVnZXg6IG1hcERhdGEoJ21hcERhdGEnKVxuICAgIH0sXG4gICAgbWFwTGF5b3V0RGF0YToge1xuICAgICAgbWFwcGluZzogdHJ1ZSxcbiAgICAgIHJlZ2V4OiBtYXBEYXRhKCdtYXBMYXlvdXREYXRhJylcbiAgICB9LFxuICAgIG1hcFNjcmF0Y2g6IHtcbiAgICAgIG1hcHBpbmc6IHRydWUsXG4gICAgICByZWdleDogbWFwRGF0YSgnbWFwU2NyYXRjaCcpXG4gICAgfSxcbiAgICBmbjoge1xuICAgICAgbWFwcGluZzogdHJ1ZSxcbiAgICAgIGZuOiB0cnVlXG4gICAgfSxcbiAgICB1cmw6IHtcbiAgICAgIHJlZ2V4ZXM6IHVybFJlZ2V4ZXMsXG4gICAgICBzaW5nbGVSZWdleE1hdGNoVmFsdWU6IHRydWVcbiAgICB9LFxuICAgIHVybHM6IHtcbiAgICAgIHJlZ2V4ZXM6IHVybFJlZ2V4ZXMsXG4gICAgICBzaW5nbGVSZWdleE1hdGNoVmFsdWU6IHRydWUsXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgcHJvcExpc3Q6IHtcbiAgICAgIHByb3BMaXN0OiB0cnVlXG4gICAgfSxcbiAgICBhbmdsZToge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgdW5pdHM6ICdkZWd8cmFkJyxcbiAgICAgIGltcGxpY2l0VW5pdHM6ICdyYWQnXG4gICAgfSxcbiAgICB0ZXh0Um90YXRpb246IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIHVuaXRzOiAnZGVnfHJhZCcsXG4gICAgICBpbXBsaWNpdFVuaXRzOiAncmFkJyxcbiAgICAgIGVudW1zOiBbJ25vbmUnLCAnYXV0b3JvdGF0ZSddXG4gICAgfSxcbiAgICBwb2x5Z29uUG9pbnRMaXN0OiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgIGV2ZW5NdWx0aXBsZTogdHJ1ZSxcbiAgICAgIG1pbjogLTEsXG4gICAgICBtYXg6IDEsXG4gICAgICB1bml0bGVzczogdHJ1ZVxuICAgIH0sXG4gICAgZWRnZURpc3RhbmNlczoge1xuICAgICAgZW51bXM6IFsnaW50ZXJzZWN0aW9uJywgJ25vZGUtcG9zaXRpb24nXVxuICAgIH0sXG4gICAgZWRnZUVuZHBvaW50OiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgIHVuaXRzOiAnJXxweHxlbXxkZWd8cmFkJyxcbiAgICAgIGltcGxpY2l0VW5pdHM6ICdweCcsXG4gICAgICBlbnVtczogWydpbnNpZGUtdG8tbm9kZScsICdvdXRzaWRlLXRvLW5vZGUnLCAnb3V0c2lkZS10by1ub2RlLW9yLWxhYmVsJywgJ291dHNpZGUtdG8tbGluZScsICdvdXRzaWRlLXRvLWxpbmUtb3ItbGFiZWwnXSxcbiAgICAgIHNpbmdsZUVudW06IHRydWUsXG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUodmFsQXJyLCB1bml0c0Fycikge1xuICAgICAgICBzd2l0Y2ggKHZhbEFyci5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAvLyBjYW4gYmUgJSBvciBweCBvbmx5XG4gICAgICAgICAgICByZXR1cm4gdW5pdHNBcnJbMF0gIT09ICdkZWcnICYmIHVuaXRzQXJyWzBdICE9PSAncmFkJyAmJiB1bml0c0FyclsxXSAhPT0gJ2RlZycgJiYgdW5pdHNBcnJbMV0gIT09ICdyYWQnO1xuXG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgLy8gY2FuIGJlIGVudW0sIGRlZywgb3IgcmFkIG9ubHlcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcodmFsQXJyWzBdKSB8fCB1bml0c0FyclswXSA9PT0gJ2RlZycgfHwgdW5pdHNBcnJbMF0gPT09ICdyYWQnO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZWFzaW5nOiB7XG4gICAgICByZWdleGVzOiBbJ14oc3ByaW5nKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIkMSArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyJDEgKyAnKVxcXFxzKlxcXFwpJCcsICdeKGN1YmljLWJlemllcilcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyJDEgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciQxICsgJylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIkMSArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyJDEgKyAnKVxcXFxzKlxcXFwpJCddLFxuICAgICAgZW51bXM6IFsnbGluZWFyJywgJ2Vhc2UnLCAnZWFzZS1pbicsICdlYXNlLW91dCcsICdlYXNlLWluLW91dCcsICdlYXNlLWluLXNpbmUnLCAnZWFzZS1vdXQtc2luZScsICdlYXNlLWluLW91dC1zaW5lJywgJ2Vhc2UtaW4tcXVhZCcsICdlYXNlLW91dC1xdWFkJywgJ2Vhc2UtaW4tb3V0LXF1YWQnLCAnZWFzZS1pbi1jdWJpYycsICdlYXNlLW91dC1jdWJpYycsICdlYXNlLWluLW91dC1jdWJpYycsICdlYXNlLWluLXF1YXJ0JywgJ2Vhc2Utb3V0LXF1YXJ0JywgJ2Vhc2UtaW4tb3V0LXF1YXJ0JywgJ2Vhc2UtaW4tcXVpbnQnLCAnZWFzZS1vdXQtcXVpbnQnLCAnZWFzZS1pbi1vdXQtcXVpbnQnLCAnZWFzZS1pbi1leHBvJywgJ2Vhc2Utb3V0LWV4cG8nLCAnZWFzZS1pbi1vdXQtZXhwbycsICdlYXNlLWluLWNpcmMnLCAnZWFzZS1vdXQtY2lyYycsICdlYXNlLWluLW91dC1jaXJjJ11cbiAgICB9LFxuICAgIGdyYWRpZW50RGlyZWN0aW9uOiB7XG4gICAgICBlbnVtczogWyd0by1ib3R0b20nLCAndG8tdG9wJywgJ3RvLWxlZnQnLCAndG8tcmlnaHQnLCAndG8tYm90dG9tLXJpZ2h0JywgJ3RvLWJvdHRvbS1sZWZ0JywgJ3RvLXRvcC1yaWdodCcsICd0by10b3AtbGVmdCcsICd0by1yaWdodC1ib3R0b20nLCAndG8tbGVmdC1ib3R0b20nLCAndG8tcmlnaHQtdG9wJywgJ3RvLWxlZnQtdG9wJyAvLyBkaWZmZXJlbnQgb3JkZXJcbiAgICAgIF1cbiAgICB9LFxuICAgIGJvdW5kc0V4cGFuc2lvbjoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbXVsdGlwbGU6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUodmFsQXJyKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB2YWxBcnIubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbGVuZ3RoID09PSAxIHx8IGxlbmd0aCA9PT0gMiB8fCBsZW5ndGggPT09IDQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgZGlmZiA9IHtcbiAgICB6ZXJvTm9uWmVybzogZnVuY3Rpb24gemVyb05vblplcm8odmFsMSwgdmFsMikge1xuICAgICAgaWYgKCh2YWwxID09IG51bGwgfHwgdmFsMiA9PSBudWxsKSAmJiB2YWwxICE9PSB2YWwyKSB7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBudWxsIGNhc2VzIGNvdWxkIHJlcHJlc2VudCBhbnkgdmFsdWVcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbDEgPT0gMCAmJiB2YWwyICE9IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHZhbDEgIT0gMCAmJiB2YWwyID09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBhbnk6IGZ1bmN0aW9uIGFueSh2YWwxLCB2YWwyKSB7XG4gICAgICByZXR1cm4gdmFsMSAhPSB2YWwyO1xuICAgIH0sXG4gICAgZW1wdHlOb25FbXB0eTogZnVuY3Rpb24gZW1wdHlOb25FbXB0eShzdHIxLCBzdHIyKSB7XG4gICAgICB2YXIgZW1wdHkxID0gZW1wdHlTdHJpbmcoc3RyMSk7XG4gICAgICB2YXIgZW1wdHkyID0gZW1wdHlTdHJpbmcoc3RyMik7XG4gICAgICByZXR1cm4gZW1wdHkxICYmICFlbXB0eTIgfHwgIWVtcHR5MSAmJiBlbXB0eTI7XG4gICAgfVxuICB9OyAvLyBkZWZpbmUgdmlzdWFsIHN0eWxlIHByb3BlcnRpZXNcbiAgLy9cbiAgLy8gLSBuLmIuIGFkZGluZyBhIG5ldyBncm91cCBvZiBwcm9wcyBtYXkgcmVxdWlyZSB1cGRhdGVzIHRvIHVwZGF0ZVN0eWxlSGludHMoKVxuICAvLyAtIGFkZGluZyBuZXcgcHJvcHMgdG8gYW4gZXhpc3RpbmcgZ3JvdXAgZ2V0cyBoYW5kbGVkIGF1dG9tYXRpY2FsbHlcblxuICB2YXIgdCA9IHN0eWZuJDIudHlwZXM7XG4gIHZhciBtYWluTGFiZWwgPSBbe1xuICAgIG5hbWU6ICdsYWJlbCcsXG4gICAgdHlwZTogdC50ZXh0LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueSxcbiAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi5lbXB0eU5vbkVtcHR5XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1yb3RhdGlvbicsXG4gICAgdHlwZTogdC50ZXh0Um90YXRpb24sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1tYXJnaW4teCcsXG4gICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LW1hcmdpbi15JyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIHNvdXJjZUxhYmVsID0gW3tcbiAgICBuYW1lOiAnc291cmNlLWxhYmVsJyxcbiAgICB0eXBlOiB0LnRleHQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnc291cmNlLXRleHQtcm90YXRpb24nLFxuICAgIHR5cGU6IHQudGV4dFJvdGF0aW9uLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3NvdXJjZS10ZXh0LW1hcmdpbi14JyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3NvdXJjZS10ZXh0LW1hcmdpbi15JyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3NvdXJjZS10ZXh0LW9mZnNldCcsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIHRhcmdldExhYmVsID0gW3tcbiAgICBuYW1lOiAndGFyZ2V0LWxhYmVsJyxcbiAgICB0eXBlOiB0LnRleHQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGFyZ2V0LXRleHQtcm90YXRpb24nLFxuICAgIHR5cGU6IHQudGV4dFJvdGF0aW9uLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RhcmdldC10ZXh0LW1hcmdpbi14JyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RhcmdldC10ZXh0LW1hcmdpbi15JyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RhcmdldC10ZXh0LW9mZnNldCcsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIGxhYmVsRGltZW5zaW9ucyA9IFt7XG4gICAgbmFtZTogJ2ZvbnQtZmFtaWx5JyxcbiAgICB0eXBlOiB0LmZvbnRGYW1pbHksXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnZm9udC1zdHlsZScsXG4gICAgdHlwZTogdC5mb250U3R5bGUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnZm9udC13ZWlnaHQnLFxuICAgIHR5cGU6IHQuZm9udFdlaWdodCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdmb250LXNpemUnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LXRyYW5zZm9ybScsXG4gICAgdHlwZTogdC50ZXh0VHJhbnNmb3JtLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtd3JhcCcsXG4gICAgdHlwZTogdC50ZXh0V3JhcCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LW92ZXJmbG93LXdyYXAnLFxuICAgIHR5cGU6IHQudGV4dE92ZXJmbG93V3JhcCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LW1heC13aWR0aCcsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtb3V0bGluZS13aWR0aCcsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2xpbmUtaGVpZ2h0JyxcbiAgICB0eXBlOiB0LnBvc2l0aXZlTnVtYmVyLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIGNvbW1vbkxhYmVsID0gW3tcbiAgICBuYW1lOiAndGV4dC12YWxpZ24nLFxuICAgIHR5cGU6IHQudmFsaWduLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtaGFsaWduJyxcbiAgICB0eXBlOiB0LmhhbGlnbixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdjb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtb3V0bGluZS1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtb3V0bGluZS1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1iYWNrZ3JvdW5kLXBhZGRpbmcnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWJvcmRlci1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWJvcmRlci1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtYm9yZGVyLXdpZHRoJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1ib3JkZXItc3R5bGUnLFxuICAgIHR5cGU6IHQuYm9yZGVyU3R5bGUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1iYWNrZ3JvdW5kLXNoYXBlJyxcbiAgICB0eXBlOiB0LnRleHRCYWNrZ3JvdW5kU2hhcGUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1qdXN0aWZpY2F0aW9uJyxcbiAgICB0eXBlOiB0Lmp1c3RpZmljYXRpb25cbiAgfV07XG4gIHZhciBiZWhhdmlvciA9IFt7XG4gICAgbmFtZTogJ2V2ZW50cycsXG4gICAgdHlwZTogdC5ib29sXG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1ldmVudHMnLFxuICAgIHR5cGU6IHQuYm9vbFxuICB9XTtcbiAgdmFyIHZpc2liaWxpdHkgPSBbe1xuICAgIG5hbWU6ICdkaXNwbGF5JyxcbiAgICB0eXBlOiB0LmRpc3BsYXksXG4gICAgdHJpZ2dlcnNaT3JkZXI6IGRpZmYuYW55LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueSxcbiAgICB0cmlnZ2Vyc0JvdW5kc09mUGFyYWxsZWxCZXppZXJzOiB0cnVlXG4gIH0sIHtcbiAgICBuYW1lOiAndmlzaWJpbGl0eScsXG4gICAgdHlwZTogdC52aXNpYmlsaXR5LFxuICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ29wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlcixcbiAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi56ZXJvTm9uWmVyb1xuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAnbWluLXpvb21lZC1mb250LXNpemUnLFxuICAgIHR5cGU6IHQuc2l6ZVxuICB9LCB7XG4gICAgbmFtZTogJ3otY29tcG91bmQtZGVwdGgnLFxuICAgIHR5cGU6IHQuekNvbXBvdW5kRGVwdGgsXG4gICAgdHJpZ2dlcnNaT3JkZXI6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnei1pbmRleC1jb21wYXJlJyxcbiAgICB0eXBlOiB0LnpJbmRleENvbXBhcmUsXG4gICAgdHJpZ2dlcnNaT3JkZXI6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnei1pbmRleCcsXG4gICAgdHlwZTogdC5ub25OZWdhdGl2ZUludCxcbiAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi5hbnlcbiAgfV07XG4gIHZhciBvdmVybGF5ID0gW3tcbiAgICBuYW1lOiAnb3ZlcmxheS1wYWRkaW5nJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnb3ZlcmxheS1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ292ZXJsYXktb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLnplcm9Ob25aZXJvXG4gIH0sIHtcbiAgICBuYW1lOiAnb3ZlcmxheS1zaGFwZScsXG4gICAgdHlwZTogdC5vdmVybGF5U2hhcGUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgdW5kZXJsYXkgPSBbe1xuICAgIG5hbWU6ICd1bmRlcmxheS1wYWRkaW5nJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndW5kZXJsYXktY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICd1bmRlcmxheS1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXIsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuemVyb05vblplcm9cbiAgfSwge1xuICAgIG5hbWU6ICd1bmRlcmxheS1zaGFwZScsXG4gICAgdHlwZTogdC5vdmVybGF5U2hhcGUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgdHJhbnNpdGlvbiA9IFt7XG4gICAgbmFtZTogJ3RyYW5zaXRpb24tcHJvcGVydHknLFxuICAgIHR5cGU6IHQucHJvcExpc3RcbiAgfSwge1xuICAgIG5hbWU6ICd0cmFuc2l0aW9uLWR1cmF0aW9uJyxcbiAgICB0eXBlOiB0LnRpbWVcbiAgfSwge1xuICAgIG5hbWU6ICd0cmFuc2l0aW9uLWRlbGF5JyxcbiAgICB0eXBlOiB0LnRpbWVcbiAgfSwge1xuICAgIG5hbWU6ICd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbicsXG4gICAgdHlwZTogdC5lYXNpbmdcbiAgfV07XG5cbiAgdmFyIG5vZGVTaXplSGFzaE92ZXJyaWRlID0gZnVuY3Rpb24gbm9kZVNpemVIYXNoT3ZlcnJpZGUoZWxlLCBwYXJzZWRQcm9wKSB7XG4gICAgaWYgKHBhcnNlZFByb3AudmFsdWUgPT09ICdsYWJlbCcpIHtcbiAgICAgIHJldHVybiAtZWxlLnBvb2xJbmRleCgpOyAvLyBubyBoYXNoIGtleSBoaXRzIGlzIHVzaW5nIGxhYmVsIHNpemUgKGhpdHJhdGUgZm9yIHBlcmYgcHJvYmFibHkgbG93IGFueXdheSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhcnNlZFByb3AucGZWYWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIG5vZGVCb2R5ID0gW3tcbiAgICBuYW1lOiAnaGVpZ2h0JyxcbiAgICB0eXBlOiB0Lm5vZGVTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueSxcbiAgICBoYXNoT3ZlcnJpZGU6IG5vZGVTaXplSGFzaE92ZXJyaWRlXG4gIH0sIHtcbiAgICBuYW1lOiAnd2lkdGgnLFxuICAgIHR5cGU6IHQubm9kZVNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55LFxuICAgIGhhc2hPdmVycmlkZTogbm9kZVNpemVIYXNoT3ZlcnJpZGVcbiAgfSwge1xuICAgIG5hbWU6ICdzaGFwZScsXG4gICAgdHlwZTogdC5ub2RlU2hhcGUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnc2hhcGUtcG9seWdvbi1wb2ludHMnLFxuICAgIHR5cGU6IHQucG9seWdvblBvaW50TGlzdCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1maWxsJyxcbiAgICB0eXBlOiB0LmZpbGxcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtYmxhY2tlbicsXG4gICAgdHlwZTogdC5uT25lT25lTnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1ncmFkaWVudC1zdG9wLWNvbG9ycycsXG4gICAgdHlwZTogdC5jb2xvcnNcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWdyYWRpZW50LXN0b3AtcG9zaXRpb25zJyxcbiAgICB0eXBlOiB0LnBlcmNlbnRhZ2VzXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1ncmFkaWVudC1kaXJlY3Rpb24nLFxuICAgIHR5cGU6IHQuZ3JhZGllbnREaXJlY3Rpb25cbiAgfSwge1xuICAgIG5hbWU6ICdwYWRkaW5nJyxcbiAgICB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAncGFkZGluZy1yZWxhdGl2ZS10bycsXG4gICAgdHlwZTogdC5wYWRkaW5nUmVsYXRpdmVUbyxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdib3VuZHMtZXhwYW5zaW9uJyxcbiAgICB0eXBlOiB0LmJvdW5kc0V4cGFuc2lvbixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfV07XG4gIHZhciBub2RlQm9yZGVyID0gW3tcbiAgICBuYW1lOiAnYm9yZGVyLWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnYm9yZGVyLW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ2JvcmRlci13aWR0aCcsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2JvcmRlci1zdHlsZScsXG4gICAgdHlwZTogdC5ib3JkZXJTdHlsZVxuICB9XTtcbiAgdmFyIGJhY2tncm91bmRJbWFnZSA9IFt7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtaW1hZ2UnLFxuICAgIHR5cGU6IHQudXJsc1xuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtaW1hZ2UtY3Jvc3NvcmlnaW4nLFxuICAgIHR5cGU6IHQuYmdDcm9zc09yaWdpblxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtaW1hZ2Utb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyc1xuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtaW1hZ2UtY29udGFpbm1lbnQnLFxuICAgIHR5cGU6IHQuYmdDb250YWlubWVudFxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtaW1hZ2Utc21vb3RoaW5nJyxcbiAgICB0eXBlOiB0LmJvb2xzXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1wb3NpdGlvbi14JyxcbiAgICB0eXBlOiB0LmJnUG9zXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1wb3NpdGlvbi15JyxcbiAgICB0eXBlOiB0LmJnUG9zXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC13aWR0aC1yZWxhdGl2ZS10bycsXG4gICAgdHlwZTogdC5iZ1JlbGF0aXZlVG9cbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWhlaWdodC1yZWxhdGl2ZS10bycsXG4gICAgdHlwZTogdC5iZ1JlbGF0aXZlVG9cbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLXJlcGVhdCcsXG4gICAgdHlwZTogdC5iZ1JlcGVhdFxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtZml0JyxcbiAgICB0eXBlOiB0LmJnRml0XG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1jbGlwJyxcbiAgICB0eXBlOiB0LmJnQ2xpcFxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtd2lkdGgnLFxuICAgIHR5cGU6IHQuYmdXSFxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtaGVpZ2h0JyxcbiAgICB0eXBlOiB0LmJnV0hcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLW9mZnNldC14JyxcbiAgICB0eXBlOiB0LmJnUG9zXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1vZmZzZXQteScsXG4gICAgdHlwZTogdC5iZ1Bvc1xuICB9XTtcbiAgdmFyIGNvbXBvdW5kID0gW3tcbiAgICBuYW1lOiAncG9zaXRpb24nLFxuICAgIHR5cGU6IHQucG9zaXRpb24sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnY29tcG91bmQtc2l6aW5nLXdydC1sYWJlbHMnLFxuICAgIHR5cGU6IHQuY29tcG91bmRJbmNsdWRlTGFiZWxzLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ21pbi13aWR0aCcsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ21pbi13aWR0aC1iaWFzLWxlZnQnLFxuICAgIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdtaW4td2lkdGgtYmlhcy1yaWdodCcsXG4gICAgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ21pbi1oZWlnaHQnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdtaW4taGVpZ2h0LWJpYXMtdG9wJyxcbiAgICB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnbWluLWhlaWdodC1iaWFzLWJvdHRvbScsXG4gICAgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIGVkZ2VMaW5lID0gW3tcbiAgICBuYW1lOiAnbGluZS1zdHlsZScsXG4gICAgdHlwZTogdC5saW5lU3R5bGVcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lLWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZS1maWxsJyxcbiAgICB0eXBlOiB0LmZpbGxcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lLWNhcCcsXG4gICAgdHlwZTogdC5saW5lQ2FwXG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZS1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lLWRhc2gtcGF0dGVybicsXG4gICAgdHlwZTogdC5udW1iZXJzXG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZS1kYXNoLW9mZnNldCcsXG4gICAgdHlwZTogdC5udW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lLWdyYWRpZW50LXN0b3AtY29sb3JzJyxcbiAgICB0eXBlOiB0LmNvbG9yc1xuICB9LCB7XG4gICAgbmFtZTogJ2xpbmUtZ3JhZGllbnQtc3RvcC1wb3NpdGlvbnMnLFxuICAgIHR5cGU6IHQucGVyY2VudGFnZXNcbiAgfSwge1xuICAgIG5hbWU6ICdjdXJ2ZS1zdHlsZScsXG4gICAgdHlwZTogdC5jdXJ2ZVN0eWxlLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueSxcbiAgICB0cmlnZ2Vyc0JvdW5kc09mUGFyYWxsZWxCZXppZXJzOiB0cnVlXG4gIH0sIHtcbiAgICBuYW1lOiAnaGF5c3RhY2stcmFkaXVzJyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXIsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnc291cmNlLWVuZHBvaW50JyxcbiAgICB0eXBlOiB0LmVkZ2VFbmRwb2ludCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0YXJnZXQtZW5kcG9pbnQnLFxuICAgIHR5cGU6IHQuZWRnZUVuZHBvaW50LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnY29udHJvbC1wb2ludC1kaXN0YW5jZXMnLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemVzLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0cycsXG4gICAgdHlwZTogdC5udW1iZXJzLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3NlZ21lbnQtZGlzdGFuY2VzJyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplcyxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdzZWdtZW50LXdlaWdodHMnLFxuICAgIHR5cGU6IHQubnVtYmVycyxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0YXhpLXR1cm4nLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemVNYXliZVBlcmNlbnQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGF4aS10dXJuLW1pbi1kaXN0YW5jZScsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RheGktZGlyZWN0aW9uJyxcbiAgICB0eXBlOiB0LmF4aXNEaXJlY3Rpb24sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnZWRnZS1kaXN0YW5jZXMnLFxuICAgIHR5cGU6IHQuZWRnZURpc3RhbmNlcyxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdhcnJvdy1zY2FsZScsXG4gICAgdHlwZTogdC5wb3NpdGl2ZU51bWJlcixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdsb29wLWRpcmVjdGlvbicsXG4gICAgdHlwZTogdC5hbmdsZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdsb29wLXN3ZWVwJyxcbiAgICB0eXBlOiB0LmFuZ2xlLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3NvdXJjZS1kaXN0YW5jZS1mcm9tLW5vZGUnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0YXJnZXQtZGlzdGFuY2UtZnJvbS1ub2RlJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgZ2hvc3QgPSBbe1xuICAgIG5hbWU6ICdnaG9zdCcsXG4gICAgdHlwZTogdC5ib29sLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2dob3N0LW9mZnNldC14JyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2dob3N0LW9mZnNldC15JyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2dob3N0LW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9XTtcbiAgdmFyIGNvcmUgPSBbe1xuICAgIG5hbWU6ICdzZWxlY3Rpb24tYm94LWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnc2VsZWN0aW9uLWJveC1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLXdpZHRoJyxcbiAgICB0eXBlOiB0LnNpemVcbiAgfSwge1xuICAgIG5hbWU6ICdhY3RpdmUtYmctY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdhY3RpdmUtYmctb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAnYWN0aXZlLWJnLXNpemUnLFxuICAgIHR5cGU6IHQuc2l6ZVxuICB9LCB7XG4gICAgbmFtZTogJ291dHNpZGUtdGV4dHVyZS1iZy1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ291dHNpZGUtdGV4dHVyZS1iZy1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfV07IC8vIHBpZSBiYWNrZ3JvdW5kcyBmb3Igbm9kZXNcblxuICB2YXIgcGllID0gW107XG4gIHN0eWZuJDIucGllQmFja2dyb3VuZE4gPSAxNjsgLy8gYmVjYXVzZSB0aGUgcGllIHByb3BlcnRpZXMgYXJlIG51bWJlcmVkLCBnaXZlIGFjY2VzcyB0byBhIGNvbnN0YW50IE4gKGZvciByZW5kZXJlciB1c2UpXG5cbiAgcGllLnB1c2goe1xuICAgIG5hbWU6ICdwaWUtc2l6ZScsXG4gICAgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50XG4gIH0pO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IHN0eWZuJDIucGllQmFja2dyb3VuZE47IGkrKykge1xuICAgIHBpZS5wdXNoKHtcbiAgICAgIG5hbWU6ICdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtY29sb3InLFxuICAgICAgdHlwZTogdC5jb2xvclxuICAgIH0pO1xuICAgIHBpZS5wdXNoKHtcbiAgICAgIG5hbWU6ICdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtc2l6ZScsXG4gICAgICB0eXBlOiB0LnBlcmNlbnRcbiAgICB9KTtcbiAgICBwaWUucHVzaCh7XG4gICAgICBuYW1lOiAncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLW9wYWNpdHknLFxuICAgICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gICAgfSk7XG4gIH0gLy8gZWRnZSBhcnJvd3NcblxuXG4gIHZhciBlZGdlQXJyb3cgPSBbXTtcbiAgdmFyIGFycm93UHJlZml4ZXMgPSBzdHlmbiQyLmFycm93UHJlZml4ZXMgPSBbJ3NvdXJjZScsICdtaWQtc291cmNlJywgJ3RhcmdldCcsICdtaWQtdGFyZ2V0J107XG4gIFt7XG4gICAgbmFtZTogJ2Fycm93LXNoYXBlJyxcbiAgICB0eXBlOiB0LmFycm93U2hhcGUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnYXJyb3ctY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdhcnJvdy1maWxsJyxcbiAgICB0eXBlOiB0LmFycm93RmlsbFxuICB9XS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgYXJyb3dQcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgIHZhciBuYW1lID0gcHJlZml4ICsgJy0nICsgcHJvcC5uYW1lO1xuICAgICAgdmFyIHR5cGUgPSBwcm9wLnR5cGUsXG4gICAgICAgICAgdHJpZ2dlcnNCb3VuZHMgPSBwcm9wLnRyaWdnZXJzQm91bmRzO1xuICAgICAgZWRnZUFycm93LnB1c2goe1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICB0cmlnZ2Vyc0JvdW5kczogdHJpZ2dlcnNCb3VuZHNcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCB7fSk7XG4gIHZhciBwcm9wcyA9IHN0eWZuJDIucHJvcGVydGllcyA9IFtdLmNvbmNhdChiZWhhdmlvciwgdHJhbnNpdGlvbiwgdmlzaWJpbGl0eSwgb3ZlcmxheSwgdW5kZXJsYXksIGdob3N0LCBjb21tb25MYWJlbCwgbGFiZWxEaW1lbnNpb25zLCBtYWluTGFiZWwsIHNvdXJjZUxhYmVsLCB0YXJnZXRMYWJlbCwgbm9kZUJvZHksIG5vZGVCb3JkZXIsIGJhY2tncm91bmRJbWFnZSwgcGllLCBjb21wb3VuZCwgZWRnZUxpbmUsIGVkZ2VBcnJvdywgY29yZSk7XG4gIHZhciBwcm9wR3JvdXBzID0gc3R5Zm4kMi5wcm9wZXJ0eUdyb3VwcyA9IHtcbiAgICAvLyBjb21tb24gdG8gYWxsIGVsZXNcbiAgICBiZWhhdmlvcjogYmVoYXZpb3IsXG4gICAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbixcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmlsaXR5LFxuICAgIG92ZXJsYXk6IG92ZXJsYXksXG4gICAgdW5kZXJsYXk6IHVuZGVybGF5LFxuICAgIGdob3N0OiBnaG9zdCxcbiAgICAvLyBsYWJlbHNcbiAgICBjb21tb25MYWJlbDogY29tbW9uTGFiZWwsXG4gICAgbGFiZWxEaW1lbnNpb25zOiBsYWJlbERpbWVuc2lvbnMsXG4gICAgbWFpbkxhYmVsOiBtYWluTGFiZWwsXG4gICAgc291cmNlTGFiZWw6IHNvdXJjZUxhYmVsLFxuICAgIHRhcmdldExhYmVsOiB0YXJnZXRMYWJlbCxcbiAgICAvLyBub2RlIHByb3BzXG4gICAgbm9kZUJvZHk6IG5vZGVCb2R5LFxuICAgIG5vZGVCb3JkZXI6IG5vZGVCb3JkZXIsXG4gICAgYmFja2dyb3VuZEltYWdlOiBiYWNrZ3JvdW5kSW1hZ2UsXG4gICAgcGllOiBwaWUsXG4gICAgY29tcG91bmQ6IGNvbXBvdW5kLFxuICAgIC8vIGVkZ2UgcHJvcHNcbiAgICBlZGdlTGluZTogZWRnZUxpbmUsXG4gICAgZWRnZUFycm93OiBlZGdlQXJyb3csXG4gICAgY29yZTogY29yZVxuICB9O1xuICB2YXIgcHJvcEdyb3VwTmFtZXMgPSBzdHlmbiQyLnByb3BlcnR5R3JvdXBOYW1lcyA9IHt9O1xuICB2YXIgcHJvcEdyb3VwS2V5cyA9IHN0eWZuJDIucHJvcGVydHlHcm91cEtleXMgPSBPYmplY3Qua2V5cyhwcm9wR3JvdXBzKTtcbiAgcHJvcEdyb3VwS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBwcm9wR3JvdXBOYW1lc1trZXldID0gcHJvcEdyb3Vwc1trZXldLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgcmV0dXJuIHByb3AubmFtZTtcbiAgICB9KTtcbiAgICBwcm9wR3JvdXBzW2tleV0uZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgcmV0dXJuIHByb3AuZ3JvdXBLZXkgPSBrZXk7XG4gICAgfSk7XG4gIH0pOyAvLyBkZWZpbmUgYWxpYXNlc1xuXG4gIHZhciBhbGlhc2VzID0gc3R5Zm4kMi5hbGlhc2VzID0gW3tcbiAgICBuYW1lOiAnY29udGVudCcsXG4gICAgcG9pbnRzVG86ICdsYWJlbCdcbiAgfSwge1xuICAgIG5hbWU6ICdjb250cm9sLXBvaW50LWRpc3RhbmNlJyxcbiAgICBwb2ludHNUbzogJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2VzJ1xuICB9LCB7XG4gICAgbmFtZTogJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0JyxcbiAgICBwb2ludHNUbzogJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0cydcbiAgfSwge1xuICAgIG5hbWU6ICdlZGdlLXRleHQtcm90YXRpb24nLFxuICAgIHBvaW50c1RvOiAndGV4dC1yb3RhdGlvbidcbiAgfSwge1xuICAgIG5hbWU6ICdwYWRkaW5nLWxlZnQnLFxuICAgIHBvaW50c1RvOiAncGFkZGluZydcbiAgfSwge1xuICAgIG5hbWU6ICdwYWRkaW5nLXJpZ2h0JyxcbiAgICBwb2ludHNUbzogJ3BhZGRpbmcnXG4gIH0sIHtcbiAgICBuYW1lOiAncGFkZGluZy10b3AnLFxuICAgIHBvaW50c1RvOiAncGFkZGluZydcbiAgfSwge1xuICAgIG5hbWU6ICdwYWRkaW5nLWJvdHRvbScsXG4gICAgcG9pbnRzVG86ICdwYWRkaW5nJ1xuICB9XTsgLy8gbGlzdCBvZiBwcm9wZXJ0eSBuYW1lc1xuXG4gIHN0eWZuJDIucHJvcGVydHlOYW1lcyA9IHByb3BzLm1hcChmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwLm5hbWU7XG4gIH0pOyAvLyBhbGxvdyBhY2Nlc3Mgb2YgcHJvcGVydGllcyBieSBuYW1lICggZS5nLiBzdHlsZS5wcm9wZXJ0aWVzLmhlaWdodCApXG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHByb3BzLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBwcm9wID0gcHJvcHNbX2ldO1xuICAgIHByb3BzW3Byb3AubmFtZV0gPSBwcm9wOyAvLyBhbGxvdyBsb29rdXAgYnkgbmFtZVxuICB9IC8vIG1hcCBhbGlhc2VzXG5cblxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBhbGlhc2VzLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgYWxpYXMgPSBhbGlhc2VzW19pMl07XG4gICAgdmFyIHBvaW50c1RvUHJvcCA9IHByb3BzW2FsaWFzLnBvaW50c1RvXTtcbiAgICB2YXIgYWxpYXNQcm9wID0ge1xuICAgICAgbmFtZTogYWxpYXMubmFtZSxcbiAgICAgIGFsaWFzOiB0cnVlLFxuICAgICAgcG9pbnRzVG86IHBvaW50c1RvUHJvcFxuICAgIH07IC8vIGFkZCBhbGlhcyBwcm9wIGZvciBwYXJzaW5nXG5cbiAgICBwcm9wcy5wdXNoKGFsaWFzUHJvcCk7XG4gICAgcHJvcHNbYWxpYXMubmFtZV0gPSBhbGlhc1Byb3A7IC8vIGFsbG93IGxvb2t1cCBieSBuYW1lXG4gIH1cbn0pKCk7XG5cbnN0eWZuJDIuZ2V0RGVmYXVsdFByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoKVtuYW1lXTtcbn07XG5cbnN0eWZuJDIuZ2V0RGVmYXVsdFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgaWYgKF9wLmRlZmF1bHRQcm9wZXJ0aWVzICE9IG51bGwpIHtcbiAgICByZXR1cm4gX3AuZGVmYXVsdFByb3BlcnRpZXM7XG4gIH1cblxuICB2YXIgcmF3UHJvcHMgPSBleHRlbmQoe1xuICAgIC8vIGNvcmUgcHJvcHNcbiAgICAnc2VsZWN0aW9uLWJveC1jb2xvcic6ICcjZGRkJyxcbiAgICAnc2VsZWN0aW9uLWJveC1vcGFjaXR5JzogMC42NSxcbiAgICAnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InOiAnI2FhYScsXG4gICAgJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLXdpZHRoJzogMSxcbiAgICAnYWN0aXZlLWJnLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAnYWN0aXZlLWJnLW9wYWNpdHknOiAwLjE1LFxuICAgICdhY3RpdmUtYmctc2l6ZSc6IDMwLFxuICAgICdvdXRzaWRlLXRleHR1cmUtYmctY29sb3InOiAnIzAwMCcsXG4gICAgJ291dHNpZGUtdGV4dHVyZS1iZy1vcGFjaXR5JzogMC4xMjUsXG4gICAgLy8gY29tbW9uIG5vZGUvZWRnZSBwcm9wc1xuICAgICdldmVudHMnOiAneWVzJyxcbiAgICAndGV4dC1ldmVudHMnOiAnbm8nLFxuICAgICd0ZXh0LXZhbGlnbic6ICd0b3AnLFxuICAgICd0ZXh0LWhhbGlnbic6ICdjZW50ZXInLFxuICAgICd0ZXh0LWp1c3RpZmljYXRpb24nOiAnYXV0bycsXG4gICAgJ2xpbmUtaGVpZ2h0JzogMSxcbiAgICAnY29sb3InOiAnIzAwMCcsXG4gICAgJ3RleHQtb3V0bGluZS1jb2xvcic6ICcjMDAwJyxcbiAgICAndGV4dC1vdXRsaW5lLXdpZHRoJzogMCxcbiAgICAndGV4dC1vdXRsaW5lLW9wYWNpdHknOiAxLFxuICAgICd0ZXh0LW9wYWNpdHknOiAxLFxuICAgICd0ZXh0LWRlY29yYXRpb24nOiAnbm9uZScsXG4gICAgJ3RleHQtdHJhbnNmb3JtJzogJ25vbmUnLFxuICAgICd0ZXh0LXdyYXAnOiAnbm9uZScsXG4gICAgJ3RleHQtb3ZlcmZsb3ctd3JhcCc6ICd3aGl0ZXNwYWNlJyxcbiAgICAndGV4dC1tYXgtd2lkdGgnOiA5OTk5LFxuICAgICd0ZXh0LWJhY2tncm91bmQtY29sb3InOiAnIzAwMCcsXG4gICAgJ3RleHQtYmFja2dyb3VuZC1vcGFjaXR5JzogMCxcbiAgICAndGV4dC1iYWNrZ3JvdW5kLXNoYXBlJzogJ3JlY3RhbmdsZScsXG4gICAgJ3RleHQtYmFja2dyb3VuZC1wYWRkaW5nJzogMCxcbiAgICAndGV4dC1ib3JkZXItb3BhY2l0eSc6IDAsXG4gICAgJ3RleHQtYm9yZGVyLXdpZHRoJzogMCxcbiAgICAndGV4dC1ib3JkZXItc3R5bGUnOiAnc29saWQnLFxuICAgICd0ZXh0LWJvcmRlci1jb2xvcic6ICcjMDAwJyxcbiAgICAnZm9udC1mYW1pbHknOiAnSGVsdmV0aWNhIE5ldWUsIEhlbHZldGljYSwgc2Fucy1zZXJpZicsXG4gICAgJ2ZvbnQtc3R5bGUnOiAnbm9ybWFsJyxcbiAgICAnZm9udC13ZWlnaHQnOiAnbm9ybWFsJyxcbiAgICAnZm9udC1zaXplJzogMTYsXG4gICAgJ21pbi16b29tZWQtZm9udC1zaXplJzogMCxcbiAgICAndGV4dC1yb3RhdGlvbic6ICdub25lJyxcbiAgICAnc291cmNlLXRleHQtcm90YXRpb24nOiAnbm9uZScsXG4gICAgJ3RhcmdldC10ZXh0LXJvdGF0aW9uJzogJ25vbmUnLFxuICAgICd2aXNpYmlsaXR5JzogJ3Zpc2libGUnLFxuICAgICdkaXNwbGF5JzogJ2VsZW1lbnQnLFxuICAgICdvcGFjaXR5JzogMSxcbiAgICAnei1jb21wb3VuZC1kZXB0aCc6ICdhdXRvJyxcbiAgICAnei1pbmRleC1jb21wYXJlJzogJ2F1dG8nLFxuICAgICd6LWluZGV4JzogMCxcbiAgICAnbGFiZWwnOiAnJyxcbiAgICAndGV4dC1tYXJnaW4teCc6IDAsXG4gICAgJ3RleHQtbWFyZ2luLXknOiAwLFxuICAgICdzb3VyY2UtbGFiZWwnOiAnJyxcbiAgICAnc291cmNlLXRleHQtb2Zmc2V0JzogMCxcbiAgICAnc291cmNlLXRleHQtbWFyZ2luLXgnOiAwLFxuICAgICdzb3VyY2UtdGV4dC1tYXJnaW4teSc6IDAsXG4gICAgJ3RhcmdldC1sYWJlbCc6ICcnLFxuICAgICd0YXJnZXQtdGV4dC1vZmZzZXQnOiAwLFxuICAgICd0YXJnZXQtdGV4dC1tYXJnaW4teCc6IDAsXG4gICAgJ3RhcmdldC10ZXh0LW1hcmdpbi15JzogMCxcbiAgICAnb3ZlcmxheS1vcGFjaXR5JzogMCxcbiAgICAnb3ZlcmxheS1jb2xvcic6ICcjMDAwJyxcbiAgICAnb3ZlcmxheS1wYWRkaW5nJzogMTAsXG4gICAgJ292ZXJsYXktc2hhcGUnOiAncm91bmQtcmVjdGFuZ2xlJyxcbiAgICAndW5kZXJsYXktb3BhY2l0eSc6IDAsXG4gICAgJ3VuZGVybGF5LWNvbG9yJzogJyMwMDAnLFxuICAgICd1bmRlcmxheS1wYWRkaW5nJzogMTAsXG4gICAgJ3VuZGVybGF5LXNoYXBlJzogJ3JvdW5kLXJlY3RhbmdsZScsXG4gICAgJ3RyYW5zaXRpb24tcHJvcGVydHknOiAnbm9uZScsXG4gICAgJ3RyYW5zaXRpb24tZHVyYXRpb24nOiAwLFxuICAgICd0cmFuc2l0aW9uLWRlbGF5JzogMCxcbiAgICAndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nOiAnbGluZWFyJyxcbiAgICAvLyBub2RlIHByb3BzXG4gICAgJ2JhY2tncm91bmQtYmxhY2tlbic6IDAsXG4gICAgJ2JhY2tncm91bmQtY29sb3InOiAnIzk5OScsXG4gICAgJ2JhY2tncm91bmQtZmlsbCc6ICdzb2xpZCcsXG4gICAgJ2JhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgJ2JhY2tncm91bmQtaW1hZ2UnOiAnbm9uZScsXG4gICAgJ2JhY2tncm91bmQtaW1hZ2UtY3Jvc3NvcmlnaW4nOiAnYW5vbnltb3VzJyxcbiAgICAnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5JzogMSxcbiAgICAnYmFja2dyb3VuZC1pbWFnZS1jb250YWlubWVudCc6ICdpbnNpZGUnLFxuICAgICdiYWNrZ3JvdW5kLWltYWdlLXNtb290aGluZyc6ICd5ZXMnLFxuICAgICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnOiAnNTAlJyxcbiAgICAnYmFja2dyb3VuZC1wb3NpdGlvbi15JzogJzUwJScsXG4gICAgJ2JhY2tncm91bmQtb2Zmc2V0LXgnOiAwLFxuICAgICdiYWNrZ3JvdW5kLW9mZnNldC15JzogMCxcbiAgICAnYmFja2dyb3VuZC13aWR0aC1yZWxhdGl2ZS10byc6ICdpbmNsdWRlLXBhZGRpbmcnLFxuICAgICdiYWNrZ3JvdW5kLWhlaWdodC1yZWxhdGl2ZS10byc6ICdpbmNsdWRlLXBhZGRpbmcnLFxuICAgICdiYWNrZ3JvdW5kLXJlcGVhdCc6ICduby1yZXBlYXQnLFxuICAgICdiYWNrZ3JvdW5kLWZpdCc6ICdub25lJyxcbiAgICAnYmFja2dyb3VuZC1jbGlwJzogJ25vZGUnLFxuICAgICdiYWNrZ3JvdW5kLXdpZHRoJzogJ2F1dG8nLFxuICAgICdiYWNrZ3JvdW5kLWhlaWdodCc6ICdhdXRvJyxcbiAgICAnYm9yZGVyLWNvbG9yJzogJyMwMDAnLFxuICAgICdib3JkZXItb3BhY2l0eSc6IDEsXG4gICAgJ2JvcmRlci13aWR0aCc6IDAsXG4gICAgJ2JvcmRlci1zdHlsZSc6ICdzb2xpZCcsXG4gICAgJ2hlaWdodCc6IDMwLFxuICAgICd3aWR0aCc6IDMwLFxuICAgICdzaGFwZSc6ICdlbGxpcHNlJyxcbiAgICAnc2hhcGUtcG9seWdvbi1wb2ludHMnOiAnLTEsIC0xLCAgIDEsIC0xLCAgIDEsIDEsICAgLTEsIDEnLFxuICAgICdib3VuZHMtZXhwYW5zaW9uJzogMCxcbiAgICAvLyBub2RlIGdyYWRpZW50XG4gICAgJ2JhY2tncm91bmQtZ3JhZGllbnQtZGlyZWN0aW9uJzogJ3RvLWJvdHRvbScsXG4gICAgJ2JhY2tncm91bmQtZ3JhZGllbnQtc3RvcC1jb2xvcnMnOiAnIzk5OScsXG4gICAgJ2JhY2tncm91bmQtZ3JhZGllbnQtc3RvcC1wb3NpdGlvbnMnOiAnMCUnLFxuICAgIC8vIGdob3N0IHByb3BzXG4gICAgJ2dob3N0JzogJ25vJyxcbiAgICAnZ2hvc3Qtb2Zmc2V0LXknOiAwLFxuICAgICdnaG9zdC1vZmZzZXQteCc6IDAsXG4gICAgJ2dob3N0LW9wYWNpdHknOiAwLFxuICAgIC8vIGNvbXBvdW5kIHByb3BzXG4gICAgJ3BhZGRpbmcnOiAwLFxuICAgICdwYWRkaW5nLXJlbGF0aXZlLXRvJzogJ3dpZHRoJyxcbiAgICAncG9zaXRpb24nOiAnb3JpZ2luJyxcbiAgICAnY29tcG91bmQtc2l6aW5nLXdydC1sYWJlbHMnOiAnaW5jbHVkZScsXG4gICAgJ21pbi13aWR0aCc6IDAsXG4gICAgJ21pbi13aWR0aC1iaWFzLWxlZnQnOiAwLFxuICAgICdtaW4td2lkdGgtYmlhcy1yaWdodCc6IDAsXG4gICAgJ21pbi1oZWlnaHQnOiAwLFxuICAgICdtaW4taGVpZ2h0LWJpYXMtdG9wJzogMCxcbiAgICAnbWluLWhlaWdodC1iaWFzLWJvdHRvbSc6IDBcbiAgfSwge1xuICAgIC8vIG5vZGUgcGllIGJnXG4gICAgJ3BpZS1zaXplJzogJzEwMCUnXG4gIH0sIFt7XG4gICAgbmFtZTogJ3BpZS17e2l9fS1iYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICB2YWx1ZTogJ2JsYWNrJ1xuICB9LCB7XG4gICAgbmFtZTogJ3BpZS17e2l9fS1iYWNrZ3JvdW5kLXNpemUnLFxuICAgIHZhbHVlOiAnMCUnXG4gIH0sIHtcbiAgICBuYW1lOiAncGllLXt7aX19LWJhY2tncm91bmQtb3BhY2l0eScsXG4gICAgdmFsdWU6IDFcbiAgfV0ucmVkdWNlKGZ1bmN0aW9uIChjc3MsIHByb3ApIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBzdHlmbiQyLnBpZUJhY2tncm91bmROOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lLnJlcGxhY2UoJ3t7aX19JywgaSk7XG4gICAgICB2YXIgdmFsID0gcHJvcC52YWx1ZTtcbiAgICAgIGNzc1tuYW1lXSA9IHZhbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3NzO1xuICB9LCB7fSksIHtcbiAgICAvLyBlZGdlIHByb3BzXG4gICAgJ2xpbmUtc3R5bGUnOiAnc29saWQnLFxuICAgICdsaW5lLWNvbG9yJzogJyM5OTknLFxuICAgICdsaW5lLWZpbGwnOiAnc29saWQnLFxuICAgICdsaW5lLWNhcCc6ICdidXR0JyxcbiAgICAnbGluZS1vcGFjaXR5JzogMSxcbiAgICAnbGluZS1ncmFkaWVudC1zdG9wLWNvbG9ycyc6ICcjOTk5JyxcbiAgICAnbGluZS1ncmFkaWVudC1zdG9wLXBvc2l0aW9ucyc6ICcwJScsXG4gICAgJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJzogNDAsXG4gICAgJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0cyc6IDAuNSxcbiAgICAnc2VnbWVudC13ZWlnaHRzJzogMC41LFxuICAgICdzZWdtZW50LWRpc3RhbmNlcyc6IDIwLFxuICAgICd0YXhpLXR1cm4nOiAnNTAlJyxcbiAgICAndGF4aS10dXJuLW1pbi1kaXN0YW5jZSc6IDEwLFxuICAgICd0YXhpLWRpcmVjdGlvbic6ICdhdXRvJyxcbiAgICAnZWRnZS1kaXN0YW5jZXMnOiAnaW50ZXJzZWN0aW9uJyxcbiAgICAnY3VydmUtc3R5bGUnOiAnaGF5c3RhY2snLFxuICAgICdoYXlzdGFjay1yYWRpdXMnOiAwLFxuICAgICdhcnJvdy1zY2FsZSc6IDEsXG4gICAgJ2xvb3AtZGlyZWN0aW9uJzogJy00NWRlZycsXG4gICAgJ2xvb3Atc3dlZXAnOiAnLTkwZGVnJyxcbiAgICAnc291cmNlLWRpc3RhbmNlLWZyb20tbm9kZSc6IDAsXG4gICAgJ3RhcmdldC1kaXN0YW5jZS1mcm9tLW5vZGUnOiAwLFxuICAgICdzb3VyY2UtZW5kcG9pbnQnOiAnb3V0c2lkZS10by1ub2RlJyxcbiAgICAndGFyZ2V0LWVuZHBvaW50JzogJ291dHNpZGUtdG8tbm9kZScsXG4gICAgJ2xpbmUtZGFzaC1wYXR0ZXJuJzogWzYsIDNdLFxuICAgICdsaW5lLWRhc2gtb2Zmc2V0JzogMFxuICB9LCBbe1xuICAgIG5hbWU6ICdhcnJvdy1zaGFwZScsXG4gICAgdmFsdWU6ICdub25lJ1xuICB9LCB7XG4gICAgbmFtZTogJ2Fycm93LWNvbG9yJyxcbiAgICB2YWx1ZTogJyM5OTknXG4gIH0sIHtcbiAgICBuYW1lOiAnYXJyb3ctZmlsbCcsXG4gICAgdmFsdWU6ICdmaWxsZWQnXG4gIH1dLnJlZHVjZShmdW5jdGlvbiAoY3NzLCBwcm9wKSB7XG4gICAgc3R5Zm4kMi5hcnJvd1ByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgICAgdmFyIG5hbWUgPSBwcmVmaXggKyAnLScgKyBwcm9wLm5hbWU7XG4gICAgICB2YXIgdmFsID0gcHJvcC52YWx1ZTtcbiAgICAgIGNzc1tuYW1lXSA9IHZhbDtcbiAgICB9KTtcbiAgICByZXR1cm4gY3NzO1xuICB9LCB7fSkpO1xuICB2YXIgcGFyc2VkUHJvcHMgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzW2ldO1xuXG4gICAgaWYgKHByb3AucG9pbnRzVG8pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuICAgIHZhciB2YWwgPSByYXdQcm9wc1tuYW1lXTtcbiAgICB2YXIgcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgdmFsKTtcbiAgICBwYXJzZWRQcm9wc1tuYW1lXSA9IHBhcnNlZFByb3A7XG4gIH1cblxuICBfcC5kZWZhdWx0UHJvcGVydGllcyA9IHBhcnNlZFByb3BzO1xuICByZXR1cm4gX3AuZGVmYXVsdFByb3BlcnRpZXM7XG59O1xuXG5zdHlmbiQyLmFkZERlZmF1bHRTdHlsZXNoZWV0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlbGVjdG9yKCc6cGFyZW50JykuY3NzKHtcbiAgICAnc2hhcGUnOiAncmVjdGFuZ2xlJyxcbiAgICAncGFkZGluZyc6IDEwLFxuICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyNlZWUnLFxuICAgICdib3JkZXItY29sb3InOiAnI2NjYycsXG4gICAgJ2JvcmRlci13aWR0aCc6IDFcbiAgfSkuc2VsZWN0b3IoJ2VkZ2UnKS5jc3Moe1xuICAgICd3aWR0aCc6IDNcbiAgfSkuc2VsZWN0b3IoJzpsb29wJykuY3NzKHtcbiAgICAnY3VydmUtc3R5bGUnOiAnYmV6aWVyJ1xuICB9KS5zZWxlY3RvcignZWRnZTpjb21wb3VuZCcpLmNzcyh7XG4gICAgJ2N1cnZlLXN0eWxlJzogJ2JlemllcicsXG4gICAgJ3NvdXJjZS1lbmRwb2ludCc6ICdvdXRzaWRlLXRvLWxpbmUnLFxuICAgICd0YXJnZXQtZW5kcG9pbnQnOiAnb3V0c2lkZS10by1saW5lJ1xuICB9KS5zZWxlY3RvcignOnNlbGVjdGVkJykuY3NzKHtcbiAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjMDE2OUQ5JyxcbiAgICAnbGluZS1jb2xvcic6ICcjMDE2OUQ5JyxcbiAgICAnc291cmNlLWFycm93LWNvbG9yJzogJyMwMTY5RDknLFxuICAgICd0YXJnZXQtYXJyb3ctY29sb3InOiAnIzAxNjlEOScsXG4gICAgJ21pZC1zb3VyY2UtYXJyb3ctY29sb3InOiAnIzAxNjlEOScsXG4gICAgJ21pZC10YXJnZXQtYXJyb3ctY29sb3InOiAnIzAxNjlEOSdcbiAgfSkuc2VsZWN0b3IoJzpwYXJlbnQ6c2VsZWN0ZWQnKS5jc3Moe1xuICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyNDQ0UxRjknLFxuICAgICdib3JkZXItY29sb3InOiAnI2FlYzhlNSdcbiAgfSkuc2VsZWN0b3IoJzphY3RpdmUnKS5jc3Moe1xuICAgICdvdmVybGF5LWNvbG9yJzogJ2JsYWNrJyxcbiAgICAnb3ZlcmxheS1wYWRkaW5nJzogMTAsXG4gICAgJ292ZXJsYXktb3BhY2l0eSc6IDAuMjVcbiAgfSk7XG4gIHRoaXMuZGVmYXVsdExlbmd0aCA9IHRoaXMubGVuZ3RoO1xufTtcblxudmFyIHN0eWZuJDEgPSB7fTsgLy8gYSBjYWNoaW5nIGxheWVyIGZvciBwcm9wZXJ0eSBwYXJzaW5nXG5cbnN0eWZuJDEucGFyc2UgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCkge1xuICB2YXIgc2VsZiA9IHRoaXM7IC8vIGZ1bmN0aW9uIHZhbHVlcyBjYW4ndCBiZSBjYWNoZWQgaW4gYWxsIGNhc2VzLCBhbmQgdGhlcmUgaXNuJ3QgbXVjaCBiZW5lZml0IG9mIGNhY2hpbmcgdGhlbSBhbnl3YXlcblxuICBpZiAoZm4kNih2YWx1ZSkpIHtcbiAgICByZXR1cm4gc2VsZi5wYXJzZUltcGxXYXJuKG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQpO1xuICB9XG5cbiAgdmFyIGZsYXRLZXkgPSBwcm9wSXNGbGF0ID09PSAnbWFwcGluZycgfHwgcHJvcElzRmxhdCA9PT0gdHJ1ZSB8fCBwcm9wSXNGbGF0ID09PSBmYWxzZSB8fCBwcm9wSXNGbGF0ID09IG51bGwgPyAnZG9udGNhcmUnIDogcHJvcElzRmxhdDtcbiAgdmFyIGJ5cGFzc0tleSA9IHByb3BJc0J5cGFzcyA/ICd0JyA6ICdmJztcbiAgdmFyIHZhbHVlS2V5ID0gJycgKyB2YWx1ZTtcbiAgdmFyIGFyZ0hhc2ggPSBoYXNoU3RyaW5ncyhuYW1lLCB2YWx1ZUtleSwgYnlwYXNzS2V5LCBmbGF0S2V5KTtcbiAgdmFyIHByb3BDYWNoZSA9IHNlbGYucHJvcENhY2hlID0gc2VsZi5wcm9wQ2FjaGUgfHwgW107XG4gIHZhciByZXQ7XG5cbiAgaWYgKCEocmV0ID0gcHJvcENhY2hlW2FyZ0hhc2hdKSkge1xuICAgIHJldCA9IHByb3BDYWNoZVthcmdIYXNoXSA9IHNlbGYucGFyc2VJbXBsV2FybihuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0KTtcbiAgfSAvLyAtIGJ5cGFzc2VzIGNhbid0IGJlIHNoYXJlZCBiL2MgdGhlIHZhbHVlIGNhbiBiZSBjaGFuZ2VkIGJ5IGFuaW1hdGlvbnMgb3Igb3RoZXJ3aXNlIG92ZXJyaWRkZW5cbiAgLy8gLSBtYXBwaW5ncyBjYW4ndCBiZSBzaGFyZWQgYi9jIG1hcHBpbmdzIGFyZSBwZXItZWxlbWVudFxuXG5cbiAgaWYgKHByb3BJc0J5cGFzcyB8fCBwcm9wSXNGbGF0ID09PSAnbWFwcGluZycpIHtcbiAgICAvLyBuZWVkIGEgY29weSBzaW5jZSBwcm9wcyBhcmUgbXV0YXRlZCBsYXRlciBpbiB0aGVpciBsaWZlY3ljbGVzXG4gICAgcmV0ID0gY29weShyZXQpO1xuXG4gICAgaWYgKHJldCkge1xuICAgICAgcmV0LnZhbHVlID0gY29weShyZXQudmFsdWUpOyAvLyBiZWNhdXNlIGl0IGNvdWxkIGJlIGFuIGFycmF5LCBlLmcuIGNvbG91clxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5zdHlmbiQxLnBhcnNlSW1wbFdhcm4gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCkge1xuICB2YXIgcHJvcCA9IHRoaXMucGFyc2VJbXBsKG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQpO1xuXG4gIGlmICghcHJvcCAmJiB2YWx1ZSAhPSBudWxsKSB7XG4gICAgd2FybihcIlRoZSBzdHlsZSBwcm9wZXJ0eSBgXCIuY29uY2F0KG5hbWUsIFwiOiBcIikuY29uY2F0KHZhbHVlLCBcImAgaXMgaW52YWxpZFwiKSk7XG4gIH1cblxuICBpZiAocHJvcCAmJiAocHJvcC5uYW1lID09PSAnd2lkdGgnIHx8IHByb3AubmFtZSA9PT0gJ2hlaWdodCcpICYmIHZhbHVlID09PSAnbGFiZWwnKSB7XG4gICAgd2FybignVGhlIHN0eWxlIHZhbHVlIG9mIGBsYWJlbGAgaXMgZGVwcmVjYXRlZCBmb3IgYCcgKyBwcm9wLm5hbWUgKyAnYCcpO1xuICB9XG5cbiAgcmV0dXJuIHByb3A7XG59OyAvLyBwYXJzZSBhIHByb3BlcnR5OyByZXR1cm4gbnVsbCBvbiBpbnZhbGlkOyByZXR1cm4gcGFyc2VkIHByb3BlcnR5IG90aGVyd2lzZVxuLy8gZmllbGRzIDpcbi8vIC0gbmFtZSA6IHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eVxuLy8gLSB2YWx1ZSA6IHRoZSBwYXJzZWQsIG5hdGl2ZS10eXBlZCB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbi8vIC0gc3RyVmFsdWUgOiBhIHN0cmluZyB2YWx1ZSB0aGF0IHJlcHJlc2VudHMgdGhlIHByb3BlcnR5IHZhbHVlIGluIHZhbGlkIGNzc1xuLy8gLSBieXBhc3MgOiB0cnVlIGlmZiB0aGUgcHJvcGVydHkgaXMgYSBieXBhc3MgcHJvcGVydHlcblxuXG5zdHlmbiQxLnBhcnNlSW1wbCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0KSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgbmFtZSA9IGNhbWVsMmRhc2gobmFtZSk7IC8vIG1ha2Ugc3VyZSB0aGUgcHJvcGVydHkgbmFtZSBpcyBpbiBkYXNoIGZvcm0gKGUuZy4gJ3Byb3BlcnR5LW5hbWUnIG5vdCAncHJvcGVydHlOYW1lJylcblxuICB2YXIgcHJvcGVydHkgPSBzZWxmLnByb3BlcnRpZXNbbmFtZV07XG4gIHZhciBwYXNzZWRWYWx1ZSA9IHZhbHVlO1xuICB2YXIgdHlwZXMgPSBzZWxmLnR5cGVzO1xuXG4gIGlmICghcHJvcGVydHkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyByZXR1cm4gbnVsbCBvbiBwcm9wZXJ0eSBvZiB1bmtub3duIG5hbWVcblxuXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gY2FuJ3QgYXNzaWduIHVuZGVmaW5lZFxuICAvLyB0aGUgcHJvcGVydHkgbWF5IGJlIGFuIGFsaWFzXG5cblxuICBpZiAocHJvcGVydHkuYWxpYXMpIHtcbiAgICBwcm9wZXJ0eSA9IHByb3BlcnR5LnBvaW50c1RvO1xuICAgIG5hbWUgPSBwcm9wZXJ0eS5uYW1lO1xuICB9XG5cbiAgdmFyIHZhbHVlSXNTdHJpbmcgPSBzdHJpbmcodmFsdWUpO1xuXG4gIGlmICh2YWx1ZUlzU3RyaW5nKSB7XG4gICAgLy8gdHJpbSB0aGUgdmFsdWUgdG8gbWFrZSBwYXJzaW5nIGVhc2llclxuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBwcm9wZXJ0eS50eXBlO1xuXG4gIGlmICghdHlwZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIG5vIHR5cGUsIG5vIGx1Y2tcbiAgLy8gY2hlY2sgaWYgYnlwYXNzIGlzIG51bGwgb3IgZW1wdHkgc3RyaW5nIChpLmUuIGluZGljYXRpb24gdG8gZGVsZXRlIGJ5cGFzcyBwcm9wZXJ0eSlcblxuXG4gIGlmIChwcm9wSXNCeXBhc3MgJiYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gbnVsbCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGJ5cGFzczogdHJ1ZSxcbiAgICAgIGRlbGV0ZUJ5cGFzczogdHJ1ZVxuICAgIH07XG4gIH0gLy8gY2hlY2sgaWYgdmFsdWUgaXMgYSBmdW5jdGlvbiB1c2VkIGFzIGEgbWFwcGVyXG5cblxuICBpZiAoZm4kNih2YWx1ZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIHN0clZhbHVlOiAnZm4nLFxuICAgICAgbWFwcGVkOiB0eXBlcy5mbixcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcbiAgfSAvLyBjaGVjayBpZiB2YWx1ZSBpcyBtYXBwZWRcblxuXG4gIHZhciBkYXRhLCBtYXBEYXRhO1xuXG4gIGlmICghdmFsdWVJc1N0cmluZyB8fCBwcm9wSXNGbGF0IHx8IHZhbHVlLmxlbmd0aCA8IDcgfHwgdmFsdWVbMV0gIT09ICdhJykgOyBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPj0gNyAmJiB2YWx1ZVswXSA9PT0gJ2QnICYmIChkYXRhID0gbmV3IFJlZ0V4cCh0eXBlcy5kYXRhLnJlZ2V4KS5leGVjKHZhbHVlKSkpIHtcbiAgICBpZiAocHJvcElzQnlwYXNzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBtYXBwZXJzIG5vdCBhbGxvd2VkIGluIGJ5cGFzc1xuXG5cbiAgICB2YXIgbWFwcGVkID0gdHlwZXMuZGF0YTtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiBkYXRhLFxuICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICBtYXBwZWQ6IG1hcHBlZCxcbiAgICAgIGZpZWxkOiBkYXRhWzFdLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9O1xuICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA+PSAxMCAmJiB2YWx1ZVswXSA9PT0gJ20nICYmIChtYXBEYXRhID0gbmV3IFJlZ0V4cCh0eXBlcy5tYXBEYXRhLnJlZ2V4KS5leGVjKHZhbHVlKSkpIHtcbiAgICBpZiAocHJvcElzQnlwYXNzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBtYXBwZXJzIG5vdCBhbGxvd2VkIGluIGJ5cGFzc1xuXG5cbiAgICBpZiAodHlwZS5tdWx0aXBsZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gaW1wb3NzaWJsZSB0byBtYXAgdG8gbnVtXG5cblxuICAgIHZhciBfbWFwcGVkID0gdHlwZXMubWFwRGF0YTsgLy8gd2UgY2FuIG1hcCBvbmx5IGlmIHRoZSB0eXBlIGlzIGEgY29sb3VyIG9yIGEgbnVtYmVyXG5cbiAgICBpZiAoISh0eXBlLmNvbG9yIHx8IHR5cGUubnVtYmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZU1pbiA9IHRoaXMucGFyc2UobmFtZSwgbWFwRGF0YVs0XSk7IC8vIHBhcnNlIHRvIHZhbGlkYXRlXG5cbiAgICBpZiAoIXZhbHVlTWluIHx8IHZhbHVlTWluLm1hcHBlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gY2FuJ3QgYmUgaW52YWxpZCBvciBtYXBwZWRcblxuXG4gICAgdmFyIHZhbHVlTWF4ID0gdGhpcy5wYXJzZShuYW1lLCBtYXBEYXRhWzVdKTsgLy8gcGFyc2UgdG8gdmFsaWRhdGVcblxuICAgIGlmICghdmFsdWVNYXggfHwgdmFsdWVNYXgubWFwcGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBjYW4ndCBiZSBpbnZhbGlkIG9yIG1hcHBlZFxuICAgIC8vIGNoZWNrIGlmIHZhbHVlTWluIGFuZCB2YWx1ZU1heCBhcmUgdGhlIHNhbWVcblxuXG4gICAgaWYgKHZhbHVlTWluLnBmVmFsdWUgPT09IHZhbHVlTWF4LnBmVmFsdWUgfHwgdmFsdWVNaW4uc3RyVmFsdWUgPT09IHZhbHVlTWF4LnN0clZhbHVlKSB7XG4gICAgICB3YXJuKCdgJyArIG5hbWUgKyAnOiAnICsgdmFsdWUgKyAnYCBpcyBub3QgYSB2YWxpZCBtYXBwZXIgYmVjYXVzZSB0aGUgb3V0cHV0IHJhbmdlIGlzIHplcm87IGNvbnZlcnRpbmcgdG8gYCcgKyBuYW1lICsgJzogJyArIHZhbHVlTWluLnN0clZhbHVlICsgJ2AnKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlKG5hbWUsIHZhbHVlTWluLnN0clZhbHVlKTsgLy8gY2FuJ3QgbWFrZSBtdWNoIG9mIGEgbWFwcGVyIHdpdGhvdXQgYSByYW5nZVxuICAgIH0gZWxzZSBpZiAodHlwZS5jb2xvcikge1xuICAgICAgdmFyIGMxID0gdmFsdWVNaW4udmFsdWU7XG4gICAgICB2YXIgYzIgPSB2YWx1ZU1heC52YWx1ZTtcbiAgICAgIHZhciBzYW1lID0gYzFbMF0gPT09IGMyWzBdIC8vIHJlZFxuICAgICAgJiYgYzFbMV0gPT09IGMyWzFdIC8vIGdyZWVuXG4gICAgICAmJiBjMVsyXSA9PT0gYzJbMl0gLy8gYmx1ZVxuICAgICAgJiYgKCAvLyBvcHRpb25hbCBhbHBoYVxuICAgICAgYzFbM10gPT09IGMyWzNdIC8vIHNhbWUgYWxwaGEgb3V0cmlnaHRcbiAgICAgIHx8IChjMVszXSA9PSBudWxsIHx8IGMxWzNdID09PSAxIC8vIGZ1bGwgb3BhY2l0eSBmb3IgY29sb3VyIDE/XG4gICAgICApICYmIChjMlszXSA9PSBudWxsIHx8IGMyWzNdID09PSAxKSAvLyBmdWxsIG9wYWNpdHkgZm9yIGNvbG91ciAyP1xuICAgICAgKTtcblxuICAgICAgaWYgKHNhbWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBjYW4ndCBtYWtlIGEgbWFwcGVyIHdpdGhvdXQgYSByYW5nZVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogbWFwRGF0YSxcbiAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgbWFwcGVkOiBfbWFwcGVkLFxuICAgICAgZmllbGQ6IG1hcERhdGFbMV0sXG4gICAgICBmaWVsZE1pbjogcGFyc2VGbG9hdChtYXBEYXRhWzJdKSxcbiAgICAgIC8vIG1pbiAmIG1heCBhcmUgbnVtZXJpY1xuICAgICAgZmllbGRNYXg6IHBhcnNlRmxvYXQobWFwRGF0YVszXSksXG4gICAgICB2YWx1ZU1pbjogdmFsdWVNaW4udmFsdWUsXG4gICAgICB2YWx1ZU1heDogdmFsdWVNYXgudmFsdWUsXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG4gIH1cblxuICBpZiAodHlwZS5tdWx0aXBsZSAmJiBwcm9wSXNGbGF0ICE9PSAnbXVsdGlwbGUnKSB7XG4gICAgdmFyIHZhbHM7XG5cbiAgICBpZiAodmFsdWVJc1N0cmluZykge1xuICAgICAgdmFscyA9IHZhbHVlLnNwbGl0KC9cXHMrLyk7XG4gICAgfSBlbHNlIGlmIChhcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHMgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFscyA9IFt2YWx1ZV07XG4gICAgfVxuXG4gICAgaWYgKHR5cGUuZXZlbk11bHRpcGxlICYmIHZhbHMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHZhbEFyciA9IFtdO1xuICAgIHZhciB1bml0c0FyciA9IFtdO1xuICAgIHZhciBwZlZhbEFyciA9IFtdO1xuICAgIHZhciBzdHJWYWwgPSAnJztcbiAgICB2YXIgaGFzRW51bSA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHNlbGYucGFyc2UobmFtZSwgdmFsc1tpXSwgcHJvcElzQnlwYXNzLCAnbXVsdGlwbGUnKTtcbiAgICAgIGhhc0VudW0gPSBoYXNFbnVtIHx8IHN0cmluZyhwLnZhbHVlKTtcbiAgICAgIHZhbEFyci5wdXNoKHAudmFsdWUpO1xuICAgICAgcGZWYWxBcnIucHVzaChwLnBmVmFsdWUgIT0gbnVsbCA/IHAucGZWYWx1ZSA6IHAudmFsdWUpO1xuICAgICAgdW5pdHNBcnIucHVzaChwLnVuaXRzKTtcbiAgICAgIHN0clZhbCArPSAoaSA+IDAgPyAnICcgOiAnJykgKyBwLnN0clZhbHVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlLnZhbGlkYXRlICYmICF0eXBlLnZhbGlkYXRlKHZhbEFyciwgdW5pdHNBcnIpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodHlwZS5zaW5nbGVFbnVtICYmIGhhc0VudW0pIHtcbiAgICAgIGlmICh2YWxBcnIubGVuZ3RoID09PSAxICYmIHN0cmluZyh2YWxBcnJbMF0pKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB2YWx1ZTogdmFsQXJyWzBdLFxuICAgICAgICAgIHN0clZhbHVlOiB2YWxBcnJbMF0sXG4gICAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbEFycixcbiAgICAgIHBmVmFsdWU6IHBmVmFsQXJyLFxuICAgICAgc3RyVmFsdWU6IHN0clZhbCxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzLFxuICAgICAgdW5pdHM6IHVuaXRzQXJyXG4gICAgfTtcbiAgfSAvLyBzZXZlcmFsIHR5cGVzIGFsc28gYWxsb3cgZW51bXNcblxuXG4gIHZhciBjaGVja0VudW1zID0gZnVuY3Rpb24gY2hlY2tFbnVtcygpIHtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdHlwZS5lbnVtcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBlbiA9IHR5cGUuZW51bXNbX2ldO1xuXG4gICAgICBpZiAoZW4gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTsgLy8gY2hlY2sgdGhlIHR5cGUgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgb2JqZWN0XG5cblxuICBpZiAodHlwZS5udW1iZXIpIHtcbiAgICB2YXIgdW5pdHM7XG4gICAgdmFyIGltcGxpY2l0VW5pdHMgPSAncHgnOyAvLyBub3Qgc2V0ID0+IHB4XG5cbiAgICBpZiAodHlwZS51bml0cykge1xuICAgICAgLy8gdXNlIHNwZWNpZmllZCB1bml0cyBpZiBzZXRcbiAgICAgIHVuaXRzID0gdHlwZS51bml0cztcbiAgICB9XG5cbiAgICBpZiAodHlwZS5pbXBsaWNpdFVuaXRzKSB7XG4gICAgICBpbXBsaWNpdFVuaXRzID0gdHlwZS5pbXBsaWNpdFVuaXRzO1xuICAgIH1cblxuICAgIGlmICghdHlwZS51bml0bGVzcykge1xuICAgICAgaWYgKHZhbHVlSXNTdHJpbmcpIHtcbiAgICAgICAgdmFyIHVuaXRzUmVnZXggPSAncHh8ZW0nICsgKHR5cGUuYWxsb3dQZXJjZW50ID8gJ3xcXFxcJScgOiAnJyk7XG5cbiAgICAgICAgaWYgKHVuaXRzKSB7XG4gICAgICAgICAgdW5pdHNSZWdleCA9IHVuaXRzO1xuICAgICAgICB9IC8vIG9ubHkgYWxsb3cgZXhwbGljaXQgdW5pdHMgaWYgc28gc2V0XG5cblxuICAgICAgICB2YXIgbWF0Y2ggPSB2YWx1ZS5tYXRjaCgnXignICsgbnVtYmVyICsgJykoJyArIHVuaXRzUmVnZXggKyAnKT8nICsgJyQnKTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICB2YWx1ZSA9IG1hdGNoWzFdO1xuICAgICAgICAgIHVuaXRzID0gbWF0Y2hbMl0gfHwgaW1wbGljaXRVbml0cztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghdW5pdHMgfHwgdHlwZS5pbXBsaWNpdFVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gaW1wbGljaXRVbml0czsgLy8gaW1wbGljaXRseSBweCBpZiB1bnNwZWNpZmllZFxuICAgICAgfVxuICAgIH1cblxuICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7IC8vIGlmIG5vdCBhIG51bWJlciBhbmQgZW51bXMgbm90IGFsbG93ZWQsIHRoZW4gdGhlIHZhbHVlIGlzIGludmFsaWRcblxuICAgIGlmIChpc05hTih2YWx1ZSkgJiYgdHlwZS5lbnVtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIGNoZWNrIGlmIHRoaXMgbnVtYmVyIHR5cGUgYWxzbyBhY2NlcHRzIHNwZWNpYWwga2V5d29yZHMgaW4gcGxhY2Ugb2YgbnVtYmVyc1xuICAgIC8vIChpLmUuIGBsZWZ0YCwgYGF1dG9gLCBldGMpXG5cblxuICAgIGlmIChpc05hTih2YWx1ZSkgJiYgdHlwZS5lbnVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWx1ZSA9IHBhc3NlZFZhbHVlO1xuICAgICAgcmV0dXJuIGNoZWNrRW51bXMoKTtcbiAgICB9IC8vIGNoZWNrIGlmIHZhbHVlIG11c3QgYmUgYW4gaW50ZWdlclxuXG5cbiAgICBpZiAodHlwZS5pbnRlZ2VyICYmICFpbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBjaGVjayB2YWx1ZSBpcyB3aXRoaW4gcmFuZ2VcblxuXG4gICAgaWYgKHR5cGUubWluICE9PSB1bmRlZmluZWQgJiYgKHZhbHVlIDwgdHlwZS5taW4gfHwgdHlwZS5zdHJpY3RNaW4gJiYgdmFsdWUgPT09IHR5cGUubWluKSB8fCB0eXBlLm1heCAhPT0gdW5kZWZpbmVkICYmICh2YWx1ZSA+IHR5cGUubWF4IHx8IHR5cGUuc3RyaWN0TWF4ICYmIHZhbHVlID09PSB0eXBlLm1heCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciByZXQgPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUgKyAodW5pdHMgPyB1bml0cyA6ICcnKSxcbiAgICAgIHVuaXRzOiB1bml0cyxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTsgLy8gbm9ybWFsaXNlIHZhbHVlIGluIHBpeGVsc1xuXG4gICAgaWYgKHR5cGUudW5pdGxlc3MgfHwgdW5pdHMgIT09ICdweCcgJiYgdW5pdHMgIT09ICdlbScpIHtcbiAgICAgIHJldC5wZlZhbHVlID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldC5wZlZhbHVlID0gdW5pdHMgPT09ICdweCcgfHwgIXVuaXRzID8gdmFsdWUgOiB0aGlzLmdldEVtU2l6ZUluUGl4ZWxzKCkgKiB2YWx1ZTtcbiAgICB9IC8vIG5vcm1hbGlzZSB2YWx1ZSBpbiBtc1xuXG5cbiAgICBpZiAodW5pdHMgPT09ICdtcycgfHwgdW5pdHMgPT09ICdzJykge1xuICAgICAgcmV0LnBmVmFsdWUgPSB1bml0cyA9PT0gJ21zJyA/IHZhbHVlIDogMTAwMCAqIHZhbHVlO1xuICAgIH0gLy8gbm9ybWFsaXNlIHZhbHVlIGluIHJhZFxuXG5cbiAgICBpZiAodW5pdHMgPT09ICdkZWcnIHx8IHVuaXRzID09PSAncmFkJykge1xuICAgICAgcmV0LnBmVmFsdWUgPSB1bml0cyA9PT0gJ3JhZCcgPyB2YWx1ZSA6IGRlZzJyYWQodmFsdWUpO1xuICAgIH0gLy8gbm9ybWFsaXplIHZhbHVlIGluICVcblxuXG4gICAgaWYgKHVuaXRzID09PSAnJScpIHtcbiAgICAgIHJldC5wZlZhbHVlID0gdmFsdWUgLyAxMDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfSBlbHNlIGlmICh0eXBlLnByb3BMaXN0KSB7XG4gICAgdmFyIHByb3BzID0gW107XG4gICAgdmFyIHByb3BzU3RyID0gJycgKyB2YWx1ZTtcblxuICAgIGlmIChwcm9wc1N0ciA9PT0gJ25vbmUnKSA7IGVsc2Uge1xuICAgICAgLy8gZ28gb3ZlciBlYWNoIHByb3BcbiAgICAgIHZhciBwcm9wc1NwbGl0ID0gcHJvcHNTdHIuc3BsaXQoL1xccyosXFxzKnxcXHMrLyk7XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHByb3BzU3BsaXQubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wc1NwbGl0W19pMl0udHJpbSgpO1xuXG4gICAgICAgIGlmIChzZWxmLnByb3BlcnRpZXNbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgcHJvcHMucHVzaChwcm9wTmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybignYCcgKyBwcm9wTmFtZSArICdgIGlzIG5vdCBhIHZhbGlkIHByb3BlcnR5IG5hbWUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocHJvcHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHByb3BzLFxuICAgICAgc3RyVmFsdWU6IHByb3BzLmxlbmd0aCA9PT0gMCA/ICdub25lJyA6IHByb3BzLmpvaW4oJyAnKSxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlLmNvbG9yKSB7XG4gICAgdmFyIHR1cGxlID0gY29sb3IydHVwbGUodmFsdWUpO1xuXG4gICAgaWYgKCF0dXBsZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdHVwbGUsXG4gICAgICBwZlZhbHVlOiB0dXBsZSxcbiAgICAgIHN0clZhbHVlOiAncmdiKCcgKyB0dXBsZVswXSArICcsJyArIHR1cGxlWzFdICsgJywnICsgdHVwbGVbMl0gKyAnKScsXG4gICAgICAvLyBuLmIuIG5vIHNwYWNlcyBiL2Mgb2YgbXVsdGlwbGUgc3VwcG9ydFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGUucmVnZXggfHwgdHlwZS5yZWdleGVzKSB7XG4gICAgLy8gZmlyc3QgY2hlY2sgZW51bXNcbiAgICBpZiAodHlwZS5lbnVtcykge1xuICAgICAgdmFyIGVudW1Qcm9wID0gY2hlY2tFbnVtcygpO1xuXG4gICAgICBpZiAoZW51bVByb3ApIHtcbiAgICAgICAgcmV0dXJuIGVudW1Qcm9wO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZWdleGVzID0gdHlwZS5yZWdleGVzID8gdHlwZS5yZWdleGVzIDogW3R5cGUucmVnZXhdO1xuXG4gICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgcmVnZXhlcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4ZXNbX2kzXSk7IC8vIG1ha2UgYSByZWdleCBmcm9tIHRoZSB0eXBlIHN0cmluZ1xuXG4gICAgICB2YXIgbSA9IHJlZ2V4LmV4ZWModmFsdWUpO1xuXG4gICAgICBpZiAobSkge1xuICAgICAgICAvLyByZWdleCBtYXRjaGVzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB2YWx1ZTogdHlwZS5zaW5nbGVSZWdleE1hdGNoVmFsdWUgPyBtWzFdIDogbSxcbiAgICAgICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsOyAvLyBkaWRuJ3QgbWF0Y2ggYW55XG4gIH0gZWxzZSBpZiAodHlwZS5zdHJpbmcpIHtcbiAgICAvLyBqdXN0IHJldHVyblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlLmVudW1zKSB7XG4gICAgLy8gY2hlY2sgZW51bXMgbGFzdCBiZWNhdXNlIGl0J3MgYSBjb21ibyB0eXBlIGluIG90aGVyc1xuICAgIHJldHVybiBjaGVja0VudW1zKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7IC8vIG5vdCBhIHR5cGUgd2UgY2FuIGhhbmRsZVxuICB9XG59O1xuXG52YXIgU3R5bGUgPSBmdW5jdGlvbiBTdHlsZShjeSkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3R5bGUpKSB7XG4gICAgcmV0dXJuIG5ldyBTdHlsZShjeSk7XG4gIH1cblxuICBpZiAoIWNvcmUoY3kpKSB7XG4gICAgZXJyb3IoJ0Egc3R5bGUgbXVzdCBoYXZlIGEgY29yZSByZWZlcmVuY2UnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9wcml2YXRlID0ge1xuICAgIGN5OiBjeSxcbiAgICBjb3JlU3R5bGU6IHt9XG4gIH07XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5yZXNldFRvRGVmYXVsdCgpO1xufTtcblxudmFyIHN0eWZuID0gU3R5bGUucHJvdG90eXBlO1xuXG5zdHlmbi5pbnN0YW5jZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICdzdHlsZSc7XG59OyAvLyByZW1vdmUgYWxsIGNvbnRleHRzXG5cblxuc3R5Zm4uY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gIHZhciBjeSA9IF9wLmN5O1xuICB2YXIgZWxlcyA9IGN5LmVsZW1lbnRzKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpc1tpXSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgX3AuY29udGV4dFN0eWxlcyA9IHt9O1xuICBfcC5wcm9wRGlmZnMgPSB7fTtcbiAgdGhpcy5jbGVhbkVsZW1lbnRzKGVsZXMsIHRydWUpO1xuICBlbGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciBlbGVfcCA9IGVsZVswXS5fcHJpdmF0ZTtcbiAgICBlbGVfcC5zdHlsZURpcnR5ID0gdHJ1ZTtcbiAgICBlbGVfcC5hcHBsaWVkSW5pdFN0eWxlID0gZmFsc2U7XG4gIH0pO1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbnN0eWZuLnJlc2V0VG9EZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNsZWFyKCk7XG4gIHRoaXMuYWRkRGVmYXVsdFN0eWxlc2hlZXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59OyAvLyBidWlsZHMgYSBzdHlsZSBvYmplY3QgZm9yIHRoZSAnY29yZScgc2VsZWN0b3JcblxuXG5zdHlmbi5jb3JlID0gZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gIHJldHVybiB0aGlzLl9wcml2YXRlLmNvcmVTdHlsZVtwcm9wTmFtZV0gfHwgdGhpcy5nZXREZWZhdWx0UHJvcGVydHkocHJvcE5hbWUpO1xufTsgLy8gY3JlYXRlIGEgbmV3IGNvbnRleHQgZnJvbSB0aGUgc3BlY2lmaWVkIHNlbGVjdG9yIHN0cmluZyBhbmQgc3dpdGNoIHRvIHRoYXQgY29udGV4dFxuXG5cbnN0eWZuLnNlbGVjdG9yID0gZnVuY3Rpb24gKHNlbGVjdG9yU3RyKSB7XG4gIC8vICdjb3JlJyBpcyBhIHNwZWNpYWwgY2FzZSBhbmQgZG9lcyBub3QgbmVlZCBhIHNlbGVjdG9yXG4gIHZhciBzZWxlY3RvciA9IHNlbGVjdG9yU3RyID09PSAnY29yZScgPyBudWxsIDogbmV3IFNlbGVjdG9yKHNlbGVjdG9yU3RyKTtcbiAgdmFyIGkgPSB0aGlzLmxlbmd0aCsrOyAvLyBuZXcgY29udGV4dCBtZWFucyBuZXcgaW5kZXhcblxuICB0aGlzW2ldID0ge1xuICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICBwcm9wZXJ0aWVzOiBbXSxcbiAgICBtYXBwZWRQcm9wZXJ0aWVzOiBbXSxcbiAgICBpbmRleDogaVxuICB9O1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07IC8vIGFkZCBvbmUgb3IgbWFueSBjc3MgcnVsZXMgdG8gdGhlIGN1cnJlbnQgY29udGV4dFxuXG5cbnN0eWZuLmNzcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgbWFwID0gYXJnc1swXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1tpXTtcbiAgICAgIHZhciBtYXBWYWwgPSBtYXBbcHJvcC5uYW1lXTtcblxuICAgICAgaWYgKG1hcFZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1hcFZhbCA9IG1hcFtkYXNoMmNhbWVsKHByb3AubmFtZSldO1xuICAgICAgfVxuXG4gICAgICBpZiAobWFwVmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5jc3NSdWxlKHByb3AubmFtZSwgbWFwVmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICB0aGlzLmNzc1J1bGUoYXJnc1swXSwgYXJnc1sxXSk7XG4gIH0gLy8gZG8gbm90aGluZyBpZiBhcmdzIGFyZSBpbnZhbGlkXG5cblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbnN0eWZuLnN0eWxlID0gc3R5Zm4uY3NzOyAvLyBhZGQgYSBzaW5nbGUgY3NzIHJ1bGUgdG8gdGhlIGN1cnJlbnQgY29udGV4dFxuXG5zdHlmbi5jc3NSdWxlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIC8vIG5hbWUtdmFsdWUgcGFpclxuICB2YXIgcHJvcGVydHkgPSB0aGlzLnBhcnNlKG5hbWUsIHZhbHVlKTsgLy8gYWRkIHByb3BlcnR5IHRvIGN1cnJlbnQgY29udGV4dCBpZiB2YWxpZFxuXG4gIGlmIChwcm9wZXJ0eSkge1xuICAgIHZhciBpID0gdGhpcy5sZW5ndGggLSAxO1xuICAgIHRoaXNbaV0ucHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICB0aGlzW2ldLnByb3BlcnRpZXNbcHJvcGVydHkubmFtZV0gPSBwcm9wZXJ0eTsgLy8gYWxsb3cgYWNjZXNzIGJ5IG5hbWUgYXMgd2VsbFxuXG4gICAgaWYgKHByb3BlcnR5Lm5hbWUubWF0Y2goL3BpZS0oXFxkKyktYmFja2dyb3VuZC1zaXplLykgJiYgcHJvcGVydHkudmFsdWUpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuaGFzUGllID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvcGVydHkubWFwcGVkKSB7XG4gICAgICB0aGlzW2ldLm1hcHBlZFByb3BlcnRpZXMucHVzaChwcm9wZXJ0eSk7XG4gICAgfSAvLyBhZGQgdG8gY29yZSBzdHlsZSBpZiBuZWNlc3NhcnlcblxuXG4gICAgdmFyIGN1cnJlbnRTZWxlY3RvcklzQ29yZSA9ICF0aGlzW2ldLnNlbGVjdG9yO1xuXG4gICAgaWYgKGN1cnJlbnRTZWxlY3RvcklzQ29yZSkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5jb3JlU3R5bGVbcHJvcGVydHkubmFtZV0gPSBwcm9wZXJ0eTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbnN0eWZuLmFwcGVuZCA9IGZ1bmN0aW9uIChzdHlsZSkge1xuICBpZiAoc3R5bGVzaGVldChzdHlsZSkpIHtcbiAgICBzdHlsZS5hcHBlbmRUb1N0eWxlKHRoaXMpO1xuICB9IGVsc2UgaWYgKGFycmF5KHN0eWxlKSkge1xuICAgIHRoaXMuYXBwZW5kRnJvbUpzb24oc3R5bGUpO1xuICB9IGVsc2UgaWYgKHN0cmluZyhzdHlsZSkpIHtcbiAgICB0aGlzLmFwcGVuZEZyb21TdHJpbmcoc3R5bGUpO1xuICB9IC8vIHlvdSBwcm9iYWJseSB3b3VsZG4ndCB3YW50IHRvIGFwcGVuZCBhIFN0eWxlLCBzaW5jZSB5b3UnZCBkdXBsaWNhdGUgdGhlIGRlZmF1bHQgcGFydHNcblxuXG4gIHJldHVybiB0aGlzO1xufTsgLy8gc3RhdGljIGZ1bmN0aW9uXG5cblxuU3R5bGUuZnJvbUpzb24gPSBmdW5jdGlvbiAoY3ksIGpzb24pIHtcbiAgdmFyIHN0eWxlID0gbmV3IFN0eWxlKGN5KTtcbiAgc3R5bGUuZnJvbUpzb24oanNvbik7XG4gIHJldHVybiBzdHlsZTtcbn07XG5cblN0eWxlLmZyb21TdHJpbmcgPSBmdW5jdGlvbiAoY3ksIHN0cmluZykge1xuICByZXR1cm4gbmV3IFN0eWxlKGN5KS5mcm9tU3RyaW5nKHN0cmluZyk7XG59O1xuXG5bc3R5Zm4kOCwgc3R5Zm4kNywgc3R5Zm4kNiwgc3R5Zm4kNSwgc3R5Zm4kNCwgc3R5Zm4kMywgc3R5Zm4kMiwgc3R5Zm4kMV0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgZXh0ZW5kKHN0eWZuLCBwcm9wcyk7XG59KTtcblN0eWxlLnR5cGVzID0gc3R5Zm4udHlwZXM7XG5TdHlsZS5wcm9wZXJ0aWVzID0gc3R5Zm4ucHJvcGVydGllcztcblN0eWxlLnByb3BlcnR5R3JvdXBzID0gc3R5Zm4ucHJvcGVydHlHcm91cHM7XG5TdHlsZS5wcm9wZXJ0eUdyb3VwTmFtZXMgPSBzdHlmbi5wcm9wZXJ0eUdyb3VwTmFtZXM7XG5TdHlsZS5wcm9wZXJ0eUdyb3VwS2V5cyA9IHN0eWZuLnByb3BlcnR5R3JvdXBLZXlzO1xuXG52YXIgY29yZWZuJDIgPSB7XG4gIHN0eWxlOiBmdW5jdGlvbiBzdHlsZShuZXdTdHlsZSkge1xuICAgIGlmIChuZXdTdHlsZSkge1xuICAgICAgdmFyIHMgPSB0aGlzLnNldFN0eWxlKG5ld1N0eWxlKTtcbiAgICAgIHMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuc3R5bGU7XG4gIH0sXG4gIHNldFN0eWxlOiBmdW5jdGlvbiBzZXRTdHlsZShzdHlsZSkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiAoc3R5bGVzaGVldChzdHlsZSkpIHtcbiAgICAgIF9wLnN0eWxlID0gc3R5bGUuZ2VuZXJhdGVTdHlsZSh0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGFycmF5KHN0eWxlKSkge1xuICAgICAgX3Auc3R5bGUgPSBTdHlsZS5mcm9tSnNvbih0aGlzLCBzdHlsZSk7XG4gICAgfSBlbHNlIGlmIChzdHJpbmcoc3R5bGUpKSB7XG4gICAgICBfcC5zdHlsZSA9IFN0eWxlLmZyb21TdHJpbmcodGhpcywgc3R5bGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfcC5zdHlsZSA9IFN0eWxlKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcC5zdHlsZTtcbiAgfSxcbiAgLy8gZS5nLiBjeS5kYXRhKCkgY2hhbmdlZCA9PiByZWNhbGMgZWxlIG1hcHBlcnNcbiAgdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKCkge1xuICAgIHRoaXMubXV0YWJsZUVsZW1lbnRzKCkudXBkYXRlU3R5bGUoKTsgLy8ganVzdCBzZW5kIHRvIGFsbCBlbGVzXG4gIH1cbn07XG5cbnZhciBkZWZhdWx0U2VsZWN0aW9uVHlwZSA9ICdzaW5nbGUnO1xudmFyIGNvcmVmbiQxID0ge1xuICBhdXRvbG9jazogZnVuY3Rpb24gYXV0b2xvY2soYm9vbCkge1xuICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuYXV0b2xvY2sgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5hdXRvbG9jaztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgYXV0b3VuZ3JhYmlmeTogZnVuY3Rpb24gYXV0b3VuZ3JhYmlmeShib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5hdXRvdW5ncmFiaWZ5ID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYXV0b3VuZ3JhYmlmeTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgYXV0b3Vuc2VsZWN0aWZ5OiBmdW5jdGlvbiBhdXRvdW5zZWxlY3RpZnkoYm9vbCkge1xuICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuYXV0b3Vuc2VsZWN0aWZ5ID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYXV0b3Vuc2VsZWN0aWZ5O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICBzZWxlY3Rpb25UeXBlOiBmdW5jdGlvbiBzZWxlY3Rpb25UeXBlKHNlbFR5cGUpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgaWYgKF9wLnNlbGVjdGlvblR5cGUgPT0gbnVsbCkge1xuICAgICAgX3Auc2VsZWN0aW9uVHlwZSA9IGRlZmF1bHRTZWxlY3Rpb25UeXBlO1xuICAgIH1cblxuICAgIGlmIChzZWxUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChzZWxUeXBlID09PSAnYWRkaXRpdmUnIHx8IHNlbFR5cGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgIF9wLnNlbGVjdGlvblR5cGUgPSBzZWxUeXBlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX3Auc2VsZWN0aW9uVHlwZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcGFubmluZ0VuYWJsZWQ6IGZ1bmN0aW9uIHBhbm5pbmdFbmFibGVkKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHVzZXJQYW5uaW5nRW5hYmxlZDogZnVuY3Rpb24gdXNlclBhbm5pbmdFbmFibGVkKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLnVzZXJQYW5uaW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnVzZXJQYW5uaW5nRW5hYmxlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgem9vbWluZ0VuYWJsZWQ6IGZ1bmN0aW9uIHpvb21pbmdFbmFibGVkKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHVzZXJab29taW5nRW5hYmxlZDogZnVuY3Rpb24gdXNlclpvb21pbmdFbmFibGVkKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLnVzZXJab29taW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnVzZXJab29taW5nRW5hYmxlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgYm94U2VsZWN0aW9uRW5hYmxlZDogZnVuY3Rpb24gYm94U2VsZWN0aW9uRW5hYmxlZChib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5ib3hTZWxlY3Rpb25FbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYm94U2VsZWN0aW9uRW5hYmxlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgcGFuOiBmdW5jdGlvbiBwYW4oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHBhbiA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgIHZhciBkaW0sIHZhbCwgZGltcywgeCwgeTtcblxuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgLy8gLnBhbigpXG4gICAgICAgIHJldHVybiBwYW47XG5cbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaWYgKHN0cmluZyhhcmdzWzBdKSkge1xuICAgICAgICAgIC8vIC5wYW4oJ3gnKVxuICAgICAgICAgIGRpbSA9IGFyZ3NbMF07XG4gICAgICAgICAgcmV0dXJuIHBhbltkaW1dO1xuICAgICAgICB9IGVsc2UgaWYgKHBsYWluT2JqZWN0KGFyZ3NbMF0pKSB7XG4gICAgICAgICAgLy8gLnBhbih7IHg6IDAsIHk6IDEwMCB9KVxuICAgICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGltcyA9IGFyZ3NbMF07XG4gICAgICAgICAgeCA9IGRpbXMueDtcbiAgICAgICAgICB5ID0gZGltcy55O1xuXG4gICAgICAgICAgaWYgKG51bWJlciQxKHgpKSB7XG4gICAgICAgICAgICBwYW4ueCA9IHg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG51bWJlciQxKHkpKSB7XG4gICAgICAgICAgICBwYW4ueSA9IHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5lbWl0KCdwYW4gdmlld3BvcnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIC8vIC5wYW4oJ3gnLCAxMDApXG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgZGltID0gYXJnc1swXTtcbiAgICAgICAgdmFsID0gYXJnc1sxXTtcblxuICAgICAgICBpZiAoKGRpbSA9PT0gJ3gnIHx8IGRpbSA9PT0gJ3knKSAmJiBudW1iZXIkMSh2YWwpKSB7XG4gICAgICAgICAgcGFuW2RpbV0gPSB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXQoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIGludmFsaWRcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeSgndmlld3BvcnQnKTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgcGFuQnk6IGZ1bmN0aW9uIHBhbkJ5KGFyZzAsIGFyZzEpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgcGFuID0gdGhpcy5fcHJpdmF0ZS5wYW47XG4gICAgdmFyIGRpbSwgdmFsLCBkaW1zLCB4LCB5O1xuXG4gICAgaWYgKCF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGlmIChwbGFpbk9iamVjdChhcmcwKSkge1xuICAgICAgICAgIC8vIC5wYW5CeSh7IHg6IDAsIHk6IDEwMCB9KVxuICAgICAgICAgIGRpbXMgPSBhcmdzWzBdO1xuICAgICAgICAgIHggPSBkaW1zLng7XG4gICAgICAgICAgeSA9IGRpbXMueTtcblxuICAgICAgICAgIGlmIChudW1iZXIkMSh4KSkge1xuICAgICAgICAgICAgcGFuLnggKz0geDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobnVtYmVyJDEoeSkpIHtcbiAgICAgICAgICAgIHBhbi55ICs9IHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5lbWl0KCdwYW4gdmlld3BvcnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIC8vIC5wYW5CeSgneCcsIDEwMClcbiAgICAgICAgZGltID0gYXJnMDtcbiAgICAgICAgdmFsID0gYXJnMTtcblxuICAgICAgICBpZiAoKGRpbSA9PT0gJ3gnIHx8IGRpbSA9PT0gJ3knKSAmJiBudW1iZXIkMSh2YWwpKSB7XG4gICAgICAgICAgcGFuW2RpbV0gKz0gdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdwYW4gdmlld3BvcnQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBpbnZhbGlkXG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnkoJ3ZpZXdwb3J0Jyk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGZpdDogZnVuY3Rpb24gZml0KGVsZW1lbnRzLCBwYWRkaW5nKSB7XG4gICAgdmFyIHZpZXdwb3J0U3RhdGUgPSB0aGlzLmdldEZpdFZpZXdwb3J0KGVsZW1lbnRzLCBwYWRkaW5nKTtcblxuICAgIGlmICh2aWV3cG9ydFN0YXRlKSB7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgX3Auem9vbSA9IHZpZXdwb3J0U3RhdGUuem9vbTtcbiAgICAgIF9wLnBhbiA9IHZpZXdwb3J0U3RhdGUucGFuO1xuICAgICAgdGhpcy5lbWl0KCdwYW4gem9vbSB2aWV3cG9ydCcpO1xuICAgICAgdGhpcy5ub3RpZnkoJ3ZpZXdwb3J0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGdldEZpdFZpZXdwb3J0OiBmdW5jdGlvbiBnZXRGaXRWaWV3cG9ydChlbGVtZW50cywgcGFkZGluZykge1xuICAgIGlmIChudW1iZXIkMShlbGVtZW50cykgJiYgcGFkZGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBlbGVtZW50cyBpcyBvcHRpb25hbFxuICAgICAgcGFkZGluZyA9IGVsZW1lbnRzO1xuICAgICAgZWxlbWVudHMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkIHx8ICF0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJiO1xuXG4gICAgaWYgKHN0cmluZyhlbGVtZW50cykpIHtcbiAgICAgIHZhciBzZWwgPSBlbGVtZW50cztcbiAgICAgIGVsZW1lbnRzID0gdGhpcy4kKHNlbCk7XG4gICAgfSBlbHNlIGlmIChib3VuZGluZ0JveChlbGVtZW50cykpIHtcbiAgICAgIC8vIGFzc3VtZSBiYlxuICAgICAgdmFyIGJiZSA9IGVsZW1lbnRzO1xuICAgICAgYmIgPSB7XG4gICAgICAgIHgxOiBiYmUueDEsXG4gICAgICAgIHkxOiBiYmUueTEsXG4gICAgICAgIHgyOiBiYmUueDIsXG4gICAgICAgIHkyOiBiYmUueTJcbiAgICAgIH07XG4gICAgICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgICAgIGJiLmggPSBiYi55MiAtIGJiLnkxO1xuICAgIH0gZWxzZSBpZiAoIWVsZW1lbnRPckNvbGxlY3Rpb24oZWxlbWVudHMpKSB7XG4gICAgICBlbGVtZW50cyA9IHRoaXMubXV0YWJsZUVsZW1lbnRzKCk7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24oZWxlbWVudHMpICYmIGVsZW1lbnRzLmVtcHR5KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGNhbid0IGZpdCB0byBub3RoaW5nXG5cblxuICAgIGJiID0gYmIgfHwgZWxlbWVudHMuYm91bmRpbmdCb3goKTtcbiAgICB2YXIgdyA9IHRoaXMud2lkdGgoKTtcbiAgICB2YXIgaCA9IHRoaXMuaGVpZ2h0KCk7XG4gICAgdmFyIHpvb207XG4gICAgcGFkZGluZyA9IG51bWJlciQxKHBhZGRpbmcpID8gcGFkZGluZyA6IDA7XG5cbiAgICBpZiAoIWlzTmFOKHcpICYmICFpc05hTihoKSAmJiB3ID4gMCAmJiBoID4gMCAmJiAhaXNOYU4oYmIudykgJiYgIWlzTmFOKGJiLmgpICYmIGJiLncgPiAwICYmIGJiLmggPiAwKSB7XG4gICAgICB6b29tID0gTWF0aC5taW4oKHcgLSAyICogcGFkZGluZykgLyBiYi53LCAoaCAtIDIgKiBwYWRkaW5nKSAvIGJiLmgpOyAvLyBjcm9wIHpvb21cblxuICAgICAgem9vbSA9IHpvb20gPiB0aGlzLl9wcml2YXRlLm1heFpvb20gPyB0aGlzLl9wcml2YXRlLm1heFpvb20gOiB6b29tO1xuICAgICAgem9vbSA9IHpvb20gPCB0aGlzLl9wcml2YXRlLm1pblpvb20gPyB0aGlzLl9wcml2YXRlLm1pblpvb20gOiB6b29tO1xuICAgICAgdmFyIHBhbiA9IHtcbiAgICAgICAgLy8gbm93IHBhbiB0byBtaWRkbGVcbiAgICAgICAgeDogKHcgLSB6b29tICogKGJiLngxICsgYmIueDIpKSAvIDIsXG4gICAgICAgIHk6IChoIC0gem9vbSAqIChiYi55MSArIGJiLnkyKSkgLyAyXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgem9vbTogem9vbSxcbiAgICAgICAgcGFuOiBwYW5cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9LFxuICB6b29tUmFuZ2U6IGZ1bmN0aW9uIHpvb21SYW5nZShtaW4sIG1heCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIHZhciBvcHRzID0gbWluO1xuICAgICAgbWluID0gb3B0cy5taW47XG4gICAgICBtYXggPSBvcHRzLm1heDtcbiAgICB9XG5cbiAgICBpZiAobnVtYmVyJDEobWluKSAmJiBudW1iZXIkMShtYXgpICYmIG1pbiA8PSBtYXgpIHtcbiAgICAgIF9wLm1pblpvb20gPSBtaW47XG4gICAgICBfcC5tYXhab29tID0gbWF4O1xuICAgIH0gZWxzZSBpZiAobnVtYmVyJDEobWluKSAmJiBtYXggPT09IHVuZGVmaW5lZCAmJiBtaW4gPD0gX3AubWF4Wm9vbSkge1xuICAgICAgX3AubWluWm9vbSA9IG1pbjtcbiAgICB9IGVsc2UgaWYgKG51bWJlciQxKG1heCkgJiYgbWluID09PSB1bmRlZmluZWQgJiYgbWF4ID49IF9wLm1pblpvb20pIHtcbiAgICAgIF9wLm1heFpvb20gPSBtYXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG1pblpvb206IGZ1bmN0aW9uIG1pblpvb20oem9vbSkge1xuICAgIGlmICh6b29tID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLm1pblpvb207XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnpvb21SYW5nZSh7XG4gICAgICAgIG1pbjogem9vbVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBtYXhab29tOiBmdW5jdGlvbiBtYXhab29tKHpvb20pIHtcbiAgICBpZiAoem9vbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5tYXhab29tO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy56b29tUmFuZ2Uoe1xuICAgICAgICBtYXg6IHpvb21cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgZ2V0Wm9vbWVkVmlld3BvcnQ6IGZ1bmN0aW9uIGdldFpvb21lZFZpZXdwb3J0KHBhcmFtcykge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIGN1cnJlbnRQYW4gPSBfcC5wYW47XG4gICAgdmFyIGN1cnJlbnRab29tID0gX3Auem9vbTtcbiAgICB2YXIgcG9zOyAvLyBpbiByZW5kZXJlZCBweFxuXG4gICAgdmFyIHpvb207XG4gICAgdmFyIGJhaWwgPSBmYWxzZTtcblxuICAgIGlmICghX3Auem9vbWluZ0VuYWJsZWQpIHtcbiAgICAgIC8vIHpvb21pbmcgZGlzYWJsZWRcbiAgICAgIGJhaWwgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChudW1iZXIkMShwYXJhbXMpKSB7XG4gICAgICAvLyB0aGVuIHNldCB0aGUgem9vbVxuICAgICAgem9vbSA9IHBhcmFtcztcbiAgICB9IGVsc2UgaWYgKHBsYWluT2JqZWN0KHBhcmFtcykpIHtcbiAgICAgIC8vIHRoZW4gem9vbSBhYm91dCBhIHBvaW50XG4gICAgICB6b29tID0gcGFyYW1zLmxldmVsO1xuXG4gICAgICBpZiAocGFyYW1zLnBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgcG9zID0gbW9kZWxUb1JlbmRlcmVkUG9zaXRpb24ocGFyYW1zLnBvc2l0aW9uLCBjdXJyZW50Wm9vbSwgY3VycmVudFBhbik7XG4gICAgICB9IGVsc2UgaWYgKHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgcG9zID0gcGFyYW1zLnJlbmRlcmVkUG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3MgIT0gbnVsbCAmJiAhX3AucGFubmluZ0VuYWJsZWQpIHtcbiAgICAgICAgLy8gcGFubmluZyBkaXNhYmxlZFxuICAgICAgICBiYWlsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IC8vIGNyb3Agem9vbVxuXG5cbiAgICB6b29tID0gem9vbSA+IF9wLm1heFpvb20gPyBfcC5tYXhab29tIDogem9vbTtcbiAgICB6b29tID0gem9vbSA8IF9wLm1pblpvb20gPyBfcC5taW5ab29tIDogem9vbTsgLy8gY2FuJ3Qgem9vbSB3aXRoIGludmFsaWQgcGFyYW1zXG5cbiAgICBpZiAoYmFpbCB8fCAhbnVtYmVyJDEoem9vbSkgfHwgem9vbSA9PT0gY3VycmVudFpvb20gfHwgcG9zICE9IG51bGwgJiYgKCFudW1iZXIkMShwb3MueCkgfHwgIW51bWJlciQxKHBvcy55KSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChwb3MgIT0gbnVsbCkge1xuICAgICAgLy8gc2V0IHpvb20gYWJvdXQgcG9zaXRpb25cbiAgICAgIHZhciBwYW4xID0gY3VycmVudFBhbjtcbiAgICAgIHZhciB6b29tMSA9IGN1cnJlbnRab29tO1xuICAgICAgdmFyIHpvb20yID0gem9vbTtcbiAgICAgIHZhciBwYW4yID0ge1xuICAgICAgICB4OiAtem9vbTIgLyB6b29tMSAqIChwb3MueCAtIHBhbjEueCkgKyBwb3MueCxcbiAgICAgICAgeTogLXpvb20yIC8gem9vbTEgKiAocG9zLnkgLSBwYW4xLnkpICsgcG9zLnlcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB6b29tZWQ6IHRydWUsXG4gICAgICAgIHBhbm5lZDogdHJ1ZSxcbiAgICAgICAgem9vbTogem9vbTIsXG4gICAgICAgIHBhbjogcGFuMlxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8ganVzdCBzZXQgdGhlIHpvb21cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHpvb21lZDogdHJ1ZSxcbiAgICAgICAgcGFubmVkOiBmYWxzZSxcbiAgICAgICAgem9vbTogem9vbSxcbiAgICAgICAgcGFuOiBjdXJyZW50UGFuXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgem9vbTogZnVuY3Rpb24gem9vbShwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGdldFxuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuem9vbTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2V0XG4gICAgICB2YXIgdnAgPSB0aGlzLmdldFpvb21lZFZpZXdwb3J0KHBhcmFtcyk7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgICBpZiAodnAgPT0gbnVsbCB8fCAhdnAuem9vbWVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBfcC56b29tID0gdnAuem9vbTtcblxuICAgICAgaWYgKHZwLnBhbm5lZCkge1xuICAgICAgICBfcC5wYW4ueCA9IHZwLnBhbi54O1xuICAgICAgICBfcC5wYW4ueSA9IHZwLnBhbi55O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVtaXQoJ3pvb20nICsgKHZwLnBhbm5lZCA/ICcgcGFuJyA6ICcnKSArICcgdmlld3BvcnQnKTtcbiAgICAgIHRoaXMubm90aWZ5KCd2aWV3cG9ydCcpO1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfVxuICB9LFxuICB2aWV3cG9ydDogZnVuY3Rpb24gdmlld3BvcnQob3B0cykge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIHpvb21EZWZkID0gdHJ1ZTtcbiAgICB2YXIgcGFuRGVmZCA9IHRydWU7XG4gICAgdmFyIGV2ZW50cyA9IFtdOyAvLyB0byB0cmlnZ2VyXG5cbiAgICB2YXIgem9vbUZhaWxlZCA9IGZhbHNlO1xuICAgIHZhciBwYW5GYWlsZWQgPSBmYWxzZTtcblxuICAgIGlmICghb3B0cykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKCFudW1iZXIkMShvcHRzLnpvb20pKSB7XG4gICAgICB6b29tRGVmZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghcGxhaW5PYmplY3Qob3B0cy5wYW4pKSB7XG4gICAgICBwYW5EZWZkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF6b29tRGVmZCAmJiAhcGFuRGVmZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHpvb21EZWZkKSB7XG4gICAgICB2YXIgeiA9IG9wdHMuem9vbTtcblxuICAgICAgaWYgKHogPCBfcC5taW5ab29tIHx8IHogPiBfcC5tYXhab29tIHx8ICFfcC56b29taW5nRW5hYmxlZCkge1xuICAgICAgICB6b29tRmFpbGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9wLnpvb20gPSB6O1xuICAgICAgICBldmVudHMucHVzaCgnem9vbScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYW5EZWZkICYmICghem9vbUZhaWxlZCB8fCAhb3B0cy5jYW5jZWxPbkZhaWxlZFpvb20pICYmIF9wLnBhbm5pbmdFbmFibGVkKSB7XG4gICAgICB2YXIgcCA9IG9wdHMucGFuO1xuXG4gICAgICBpZiAobnVtYmVyJDEocC54KSkge1xuICAgICAgICBfcC5wYW4ueCA9IHAueDtcbiAgICAgICAgcGFuRmFpbGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChudW1iZXIkMShwLnkpKSB7XG4gICAgICAgIF9wLnBhbi55ID0gcC55O1xuICAgICAgICBwYW5GYWlsZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYW5GYWlsZWQpIHtcbiAgICAgICAgZXZlbnRzLnB1c2goJ3BhbicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChldmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgZXZlbnRzLnB1c2goJ3ZpZXdwb3J0Jyk7XG4gICAgICB0aGlzLmVtaXQoZXZlbnRzLmpvaW4oJyAnKSk7XG4gICAgICB0aGlzLm5vdGlmeSgndmlld3BvcnQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgY2VudGVyOiBmdW5jdGlvbiBjZW50ZXIoZWxlbWVudHMpIHtcbiAgICB2YXIgcGFuID0gdGhpcy5nZXRDZW50ZXJQYW4oZWxlbWVudHMpO1xuXG4gICAgaWYgKHBhbikge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5wYW4gPSBwYW47XG4gICAgICB0aGlzLmVtaXQoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgdGhpcy5ub3RpZnkoJ3ZpZXdwb3J0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGdldENlbnRlclBhbjogZnVuY3Rpb24gZ2V0Q2VudGVyUGFuKGVsZW1lbnRzLCB6b29tKSB7XG4gICAgaWYgKCF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHN0cmluZyhlbGVtZW50cykpIHtcbiAgICAgIHZhciBzZWxlY3RvciA9IGVsZW1lbnRzO1xuICAgICAgZWxlbWVudHMgPSB0aGlzLm11dGFibGVFbGVtZW50cygpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfSBlbHNlIGlmICghZWxlbWVudE9yQ29sbGVjdGlvbihlbGVtZW50cykpIHtcbiAgICAgIGVsZW1lbnRzID0gdGhpcy5tdXRhYmxlRWxlbWVudHMoKTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBjYW4ndCBjZW50cmUgcGFuIHRvIG5vdGhpbmdcblxuXG4gICAgdmFyIGJiID0gZWxlbWVudHMuYm91bmRpbmdCb3goKTtcbiAgICB2YXIgdyA9IHRoaXMud2lkdGgoKTtcbiAgICB2YXIgaCA9IHRoaXMuaGVpZ2h0KCk7XG4gICAgem9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3ByaXZhdGUuem9vbSA6IHpvb207XG4gICAgdmFyIHBhbiA9IHtcbiAgICAgIC8vIG1pZGRsZVxuICAgICAgeDogKHcgLSB6b29tICogKGJiLngxICsgYmIueDIpKSAvIDIsXG4gICAgICB5OiAoaCAtIHpvb20gKiAoYmIueTEgKyBiYi55MikpIC8gMlxuICAgIH07XG4gICAgcmV0dXJuIHBhbjtcbiAgfSxcbiAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCB8fCAhdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy52aWV3cG9ydCh7XG4gICAgICBwYW46IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSxcbiAgICAgIHpvb206IDFcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgaW52YWxpZGF0ZVNpemU6IGZ1bmN0aW9uIGludmFsaWRhdGVTaXplKCkge1xuICAgIHRoaXMuX3ByaXZhdGUuc2l6ZUNhY2hlID0gbnVsbDtcbiAgfSxcbiAgc2l6ZTogZnVuY3Rpb24gc2l6ZSgpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciBjb250YWluZXIgPSBfcC5jb250YWluZXI7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICByZXR1cm4gX3Auc2l6ZUNhY2hlID0gX3Auc2l6ZUNhY2hlIHx8IChjb250YWluZXIgPyBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3R5bGUgPSBjeS53aW5kb3coKS5nZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcik7XG5cbiAgICAgIHZhciB2YWwgPSBmdW5jdGlvbiB2YWwobmFtZSkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBjb250YWluZXIuY2xpZW50V2lkdGggLSB2YWwoJ3BhZGRpbmctbGVmdCcpIC0gdmFsKCdwYWRkaW5nLXJpZ2h0JyksXG4gICAgICAgIGhlaWdodDogY29udGFpbmVyLmNsaWVudEhlaWdodCAtIHZhbCgncGFkZGluZy10b3AnKSAtIHZhbCgncGFkZGluZy1ib3R0b20nKVxuICAgICAgfTtcbiAgICB9KCkgOiB7XG4gICAgICAvLyBmYWxsYmFjayBpZiBubyBjb250YWluZXIgKG5vdCAwIGIvYyBjYW4gYmUgdXNlZCBmb3IgZGl2aWRpbmcgZXRjKVxuICAgICAgd2lkdGg6IDEsXG4gICAgICBoZWlnaHQ6IDFcbiAgICB9KTtcbiAgfSxcbiAgd2lkdGg6IGZ1bmN0aW9uIHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnNpemUoKS53aWR0aDtcbiAgfSxcbiAgaGVpZ2h0OiBmdW5jdGlvbiBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZSgpLmhlaWdodDtcbiAgfSxcbiAgZXh0ZW50OiBmdW5jdGlvbiBleHRlbnQoKSB7XG4gICAgdmFyIHBhbiA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgIHZhciB6b29tID0gdGhpcy5fcHJpdmF0ZS56b29tO1xuICAgIHZhciByYiA9IHRoaXMucmVuZGVyZWRFeHRlbnQoKTtcbiAgICB2YXIgYiA9IHtcbiAgICAgIHgxOiAocmIueDEgLSBwYW4ueCkgLyB6b29tLFxuICAgICAgeDI6IChyYi54MiAtIHBhbi54KSAvIHpvb20sXG4gICAgICB5MTogKHJiLnkxIC0gcGFuLnkpIC8gem9vbSxcbiAgICAgIHkyOiAocmIueTIgLSBwYW4ueSkgLyB6b29tXG4gICAgfTtcbiAgICBiLncgPSBiLngyIC0gYi54MTtcbiAgICBiLmggPSBiLnkyIC0gYi55MTtcbiAgICByZXR1cm4gYjtcbiAgfSxcbiAgcmVuZGVyZWRFeHRlbnQ6IGZ1bmN0aW9uIHJlbmRlcmVkRXh0ZW50KCkge1xuICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGgoKTtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5oZWlnaHQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDE6IDAsXG4gICAgICB5MTogMCxcbiAgICAgIHgyOiB3aWR0aCxcbiAgICAgIHkyOiBoZWlnaHQsXG4gICAgICB3OiB3aWR0aCxcbiAgICAgIGg6IGhlaWdodFxuICAgIH07XG4gIH0sXG4gIG11bHRpQ2xpY2tEZWJvdW5jZVRpbWU6IGZ1bmN0aW9uIG11bHRpQ2xpY2tEZWJvdW5jZVRpbWUoX2ludCkge1xuICAgIGlmIChfaW50KSB0aGlzLl9wcml2YXRlLm11bHRpQ2xpY2tEZWJvdW5jZVRpbWUgPSBfaW50O2Vsc2UgcmV0dXJuIHRoaXMuX3ByaXZhdGUubXVsdGlDbGlja0RlYm91bmNlVGltZTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfVxufTsgLy8gYWxpYXNlc1xuXG5jb3JlZm4kMS5jZW50cmUgPSBjb3JlZm4kMS5jZW50ZXI7IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cbmNvcmVmbiQxLmF1dG9sb2NrTm9kZXMgPSBjb3JlZm4kMS5hdXRvbG9jaztcbmNvcmVmbiQxLmF1dG91bmdyYWJpZnlOb2RlcyA9IGNvcmVmbiQxLmF1dG91bmdyYWJpZnk7XG5cbnZhciBmbiA9IHtcbiAgZGF0YTogZGVmaW5lLmRhdGEoe1xuICAgIGZpZWxkOiAnZGF0YScsXG4gICAgYmluZGluZ0V2ZW50OiAnZGF0YScsXG4gICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nRXZlbnQ6ICdkYXRhJyxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gIH0pLFxuICByZW1vdmVEYXRhOiBkZWZpbmUucmVtb3ZlRGF0YSh7XG4gICAgZmllbGQ6ICdkYXRhJyxcbiAgICBldmVudDogJ2RhdGEnLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICB0cmlnZ2VyRXZlbnQ6IHRydWUsXG4gICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgfSksXG4gIHNjcmF0Y2g6IGRlZmluZS5kYXRhKHtcbiAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgIGJpbmRpbmdFdmVudDogJ3NjcmF0Y2gnLFxuICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9KSxcbiAgcmVtb3ZlU2NyYXRjaDogZGVmaW5lLnJlbW92ZURhdGEoe1xuICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgZXZlbnQ6ICdzY3JhdGNoJyxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgdHJpZ2dlckV2ZW50OiB0cnVlLFxuICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gIH0pXG59OyAvLyBhbGlhc2VzXG5cbmZuLmF0dHIgPSBmbi5kYXRhO1xuZm4ucmVtb3ZlQXR0ciA9IGZuLnJlbW92ZURhdGE7XG5cbnZhciBDb3JlID0gZnVuY3Rpb24gQ29yZShvcHRzKSB7XG4gIHZhciBjeSA9IHRoaXM7XG4gIG9wdHMgPSBleHRlbmQoe30sIG9wdHMpO1xuICB2YXIgY29udGFpbmVyID0gb3B0cy5jb250YWluZXI7IC8vIGFsbG93IGZvciBwYXNzaW5nIGEgd3JhcHBlZCBqcXVlcnkgb2JqZWN0XG4gIC8vIGUuZy4gY3l0b3NjYXBlKHsgY29udGFpbmVyOiAkKCcjY3knKSB9KVxuXG4gIGlmIChjb250YWluZXIgJiYgIWh0bWxFbGVtZW50KGNvbnRhaW5lcikgJiYgaHRtbEVsZW1lbnQoY29udGFpbmVyWzBdKSkge1xuICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lclswXTtcbiAgfVxuXG4gIHZhciByZWcgPSBjb250YWluZXIgPyBjb250YWluZXIuX2N5cmVnIDogbnVsbDsgLy8gZS5nLiBhbHJlYWR5IHJlZ2lzdGVyZWQgc29tZSBpbmZvIChlLmcuIHJlYWRpZXMpIHZpYSBqcXVlcnlcblxuICByZWcgPSByZWcgfHwge307XG5cbiAgaWYgKHJlZyAmJiByZWcuY3kpIHtcbiAgICByZWcuY3kuZGVzdHJveSgpO1xuICAgIHJlZyA9IHt9OyAvLyBvbGQgaW5zdGFuY2UgPT4gcmVwbGFjZSByZWcgY29tcGxldGVseVxuICB9XG5cbiAgdmFyIHJlYWRpZXMgPSByZWcucmVhZGllcyA9IHJlZy5yZWFkaWVzIHx8IFtdO1xuXG4gIGlmIChjb250YWluZXIpIHtcbiAgICBjb250YWluZXIuX2N5cmVnID0gcmVnO1xuICB9IC8vIG1ha2Ugc3VyZSBjb250YWluZXIgYXNzb2MnZCByZWcgcG9pbnRzIHRvIHRoaXMgY3lcblxuXG4gIHJlZy5jeSA9IGN5O1xuICB2YXIgaGVhZCA9IF93aW5kb3cgIT09IHVuZGVmaW5lZCAmJiBjb250YWluZXIgIT09IHVuZGVmaW5lZCAmJiAhb3B0cy5oZWFkbGVzcztcbiAgdmFyIG9wdGlvbnMgPSBvcHRzO1xuICBvcHRpb25zLmxheW91dCA9IGV4dGVuZCh7XG4gICAgbmFtZTogaGVhZCA/ICdncmlkJyA6ICdudWxsJ1xuICB9LCBvcHRpb25zLmxheW91dCk7XG4gIG9wdGlvbnMucmVuZGVyZXIgPSBleHRlbmQoe1xuICAgIG5hbWU6IGhlYWQgPyAnY2FudmFzJyA6ICdudWxsJ1xuICB9LCBvcHRpb25zLnJlbmRlcmVyKTtcblxuICB2YXIgZGVmVmFsID0gZnVuY3Rpb24gZGVmVmFsKGRlZiwgdmFsLCBhbHRWYWwpIHtcbiAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSBlbHNlIGlmIChhbHRWYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGFsdFZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRlZjtcbiAgICB9XG4gIH07XG5cbiAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAvLyBodG1sIGRvbSBlbGUgY29udGFpbmVyXG4gICAgcmVhZHk6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgcmVhZHkgaGFzIGJlZW4gdHJpZ2dlcmVkXG4gICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAvLyBjYWNoZWQgb3B0aW9uc1xuICAgIGVsZW1lbnRzOiBuZXcgQ29sbGVjdGlvbih0aGlzKSxcbiAgICAvLyBlbGVtZW50cyBpbiB0aGUgZ3JhcGhcbiAgICBsaXN0ZW5lcnM6IFtdLFxuICAgIC8vIGxpc3Qgb2YgbGlzdGVuZXJzXG4gICAgYW5pRWxlczogbmV3IENvbGxlY3Rpb24odGhpcyksXG4gICAgLy8gZWxlbWVudHMgYmVpbmcgYW5pbWF0ZWRcbiAgICBkYXRhOiBvcHRpb25zLmRhdGEgfHwge30sXG4gICAgLy8gZGF0YSBmb3IgdGhlIGNvcmVcbiAgICBzY3JhdGNoOiB7fSxcbiAgICAvLyBzY3JhdGNoIG9iamVjdCBmb3IgY29yZVxuICAgIGxheW91dDogbnVsbCxcbiAgICByZW5kZXJlcjogbnVsbCxcbiAgICBkZXN0cm95ZWQ6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgZGVzdHJveSB3YXMgY2FsbGVkXG4gICAgbm90aWZpY2F0aW9uc0VuYWJsZWQ6IHRydWUsXG4gICAgLy8gd2hldGhlciBub3RpZmljYXRpb25zIGFyZSBzZW50IHRvIHRoZSByZW5kZXJlclxuICAgIG1pblpvb206IDFlLTUwLFxuICAgIG1heFpvb206IDFlNTAsXG4gICAgem9vbWluZ0VuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLnpvb21pbmdFbmFibGVkKSxcbiAgICB1c2VyWm9vbWluZ0VuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLnVzZXJab29taW5nRW5hYmxlZCksXG4gICAgcGFubmluZ0VuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLnBhbm5pbmdFbmFibGVkKSxcbiAgICB1c2VyUGFubmluZ0VuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLnVzZXJQYW5uaW5nRW5hYmxlZCksXG4gICAgYm94U2VsZWN0aW9uRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMuYm94U2VsZWN0aW9uRW5hYmxlZCksXG4gICAgYXV0b2xvY2s6IGRlZlZhbChmYWxzZSwgb3B0aW9ucy5hdXRvbG9jaywgb3B0aW9ucy5hdXRvbG9ja05vZGVzKSxcbiAgICBhdXRvdW5ncmFiaWZ5OiBkZWZWYWwoZmFsc2UsIG9wdGlvbnMuYXV0b3VuZ3JhYmlmeSwgb3B0aW9ucy5hdXRvdW5ncmFiaWZ5Tm9kZXMpLFxuICAgIGF1dG91bnNlbGVjdGlmeTogZGVmVmFsKGZhbHNlLCBvcHRpb25zLmF1dG91bnNlbGVjdGlmeSksXG4gICAgc3R5bGVFbmFibGVkOiBvcHRpb25zLnN0eWxlRW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gaGVhZCA6IG9wdGlvbnMuc3R5bGVFbmFibGVkLFxuICAgIHpvb206IG51bWJlciQxKG9wdGlvbnMuem9vbSkgPyBvcHRpb25zLnpvb20gOiAxLFxuICAgIHBhbjoge1xuICAgICAgeDogcGxhaW5PYmplY3Qob3B0aW9ucy5wYW4pICYmIG51bWJlciQxKG9wdGlvbnMucGFuLngpID8gb3B0aW9ucy5wYW4ueCA6IDAsXG4gICAgICB5OiBwbGFpbk9iamVjdChvcHRpb25zLnBhbikgJiYgbnVtYmVyJDEob3B0aW9ucy5wYW4ueSkgPyBvcHRpb25zLnBhbi55IDogMFxuICAgIH0sXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICAvLyBvYmplY3QgZm9yIGN1cnJlbnRseS1ydW5uaW5nIGFuaW1hdGlvbnNcbiAgICAgIGN1cnJlbnQ6IFtdLFxuICAgICAgcXVldWU6IFtdXG4gICAgfSxcbiAgICBoYXNDb21wb3VuZE5vZGVzOiBmYWxzZSxcbiAgICBtdWx0aUNsaWNrRGVib3VuY2VUaW1lOiBkZWZWYWwoMjUwLCBvcHRpb25zLm11bHRpQ2xpY2tEZWJvdW5jZVRpbWUpXG4gIH07XG5cbiAgdGhpcy5jcmVhdGVFbWl0dGVyKCk7IC8vIHNldCBzZWxlY3Rpb24gdHlwZVxuXG4gIHRoaXMuc2VsZWN0aW9uVHlwZShvcHRpb25zLnNlbGVjdGlvblR5cGUpOyAvLyBpbml0IHpvb20gYm91bmRzXG5cbiAgdGhpcy56b29tUmFuZ2Uoe1xuICAgIG1pbjogb3B0aW9ucy5taW5ab29tLFxuICAgIG1heDogb3B0aW9ucy5tYXhab29tXG4gIH0pO1xuXG4gIHZhciBsb2FkRXh0RGF0YSA9IGZ1bmN0aW9uIGxvYWRFeHREYXRhKGV4dERhdGEsIG5leHQpIHtcbiAgICB2YXIgYW55SXNQcm9taXNlID0gZXh0RGF0YS5zb21lKHByb21pc2UpO1xuXG4gICAgaWYgKGFueUlzUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UkMS5hbGwoZXh0RGF0YSkudGhlbihuZXh0KTsgLy8gbG9hZCBhbGwgZGF0YSBhc3luY2hyb25vdXNseSwgdGhlbiBleGVjIHJlc3Qgb2YgaW5pdFxuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0KGV4dERhdGEpOyAvLyBleGVjIHN5bmNocm9ub3VzbHkgZm9yIGNvbnZlbmllbmNlXG4gICAgfVxuICB9OyAvLyBzdGFydCB3aXRoIHRoZSBkZWZhdWx0IHN0eWxlc2hlZXQgc28gd2UgaGF2ZSBzb21ldGhpbmcgYmVmb3JlIGxvYWRpbmcgYW4gZXh0ZXJuYWwgc3R5bGVzaGVldFxuXG5cbiAgaWYgKF9wLnN0eWxlRW5hYmxlZCkge1xuICAgIGN5LnNldFN0eWxlKFtdKTtcbiAgfSAvLyBjcmVhdGUgdGhlIHJlbmRlcmVyXG5cblxuICB2YXIgcmVuZGVyZXJPcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zLCBvcHRpb25zLnJlbmRlcmVyKTsgLy8gYWxsb3cgcmVuZGVyaW5nIGhpbnRzIGluIHRvcCBsZXZlbCBvcHRpb25zXG5cbiAgY3kuaW5pdFJlbmRlcmVyKHJlbmRlcmVyT3B0aW9ucyk7XG5cbiAgdmFyIHNldEVsZXNBbmRMYXlvdXQgPSBmdW5jdGlvbiBzZXRFbGVzQW5kTGF5b3V0KGVsZW1lbnRzLCBvbmxvYWQsIG9uZG9uZSkge1xuICAgIGN5Lm5vdGlmaWNhdGlvbnMoZmFsc2UpOyAvLyByZW1vdmUgb2xkIGVsZW1lbnRzXG5cbiAgICB2YXIgb2xkRWxlcyA9IGN5Lm11dGFibGVFbGVtZW50cygpO1xuXG4gICAgaWYgKG9sZEVsZXMubGVuZ3RoID4gMCkge1xuICAgICAgb2xkRWxlcy5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudHMgIT0gbnVsbCkge1xuICAgICAgaWYgKHBsYWluT2JqZWN0KGVsZW1lbnRzKSB8fCBhcnJheShlbGVtZW50cykpIHtcbiAgICAgICAgY3kuYWRkKGVsZW1lbnRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjeS5vbmUoJ2xheW91dHJlYWR5JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGN5Lm5vdGlmaWNhdGlvbnModHJ1ZSk7XG4gICAgICBjeS5lbWl0KGUpOyAvLyB3ZSBtaXNzZWQgdGhpcyBldmVudCBieSB0dXJuaW5nIG5vdGlmaWNhdGlvbnMgb2ZmLCBzbyBwYXNzIGl0IG9uXG5cbiAgICAgIGN5Lm9uZSgnbG9hZCcsIG9ubG9hZCk7XG4gICAgICBjeS5lbWl0QW5kTm90aWZ5KCdsb2FkJyk7XG4gICAgfSkub25lKCdsYXlvdXRzdG9wJywgZnVuY3Rpb24gKCkge1xuICAgICAgY3kub25lKCdkb25lJywgb25kb25lKTtcbiAgICAgIGN5LmVtaXQoJ2RvbmUnKTtcbiAgICB9KTtcbiAgICB2YXIgbGF5b3V0T3B0cyA9IGV4dGVuZCh7fSwgY3kuX3ByaXZhdGUub3B0aW9ucy5sYXlvdXQpO1xuICAgIGxheW91dE9wdHMuZWxlcyA9IGN5LmVsZW1lbnRzKCk7XG4gICAgY3kubGF5b3V0KGxheW91dE9wdHMpLnJ1bigpO1xuICB9O1xuXG4gIGxvYWRFeHREYXRhKFtvcHRpb25zLnN0eWxlLCBvcHRpb25zLmVsZW1lbnRzXSwgZnVuY3Rpb24gKHRoZW5zKSB7XG4gICAgdmFyIGluaXRTdHlsZSA9IHRoZW5zWzBdO1xuICAgIHZhciBpbml0RWxlcyA9IHRoZW5zWzFdOyAvLyBpbml0IHN0eWxlXG5cbiAgICBpZiAoX3Auc3R5bGVFbmFibGVkKSB7XG4gICAgICBjeS5zdHlsZSgpLmFwcGVuZChpbml0U3R5bGUpO1xuICAgIH0gLy8gaW5pdGlhbCBsb2FkXG5cblxuICAgIHNldEVsZXNBbmRMYXlvdXQoaW5pdEVsZXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIG9ucmVhZHlcbiAgICAgIGN5LnN0YXJ0QW5pbWF0aW9uTG9vcCgpO1xuICAgICAgX3AucmVhZHkgPSB0cnVlOyAvLyBpZiBhIHJlYWR5IGNhbGxiYWNrIGlzIHNwZWNpZmllZCBhcyBhbiBvcHRpb24sIHRoZSBiaW5kIGl0XG5cbiAgICAgIGlmIChmbiQ2KG9wdGlvbnMucmVhZHkpKSB7XG4gICAgICAgIGN5Lm9uKCdyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgfSAvLyBiaW5kIGFsbCB0aGUgcmVhZHkgaGFuZGxlcnMgcmVnaXN0ZXJlZCBiZWZvcmUgY3JlYXRpbmcgdGhpcyBpbnN0YW5jZVxuXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVhZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZm4gPSByZWFkaWVzW2ldO1xuICAgICAgICBjeS5vbigncmVhZHknLCBmbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWcpIHtcbiAgICAgICAgcmVnLnJlYWRpZXMgPSBbXTtcbiAgICAgIH0gLy8gY2xlYXIgYi9jIHdlJ3ZlIGJvdW5kIHRoZW0gYWxsIGFuZCBkb24ndCB3YW50IHRvIGtlZXAgaXQgYXJvdW5kIGluIGNhc2UgYSBuZXcgY29yZSB1c2VzIHRoZSBzYW1lIGRpdiBldGNcblxuXG4gICAgICBjeS5lbWl0KCdyZWFkeScpO1xuICAgIH0sIG9wdGlvbnMuZG9uZSk7XG4gIH0pO1xufTtcblxudmFyIGNvcmVmbiA9IENvcmUucHJvdG90eXBlOyAvLyBzaG9ydCBhbGlhc1xuXG5leHRlbmQoY29yZWZuLCB7XG4gIGluc3RhbmNlU3RyaW5nOiBmdW5jdGlvbiBpbnN0YW5jZVN0cmluZygpIHtcbiAgICByZXR1cm4gJ2NvcmUnO1xuICB9LFxuICBpc1JlYWR5OiBmdW5jdGlvbiBpc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnJlYWR5O1xuICB9LFxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHJlYWR5OiBmdW5jdGlvbiByZWFkeShmbikge1xuICAgIGlmICh0aGlzLmlzUmVhZHkoKSkge1xuICAgICAgdGhpcy5lbWl0dGVyKCkuZW1pdCgncmVhZHknLCBbXSwgZm4pOyAvLyBqdXN0IGNhbGxzIGZuIGFzIHRob3VnaCB0cmlnZ2VyZWQgdmlhIHJlYWR5IGV2ZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub24oJ3JlYWR5JywgZm4pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgaWYgKGN5LmRlc3Ryb3llZCgpKSByZXR1cm47XG4gICAgY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcbiAgICBjeS5kZXN0cm95UmVuZGVyZXIoKTtcbiAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3knKTtcbiAgICBjeS5fcHJpdmF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHJldHVybiBjeTtcbiAgfSxcbiAgaGFzRWxlbWVudFdpdGhJZDogZnVuY3Rpb24gaGFzRWxlbWVudFdpdGhJZChpZCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVsZW1lbnRzLmhhc0VsZW1lbnRXaXRoSWQoaWQpO1xuICB9LFxuICBnZXRFbGVtZW50QnlJZDogZnVuY3Rpb24gZ2V0RWxlbWVudEJ5SWQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cy5nZXRFbGVtZW50QnlJZChpZCk7XG4gIH0sXG4gIGhhc0NvbXBvdW5kTm9kZXM6IGZ1bmN0aW9uIGhhc0NvbXBvdW5kTm9kZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuaGFzQ29tcG91bmROb2RlcztcbiAgfSxcbiAgaGVhZGxlc3M6IGZ1bmN0aW9uIGhlYWRsZXNzKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnJlbmRlcmVyLmlzSGVhZGxlc3MoKTtcbiAgfSxcbiAgc3R5bGVFbmFibGVkOiBmdW5jdGlvbiBzdHlsZUVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuICB9LFxuICBhZGRUb1Bvb2w6IGZ1bmN0aW9uIGFkZFRvUG9vbChlbGVzKSB7XG4gICAgdGhpcy5fcHJpdmF0ZS5lbGVtZW50cy5tZXJnZShlbGVzKTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICByZW1vdmVGcm9tUG9vbDogZnVuY3Rpb24gcmVtb3ZlRnJvbVBvb2woZWxlcykge1xuICAgIHRoaXMuX3ByaXZhdGUuZWxlbWVudHMudW5tZXJnZShlbGVzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBjb250YWluZXI6IGZ1bmN0aW9uIGNvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5jb250YWluZXIgfHwgbnVsbDtcbiAgfSxcbiAgd2luZG93OiBmdW5jdGlvbiB3aW5kb3coKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX3ByaXZhdGUuY29udGFpbmVyO1xuICAgIGlmIChjb250YWluZXIgPT0gbnVsbCkgcmV0dXJuIF93aW5kb3c7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSB0aGlzLl9wcml2YXRlLmNvbnRhaW5lci5vd25lckRvY3VtZW50O1xuXG4gICAgaWYgKG93bmVyRG9jdW1lbnQgPT09IHVuZGVmaW5lZCB8fCBvd25lckRvY3VtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBfd2luZG93O1xuICAgIH1cblxuICAgIHJldHVybiBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IF93aW5kb3c7XG4gIH0sXG4gIG1vdW50OiBmdW5jdGlvbiBtb3VudChjb250YWluZXIpIHtcbiAgICBpZiAoY29udGFpbmVyID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIHZhciBfcCA9IGN5Ll9wcml2YXRlO1xuICAgIHZhciBvcHRpb25zID0gX3Aub3B0aW9ucztcblxuICAgIGlmICghaHRtbEVsZW1lbnQoY29udGFpbmVyKSAmJiBodG1sRWxlbWVudChjb250YWluZXJbMF0pKSB7XG4gICAgICBjb250YWluZXIgPSBjb250YWluZXJbMF07XG4gICAgfVxuXG4gICAgY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcbiAgICBjeS5kZXN0cm95UmVuZGVyZXIoKTtcbiAgICBfcC5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgX3Auc3R5bGVFbmFibGVkID0gdHJ1ZTtcbiAgICBjeS5pbnZhbGlkYXRlU2l6ZSgpO1xuICAgIGN5LmluaXRSZW5kZXJlcihleHRlbmQoe30sIG9wdGlvbnMsIG9wdGlvbnMucmVuZGVyZXIsIHtcbiAgICAgIC8vIGFsbG93IGN1c3RvbSByZW5kZXJlciBuYW1lIHRvIGJlIHJlLXVzZWQsIG90aGVyd2lzZSB1c2UgY2FudmFzXG4gICAgICBuYW1lOiBvcHRpb25zLnJlbmRlcmVyLm5hbWUgPT09ICdudWxsJyA/ICdjYW52YXMnIDogb3B0aW9ucy5yZW5kZXJlci5uYW1lXG4gICAgfSkpO1xuICAgIGN5LnN0YXJ0QW5pbWF0aW9uTG9vcCgpO1xuICAgIGN5LnN0eWxlKG9wdGlvbnMuc3R5bGUpO1xuICAgIGN5LmVtaXQoJ21vdW50Jyk7XG4gICAgcmV0dXJuIGN5O1xuICB9LFxuICB1bm1vdW50OiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcbiAgICBjeS5kZXN0cm95UmVuZGVyZXIoKTtcbiAgICBjeS5pbml0UmVuZGVyZXIoe1xuICAgICAgbmFtZTogJ251bGwnXG4gICAgfSk7XG4gICAgY3kuZW1pdCgndW5tb3VudCcpO1xuICAgIHJldHVybiBjeTtcbiAgfSxcbiAgb3B0aW9uczogZnVuY3Rpb24gb3B0aW9ucygpIHtcbiAgICByZXR1cm4gY29weSh0aGlzLl9wcml2YXRlLm9wdGlvbnMpO1xuICB9LFxuICBqc29uOiBmdW5jdGlvbiBqc29uKG9iaikge1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgdmFyIF9wID0gY3kuX3ByaXZhdGU7XG4gICAgdmFyIGVsZXMgPSBjeS5tdXRhYmxlRWxlbWVudHMoKTtcblxuICAgIHZhciBnZXRGcmVzaFJlZiA9IGZ1bmN0aW9uIGdldEZyZXNoUmVmKGVsZSkge1xuICAgICAgcmV0dXJuIGN5LmdldEVsZW1lbnRCeUlkKGVsZS5pZCgpKTtcbiAgICB9O1xuXG4gICAgaWYgKHBsYWluT2JqZWN0KG9iaikpIHtcbiAgICAgIC8vIHNldFxuICAgICAgY3kuc3RhcnRCYXRjaCgpO1xuXG4gICAgICBpZiAob2JqLmVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBpZEluSnNvbiA9IHt9O1xuXG4gICAgICAgIHZhciB1cGRhdGVFbGVzID0gZnVuY3Rpb24gdXBkYXRlRWxlcyhqc29ucywgZ3IpIHtcbiAgICAgICAgICB2YXIgdG9BZGQgPSBbXTtcbiAgICAgICAgICB2YXIgdG9Nb2QgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwganNvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBqc29uID0ganNvbnNbaV07XG5cbiAgICAgICAgICAgIGlmICghanNvbi5kYXRhLmlkKSB7XG4gICAgICAgICAgICAgIHdhcm4oJ2N5Lmpzb24oKSBjYW5ub3QgaGFuZGxlIGVsZW1lbnRzIHdpdGhvdXQgYW4gSUQgYXR0cmlidXRlJyk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaWQgPSAnJyArIGpzb24uZGF0YS5pZDsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcblxuICAgICAgICAgICAgdmFyIGVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgICAgIGlkSW5Kc29uW2lkXSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmIChlbGUubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIC8vIGV4aXN0aW5nIGVsZW1lbnQgc2hvdWxkIGJlIHVwZGF0ZWRcbiAgICAgICAgICAgICAgdG9Nb2QucHVzaCh7XG4gICAgICAgICAgICAgICAgZWxlOiBlbGUsXG4gICAgICAgICAgICAgICAganNvbjoganNvblxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBzaG91bGQgYmUgYWRkZWRcbiAgICAgICAgICAgICAgaWYgKGdyKSB7XG4gICAgICAgICAgICAgICAganNvbi5ncm91cCA9IGdyO1xuICAgICAgICAgICAgICAgIHRvQWRkLnB1c2goanNvbik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9BZGQucHVzaChqc29uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGN5LmFkZCh0b0FkZCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdG9Nb2QubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgX3RvTW9kJF9pID0gdG9Nb2RbX2ldLFxuICAgICAgICAgICAgICAgIF9lbGUgPSBfdG9Nb2QkX2kuZWxlLFxuICAgICAgICAgICAgICAgIF9qc29uID0gX3RvTW9kJF9pLmpzb247XG5cbiAgICAgICAgICAgIF9lbGUuanNvbihfanNvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChhcnJheShvYmouZWxlbWVudHMpKSB7XG4gICAgICAgICAgLy8gZWxlbWVudHM6IFtdXG4gICAgICAgICAgdXBkYXRlRWxlcyhvYmouZWxlbWVudHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVsZW1lbnRzOiB7IG5vZGVzOiBbXSwgZWRnZXM6IFtdIH1cbiAgICAgICAgICB2YXIgZ3JzID0gWydub2RlcycsICdlZGdlcyddO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBnciA9IGdyc1tpXTtcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IG9iai5lbGVtZW50c1tncl07XG5cbiAgICAgICAgICAgIGlmIChhcnJheShlbGVtZW50cykpIHtcbiAgICAgICAgICAgICAgdXBkYXRlRWxlcyhlbGVtZW50cywgZ3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnRzVG9SZW1vdmUgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgIGVsZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gIWlkSW5Kc29uW2VsZS5pZCgpXTtcbiAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgaWYgKGVsZS5pc1BhcmVudCgpKSB7XG4gICAgICAgICAgICBwYXJlbnRzVG9SZW1vdmUubWVyZ2UoZWxlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7IC8vIHNvIHRoYXQgY2hpbGRyZW4gYXJlIG5vdCByZW1vdmVkIHcvcGFyZW50XG5cbiAgICAgICAgcGFyZW50c1RvUmVtb3ZlLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIHJldHVybiBlbGUuY2hpbGRyZW4oKS5tb3ZlKHtcbiAgICAgICAgICAgIHBhcmVudDogbnVsbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTsgLy8gaW50ZXJtZWRpYXRlIHBhcmVudHMgbWF5IGJlIG1vdmVkIGJ5IHByaW9yIGxpbmUsIHNvIG1ha2Ugc3VyZSB3ZSByZW1vdmUgYnkgZnJlc2ggcmVmc1xuXG4gICAgICAgIHBhcmVudHNUb1JlbW92ZS5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0RnJlc2hSZWYoZWxlKS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmouc3R5bGUpIHtcbiAgICAgICAgY3kuc3R5bGUob2JqLnN0eWxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9iai56b29tICE9IG51bGwgJiYgb2JqLnpvb20gIT09IF9wLnpvb20pIHtcbiAgICAgICAgY3kuem9vbShvYmouem9vbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmoucGFuKSB7XG4gICAgICAgIGlmIChvYmoucGFuLnggIT09IF9wLnBhbi54IHx8IG9iai5wYW4ueSAhPT0gX3AucGFuLnkpIHtcbiAgICAgICAgICBjeS5wYW4ob2JqLnBhbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9iai5kYXRhKSB7XG4gICAgICAgIGN5LmRhdGEob2JqLmRhdGEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmllbGRzID0gWydtaW5ab29tJywgJ21heFpvb20nLCAnem9vbWluZ0VuYWJsZWQnLCAndXNlclpvb21pbmdFbmFibGVkJywgJ3Bhbm5pbmdFbmFibGVkJywgJ3VzZXJQYW5uaW5nRW5hYmxlZCcsICdib3hTZWxlY3Rpb25FbmFibGVkJywgJ2F1dG9sb2NrJywgJ2F1dG91bmdyYWJpZnknLCAnYXV0b3Vuc2VsZWN0aWZ5JywgJ211bHRpQ2xpY2tEZWJvdW5jZVRpbWUnXTtcblxuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgZmllbGRzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdmFyIGYgPSBmaWVsZHNbX2kyXTtcblxuICAgICAgICBpZiAob2JqW2ZdICE9IG51bGwpIHtcbiAgICAgICAgICBjeVtmXShvYmpbZl0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN5LmVuZEJhdGNoKCk7XG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZ2V0XG4gICAgICB2YXIgZmxhdCA9ICEhb2JqO1xuICAgICAgdmFyIGpzb24gPSB7fTtcblxuICAgICAgaWYgKGZsYXQpIHtcbiAgICAgICAganNvbi5lbGVtZW50cyA9IHRoaXMuZWxlbWVudHMoKS5tYXAoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIHJldHVybiBlbGUuanNvbigpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGpzb24uZWxlbWVudHMgPSB7fTtcbiAgICAgICAgZWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICB2YXIgZ3JvdXAgPSBlbGUuZ3JvdXAoKTtcblxuICAgICAgICAgIGlmICghanNvbi5lbGVtZW50c1tncm91cF0pIHtcbiAgICAgICAgICAgIGpzb24uZWxlbWVudHNbZ3JvdXBdID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAganNvbi5lbGVtZW50c1tncm91cF0ucHVzaChlbGUuanNvbigpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9wcml2YXRlLnN0eWxlRW5hYmxlZCkge1xuICAgICAgICBqc29uLnN0eWxlID0gY3kuc3R5bGUoKS5qc29uKCk7XG4gICAgICB9XG5cbiAgICAgIGpzb24uZGF0YSA9IGNvcHkoY3kuZGF0YSgpKTtcbiAgICAgIHZhciBvcHRpb25zID0gX3Aub3B0aW9ucztcbiAgICAgIGpzb24uem9vbWluZ0VuYWJsZWQgPSBfcC56b29taW5nRW5hYmxlZDtcbiAgICAgIGpzb24udXNlclpvb21pbmdFbmFibGVkID0gX3AudXNlclpvb21pbmdFbmFibGVkO1xuICAgICAganNvbi56b29tID0gX3Auem9vbTtcbiAgICAgIGpzb24ubWluWm9vbSA9IF9wLm1pblpvb207XG4gICAgICBqc29uLm1heFpvb20gPSBfcC5tYXhab29tO1xuICAgICAganNvbi5wYW5uaW5nRW5hYmxlZCA9IF9wLnBhbm5pbmdFbmFibGVkO1xuICAgICAganNvbi51c2VyUGFubmluZ0VuYWJsZWQgPSBfcC51c2VyUGFubmluZ0VuYWJsZWQ7XG4gICAgICBqc29uLnBhbiA9IGNvcHkoX3AucGFuKTtcbiAgICAgIGpzb24uYm94U2VsZWN0aW9uRW5hYmxlZCA9IF9wLmJveFNlbGVjdGlvbkVuYWJsZWQ7XG4gICAgICBqc29uLnJlbmRlcmVyID0gY29weShvcHRpb25zLnJlbmRlcmVyKTtcbiAgICAgIGpzb24uaGlkZUVkZ2VzT25WaWV3cG9ydCA9IG9wdGlvbnMuaGlkZUVkZ2VzT25WaWV3cG9ydDtcbiAgICAgIGpzb24udGV4dHVyZU9uVmlld3BvcnQgPSBvcHRpb25zLnRleHR1cmVPblZpZXdwb3J0O1xuICAgICAganNvbi53aGVlbFNlbnNpdGl2aXR5ID0gb3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5O1xuICAgICAganNvbi5tb3Rpb25CbHVyID0gb3B0aW9ucy5tb3Rpb25CbHVyO1xuICAgICAganNvbi5tdWx0aUNsaWNrRGVib3VuY2VUaW1lID0gb3B0aW9ucy5tdWx0aUNsaWNrRGVib3VuY2VUaW1lO1xuICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICB9XG59KTtcbmNvcmVmbi4kaWQgPSBjb3JlZm4uZ2V0RWxlbWVudEJ5SWQ7XG5bY29yZWZuJDksIGNvcmVmbiQ4LCBlbGVzZm4sIGNvcmVmbiQ3LCBjb3JlZm4kNiwgY29yZWZuJDUsIGNvcmVmbiQ0LCBjb3JlZm4kMywgY29yZWZuJDIsIGNvcmVmbiQxLCBmbl0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgZXh0ZW5kKGNvcmVmbiwgcHJvcHMpO1xufSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cbnZhciBkZWZhdWx0cyQ3ID0ge1xuICBmaXQ6IHRydWUsXG4gIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgZGlyZWN0ZWQ6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRoZSB0cmVlIGlzIGRpcmVjdGVkIGRvd253YXJkcyAob3IgZWRnZXMgY2FuIHBvaW50IGluIGFueSBkaXJlY3Rpb24gaWYgZmFsc2UpXG4gIHBhZGRpbmc6IDMwLFxuICAvLyBwYWRkaW5nIG9uIGZpdFxuICBjaXJjbGU6IGZhbHNlLFxuICAvLyBwdXQgZGVwdGhzIGluIGNvbmNlbnRyaWMgY2lyY2xlcyBpZiB0cnVlLCBwdXQgZGVwdGhzIHRvcCBkb3duIGlmIGZhbHNlXG4gIGdyaWQ6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRvIGNyZWF0ZSBhbiBldmVuIGdyaWQgaW50byB3aGljaCB0aGUgREFHIGlzIHBsYWNlZCAoY2lyY2xlOmZhbHNlIG9ubHkpXG4gIHNwYWNpbmdGYWN0b3I6IDEuNzUsXG4gIC8vIHBvc2l0aXZlIHNwYWNpbmcgZmFjdG9yLCBsYXJnZXIgPT4gbW9yZSBzcGFjZSBiZXR3ZWVuIG5vZGVzIChOLkIuIG4vYSBpZiBjYXVzZXMgb3ZlcmxhcClcbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCxcbiAgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIGF2b2lkT3ZlcmxhcDogdHJ1ZSxcbiAgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggaWYgbm90IGVub3VnaCBzcGFjZVxuICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAvLyBFeGNsdWRlcyB0aGUgbGFiZWwgd2hlbiBjYWxjdWxhdGluZyBub2RlIGJvdW5kaW5nIGJveGVzIGZvciB0aGUgbGF5b3V0IGFsZ29yaXRobVxuICByb290czogdW5kZWZpbmVkLFxuICAvLyB0aGUgcm9vdHMgb2YgdGhlIHRyZWVzXG4gIGRlcHRoU29ydDogdW5kZWZpbmVkLFxuICAvLyBhIHNvcnRpbmcgZnVuY3Rpb24gdG8gb3JkZXIgbm9kZXMgYXQgZXF1YWwgZGVwdGguIGUuZy4gZnVuY3Rpb24oYSwgYil7IHJldHVybiBhLmRhdGEoJ3dlaWdodCcpIC0gYi5kYXRhKCd3ZWlnaHQnKSB9XG4gIGFuaW1hdGU6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG4gIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWQsXG4gIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAvLyBhIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZC4gIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZC4gIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gIHJlYWR5OiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlLCBwb3NpdGlvbikge1xuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfSAvLyB0cmFuc2Zvcm0gYSBnaXZlbiBub2RlIHBvc2l0aW9uLiBVc2VmdWwgZm9yIGNoYW5naW5nIGZsb3cgZGlyZWN0aW9uIGluIGRpc2NyZXRlIGxheW91dHNcblxufTtcbnZhciBkZXByZWNhdGVkT3B0aW9uRGVmYXVsdHMgPSB7XG4gIG1heGltYWw6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRvIHNoaWZ0IG5vZGVzIGRvd24gdGhlaXIgbmF0dXJhbCBCRlMgZGVwdGhzIGluIG9yZGVyIHRvIGF2b2lkIHVwd2FyZHMgZWRnZXMgKERBR1Mgb25seSk7IHNldHRpbmcgYWN5Y2xpYyB0byB0cnVlIHNldHMgbWF4aW1hbCB0byB0cnVlIGFsc29cbiAgYWN5Y2xpYzogZmFsc2UgLy8gd2hldGhlciB0aGUgdHJlZSBpcyBhY3ljbGljIGFuZCB0aHVzIGEgbm9kZSBjb3VsZCBiZSBzaGlmdGVkIChkdWUgdG8gdGhlIG1heGltYWwgb3B0aW9uKSBtdWx0aXBsZSB0aW1lcyB3aXRob3V0IGNhdXNpbmcgYW4gaW5maW5pdGUgbG9vcDsgc2V0dGluZyB0byB0cnVlIHNldHMgbWF4aW1hbCB0byB0cnVlIGFsc287IGlmIHlvdSBhcmUgdW5jZXJ0YWluIHdoZXRoZXIgYSB0cmVlIGlzIGFjeWNsaWMsIHNldCB0byBmYWxzZSB0byBhdm9pZCBwb3RlbnRpYWwgaW5maW5pdGUgbG9vcHNcblxufTtcbi8qIGVzbGludC1lbmFibGUgKi9cblxudmFyIGdldEluZm8gPSBmdW5jdGlvbiBnZXRJbmZvKGVsZSkge1xuICByZXR1cm4gZWxlLnNjcmF0Y2goJ2JyZWFkdGhmaXJzdCcpO1xufTtcblxudmFyIHNldEluZm8gPSBmdW5jdGlvbiBzZXRJbmZvKGVsZSwgb2JqKSB7XG4gIHJldHVybiBlbGUuc2NyYXRjaCgnYnJlYWR0aGZpcnN0Jywgb2JqKTtcbn07XG5cbmZ1bmN0aW9uIEJyZWFkdGhGaXJzdExheW91dChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMkNywgZGVwcmVjYXRlZE9wdGlvbkRlZmF1bHRzLCBvcHRpb25zKTtcbn1cblxuQnJlYWR0aEZpcnN0TGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0gcGFyYW1zO1xuICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkuZmlsdGVyKGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuICFuLmlzUGFyZW50KCk7XG4gIH0pO1xuICB2YXIgZ3JhcGggPSBlbGVzO1xuICB2YXIgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICB2YXIgbWF4aW1hbCA9IG9wdGlvbnMuYWN5Y2xpYyB8fCBvcHRpb25zLm1heGltYWwgfHwgb3B0aW9ucy5tYXhpbWFsQWRqdXN0bWVudHMgPiAwOyAvLyBtYXhpbWFsQWRqdXN0bWVudHMgZm9yIGNvbXBhdC4gdy8gb2xkIGNvZGU7IGFsc28sIHNldHRpbmcgYWN5Y2xpYyB0byB0cnVlIHNldHMgbWF4aW1hbCB0byB0cnVlXG5cbiAgdmFyIGJiID0gbWFrZUJvdW5kaW5nQm94KG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgIHgxOiAwLFxuICAgIHkxOiAwLFxuICAgIHc6IGN5LndpZHRoKCksXG4gICAgaDogY3kuaGVpZ2h0KClcbiAgfSk7XG4gIHZhciByb290cztcblxuICBpZiAoZWxlbWVudE9yQ29sbGVjdGlvbihvcHRpb25zLnJvb3RzKSkge1xuICAgIHJvb3RzID0gb3B0aW9ucy5yb290cztcbiAgfSBlbHNlIGlmIChhcnJheShvcHRpb25zLnJvb3RzKSkge1xuICAgIHZhciByb290c0FycmF5ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMucm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZCA9IG9wdGlvbnMucm9vdHNbaV07XG4gICAgICB2YXIgZWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgcm9vdHNBcnJheS5wdXNoKGVsZSk7XG4gICAgfVxuXG4gICAgcm9vdHMgPSBjeS5jb2xsZWN0aW9uKHJvb3RzQXJyYXkpO1xuICB9IGVsc2UgaWYgKHN0cmluZyhvcHRpb25zLnJvb3RzKSkge1xuICAgIHJvb3RzID0gY3kuJChvcHRpb25zLnJvb3RzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZGlyZWN0ZWQpIHtcbiAgICAgIHJvb3RzID0gbm9kZXMucm9vdHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbXBvbmVudHMgPSBlbGVzLmNvbXBvbmVudHMoKTtcbiAgICAgIHJvb3RzID0gY3kuY29sbGVjdGlvbigpO1xuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfaSkge1xuICAgICAgICB2YXIgY29tcCA9IGNvbXBvbmVudHNbX2ldO1xuICAgICAgICB2YXIgbWF4RGVncmVlID0gY29tcC5tYXhEZWdyZWUoZmFsc2UpO1xuICAgICAgICB2YXIgY29tcFJvb3RzID0gY29tcC5maWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIHJldHVybiBlbGUuZGVncmVlKGZhbHNlKSA9PT0gbWF4RGVncmVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcm9vdHMgPSByb290cy5hZGQoY29tcFJvb3RzKTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBjb21wb25lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBfbG9vcChfaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlcHRocyA9IFtdO1xuICB2YXIgZm91bmRCeUJmcyA9IHt9O1xuXG4gIHZhciBhZGRUb0RlcHRoID0gZnVuY3Rpb24gYWRkVG9EZXB0aChlbGUsIGQpIHtcbiAgICBpZiAoZGVwdGhzW2RdID09IG51bGwpIHtcbiAgICAgIGRlcHRoc1tkXSA9IFtdO1xuICAgIH1cblxuICAgIHZhciBpID0gZGVwdGhzW2RdLmxlbmd0aDtcbiAgICBkZXB0aHNbZF0ucHVzaChlbGUpO1xuICAgIHNldEluZm8oZWxlLCB7XG4gICAgICBpbmRleDogaSxcbiAgICAgIGRlcHRoOiBkXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGNoYW5nZURlcHRoID0gZnVuY3Rpb24gY2hhbmdlRGVwdGgoZWxlLCBuZXdEZXB0aCkge1xuICAgIHZhciBfZ2V0SW5mbyA9IGdldEluZm8oZWxlKSxcbiAgICAgICAgZGVwdGggPSBfZ2V0SW5mby5kZXB0aCxcbiAgICAgICAgaW5kZXggPSBfZ2V0SW5mby5pbmRleDtcblxuICAgIGRlcHRoc1tkZXB0aF1baW5kZXhdID0gbnVsbDtcbiAgICBhZGRUb0RlcHRoKGVsZSwgbmV3RGVwdGgpO1xuICB9OyAvLyBmaW5kIHRoZSBkZXB0aHMgb2YgdGhlIG5vZGVzXG5cblxuICBncmFwaC5iZnMoe1xuICAgIHJvb3RzOiByb290cyxcbiAgICBkaXJlY3RlZDogb3B0aW9ucy5kaXJlY3RlZCxcbiAgICB2aXNpdDogZnVuY3Rpb24gdmlzaXQobm9kZSwgZWRnZSwgcE5vZGUsIGksIGRlcHRoKSB7XG4gICAgICB2YXIgZWxlID0gbm9kZVswXTtcbiAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgICAgYWRkVG9EZXB0aChlbGUsIGRlcHRoKTtcbiAgICAgIGZvdW5kQnlCZnNbaWRdID0gdHJ1ZTtcbiAgICB9XG4gIH0pOyAvLyBjaGVjayBmb3Igbm9kZXMgbm90IGZvdW5kIGJ5IGJmc1xuXG4gIHZhciBvcnBoYW5Ob2RlcyA9IFtdO1xuXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgX2VsZSA9IG5vZGVzW19pMl07XG5cbiAgICBpZiAoZm91bmRCeUJmc1tfZWxlLmlkKCldKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3JwaGFuTm9kZXMucHVzaChfZWxlKTtcbiAgICB9XG4gIH0gLy8gYXNzaWduIHRoZSBub2RlcyBhIGRlcHRoIGFuZCBpbmRleFxuXG5cbiAgdmFyIGFzc2lnbkRlcHRoc0F0ID0gZnVuY3Rpb24gYXNzaWduRGVwdGhzQXQoaSkge1xuICAgIHZhciBlbGVzID0gZGVwdGhzW2ldO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgX2VsZTIgPSBlbGVzW2pdO1xuXG4gICAgICBpZiAoX2VsZTIgPT0gbnVsbCkge1xuICAgICAgICBlbGVzLnNwbGljZShqLCAxKTtcbiAgICAgICAgai0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc2V0SW5mbyhfZWxlMiwge1xuICAgICAgICBkZXB0aDogaSxcbiAgICAgICAgaW5kZXg6IGpcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgYXNzaWduRGVwdGhzID0gZnVuY3Rpb24gYXNzaWduRGVwdGhzKCkge1xuICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGRlcHRocy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICBhc3NpZ25EZXB0aHNBdChfaTMpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgYWRqdXN0TWF4aW1hbGx5ID0gZnVuY3Rpb24gYWRqdXN0TWF4aW1hbGx5KGVsZSwgc2hpZnRlZCkge1xuICAgIHZhciBlSW5mbyA9IGdldEluZm8oZWxlKTtcbiAgICB2YXIgaW5jb21lcnMgPSBlbGUuaW5jb21lcnMoKS5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgICByZXR1cm4gZWwuaXNOb2RlKCkgJiYgZWxlcy5oYXMoZWwpO1xuICAgIH0pO1xuICAgIHZhciBtYXhEZXB0aCA9IC0xO1xuICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBpbmNvbWVycy5sZW5ndGg7IGsrKykge1xuICAgICAgdmFyIGluY21yID0gaW5jb21lcnNba107XG4gICAgICB2YXIgaUluZm8gPSBnZXRJbmZvKGluY21yKTtcbiAgICAgIG1heERlcHRoID0gTWF0aC5tYXgobWF4RGVwdGgsIGlJbmZvLmRlcHRoKTtcbiAgICB9XG5cbiAgICBpZiAoZUluZm8uZGVwdGggPD0gbWF4RGVwdGgpIHtcbiAgICAgIGlmICghb3B0aW9ucy5hY3ljbGljICYmIHNoaWZ0ZWRbaWRdKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3RGVwdGggPSBtYXhEZXB0aCArIDE7XG4gICAgICBjaGFuZ2VEZXB0aChlbGUsIG5ld0RlcHRoKTtcbiAgICAgIHNoaWZ0ZWRbaWRdID0gbmV3RGVwdGg7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07IC8vIGZvciB0aGUgZGlyZWN0ZWQgY2FzZSwgdHJ5IHRvIG1ha2UgdGhlIGVkZ2VzIGFsbCBnbyBkb3duIChpLmUuIGRlcHRoIGkgPT4gZGVwdGggaSArIDEpXG5cblxuICBpZiAoZGlyZWN0ZWQgJiYgbWF4aW1hbCkge1xuICAgIHZhciBRID0gW107XG4gICAgdmFyIHNoaWZ0ZWQgPSB7fTtcblxuICAgIHZhciBlbnF1ZXVlID0gZnVuY3Rpb24gZW5xdWV1ZShuKSB7XG4gICAgICByZXR1cm4gUS5wdXNoKG4pO1xuICAgIH07XG5cbiAgICB2YXIgZGVxdWV1ZSA9IGZ1bmN0aW9uIGRlcXVldWUoKSB7XG4gICAgICByZXR1cm4gUS5zaGlmdCgpO1xuICAgIH07XG5cbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gUS5wdXNoKG4pO1xuICAgIH0pO1xuXG4gICAgd2hpbGUgKFEubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIF9lbGUzID0gZGVxdWV1ZSgpO1xuXG4gICAgICB2YXIgZGlkU2hpZnQgPSBhZGp1c3RNYXhpbWFsbHkoX2VsZTMsIHNoaWZ0ZWQpO1xuXG4gICAgICBpZiAoZGlkU2hpZnQpIHtcbiAgICAgICAgX2VsZTMub3V0Z29lcnMoKS5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgcmV0dXJuIGVsLmlzTm9kZSgpICYmIGVsZXMuaGFzKGVsKTtcbiAgICAgICAgfSkuZm9yRWFjaChlbnF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoZGlkU2hpZnQgPT09IG51bGwpIHtcbiAgICAgICAgd2FybignRGV0ZWN0ZWQgZG91YmxlIG1heGltYWwgc2hpZnQgZm9yIG5vZGUgYCcgKyBfZWxlMy5pZCgpICsgJ2AuICBCYWlsaW5nIG1heGltYWwgYWRqdXN0bWVudCBkdWUgdG8gY3ljbGUuICBVc2UgYG9wdGlvbnMubWF4aW1hbDogdHJ1ZWAgb25seSBvbiBEQUdzLicpO1xuICAgICAgICBicmVhazsgLy8gZXhpdCBvbiBmYWlsdXJlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXNzaWduRGVwdGhzKCk7IC8vIGNsZWFyIGhvbGVzXG4gIC8vIGZpbmQgbWluIGRpc3RhbmNlIHdlIG5lZWQgdG8gbGVhdmUgYmV0d2VlbiBub2Rlc1xuXG4gIHZhciBtaW5EaXN0YW5jZSA9IDA7XG5cbiAgaWYgKG9wdGlvbnMuYXZvaWRPdmVybGFwKSB7XG4gICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbm9kZXMubGVuZ3RoOyBfaTQrKykge1xuICAgICAgdmFyIG4gPSBub2Rlc1tfaTRdO1xuICAgICAgdmFyIG5iYiA9IG4ubGF5b3V0RGltZW5zaW9ucyhvcHRpb25zKTtcbiAgICAgIHZhciB3ID0gbmJiLnc7XG4gICAgICB2YXIgaCA9IG5iYi5oO1xuICAgICAgbWluRGlzdGFuY2UgPSBNYXRoLm1heChtaW5EaXN0YW5jZSwgdywgaCk7XG4gICAgfVxuICB9IC8vIGdldCB0aGUgd2VpZ2h0ZWQgcGVyY2VudCBmb3IgYW4gZWxlbWVudCBiYXNlZCBvbiBpdHMgY29ubmVjdGl2aXR5IHRvIG90aGVyIGxldmVsc1xuXG5cbiAgdmFyIGNhY2hlZFdlaWdodGVkUGVyY2VudCA9IHt9O1xuXG4gIHZhciBnZXRXZWlnaHRlZFBlcmNlbnQgPSBmdW5jdGlvbiBnZXRXZWlnaHRlZFBlcmNlbnQoZWxlKSB7XG4gICAgaWYgKGNhY2hlZFdlaWdodGVkUGVyY2VudFtlbGUuaWQoKV0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRXZWlnaHRlZFBlcmNlbnRbZWxlLmlkKCldO1xuICAgIH1cblxuICAgIHZhciBlbGVEZXB0aCA9IGdldEluZm8oZWxlKS5kZXB0aDtcbiAgICB2YXIgbmVpZ2hib3JzID0gZWxlLm5laWdoYm9yaG9vZCgpO1xuICAgIHZhciBwZXJjZW50ID0gMDtcbiAgICB2YXIgc2FtcGxlcyA9IDA7XG5cbiAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBuZWlnaGJvcnMubGVuZ3RoOyBfaTUrKykge1xuICAgICAgdmFyIG5laWdoYm9yID0gbmVpZ2hib3JzW19pNV07XG5cbiAgICAgIGlmIChuZWlnaGJvci5pc0VkZ2UoKSB8fCBuZWlnaGJvci5pc1BhcmVudCgpIHx8ICFub2Rlcy5oYXMobmVpZ2hib3IpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmYgPSBnZXRJbmZvKG5laWdoYm9yKTtcblxuICAgICAgaWYgKGJmID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmRleCA9IGJmLmluZGV4O1xuICAgICAgdmFyIGRlcHRoID0gYmYuZGVwdGg7IC8vIHVuYXNzaWduZWQgbmVpZ2hib3VycyBzaG91bGRuJ3QgYWZmZWN0IHRoZSBvcmRlcmluZ1xuXG4gICAgICBpZiAoaW5kZXggPT0gbnVsbCB8fCBkZXB0aCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbkRlcHRoID0gZGVwdGhzW2RlcHRoXS5sZW5ndGg7XG5cbiAgICAgIGlmIChkZXB0aCA8IGVsZURlcHRoKSB7XG4gICAgICAgIC8vIG9ubHkgZ2V0IGluZmx1ZW5jZWQgYnkgZWxlbWVudHMgYWJvdmVcbiAgICAgICAgcGVyY2VudCArPSBpbmRleCAvIG5EZXB0aDtcbiAgICAgICAgc2FtcGxlcysrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNhbXBsZXMgPSBNYXRoLm1heCgxLCBzYW1wbGVzKTtcbiAgICBwZXJjZW50ID0gcGVyY2VudCAvIHNhbXBsZXM7XG5cbiAgICBpZiAoc2FtcGxlcyA9PT0gMCkge1xuICAgICAgLy8gcHV0IGxvbmUgbm9kZXMgYXQgdGhlIHN0YXJ0XG4gICAgICBwZXJjZW50ID0gMDtcbiAgICB9XG5cbiAgICBjYWNoZWRXZWlnaHRlZFBlcmNlbnRbZWxlLmlkKCldID0gcGVyY2VudDtcbiAgICByZXR1cm4gcGVyY2VudDtcbiAgfTsgLy8gcmVhcnJhbmdlIHRoZSBpbmRpY2VzIGluIGVhY2ggZGVwdGggbGV2ZWwgYmFzZWQgb24gY29ubmVjdGl2aXR5XG5cblxuICB2YXIgc29ydEZuID0gZnVuY3Rpb24gc29ydEZuKGEsIGIpIHtcbiAgICB2YXIgYXBjdCA9IGdldFdlaWdodGVkUGVyY2VudChhKTtcbiAgICB2YXIgYnBjdCA9IGdldFdlaWdodGVkUGVyY2VudChiKTtcbiAgICB2YXIgZGlmZiA9IGFwY3QgLSBicGN0O1xuXG4gICAgaWYgKGRpZmYgPT09IDApIHtcbiAgICAgIHJldHVybiBhc2NlbmRpbmcoYS5pZCgpLCBiLmlkKCkpOyAvLyBtYWtlIHN1cmUgc29ydCBkb2Vzbid0IGhhdmUgZG9uJ3QtY2FyZSBjb21wYXJpc29uc1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGlmZjtcbiAgICB9XG4gIH07XG5cbiAgaWYgKG9wdGlvbnMuZGVwdGhTb3J0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBzb3J0Rm4gPSBvcHRpb25zLmRlcHRoU29ydDtcbiAgfSAvLyBzb3J0IGVhY2ggbGV2ZWwgdG8gbWFrZSBjb25uZWN0ZWQgbm9kZXMgY2xvc2VyXG5cblxuICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBkZXB0aHMubGVuZ3RoOyBfaTYrKykge1xuICAgIGRlcHRoc1tfaTZdLnNvcnQoc29ydEZuKTtcblxuICAgIGFzc2lnbkRlcHRoc0F0KF9pNik7XG4gIH0gLy8gYXNzaWduIG9ycGhhbiBub2RlcyB0byBhIG5ldyB0b3AtbGV2ZWwgZGVwdGhcblxuXG4gIHZhciBvcnBoYW5EZXB0aCA9IFtdO1xuXG4gIGZvciAodmFyIF9pNyA9IDA7IF9pNyA8IG9ycGhhbk5vZGVzLmxlbmd0aDsgX2k3KyspIHtcbiAgICBvcnBoYW5EZXB0aC5wdXNoKG9ycGhhbk5vZGVzW19pN10pO1xuICB9XG5cbiAgZGVwdGhzLnVuc2hpZnQob3JwaGFuRGVwdGgpO1xuICBhc3NpZ25EZXB0aHMoKTtcbiAgdmFyIGJpZ2dlc3REZXB0aFNpemUgPSAwO1xuXG4gIGZvciAodmFyIF9pOCA9IDA7IF9pOCA8IGRlcHRocy5sZW5ndGg7IF9pOCsrKSB7XG4gICAgYmlnZ2VzdERlcHRoU2l6ZSA9IE1hdGgubWF4KGRlcHRoc1tfaThdLmxlbmd0aCwgYmlnZ2VzdERlcHRoU2l6ZSk7XG4gIH1cblxuICB2YXIgY2VudGVyID0ge1xuICAgIHg6IGJiLngxICsgYmIudyAvIDIsXG4gICAgeTogYmIueDEgKyBiYi5oIC8gMlxuICB9O1xuICB2YXIgbWF4RGVwdGhTaXplID0gZGVwdGhzLnJlZHVjZShmdW5jdGlvbiAobWF4LCBlbGVzKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1heCwgZWxlcy5sZW5ndGgpO1xuICB9LCAwKTtcblxuICB2YXIgZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbGUpIHtcbiAgICB2YXIgX2dldEluZm8yID0gZ2V0SW5mbyhlbGUpLFxuICAgICAgICBkZXB0aCA9IF9nZXRJbmZvMi5kZXB0aCxcbiAgICAgICAgaW5kZXggPSBfZ2V0SW5mbzIuaW5kZXg7XG5cbiAgICB2YXIgZGVwdGhTaXplID0gZGVwdGhzW2RlcHRoXS5sZW5ndGg7XG4gICAgdmFyIGRpc3RhbmNlWCA9IE1hdGgubWF4KGJiLncgLyAoKG9wdGlvbnMuZ3JpZCA/IG1heERlcHRoU2l6ZSA6IGRlcHRoU2l6ZSkgKyAxKSwgbWluRGlzdGFuY2UpO1xuICAgIHZhciBkaXN0YW5jZVkgPSBNYXRoLm1heChiYi5oIC8gKGRlcHRocy5sZW5ndGggKyAxKSwgbWluRGlzdGFuY2UpO1xuICAgIHZhciByYWRpdXNTdGVwU2l6ZSA9IE1hdGgubWluKGJiLncgLyAyIC8gZGVwdGhzLmxlbmd0aCwgYmIuaCAvIDIgLyBkZXB0aHMubGVuZ3RoKTtcbiAgICByYWRpdXNTdGVwU2l6ZSA9IE1hdGgubWF4KHJhZGl1c1N0ZXBTaXplLCBtaW5EaXN0YW5jZSk7XG5cbiAgICBpZiAoIW9wdGlvbnMuY2lyY2xlKSB7XG4gICAgICB2YXIgZXBvcyA9IHtcbiAgICAgICAgeDogY2VudGVyLnggKyAoaW5kZXggKyAxIC0gKGRlcHRoU2l6ZSArIDEpIC8gMikgKiBkaXN0YW5jZVgsXG4gICAgICAgIHk6IChkZXB0aCArIDEpICogZGlzdGFuY2VZXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGVwb3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByYWRpdXMgPSByYWRpdXNTdGVwU2l6ZSAqIGRlcHRoICsgcmFkaXVzU3RlcFNpemUgLSAoZGVwdGhzLmxlbmd0aCA+IDAgJiYgZGVwdGhzWzBdLmxlbmd0aCA8PSAzID8gcmFkaXVzU3RlcFNpemUgLyAyIDogMCk7XG4gICAgICB2YXIgdGhldGEgPSAyICogTWF0aC5QSSAvIGRlcHRoc1tkZXB0aF0ubGVuZ3RoICogaW5kZXg7XG5cbiAgICAgIGlmIChkZXB0aCA9PT0gMCAmJiBkZXB0aHNbMF0ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJhZGl1cyA9IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGNlbnRlci54ICsgcmFkaXVzICogTWF0aC5jb3ModGhldGEpLFxuICAgICAgICB5OiBjZW50ZXIueSArIHJhZGl1cyAqIE1hdGguc2luKHRoZXRhKVxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgZWxlcy5ub2RlcygpLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBnZXRQb3NpdGlvbik7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxudmFyIGRlZmF1bHRzJDYgPSB7XG4gIGZpdDogdHJ1ZSxcbiAgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICBwYWRkaW5nOiAzMCxcbiAgLy8gdGhlIHBhZGRpbmcgb24gZml0XG4gIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsXG4gIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICBhdm9pZE92ZXJsYXA6IHRydWUsXG4gIC8vIHByZXZlbnRzIG5vZGUgb3ZlcmxhcCwgbWF5IG92ZXJmbG93IGJvdW5kaW5nQm94IGFuZCByYWRpdXMgaWYgbm90IGVub3VnaCBzcGFjZVxuICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAvLyBFeGNsdWRlcyB0aGUgbGFiZWwgd2hlbiBjYWxjdWxhdGluZyBub2RlIGJvdW5kaW5nIGJveGVzIGZvciB0aGUgbGF5b3V0IGFsZ29yaXRobVxuICBzcGFjaW5nRmFjdG9yOiB1bmRlZmluZWQsXG4gIC8vIEFwcGxpZXMgYSBtdWx0aXBsaWNhdGl2ZSBmYWN0b3IgKD4wKSB0byBleHBhbmQgb3IgY29tcHJlc3MgdGhlIG92ZXJhbGwgYXJlYSB0aGF0IHRoZSBub2RlcyB0YWtlIHVwXG4gIHJhZGl1czogdW5kZWZpbmVkLFxuICAvLyB0aGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAgc3RhcnRBbmdsZTogMyAvIDIgKiBNYXRoLlBJLFxuICAvLyB3aGVyZSBub2RlcyBzdGFydCBpbiByYWRpYW5zXG4gIHN3ZWVwOiB1bmRlZmluZWQsXG4gIC8vIGhvdyBtYW55IHJhZGlhbnMgc2hvdWxkIGJlIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBsYXN0IG5vZGUgKGRlZmF1bHRzIHRvIGZ1bGwgY2lyY2xlKVxuICBjbG9ja3dpc2U6IHRydWUsXG4gIC8vIHdoZXRoZXIgdGhlIGxheW91dCBzaG91bGQgZ28gY2xvY2t3aXNlICh0cnVlKSBvciBjb3VudGVyY2xvY2t3aXNlL2FudGljbG9ja3dpc2UgKGZhbHNlKVxuICBzb3J0OiB1bmRlZmluZWQsXG4gIC8vIGEgc29ydGluZyBmdW5jdGlvbiB0byBvcmRlciB0aGUgbm9kZXM7IGUuZy4gZnVuY3Rpb24oYSwgYil7IHJldHVybiBhLmRhdGEoJ3dlaWdodCcpIC0gYi5kYXRhKCd3ZWlnaHQnKSB9XG4gIGFuaW1hdGU6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG4gIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWRcbiAgYW5pbWF0ZUZpbHRlcjogZnVuY3Rpb24gYW5pbWF0ZUZpbHRlcihub2RlLCBpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIC8vIGEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGFuaW1hdGVkLiAgQWxsIG5vZGVzIGFuaW1hdGVkIGJ5IGRlZmF1bHQgb24gYW5pbWF0ZSBlbmFibGVkLiAgTm9uLWFuaW1hdGVkIG5vZGVzIGFyZSBwb3NpdGlvbmVkIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGxheW91dCBzdGFydHNcbiAgcmVhZHk6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9IC8vIHRyYW5zZm9ybSBhIGdpdmVuIG5vZGUgcG9zaXRpb24uIFVzZWZ1bCBmb3IgY2hhbmdpbmcgZmxvdyBkaXJlY3Rpb24gaW4gZGlzY3JldGUgbGF5b3V0cyBcblxufTtcblxuZnVuY3Rpb24gQ2lyY2xlTGF5b3V0KG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cyQ2LCBvcHRpb25zKTtcbn1cblxuQ2lyY2xlTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0gcGFyYW1zO1xuICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgY2xvY2t3aXNlID0gb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlICE9PSB1bmRlZmluZWQgPyAhb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlIDogb3B0aW9ucy5jbG9ja3dpc2U7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcblxuICBpZiAob3B0aW9ucy5zb3J0KSB7XG4gICAgbm9kZXMgPSBub2Rlcy5zb3J0KG9wdGlvbnMuc29ydCk7XG4gIH1cblxuICB2YXIgYmIgPSBtYWtlQm91bmRpbmdCb3gob3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgeDE6IDAsXG4gICAgeTE6IDAsXG4gICAgdzogY3kud2lkdGgoKSxcbiAgICBoOiBjeS5oZWlnaHQoKVxuICB9KTtcbiAgdmFyIGNlbnRlciA9IHtcbiAgICB4OiBiYi54MSArIGJiLncgLyAyLFxuICAgIHk6IGJiLnkxICsgYmIuaCAvIDJcbiAgfTtcbiAgdmFyIHN3ZWVwID0gb3B0aW9ucy5zd2VlcCA9PT0gdW5kZWZpbmVkID8gMiAqIE1hdGguUEkgLSAyICogTWF0aC5QSSAvIG5vZGVzLmxlbmd0aCA6IG9wdGlvbnMuc3dlZXA7XG4gIHZhciBkVGhldGEgPSBzd2VlcCAvIE1hdGgubWF4KDEsIG5vZGVzLmxlbmd0aCAtIDEpO1xuICB2YXIgcjtcbiAgdmFyIG1pbkRpc3RhbmNlID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG4gPSBub2Rlc1tpXTtcbiAgICB2YXIgbmJiID0gbi5sYXlvdXREaW1lbnNpb25zKG9wdGlvbnMpO1xuICAgIHZhciB3ID0gbmJiLnc7XG4gICAgdmFyIGggPSBuYmIuaDtcbiAgICBtaW5EaXN0YW5jZSA9IE1hdGgubWF4KG1pbkRpc3RhbmNlLCB3LCBoKTtcbiAgfVxuXG4gIGlmIChudW1iZXIkMShvcHRpb25zLnJhZGl1cykpIHtcbiAgICByID0gb3B0aW9ucy5yYWRpdXM7XG4gIH0gZWxzZSBpZiAobm9kZXMubGVuZ3RoIDw9IDEpIHtcbiAgICByID0gMDtcbiAgfSBlbHNlIHtcbiAgICByID0gTWF0aC5taW4oYmIuaCwgYmIudykgLyAyIC0gbWluRGlzdGFuY2U7XG4gIH0gLy8gY2FsY3VsYXRlIHRoZSByYWRpdXNcblxuXG4gIGlmIChub2Rlcy5sZW5ndGggPiAxICYmIG9wdGlvbnMuYXZvaWRPdmVybGFwKSB7XG4gICAgLy8gYnV0IG9ubHkgaWYgbW9yZSB0aGFuIG9uZSBub2RlIChjYW4ndCBvdmVybGFwKVxuICAgIG1pbkRpc3RhbmNlICo9IDEuNzU7IC8vIGp1c3QgdG8gaGF2ZSBzb21lIG5pY2Ugc3BhY2luZ1xuXG4gICAgdmFyIGRjb3MgPSBNYXRoLmNvcyhkVGhldGEpIC0gTWF0aC5jb3MoMCk7XG4gICAgdmFyIGRzaW4gPSBNYXRoLnNpbihkVGhldGEpIC0gTWF0aC5zaW4oMCk7XG4gICAgdmFyIHJNaW4gPSBNYXRoLnNxcnQobWluRGlzdGFuY2UgKiBtaW5EaXN0YW5jZSAvIChkY29zICogZGNvcyArIGRzaW4gKiBkc2luKSk7IC8vIHMudC4gbm8gbm9kZXMgb3ZlcmxhcHBpbmdcblxuICAgIHIgPSBNYXRoLm1heChyTWluLCByKTtcbiAgfVxuXG4gIHZhciBnZXRQb3MgPSBmdW5jdGlvbiBnZXRQb3MoZWxlLCBpKSB7XG4gICAgdmFyIHRoZXRhID0gb3B0aW9ucy5zdGFydEFuZ2xlICsgaSAqIGRUaGV0YSAqIChjbG9ja3dpc2UgPyAxIDogLTEpO1xuICAgIHZhciByeCA9IHIgKiBNYXRoLmNvcyh0aGV0YSk7XG4gICAgdmFyIHJ5ID0gciAqIE1hdGguc2luKHRoZXRhKTtcbiAgICB2YXIgcG9zID0ge1xuICAgICAgeDogY2VudGVyLnggKyByeCxcbiAgICAgIHk6IGNlbnRlci55ICsgcnlcbiAgICB9O1xuICAgIHJldHVybiBwb3M7XG4gIH07XG5cbiAgZWxlcy5ub2RlcygpLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBnZXRQb3MpO1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbnZhciBkZWZhdWx0cyQ1ID0ge1xuICBmaXQ6IHRydWUsXG4gIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgcGFkZGluZzogMzAsXG4gIC8vIHRoZSBwYWRkaW5nIG9uIGZpdFxuICBzdGFydEFuZ2xlOiAzIC8gMiAqIE1hdGguUEksXG4gIC8vIHdoZXJlIG5vZGVzIHN0YXJ0IGluIHJhZGlhbnNcbiAgc3dlZXA6IHVuZGVmaW5lZCxcbiAgLy8gaG93IG1hbnkgcmFkaWFucyBzaG91bGQgYmUgYmV0d2VlbiB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9kZSAoZGVmYXVsdHMgdG8gZnVsbCBjaXJjbGUpXG4gIGNsb2Nrd2lzZTogdHJ1ZSxcbiAgLy8gd2hldGhlciB0aGUgbGF5b3V0IHNob3VsZCBnbyBjbG9ja3dpc2UgKHRydWUpIG9yIGNvdW50ZXJjbG9ja3dpc2UvYW50aWNsb2Nrd2lzZSAoZmFsc2UpXG4gIGVxdWlkaXN0YW50OiBmYWxzZSxcbiAgLy8gd2hldGhlciBsZXZlbHMgaGF2ZSBhbiBlcXVhbCByYWRpYWwgZGlzdGFuY2UgYmV0d2VuIHRoZW0sIG1heSBjYXVzZSBib3VuZGluZyBib3ggb3ZlcmZsb3dcbiAgbWluTm9kZVNwYWNpbmc6IDEwLFxuICAvLyBtaW4gc3BhY2luZyBiZXR3ZWVuIG91dHNpZGUgb2Ygbm9kZXMgKHVzZWQgZm9yIHJhZGl1cyBhZGp1c3RtZW50KVxuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLFxuICAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYXZvaWRPdmVybGFwOiB0cnVlLFxuICAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBpZiBub3QgZW5vdWdoIHNwYWNlXG4gIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2UsXG4gIC8vIEV4Y2x1ZGVzIHRoZSBsYWJlbCB3aGVuIGNhbGN1bGF0aW5nIG5vZGUgYm91bmRpbmcgYm94ZXMgZm9yIHRoZSBsYXlvdXQgYWxnb3JpdGhtXG4gIGhlaWdodDogdW5kZWZpbmVkLFxuICAvLyBoZWlnaHQgb2YgbGF5b3V0IGFyZWEgKG92ZXJyaWRlcyBjb250YWluZXIgaGVpZ2h0KVxuICB3aWR0aDogdW5kZWZpbmVkLFxuICAvLyB3aWR0aCBvZiBsYXlvdXQgYXJlYSAob3ZlcnJpZGVzIGNvbnRhaW5lciB3aWR0aClcbiAgc3BhY2luZ0ZhY3RvcjogdW5kZWZpbmVkLFxuICAvLyBBcHBsaWVzIGEgbXVsdGlwbGljYXRpdmUgZmFjdG9yICg+MCkgdG8gZXhwYW5kIG9yIGNvbXByZXNzIHRoZSBvdmVyYWxsIGFyZWEgdGhhdCB0aGUgbm9kZXMgdGFrZSB1cFxuICBjb25jZW50cmljOiBmdW5jdGlvbiBjb25jZW50cmljKG5vZGUpIHtcbiAgICAvLyByZXR1cm5zIG51bWVyaWMgdmFsdWUgZm9yIGVhY2ggbm9kZSwgcGxhY2luZyBoaWdoZXIgbm9kZXMgaW4gbGV2ZWxzIHRvd2FyZHMgdGhlIGNlbnRyZVxuICAgIHJldHVybiBub2RlLmRlZ3JlZSgpO1xuICB9LFxuICBsZXZlbFdpZHRoOiBmdW5jdGlvbiBsZXZlbFdpZHRoKG5vZGVzKSB7XG4gICAgLy8gdGhlIHZhcmlhdGlvbiBvZiBjb25jZW50cmljIHZhbHVlcyBpbiBlYWNoIGxldmVsXG4gICAgcmV0dXJuIG5vZGVzLm1heERlZ3JlZSgpIC8gNDtcbiAgfSxcbiAgYW5pbWF0ZTogZmFsc2UsXG4gIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgLy8gYSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWQuICBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWQuICBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICByZWFkeTogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0gLy8gdHJhbnNmb3JtIGEgZ2l2ZW4gbm9kZSBwb3NpdGlvbi4gVXNlZnVsIGZvciBjaGFuZ2luZyBmbG93IGRpcmVjdGlvbiBpbiBkaXNjcmV0ZSBsYXlvdXRzXG5cbn07XG5cbmZ1bmN0aW9uIENvbmNlbnRyaWNMYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJDUsIG9wdGlvbnMpO1xufVxuXG5Db25jZW50cmljTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0gcGFyYW1zO1xuICB2YXIgY2xvY2t3aXNlID0gb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlICE9PSB1bmRlZmluZWQgPyAhb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlIDogb3B0aW9ucy5jbG9ja3dpc2U7XG4gIHZhciBjeSA9IHBhcmFtcy5jeTtcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcbiAgdmFyIGJiID0gbWFrZUJvdW5kaW5nQm94KG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgIHgxOiAwLFxuICAgIHkxOiAwLFxuICAgIHc6IGN5LndpZHRoKCksXG4gICAgaDogY3kuaGVpZ2h0KClcbiAgfSk7XG4gIHZhciBjZW50ZXIgPSB7XG4gICAgeDogYmIueDEgKyBiYi53IC8gMixcbiAgICB5OiBiYi55MSArIGJiLmggLyAyXG4gIH07XG4gIHZhciBub2RlVmFsdWVzID0gW107IC8vIHsgbm9kZSwgdmFsdWUgfVxuXG4gIHZhciBtYXhOb2RlU2l6ZSA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgdmFyIHZhbHVlID0gdm9pZCAwOyAvLyBjYWxjdWxhdGUgdGhlIG5vZGUgdmFsdWVcblxuICAgIHZhbHVlID0gb3B0aW9ucy5jb25jZW50cmljKG5vZGUpO1xuICAgIG5vZGVWYWx1ZXMucHVzaCh7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBub2RlOiBub2RlXG4gICAgfSk7IC8vIGZvciBzdHlsZSBtYXBwaW5nXG5cbiAgICBub2RlLl9wcml2YXRlLnNjcmF0Y2guY29uY2VudHJpYyA9IHZhbHVlO1xuICB9IC8vIGluIGNhc2Ugd2UgdXNlZCB0aGUgYGNvbmNlbnRyaWNgIGluIHN0eWxlXG5cblxuICBub2Rlcy51cGRhdGVTdHlsZSgpOyAvLyBjYWxjdWxhdGUgbWF4IHNpemUgbm93IGJhc2VkIG9uIHBvdGVudGlhbGx5IHVwZGF0ZWQgbWFwcGVyc1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgX25vZGUgPSBub2Rlc1tfaV07XG5cbiAgICB2YXIgbmJiID0gX25vZGUubGF5b3V0RGltZW5zaW9ucyhvcHRpb25zKTtcblxuICAgIG1heE5vZGVTaXplID0gTWF0aC5tYXgobWF4Tm9kZVNpemUsIG5iYi53LCBuYmIuaCk7XG4gIH0gLy8gc29ydCBub2RlIHZhbHVlcyBpbiBkZXNjcmVhc2luZyBvcmRlclxuXG5cbiAgbm9kZVZhbHVlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIudmFsdWUgLSBhLnZhbHVlO1xuICB9KTtcbiAgdmFyIGxldmVsV2lkdGggPSBvcHRpb25zLmxldmVsV2lkdGgobm9kZXMpOyAvLyBwdXQgdGhlIHZhbHVlcyBpbnRvIGxldmVsc1xuXG4gIHZhciBsZXZlbHMgPSBbW11dO1xuICB2YXIgY3VycmVudExldmVsID0gbGV2ZWxzWzBdO1xuXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVWYWx1ZXMubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciB2YWwgPSBub2RlVmFsdWVzW19pMl07XG5cbiAgICBpZiAoY3VycmVudExldmVsLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBkaWZmID0gTWF0aC5hYnMoY3VycmVudExldmVsWzBdLnZhbHVlIC0gdmFsLnZhbHVlKTtcblxuICAgICAgaWYgKGRpZmYgPj0gbGV2ZWxXaWR0aCkge1xuICAgICAgICBjdXJyZW50TGV2ZWwgPSBbXTtcbiAgICAgICAgbGV2ZWxzLnB1c2goY3VycmVudExldmVsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50TGV2ZWwucHVzaCh2YWwpO1xuICB9IC8vIGNyZWF0ZSBwb3NpdGlvbnMgZnJvbSBsZXZlbHNcblxuXG4gIHZhciBtaW5EaXN0ID0gbWF4Tm9kZVNpemUgKyBvcHRpb25zLm1pbk5vZGVTcGFjaW5nOyAvLyBtaW4gZGlzdCBiZXR3ZWVuIG5vZGVzXG5cbiAgaWYgKCFvcHRpb25zLmF2b2lkT3ZlcmxhcCkge1xuICAgIC8vIHRoZW4gc3RyaWN0bHkgY29uc3RyYWluIHRvIGJiXG4gICAgdmFyIGZpcnN0THZsSGFzTXVsdGkgPSBsZXZlbHMubGVuZ3RoID4gMCAmJiBsZXZlbHNbMF0ubGVuZ3RoID4gMTtcbiAgICB2YXIgbWF4UiA9IE1hdGgubWluKGJiLncsIGJiLmgpIC8gMiAtIG1pbkRpc3Q7XG4gICAgdmFyIHJTdGVwID0gbWF4UiAvIChsZXZlbHMubGVuZ3RoICsgZmlyc3RMdmxIYXNNdWx0aSA/IDEgOiAwKTtcbiAgICBtaW5EaXN0ID0gTWF0aC5taW4obWluRGlzdCwgclN0ZXApO1xuICB9IC8vIGZpbmQgdGhlIG1ldHJpY3MgZm9yIGVhY2ggbGV2ZWxcblxuXG4gIHZhciByID0gMDtcblxuICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBsZXZlbHMubGVuZ3RoOyBfaTMrKykge1xuICAgIHZhciBsZXZlbCA9IGxldmVsc1tfaTNdO1xuICAgIHZhciBzd2VlcCA9IG9wdGlvbnMuc3dlZXAgPT09IHVuZGVmaW5lZCA/IDIgKiBNYXRoLlBJIC0gMiAqIE1hdGguUEkgLyBsZXZlbC5sZW5ndGggOiBvcHRpb25zLnN3ZWVwO1xuICAgIHZhciBkVGhldGEgPSBsZXZlbC5kVGhldGEgPSBzd2VlcCAvIE1hdGgubWF4KDEsIGxldmVsLmxlbmd0aCAtIDEpOyAvLyBjYWxjdWxhdGUgdGhlIHJhZGl1c1xuXG4gICAgaWYgKGxldmVsLmxlbmd0aCA+IDEgJiYgb3B0aW9ucy5hdm9pZE92ZXJsYXApIHtcbiAgICAgIC8vIGJ1dCBvbmx5IGlmIG1vcmUgdGhhbiBvbmUgbm9kZSAoY2FuJ3Qgb3ZlcmxhcClcbiAgICAgIHZhciBkY29zID0gTWF0aC5jb3MoZFRoZXRhKSAtIE1hdGguY29zKDApO1xuICAgICAgdmFyIGRzaW4gPSBNYXRoLnNpbihkVGhldGEpIC0gTWF0aC5zaW4oMCk7XG4gICAgICB2YXIgck1pbiA9IE1hdGguc3FydChtaW5EaXN0ICogbWluRGlzdCAvIChkY29zICogZGNvcyArIGRzaW4gKiBkc2luKSk7IC8vIHMudC4gbm8gbm9kZXMgb3ZlcmxhcHBpbmdcblxuICAgICAgciA9IE1hdGgubWF4KHJNaW4sIHIpO1xuICAgIH1cblxuICAgIGxldmVsLnIgPSByO1xuICAgIHIgKz0gbWluRGlzdDtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmVxdWlkaXN0YW50KSB7XG4gICAgdmFyIHJEZWx0YU1heCA9IDA7XG4gICAgdmFyIF9yID0gMDtcblxuICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGxldmVscy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICB2YXIgX2xldmVsID0gbGV2ZWxzW19pNF07XG4gICAgICB2YXIgckRlbHRhID0gX2xldmVsLnIgLSBfcjtcbiAgICAgIHJEZWx0YU1heCA9IE1hdGgubWF4KHJEZWx0YU1heCwgckRlbHRhKTtcbiAgICB9XG5cbiAgICBfciA9IDA7XG5cbiAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBsZXZlbHMubGVuZ3RoOyBfaTUrKykge1xuICAgICAgdmFyIF9sZXZlbDIgPSBsZXZlbHNbX2k1XTtcblxuICAgICAgaWYgKF9pNSA9PT0gMCkge1xuICAgICAgICBfciA9IF9sZXZlbDIucjtcbiAgICAgIH1cblxuICAgICAgX2xldmVsMi5yID0gX3I7XG4gICAgICBfciArPSByRGVsdGFNYXg7XG4gICAgfVxuICB9IC8vIGNhbGN1bGF0ZSB0aGUgbm9kZSBwb3NpdGlvbnNcblxuXG4gIHZhciBwb3MgPSB7fTsgLy8gaWQgPT4gcG9zaXRpb25cblxuICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBsZXZlbHMubGVuZ3RoOyBfaTYrKykge1xuICAgIHZhciBfbGV2ZWwzID0gbGV2ZWxzW19pNl07XG4gICAgdmFyIF9kVGhldGEgPSBfbGV2ZWwzLmRUaGV0YTtcbiAgICB2YXIgX3IyID0gX2xldmVsMy5yO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBfbGV2ZWwzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgX3ZhbCA9IF9sZXZlbDNbal07XG4gICAgICB2YXIgdGhldGEgPSBvcHRpb25zLnN0YXJ0QW5nbGUgKyAoY2xvY2t3aXNlID8gMSA6IC0xKSAqIF9kVGhldGEgKiBqO1xuICAgICAgdmFyIHAgPSB7XG4gICAgICAgIHg6IGNlbnRlci54ICsgX3IyICogTWF0aC5jb3ModGhldGEpLFxuICAgICAgICB5OiBjZW50ZXIueSArIF9yMiAqIE1hdGguc2luKHRoZXRhKVxuICAgICAgfTtcbiAgICAgIHBvc1tfdmFsLm5vZGUuaWQoKV0gPSBwO1xuICAgIH1cbiAgfSAvLyBwb3NpdGlvbiB0aGUgbm9kZXNcblxuXG4gIGVsZXMubm9kZXMoKS5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgIHJldHVybiBwb3NbaWRdO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG4vKlxuVGhlIENvU0UgbGF5b3V0IHdhcyB3cml0dGVuIGJ5IEdlcmFyZG8gSHVjay5cbmh0dHBzOi8vd3d3LmxpbmtlZGluLmNvbS9pbi9nZXJhcmRvaHVjay9cblxuQmFzZWQgb24gdGhlIGZvbGxvd2luZyBhcnRpY2xlOlxuaHR0cDovL2RsLmFjbS5vcmcvY2l0YXRpb24uY2ZtP2lkPTE0OTgwNDdcblxuTW9kaWZpY2F0aW9ucyB0cmFja2VkIG9uIEdpdGh1Yi5cbiovXG52YXIgREVCVUc7XG4vKipcbiAqIEBicmllZiA6ICBkZWZhdWx0IGxheW91dCBvcHRpb25zXG4gKi9cblxudmFyIGRlZmF1bHRzJDQgPSB7XG4gIC8vIENhbGxlZCBvbiBgbGF5b3V0cmVhZHlgXG4gIHJlYWR5OiBmdW5jdGlvbiByZWFkeSgpIHt9LFxuICAvLyBDYWxsZWQgb24gYGxheW91dHN0b3BgXG4gIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7fSxcbiAgLy8gV2hldGhlciB0byBhbmltYXRlIHdoaWxlIHJ1bm5pbmcgdGhlIGxheW91dFxuICAvLyB0cnVlIDogQW5pbWF0ZSBjb250aW51b3VzbHkgYXMgdGhlIGxheW91dCBpcyBydW5uaW5nXG4gIC8vIGZhbHNlIDogSnVzdCBzaG93IHRoZSBlbmQgcmVzdWx0XG4gIC8vICdlbmQnIDogQW5pbWF0ZSB3aXRoIHRoZSBlbmQgcmVzdWx0LCBmcm9tIHRoZSBpbml0aWFsIHBvc2l0aW9ucyB0byB0aGUgZW5kIHBvc2l0aW9uc1xuICBhbmltYXRlOiB0cnVlLFxuICAvLyBFYXNpbmcgb2YgdGhlIGFuaW1hdGlvbiBmb3IgYW5pbWF0ZTonZW5kJ1xuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgLy8gVGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gZm9yIGFuaW1hdGU6J2VuZCdcbiAgYW5pbWF0aW9uRHVyYXRpb246IHVuZGVmaW5lZCxcbiAgLy8gQSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWRcbiAgLy8gQWxsIG5vZGVzIGFuaW1hdGVkIGJ5IGRlZmF1bHQgb24gYW5pbWF0ZSBlbmFibGVkXG4gIC8vIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAvLyBUaGUgbGF5b3V0IGFuaW1hdGVzIG9ubHkgYWZ0ZXIgdGhpcyBtYW55IG1pbGxpc2Vjb25kcyBmb3IgYW5pbWF0ZTp0cnVlXG4gIC8vIChwcmV2ZW50cyBmbGFzaGluZyBvbiBmYXN0IHJ1bnMpXG4gIGFuaW1hdGlvblRocmVzaG9sZDogMjUwLFxuICAvLyBOdW1iZXIgb2YgaXRlcmF0aW9ucyBiZXR3ZWVuIGNvbnNlY3V0aXZlIHNjcmVlbiBwb3NpdGlvbnMgdXBkYXRlXG4gIHJlZnJlc2g6IDIwLFxuICAvLyBXaGV0aGVyIHRvIGZpdCB0aGUgbmV0d29yayB2aWV3IGFmdGVyIHdoZW4gZG9uZVxuICBmaXQ6IHRydWUsXG4gIC8vIFBhZGRpbmcgb24gZml0XG4gIHBhZGRpbmc6IDMwLFxuICAvLyBDb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCxcbiAgLy8gRXhjbHVkZXMgdGhlIGxhYmVsIHdoZW4gY2FsY3VsYXRpbmcgbm9kZSBib3VuZGluZyBib3hlcyBmb3IgdGhlIGxheW91dCBhbGdvcml0aG1cbiAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiBmYWxzZSxcbiAgLy8gUmFuZG9taXplIHRoZSBpbml0aWFsIHBvc2l0aW9ucyBvZiB0aGUgbm9kZXMgKHRydWUpIG9yIHVzZSBleGlzdGluZyBwb3NpdGlvbnMgKGZhbHNlKVxuICByYW5kb21pemU6IGZhbHNlLFxuICAvLyBFeHRyYSBzcGFjaW5nIGJldHdlZW4gY29tcG9uZW50cyBpbiBub24tY29tcG91bmQgZ3JhcGhzXG4gIGNvbXBvbmVudFNwYWNpbmc6IDQwLFxuICAvLyBOb2RlIHJlcHVsc2lvbiAobm9uIG92ZXJsYXBwaW5nKSBtdWx0aXBsaWVyXG4gIG5vZGVSZXB1bHNpb246IGZ1bmN0aW9uIG5vZGVSZXB1bHNpb24obm9kZSkge1xuICAgIHJldHVybiAyMDQ4O1xuICB9LFxuICAvLyBOb2RlIHJlcHVsc2lvbiAob3ZlcmxhcHBpbmcpIG11bHRpcGxpZXJcbiAgbm9kZU92ZXJsYXA6IDQsXG4gIC8vIElkZWFsIGVkZ2UgKG5vbiBuZXN0ZWQpIGxlbmd0aFxuICBpZGVhbEVkZ2VMZW5ndGg6IGZ1bmN0aW9uIGlkZWFsRWRnZUxlbmd0aChlZGdlKSB7XG4gICAgcmV0dXJuIDMyO1xuICB9LFxuICAvLyBEaXZpc29yIHRvIGNvbXB1dGUgZWRnZSBmb3JjZXNcbiAgZWRnZUVsYXN0aWNpdHk6IGZ1bmN0aW9uIGVkZ2VFbGFzdGljaXR5KGVkZ2UpIHtcbiAgICByZXR1cm4gMzI7XG4gIH0sXG4gIC8vIE5lc3RpbmcgZmFjdG9yIChtdWx0aXBsaWVyKSB0byBjb21wdXRlIGlkZWFsIGVkZ2UgbGVuZ3RoIGZvciBuZXN0ZWQgZWRnZXNcbiAgbmVzdGluZ0ZhY3RvcjogMS4yLFxuICAvLyBHcmF2aXR5IGZvcmNlIChjb25zdGFudClcbiAgZ3Jhdml0eTogMSxcbiAgLy8gTWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtXG4gIG51bUl0ZXI6IDEwMDAsXG4gIC8vIEluaXRpYWwgdGVtcGVyYXR1cmUgKG1heGltdW0gbm9kZSBkaXNwbGFjZW1lbnQpXG4gIGluaXRpYWxUZW1wOiAxMDAwLFxuICAvLyBDb29saW5nIGZhY3RvciAoaG93IHRoZSB0ZW1wZXJhdHVyZSBpcyByZWR1Y2VkIGJldHdlZW4gY29uc2VjdXRpdmUgaXRlcmF0aW9uc1xuICBjb29saW5nRmFjdG9yOiAwLjk5LFxuICAvLyBMb3dlciB0ZW1wZXJhdHVyZSB0aHJlc2hvbGQgKGJlbG93IHRoaXMgcG9pbnQgdGhlIGxheW91dCB3aWxsIGVuZClcbiAgbWluVGVtcDogMS4wXG59O1xuLyoqXG4gKiBAYnJpZWYgICAgICAgOiBjb25zdHJ1Y3RvclxuICogQGFyZyBvcHRpb25zIDogb2JqZWN0IGNvbnRhaW5pbmcgbGF5b3V0IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBDb3NlTGF5b3V0KG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cyQ0LCBvcHRpb25zKTtcbiAgdGhpcy5vcHRpb25zLmxheW91dCA9IHRoaXM7XG59XG4vKipcbiAqIEBicmllZiA6IHJ1bnMgdGhlIGxheW91dFxuICovXG5cblxuQ29zZUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIGN5ID0gb3B0aW9ucy5jeTtcbiAgdmFyIGxheW91dCA9IHRoaXM7XG4gIGxheW91dC5zdG9wcGVkID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gdHJ1ZSB8fCBvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlKSB7XG4gICAgbGF5b3V0LmVtaXQoe1xuICAgICAgdHlwZTogJ2xheW91dHN0YXJ0JyxcbiAgICAgIGxheW91dDogbGF5b3V0XG4gICAgfSk7XG4gIH0gLy8gU2V0IERFQlVHIC0gR2xvYmFsIHZhcmlhYmxlXG5cblxuICBpZiAodHJ1ZSA9PT0gb3B0aW9ucy5kZWJ1Zykge1xuICAgIERFQlVHID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBERUJVRyA9IGZhbHNlO1xuICB9IC8vIEluaXRpYWxpemUgbGF5b3V0IGluZm9cblxuXG4gIHZhciBsYXlvdXRJbmZvID0gY3JlYXRlTGF5b3V0SW5mbyhjeSwgbGF5b3V0LCBvcHRpb25zKTsgLy8gU2hvdyBMYXlvdXRJbmZvIGNvbnRlbnRzIGlmIGRlYnVnZ2luZ1xuXG4gIGlmIChERUJVRykge1xuICAgIHByaW50TGF5b3V0SW5mbyhsYXlvdXRJbmZvKTtcbiAgfSAvLyBJZiByZXF1aXJlZCwgcmFuZG9taXplIG5vZGUgcG9zaXRpb25zXG5cblxuICBpZiAob3B0aW9ucy5yYW5kb21pemUpIHtcbiAgICByYW5kb21pemVQb3NpdGlvbnMobGF5b3V0SW5mbyk7XG4gIH1cblxuICB2YXIgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcblxuICB2YXIgcmVmcmVzaCA9IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgcmVmcmVzaFBvc2l0aW9ucyhsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucyk7IC8vIEZpdCB0aGUgZ3JhcGggaWYgbmVjZXNzYXJ5XG5cbiAgICBpZiAodHJ1ZSA9PT0gb3B0aW9ucy5maXQpIHtcbiAgICAgIGN5LmZpdChvcHRpb25zLnBhZGRpbmcpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgbWFpbkxvb3AgPSBmdW5jdGlvbiBtYWluTG9vcChpKSB7XG4gICAgaWYgKGxheW91dC5zdG9wcGVkIHx8IGkgPj0gb3B0aW9ucy5udW1JdGVyKSB7XG4gICAgICAvLyBsb2dEZWJ1ZyhcIkxheW91dCBtYW51YWxseSBzdG9wcGVkLiBTdG9wcGluZyBjb21wdXRhdGlvbiBpbiBzdGVwIFwiICsgaSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBEbyBvbmUgc3RlcCBpbiB0aGUgcGhpc2ljYWwgc2ltdWxhdGlvblxuXG5cbiAgICBzdGVwKGxheW91dEluZm8sIG9wdGlvbnMpOyAvLyBVcGRhdGUgdGVtcGVyYXR1cmVcblxuICAgIGxheW91dEluZm8udGVtcGVyYXR1cmUgPSBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlICogb3B0aW9ucy5jb29saW5nRmFjdG9yOyAvLyBsb2dEZWJ1ZyhcIk5ldyB0ZW1wZXJhdHVyZTogXCIgKyBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlKTtcblxuICAgIGlmIChsYXlvdXRJbmZvLnRlbXBlcmF0dXJlIDwgb3B0aW9ucy5taW5UZW1wKSB7XG4gICAgICAvLyBsb2dEZWJ1ZyhcIlRlbXBlcmF0dXJlIGRyb3AgYmVsb3cgbWluaW11bSB0aHJlc2hvbGQuIFN0b3BwaW5nIGNvbXB1dGF0aW9uIGluIHN0ZXAgXCIgKyBpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICB2YXIgZG9uZSA9IGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgaWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gdHJ1ZSB8fCBvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlKSB7XG4gICAgICByZWZyZXNoKCk7IC8vIExheW91dCBoYXMgZmluaXNoZWRcblxuICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICBsYXlvdXQuZW1pdCh7XG4gICAgICAgIHR5cGU6ICdsYXlvdXRzdG9wJyxcbiAgICAgICAgbGF5b3V0OiBsYXlvdXRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbm9kZXMgPSBvcHRpb25zLmVsZXMubm9kZXMoKTtcbiAgICAgIHZhciBnZXRTY2FsZWRQb3MgPSBnZXRTY2FsZUluQm91bmRzRm4obGF5b3V0SW5mbywgb3B0aW9ucywgbm9kZXMpO1xuICAgICAgbm9kZXMubGF5b3V0UG9zaXRpb25zKGxheW91dCwgb3B0aW9ucywgZ2V0U2NhbGVkUG9zKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGkgPSAwO1xuICB2YXIgbG9vcFJldCA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gdHJ1ZSkge1xuICAgIHZhciBmcmFtZSA9IGZ1bmN0aW9uIGZyYW1lKCkge1xuICAgICAgdmFyIGYgPSAwO1xuXG4gICAgICB3aGlsZSAobG9vcFJldCAmJiBmIDwgb3B0aW9ucy5yZWZyZXNoKSB7XG4gICAgICAgIGxvb3BSZXQgPSBtYWluTG9vcChpKTtcbiAgICAgICAgaSsrO1xuICAgICAgICBmKys7XG4gICAgICB9XG5cbiAgICAgIGlmICghbG9vcFJldCkge1xuICAgICAgICAvLyBpdCdzIGRvbmVcbiAgICAgICAgc2VwYXJhdGVDb21wb25lbnRzKGxheW91dEluZm8sIG9wdGlvbnMpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2VOb3coKTtcblxuICAgICAgICBpZiAobm93IC0gc3RhcnRUaW1lID49IG9wdGlvbnMuYW5pbWF0aW9uVGhyZXNob2xkKSB7XG4gICAgICAgICAgcmVmcmVzaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnJhbWUoKTtcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAobG9vcFJldCkge1xuICAgICAgbG9vcFJldCA9IG1haW5Mb29wKGkpO1xuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHNlcGFyYXRlQ29tcG9uZW50cyhsYXlvdXRJbmZvLCBvcHRpb25zKTtcbiAgICBkb25lKCk7XG4gIH1cblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG4vKipcbiAqIEBicmllZiA6IGNhbGxlZCBvbiBjb250aW51b3VzIGxheW91dHMgdG8gc3RvcCB0aGVtIGJlZm9yZSB0aGV5IGZpbmlzaFxuICovXG5cblxuQ29zZUxheW91dC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcblxuICBpZiAodGhpcy50aHJlYWQpIHtcbiAgICB0aGlzLnRocmVhZC5zdG9wKCk7XG4gIH1cblxuICB0aGlzLmVtaXQoJ2xheW91dHN0b3AnKTtcbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG5Db3NlTGF5b3V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy50aHJlYWQpIHtcbiAgICB0aGlzLnRocmVhZC5zdG9wKCk7XG4gIH1cblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG4vKipcbiAqIEBicmllZiAgICAgOiBDcmVhdGVzIGFuIG9iamVjdCB3aGljaCBpcyBjb250YWlucyBhbGwgdGhlIGRhdGFcbiAqICAgICAgICAgICAgICB1c2VkIGluIHRoZSBsYXlvdXQgcHJvY2Vzc1xuICogQGFyZyBjeSAgICA6IGN5dG9zY2FwZS5qcyBvYmplY3RcbiAqIEByZXR1cm4gICAgOiBsYXlvdXRJbmZvIG9iamVjdCBpbml0aWFsaXplZFxuICovXG5cblxudmFyIGNyZWF0ZUxheW91dEluZm8gPSBmdW5jdGlvbiBjcmVhdGVMYXlvdXRJbmZvKGN5LCBsYXlvdXQsIG9wdGlvbnMpIHtcbiAgLy8gU2hvcnRjdXRcbiAgdmFyIGVkZ2VzID0gb3B0aW9ucy5lbGVzLmVkZ2VzKCk7XG4gIHZhciBub2RlcyA9IG9wdGlvbnMuZWxlcy5ub2RlcygpO1xuICB2YXIgYmIgPSBtYWtlQm91bmRpbmdCb3gob3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgeDE6IDAsXG4gICAgeTE6IDAsXG4gICAgdzogY3kud2lkdGgoKSxcbiAgICBoOiBjeS5oZWlnaHQoKVxuICB9KTtcbiAgdmFyIGxheW91dEluZm8gPSB7XG4gICAgaXNDb21wb3VuZDogY3kuaGFzQ29tcG91bmROb2RlcygpLFxuICAgIGxheW91dE5vZGVzOiBbXSxcbiAgICBpZFRvSW5kZXg6IHt9LFxuICAgIG5vZGVTaXplOiBub2Rlcy5zaXplKCksXG4gICAgZ3JhcGhTZXQ6IFtdLFxuICAgIGluZGV4VG9HcmFwaDogW10sXG4gICAgbGF5b3V0RWRnZXM6IFtdLFxuICAgIGVkZ2VTaXplOiBlZGdlcy5zaXplKCksXG4gICAgdGVtcGVyYXR1cmU6IG9wdGlvbnMuaW5pdGlhbFRlbXAsXG4gICAgY2xpZW50V2lkdGg6IGJiLncsXG4gICAgY2xpZW50SGVpZ2h0OiBiYi5oLFxuICAgIGJvdW5kaW5nQm94OiBiYlxuICB9O1xuICB2YXIgY29tcG9uZW50cyA9IG9wdGlvbnMuZWxlcy5jb21wb25lbnRzKCk7XG4gIHZhciBpZDJjbXB0SWQgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29tcG9uZW50Lmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbm9kZSA9IGNvbXBvbmVudFtqXTtcbiAgICAgIGlkMmNtcHRJZFtub2RlLmlkKCldID0gaTtcbiAgICB9XG4gIH0gLy8gSXRlcmF0ZSBvdmVyIGFsbCBub2RlcywgY3JlYXRpbmcgbGF5b3V0IG5vZGVzXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgIHZhciBuID0gbm9kZXNbaV07XG4gICAgdmFyIG5iYiA9IG4ubGF5b3V0RGltZW5zaW9ucyhvcHRpb25zKTtcbiAgICB2YXIgdGVtcE5vZGUgPSB7fTtcbiAgICB0ZW1wTm9kZS5pc0xvY2tlZCA9IG4ubG9ja2VkKCk7XG4gICAgdGVtcE5vZGUuaWQgPSBuLmRhdGEoJ2lkJyk7XG4gICAgdGVtcE5vZGUucGFyZW50SWQgPSBuLmRhdGEoJ3BhcmVudCcpO1xuICAgIHRlbXBOb2RlLmNtcHRJZCA9IGlkMmNtcHRJZFtuLmlkKCldO1xuICAgIHRlbXBOb2RlLmNoaWxkcmVuID0gW107XG4gICAgdGVtcE5vZGUucG9zaXRpb25YID0gbi5wb3NpdGlvbigneCcpO1xuICAgIHRlbXBOb2RlLnBvc2l0aW9uWSA9IG4ucG9zaXRpb24oJ3knKTtcbiAgICB0ZW1wTm9kZS5vZmZzZXRYID0gMDtcbiAgICB0ZW1wTm9kZS5vZmZzZXRZID0gMDtcbiAgICB0ZW1wTm9kZS5oZWlnaHQgPSBuYmIudztcbiAgICB0ZW1wTm9kZS53aWR0aCA9IG5iYi5oO1xuICAgIHRlbXBOb2RlLm1heFggPSB0ZW1wTm9kZS5wb3NpdGlvblggKyB0ZW1wTm9kZS53aWR0aCAvIDI7XG4gICAgdGVtcE5vZGUubWluWCA9IHRlbXBOb2RlLnBvc2l0aW9uWCAtIHRlbXBOb2RlLndpZHRoIC8gMjtcbiAgICB0ZW1wTm9kZS5tYXhZID0gdGVtcE5vZGUucG9zaXRpb25ZICsgdGVtcE5vZGUuaGVpZ2h0IC8gMjtcbiAgICB0ZW1wTm9kZS5taW5ZID0gdGVtcE5vZGUucG9zaXRpb25ZIC0gdGVtcE5vZGUuaGVpZ2h0IC8gMjtcbiAgICB0ZW1wTm9kZS5wYWRMZWZ0ID0gcGFyc2VGbG9hdChuLnN0eWxlKCdwYWRkaW5nJykpO1xuICAgIHRlbXBOb2RlLnBhZFJpZ2h0ID0gcGFyc2VGbG9hdChuLnN0eWxlKCdwYWRkaW5nJykpO1xuICAgIHRlbXBOb2RlLnBhZFRvcCA9IHBhcnNlRmxvYXQobi5zdHlsZSgncGFkZGluZycpKTtcbiAgICB0ZW1wTm9kZS5wYWRCb3R0b20gPSBwYXJzZUZsb2F0KG4uc3R5bGUoJ3BhZGRpbmcnKSk7IC8vIGZvcmNlc1xuXG4gICAgdGVtcE5vZGUubm9kZVJlcHVsc2lvbiA9IGZuJDYob3B0aW9ucy5ub2RlUmVwdWxzaW9uKSA/IG9wdGlvbnMubm9kZVJlcHVsc2lvbihuKSA6IG9wdGlvbnMubm9kZVJlcHVsc2lvbjsgLy8gQWRkIG5ldyBub2RlXG5cbiAgICBsYXlvdXRJbmZvLmxheW91dE5vZGVzLnB1c2godGVtcE5vZGUpOyAvLyBBZGQgZW50cnkgdG8gaWQtaW5kZXggbWFwXG5cbiAgICBsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wTm9kZS5pZF0gPSBpO1xuICB9IC8vIElubGluZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHF1ZXVlLCB1c2VkIGZvciB0cmF2ZXJzaW5nIHRoZSBncmFwaCBpbiBCRlMgb3JkZXJcblxuXG4gIHZhciBxdWV1ZSA9IFtdO1xuICB2YXIgc3RhcnQgPSAwOyAvLyBQb2ludHMgdG8gdGhlIHN0YXJ0IHRoZSBxdWV1ZVxuXG4gIHZhciBlbmQgPSAtMTsgLy8gUG9pbnRzIHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlXG5cbiAgdmFyIHRlbXBHcmFwaCA9IFtdOyAvLyBTZWNvbmQgcGFzcyB0byBhZGQgY2hpbGQgaW5mb3JtYXRpb24gYW5kXG4gIC8vIGluaXRpYWxpemUgcXVldWUgZm9yIGhpZXJhcmNoaWNhbCB0cmF2ZXJzYWxcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcbiAgICB2YXIgcF9pZCA9IG4ucGFyZW50SWQ7IC8vIENoZWNrIGlmIG5vZGUgbiBoYXMgYSBwYXJlbnQgbm9kZVxuXG4gICAgaWYgKG51bGwgIT0gcF9pZCkge1xuICAgICAgLy8gQWRkIG5vZGUgSWQgdG8gcGFyZW50J3MgbGlzdCBvZiBjaGlsZHJlblxuICAgICAgbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtwX2lkXV0uY2hpbGRyZW4ucHVzaChuLmlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgYSBub2RlIGRvZXNuJ3QgaGF2ZSBhIHBhcmVudCwgdGhlbiBpdCdzIGluIHRoZSByb290IGdyYXBoXG4gICAgICBxdWV1ZVsrK2VuZF0gPSBuLmlkO1xuICAgICAgdGVtcEdyYXBoLnB1c2gobi5pZCk7XG4gICAgfVxuICB9IC8vIEFkZCByb290IGdyYXBoIHRvIGdyYXBoU2V0XG5cblxuICBsYXlvdXRJbmZvLmdyYXBoU2V0LnB1c2godGVtcEdyYXBoKTsgLy8gVHJhdmVyc2UgdGhlIGdyYXBoLCBsZXZlbCBieSBsZXZlbCxcblxuICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgLy8gR2V0IHRoZSBub2RlIHRvIHZpc2l0IGFuZCByZW1vdmUgaXQgZnJvbSBxdWV1ZVxuICAgIHZhciBub2RlX2lkID0gcXVldWVbc3RhcnQrK107XG4gICAgdmFyIG5vZGVfaXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlX2lkXTtcbiAgICB2YXIgbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbm9kZV9peF07XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcblxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBBZGQgY2hpbGRyZW4gbm9kZXMgYXMgYSBuZXcgZ3JhcGggdG8gZ3JhcGggc2V0XG4gICAgICBsYXlvdXRJbmZvLmdyYXBoU2V0LnB1c2goY2hpbGRyZW4pOyAvLyBBZGQgY2hpbGRyZW4gdG8gcXVlIHF1ZXVlIHRvIGJlIHZpc2l0ZWRcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBxdWV1ZVsrK2VuZF0gPSBjaGlsZHJlbltpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ3JlYXRlIGluZGV4VG9HcmFwaCBtYXBcblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ncmFwaFNldC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBncmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbaV07XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdyYXBoLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgaW5kZXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFtqXV07XG4gICAgICBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFtpbmRleF0gPSBpO1xuICAgIH1cbiAgfSAvLyBJdGVyYXRlIG92ZXIgYWxsIGVkZ2VzLCBjcmVhdGluZyBMYXlvdXQgRWRnZXNcblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5lZGdlU2l6ZTsgaSsrKSB7XG4gICAgdmFyIGUgPSBlZGdlc1tpXTtcbiAgICB2YXIgdGVtcEVkZ2UgPSB7fTtcbiAgICB0ZW1wRWRnZS5pZCA9IGUuZGF0YSgnaWQnKTtcbiAgICB0ZW1wRWRnZS5zb3VyY2VJZCA9IGUuZGF0YSgnc291cmNlJyk7XG4gICAgdGVtcEVkZ2UudGFyZ2V0SWQgPSBlLmRhdGEoJ3RhcmdldCcpOyAvLyBDb21wdXRlIGlkZWFsIGxlbmd0aFxuXG4gICAgdmFyIGlkZWFsTGVuZ3RoID0gZm4kNihvcHRpb25zLmlkZWFsRWRnZUxlbmd0aCkgPyBvcHRpb25zLmlkZWFsRWRnZUxlbmd0aChlKSA6IG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoO1xuICAgIHZhciBlbGFzdGljaXR5ID0gZm4kNihvcHRpb25zLmVkZ2VFbGFzdGljaXR5KSA/IG9wdGlvbnMuZWRnZUVsYXN0aWNpdHkoZSkgOiBvcHRpb25zLmVkZ2VFbGFzdGljaXR5OyAvLyBDaGVjayBpZiBpdCdzIGFuIGludGVyIGdyYXBoIGVkZ2VcblxuICAgIHZhciBzb3VyY2VJeCA9IGxheW91dEluZm8uaWRUb0luZGV4W3RlbXBFZGdlLnNvdXJjZUlkXTtcbiAgICB2YXIgdGFyZ2V0SXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wRWRnZS50YXJnZXRJZF07XG4gICAgdmFyIHNvdXJjZUdyYXBoID0gbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbc291cmNlSXhdO1xuICAgIHZhciB0YXJnZXRHcmFwaCA9IGxheW91dEluZm8uaW5kZXhUb0dyYXBoW3RhcmdldEl4XTtcblxuICAgIGlmIChzb3VyY2VHcmFwaCAhPSB0YXJnZXRHcmFwaCkge1xuICAgICAgLy8gRmluZCBsb3dlc3QgY29tbW9uIGdyYXBoIGFuY2VzdG9yXG4gICAgICB2YXIgbGNhID0gZmluZExDQSh0ZW1wRWRnZS5zb3VyY2VJZCwgdGVtcEVkZ2UudGFyZ2V0SWQsIGxheW91dEluZm8pOyAvLyBDb21wdXRlIHN1bSBvZiBub2RlIGRlcHRocywgcmVsYXRpdmUgdG8gbGNhIGdyYXBoXG5cbiAgICAgIHZhciBsY2FHcmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbbGNhXTtcbiAgICAgIHZhciBkZXB0aCA9IDA7IC8vIFNvdXJjZSBkZXB0aFxuXG4gICAgICB2YXIgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3NvdXJjZUl4XTtcblxuICAgICAgd2hpbGUgKC0xID09PSBsY2FHcmFwaC5pbmRleE9mKHRlbXBOb2RlLmlkKSkge1xuICAgICAgICB0ZW1wTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcE5vZGUucGFyZW50SWRdXTtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH0gLy8gVGFyZ2V0IGRlcHRoXG5cblxuICAgICAgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3RhcmdldEl4XTtcblxuICAgICAgd2hpbGUgKC0xID09PSBsY2FHcmFwaC5pbmRleE9mKHRlbXBOb2RlLmlkKSkge1xuICAgICAgICB0ZW1wTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcE5vZGUucGFyZW50SWRdXTtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH0gLy8gbG9nRGVidWcoJ0xDQSBvZiBub2RlcyAnICsgdGVtcEVkZ2Uuc291cmNlSWQgKyAnIGFuZCAnICsgdGVtcEVkZ2UudGFyZ2V0SWQgK1xuICAgICAgLy8gIFwiLiBJbmRleDogXCIgKyBsY2EgKyBcIiBDb250ZW50czogXCIgKyBsY2FHcmFwaC50b1N0cmluZygpICtcbiAgICAgIC8vICBcIi4gRGVwdGg6IFwiICsgZGVwdGgpO1xuICAgICAgLy8gVXBkYXRlIGlkZWFsTGVuZ3RoXG5cblxuICAgICAgaWRlYWxMZW5ndGggKj0gZGVwdGggKiBvcHRpb25zLm5lc3RpbmdGYWN0b3I7XG4gICAgfVxuXG4gICAgdGVtcEVkZ2UuaWRlYWxMZW5ndGggPSBpZGVhbExlbmd0aDtcbiAgICB0ZW1wRWRnZS5lbGFzdGljaXR5ID0gZWxhc3RpY2l0eTtcbiAgICBsYXlvdXRJbmZvLmxheW91dEVkZ2VzLnB1c2godGVtcEVkZ2UpO1xuICB9IC8vIEZpbmFsbHksIHJldHVybiBsYXlvdXRJbmZvIG9iamVjdFxuXG5cbiAgcmV0dXJuIGxheW91dEluZm87XG59O1xuLyoqXG4gKiBAYnJpZWYgOiBUaGlzIGZ1bmN0aW9uIGZpbmRzIHRoZSBpbmRleCBvZiB0aGUgbG93ZXN0IGNvbW1vblxuICogICAgICAgICAgZ3JhcGggYW5jZXN0b3IgYmV0d2VlbiAyIG5vZGVzIGluIHRoZSBzdWJ0cmVlXG4gKiAgICAgICAgICAoZnJvbSB0aGUgZ3JhcGggaGllcmFyY2h5IGluZHVjZWQgdHJlZSkgd2hvc2VcbiAqICAgICAgICAgIHJvb3QgaXMgZ3JhcGhJeFxuICpcbiAqIEBhcmcgbm9kZTE6IG5vZGUxJ3MgSURcbiAqIEBhcmcgbm9kZTI6IG5vZGUyJ3MgSURcbiAqIEBhcmcgbGF5b3V0SW5mbzogbGF5b3V0SW5mbyBvYmplY3RcbiAqXG4gKi9cblxuXG52YXIgZmluZExDQSA9IGZ1bmN0aW9uIGZpbmRMQ0Eobm9kZTEsIG5vZGUyLCBsYXlvdXRJbmZvKSB7XG4gIC8vIEZpbmQgdGhlaXIgY29tbW9uIGFuY2VzdGVyLCBzdGFydGluZyBmcm9tIHRoZSByb290IGdyYXBoXG4gIHZhciByZXMgPSBmaW5kTENBX2F1eChub2RlMSwgbm9kZTIsIDAsIGxheW91dEluZm8pO1xuXG4gIGlmICgyID4gcmVzLmNvdW50KSB7XG4gICAgLy8gSWYgYXV4IGZ1bmN0aW9uIGNvdWxkbid0IGZpbmQgdGhlIGNvbW1vbiBhbmNlc3RlcixcbiAgICAvLyB0aGVuIGl0IGlzIHRoZSByb290IGdyYXBoXG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlcy5ncmFwaDtcbiAgfVxufTtcbi8qKlxuICogQGJyaWVmICAgICAgICAgIDogQXV4aWxpYXJ5IGZ1bmN0aW9uIHVzZWQgZm9yIExDQSBjb21wdXRhdGlvblxuICpcbiAqIEBhcmcgbm9kZTEgICAgICA6IG5vZGUxJ3MgSURcbiAqIEBhcmcgbm9kZTIgICAgICA6IG5vZGUyJ3MgSURcbiAqIEBhcmcgZ3JhcGhJeCAgICA6IHN1YmdyYXBoIGluZGV4XG4gKiBAYXJnIGxheW91dEluZm8gOiBsYXlvdXRJbmZvIG9iamVjdFxuICpcbiAqIEByZXR1cm4gICAgICAgICA6IG9iamVjdCBvZiB0aGUgZm9ybSB7Y291bnQ6IFgsIGdyYXBoOiBZfSwgd2hlcmU6XG4gKiAgICAgICAgICAgICAgICAgICBYIGlzIHRoZSBudW1iZXIgb2YgYW5jZXN0b3JzIChtYXg6IDIpIGZvdW5kIGluXG4gKiAgICAgICAgICAgICAgICAgICBncmFwaEl4IChhbmQgaXQncyBzdWJncmFwaHMpLFxuICogICAgICAgICAgICAgICAgICAgWSBpcyB0aGUgZ3JhcGggaW5kZXggb2YgdGhlIGxvd2VzdCBncmFwaCBjb250YWluaW5nXG4gKiAgICAgICAgICAgICAgICAgICBhbGwgWCBub2Rlc1xuICovXG5cblxudmFyIGZpbmRMQ0FfYXV4ID0gZnVuY3Rpb24gZmluZExDQV9hdXgobm9kZTEsIG5vZGUyLCBncmFwaEl4LCBsYXlvdXRJbmZvKSB7XG4gIHZhciBncmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbZ3JhcGhJeF07IC8vIElmIGJvdGggbm9kZXMgYmVsb25ncyB0byBncmFwaEl4XG5cbiAgaWYgKC0xIDwgZ3JhcGguaW5kZXhPZihub2RlMSkgJiYgLTEgPCBncmFwaC5pbmRleE9mKG5vZGUyKSkge1xuICAgIHJldHVybiB7XG4gICAgICBjb3VudDogMixcbiAgICAgIGdyYXBoOiBncmFwaEl4XG4gICAgfTtcbiAgfSAvLyBNYWtlIHJlY3Vyc2l2ZSBjYWxscyBmb3IgYWxsIHN1YmdyYXBoc1xuXG5cbiAgdmFyIGMgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhcGgubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZUlkID0gZ3JhcGhbaV07XG4gICAgdmFyIG5vZGVJeCA9IGxheW91dEluZm8uaWRUb0luZGV4W25vZGVJZF07XG4gICAgdmFyIGNoaWxkcmVuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tub2RlSXhdLmNoaWxkcmVuOyAvLyBJZiB0aGUgbm9kZSBoYXMgbm8gY2hpbGQsIHNraXAgaXRcblxuICAgIGlmICgwID09PSBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBjaGlsZEdyYXBoSXggPSBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFtsYXlvdXRJbmZvLmlkVG9JbmRleFtjaGlsZHJlblswXV1dO1xuICAgIHZhciByZXN1bHQgPSBmaW5kTENBX2F1eChub2RlMSwgbm9kZTIsIGNoaWxkR3JhcGhJeCwgbGF5b3V0SW5mbyk7XG5cbiAgICBpZiAoMCA9PT0gcmVzdWx0LmNvdW50KSB7XG4gICAgICAvLyBOZWl0aGVyIG5vZGUxIG5vciBub2RlMiBhcmUgcHJlc2VudCBpbiB0aGlzIHN1YmdyYXBoXG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKDEgPT09IHJlc3VsdC5jb3VudCkge1xuICAgICAgLy8gT25lIG9mIChub2RlMSwgbm9kZTIpIGlzIHByZXNlbnQgaW4gdGhpcyBzdWJncmFwaFxuICAgICAgYysrO1xuXG4gICAgICBpZiAoMiA9PT0gYykge1xuICAgICAgICAvLyBXZSd2ZSBhbHJlYWR5IGZvdW5kIGJvdGggbm9kZXMsIG5vIG5lZWQgdG8ga2VlcCBzZWFyY2hpbmdcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJvdGggbm9kZXMgYXJlIHByZXNlbnQgaW4gdGhpcyBzdWJncmFwaFxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvdW50OiBjLFxuICAgIGdyYXBoOiBncmFwaEl4XG4gIH07XG59O1xuLyoqXG4gKiBAYnJpZWY6IHByaW50c0xheW91dEluZm8gaW50byBqcyBjb25zb2xlXG4gKiAgICAgICAgIE9ubHkgdXNlZCBmb3IgZGViYnVnaW5nXG4gKi9cblxuXG52YXIgcHJpbnRMYXlvdXRJbmZvOyBcbi8qKlxuICogQGJyaWVmIDogUmFuZG9taXplcyB0aGUgcG9zaXRpb24gb2YgYWxsIG5vZGVzXG4gKi9cblxuXG52YXIgcmFuZG9taXplUG9zaXRpb25zID0gZnVuY3Rpb24gcmFuZG9taXplUG9zaXRpb25zKGxheW91dEluZm8sIGN5KSB7XG4gIHZhciB3aWR0aCA9IGxheW91dEluZm8uY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBsYXlvdXRJbmZvLmNsaWVudEhlaWdodDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTsgLy8gTm8gbmVlZCB0byByYW5kb21pemUgY29tcG91bmQgbm9kZXMgb3IgbG9ja2VkIG5vZGVzXG5cbiAgICBpZiAoMCA9PT0gbi5jaGlsZHJlbi5sZW5ndGggJiYgIW4uaXNMb2NrZWQpIHtcbiAgICAgIG4ucG9zaXRpb25YID0gTWF0aC5yYW5kb20oKSAqIHdpZHRoO1xuICAgICAgbi5wb3NpdGlvblkgPSBNYXRoLnJhbmRvbSgpICogaGVpZ2h0O1xuICAgIH1cbiAgfVxufTtcblxudmFyIGdldFNjYWxlSW5Cb3VuZHNGbiA9IGZ1bmN0aW9uIGdldFNjYWxlSW5Cb3VuZHNGbihsYXlvdXRJbmZvLCBvcHRpb25zLCBub2Rlcykge1xuICB2YXIgYmIgPSBsYXlvdXRJbmZvLmJvdW5kaW5nQm94O1xuICB2YXIgY29zZUJCID0ge1xuICAgIHgxOiBJbmZpbml0eSxcbiAgICB4MjogLUluZmluaXR5LFxuICAgIHkxOiBJbmZpbml0eSxcbiAgICB5MjogLUluZmluaXR5XG4gIH07XG5cbiAgaWYgKG9wdGlvbnMuYm91bmRpbmdCb3gpIHtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgbG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W25vZGUuZGF0YSgnaWQnKV1dO1xuICAgICAgY29zZUJCLngxID0gTWF0aC5taW4oY29zZUJCLngxLCBsbm9kZS5wb3NpdGlvblgpO1xuICAgICAgY29zZUJCLngyID0gTWF0aC5tYXgoY29zZUJCLngyLCBsbm9kZS5wb3NpdGlvblgpO1xuICAgICAgY29zZUJCLnkxID0gTWF0aC5taW4oY29zZUJCLnkxLCBsbm9kZS5wb3NpdGlvblkpO1xuICAgICAgY29zZUJCLnkyID0gTWF0aC5tYXgoY29zZUJCLnkyLCBsbm9kZS5wb3NpdGlvblkpO1xuICAgIH0pO1xuICAgIGNvc2VCQi53ID0gY29zZUJCLngyIC0gY29zZUJCLngxO1xuICAgIGNvc2VCQi5oID0gY29zZUJCLnkyIC0gY29zZUJCLnkxO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChlbGUsIGkpIHtcbiAgICB2YXIgbG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2VsZS5kYXRhKCdpZCcpXV07XG5cbiAgICBpZiAob3B0aW9ucy5ib3VuZGluZ0JveCkge1xuICAgICAgLy8gdGhlbiBhZGQgZXh0cmEgYm91bmRpbmcgYm94IGNvbnN0cmFpbnRcbiAgICAgIHZhciBwY3RYID0gKGxub2RlLnBvc2l0aW9uWCAtIGNvc2VCQi54MSkgLyBjb3NlQkIudztcbiAgICAgIHZhciBwY3RZID0gKGxub2RlLnBvc2l0aW9uWSAtIGNvc2VCQi55MSkgLyBjb3NlQkIuaDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGJiLngxICsgcGN0WCAqIGJiLncsXG4gICAgICAgIHk6IGJiLnkxICsgcGN0WSAqIGJiLmhcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGxub2RlLnBvc2l0aW9uWCxcbiAgICAgICAgeTogbG5vZGUucG9zaXRpb25ZXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG4vKipcbiAqIEBicmllZiAgICAgICAgICA6IFVwZGF0ZXMgdGhlIHBvc2l0aW9ucyBvZiBub2RlcyBpbiB0aGUgbmV0d29ya1xuICogQGFyZyBsYXlvdXRJbmZvIDogTGF5b3V0SW5mbyBvYmplY3RcbiAqIEBhcmcgY3kgICAgICAgICA6IEN5dG9zY2FwZSBvYmplY3RcbiAqIEBhcmcgb3B0aW9ucyAgICA6IExheW91dCBvcHRpb25zXG4gKi9cblxuXG52YXIgcmVmcmVzaFBvc2l0aW9ucyA9IGZ1bmN0aW9uIHJlZnJlc2hQb3NpdGlvbnMobGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpIHtcbiAgLy8gdmFyIHMgPSAnUmVmcmVzaGluZyBwb3NpdGlvbnMnO1xuICAvLyBsb2dEZWJ1ZyhzKTtcbiAgdmFyIGxheW91dCA9IG9wdGlvbnMubGF5b3V0O1xuICB2YXIgbm9kZXMgPSBvcHRpb25zLmVsZXMubm9kZXMoKTtcbiAgdmFyIGdldFNjYWxlZFBvcyA9IGdldFNjYWxlSW5Cb3VuZHNGbihsYXlvdXRJbmZvLCBvcHRpb25zLCBub2Rlcyk7XG4gIG5vZGVzLnBvc2l0aW9ucyhnZXRTY2FsZWRQb3MpOyAvLyBUcmlnZ2VyIGxheW91dFJlYWR5IG9ubHkgb24gZmlyc3QgY2FsbFxuXG4gIGlmICh0cnVlICE9PSBsYXlvdXRJbmZvLnJlYWR5KSB7XG4gICAgLy8gcyA9ICdUcmlnZ2VyaW5nIGxheW91dHJlYWR5JztcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICBsYXlvdXRJbmZvLnJlYWR5ID0gdHJ1ZTtcbiAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgIGxheW91dC5lbWl0KHtcbiAgICAgIHR5cGU6ICdsYXlvdXRyZWFkeScsXG4gICAgICBsYXlvdXQ6IHRoaXNcbiAgICB9KTtcbiAgfVxufTtcbi8qKlxuICogQGJyaWVmIDogTG9ncyBhIGRlYnVnIG1lc3NhZ2UgaW4gSlMgY29uc29sZSwgaWYgREVCVUcgaXMgT05cbiAqL1xuLy8gdmFyIGxvZ0RlYnVnID0gZnVuY3Rpb24odGV4dCkge1xuLy8gICBpZiAoREVCVUcpIHtcbi8vICAgICBjb25zb2xlLmRlYnVnKHRleHQpO1xuLy8gICB9XG4vLyB9O1xuXG4vKipcbiAqIEBicmllZiAgICAgICAgICA6IFBlcmZvcm1zIG9uZSBpdGVyYXRpb24gb2YgdGhlIHBoeXNpY2FsIHNpbXVsYXRpb25cbiAqIEBhcmcgbGF5b3V0SW5mbyA6IExheW91dEluZm8gb2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAqIEBhcmcgY3kgICAgICAgICA6IEN5dG9zY2FwZSBvYmplY3RcbiAqIEBhcmcgb3B0aW9ucyAgICA6IExheW91dCBvcHRpb25zXG4gKi9cblxuXG52YXIgc3RlcCA9IGZ1bmN0aW9uIHN0ZXAobGF5b3V0SW5mbywgb3B0aW9ucywgX3N0ZXApIHtcbiAgLy8gdmFyIHMgPSBcIlxcblxcbiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcIjtcbiAgLy8gcyArPSBcIlxcblNURVA6IFwiICsgc3RlcDtcbiAgLy8gcyArPSBcIlxcbiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcXG5cIjtcbiAgLy8gbG9nRGVidWcocyk7XG4gIC8vIENhbGN1bGF0ZSBub2RlIHJlcHVsc2lvbnNcbiAgY2FsY3VsYXRlTm9kZUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKTsgLy8gQ2FsY3VsYXRlIGVkZ2UgZm9yY2VzXG5cbiAgY2FsY3VsYXRlRWRnZUZvcmNlcyhsYXlvdXRJbmZvKTsgLy8gQ2FsY3VsYXRlIGdyYXZpdHkgZm9yY2VzXG5cbiAgY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKTsgLy8gUHJvcGFnYXRlIGZvcmNlcyBmcm9tIHBhcmVudCB0byBjaGlsZFxuXG4gIHByb3BhZ2F0ZUZvcmNlcyhsYXlvdXRJbmZvKTsgLy8gVXBkYXRlIHBvc2l0aW9ucyBiYXNlZCBvbiBjYWxjdWxhdGVkIGZvcmNlc1xuXG4gIHVwZGF0ZVBvc2l0aW9ucyhsYXlvdXRJbmZvKTtcbn07XG4vKipcbiAqIEBicmllZiA6IENvbXB1dGVzIHRoZSBub2RlIHJlcHVsc2lvbiBmb3JjZXNcbiAqL1xuXG5cbnZhciBjYWxjdWxhdGVOb2RlRm9yY2VzID0gZnVuY3Rpb24gY2FsY3VsYXRlTm9kZUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gIC8vIEdvIHRocm91Z2ggZWFjaCBvZiB0aGUgZ3JhcGhzIGluIGdyYXBoU2V0XG4gIC8vIE5vZGVzIG9ubHkgcmVwZWwgZWFjaCBvdGhlciBpZiB0aGV5IGJlbG9uZyB0byB0aGUgc2FtZSBncmFwaFxuICAvLyB2YXIgcyA9ICdjYWxjdWxhdGVOb2RlRm9yY2VzJztcbiAgLy8gbG9nRGVidWcocyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ncmFwaFNldC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBncmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbaV07XG4gICAgdmFyIG51bU5vZGVzID0gZ3JhcGgubGVuZ3RoOyAvLyBzID0gXCJTZXQ6IFwiICsgZ3JhcGgudG9TdHJpbmcoKTtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAvLyBOb3cgZ2V0IGFsbCB0aGUgcGFpcnMgb2Ygbm9kZXNcbiAgICAvLyBPbmx5IGdldCBlYWNoIHBhaXIgb25jZSwgKEEsIEIpID0gKEIsIEEpXG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgIHZhciBub2RlMSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbal1dXTtcblxuICAgICAgZm9yICh2YXIgayA9IGogKyAxOyBrIDwgbnVtTm9kZXM7IGsrKykge1xuICAgICAgICB2YXIgbm9kZTIgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2dyYXBoW2tdXV07XG4gICAgICAgIG5vZGVSZXB1bHNpb24obm9kZTEsIG5vZGUyLCBsYXlvdXRJbmZvLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciByYW5kb21EaXN0YW5jZSA9IGZ1bmN0aW9uIHJhbmRvbURpc3RhbmNlKG1heCkge1xuICByZXR1cm4gLW1heCArIDIgKiBtYXggKiBNYXRoLnJhbmRvbSgpO1xufTtcbi8qKlxuICogQGJyaWVmIDogQ29tcHV0ZSB0aGUgbm9kZSByZXB1bHNpb24gZm9yY2VzIGJldHdlZW4gYSBwYWlyIG9mIG5vZGVzXG4gKi9cblxuXG52YXIgbm9kZVJlcHVsc2lvbiA9IGZ1bmN0aW9uIG5vZGVSZXB1bHNpb24obm9kZTEsIG5vZGUyLCBsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gIC8vIHZhciBzID0gXCJOb2RlIHJlcHVsc2lvbi4gTm9kZTE6IFwiICsgbm9kZTEuaWQgKyBcIiBOb2RlMjogXCIgKyBub2RlMi5pZDtcbiAgdmFyIGNtcHRJZDEgPSBub2RlMS5jbXB0SWQ7XG4gIHZhciBjbXB0SWQyID0gbm9kZTIuY21wdElkO1xuXG4gIGlmIChjbXB0SWQxICE9PSBjbXB0SWQyICYmICFsYXlvdXRJbmZvLmlzQ29tcG91bmQpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gR2V0IGRpcmVjdGlvbiBvZiBsaW5lIGNvbm5lY3RpbmcgYm90aCBub2RlIGNlbnRlcnNcblxuXG4gIHZhciBkaXJlY3Rpb25YID0gbm9kZTIucG9zaXRpb25YIC0gbm9kZTEucG9zaXRpb25YO1xuICB2YXIgZGlyZWN0aW9uWSA9IG5vZGUyLnBvc2l0aW9uWSAtIG5vZGUxLnBvc2l0aW9uWTtcbiAgdmFyIG1heFJhbmREaXN0ID0gMTsgLy8gcyArPSBcIlxcbmRpcmVjdGlvblg6IFwiICsgZGlyZWN0aW9uWCArIFwiLCBkaXJlY3Rpb25ZOiBcIiArIGRpcmVjdGlvblk7XG4gIC8vIElmIGJvdGggY2VudGVycyBhcmUgdGhlIHNhbWUsIGFwcGx5IGEgcmFuZG9tIGZvcmNlXG5cbiAgaWYgKDAgPT09IGRpcmVjdGlvblggJiYgMCA9PT0gZGlyZWN0aW9uWSkge1xuICAgIGRpcmVjdGlvblggPSByYW5kb21EaXN0YW5jZShtYXhSYW5kRGlzdCk7XG4gICAgZGlyZWN0aW9uWSA9IHJhbmRvbURpc3RhbmNlKG1heFJhbmREaXN0KTtcbiAgfVxuXG4gIHZhciBvdmVybGFwID0gbm9kZXNPdmVybGFwKG5vZGUxLCBub2RlMiwgZGlyZWN0aW9uWCwgZGlyZWN0aW9uWSk7XG5cbiAgaWYgKG92ZXJsYXAgPiAwKSB7XG4gICAgLy8gcyArPSBcIlxcbk5vZGVzIERPIG92ZXJsYXAuXCI7XG4gICAgLy8gcyArPSBcIlxcbk92ZXJsYXA6IFwiICsgb3ZlcmxhcDtcbiAgICAvLyBJZiBub2RlcyBvdmVybGFwLCByZXB1bHNpb24gZm9yY2UgaXMgcHJvcG9ydGlvbmFsXG4gICAgLy8gdG8gdGhlIG92ZXJsYXBcbiAgICB2YXIgZm9yY2UgPSBvcHRpb25zLm5vZGVPdmVybGFwICogb3ZlcmxhcDsgLy8gQ29tcHV0ZSB0aGUgbW9kdWxlIGFuZCBjb21wb25lbnRzIG9mIHRoZSBmb3JjZSB2ZWN0b3JcblxuICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChkaXJlY3Rpb25YICogZGlyZWN0aW9uWCArIGRpcmVjdGlvblkgKiBkaXJlY3Rpb25ZKTsgLy8gcyArPSBcIlxcbkRpc3RhbmNlOiBcIiArIGRpc3RhbmNlO1xuXG4gICAgdmFyIGZvcmNlWCA9IGZvcmNlICogZGlyZWN0aW9uWCAvIGRpc3RhbmNlO1xuICAgIHZhciBmb3JjZVkgPSBmb3JjZSAqIGRpcmVjdGlvblkgLyBkaXN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBzICs9IFwiXFxuTm9kZXMgZG8gTk9UIG92ZXJsYXAuXCI7XG4gICAgLy8gSWYgdGhlcmUncyBubyBvdmVybGFwLCBmb3JjZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsXG4gICAgLy8gdG8gc3F1YXJlZCBkaXN0YW5jZVxuICAgIC8vIEdldCBjbGlwcGluZyBwb2ludHMgZm9yIGJvdGggbm9kZXNcbiAgICB2YXIgcG9pbnQxID0gZmluZENsaXBwaW5nUG9pbnQobm9kZTEsIGRpcmVjdGlvblgsIGRpcmVjdGlvblkpO1xuICAgIHZhciBwb2ludDIgPSBmaW5kQ2xpcHBpbmdQb2ludChub2RlMiwgLTEgKiBkaXJlY3Rpb25YLCAtMSAqIGRpcmVjdGlvblkpOyAvLyBVc2UgY2xpcHBpbmcgcG9pbnRzIHRvIGNvbXB1dGUgZGlzdGFuY2VcblxuICAgIHZhciBkaXN0YW5jZVggPSBwb2ludDIueCAtIHBvaW50MS54O1xuICAgIHZhciBkaXN0YW5jZVkgPSBwb2ludDIueSAtIHBvaW50MS55O1xuICAgIHZhciBkaXN0YW5jZVNxciA9IGRpc3RhbmNlWCAqIGRpc3RhbmNlWCArIGRpc3RhbmNlWSAqIGRpc3RhbmNlWTtcbiAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZGlzdGFuY2VTcXIpOyAvLyBzICs9IFwiXFxuRGlzdGFuY2U6IFwiICsgZGlzdGFuY2U7XG4gICAgLy8gQ29tcHV0ZSB0aGUgbW9kdWxlIGFuZCBjb21wb25lbnRzIG9mIHRoZSBmb3JjZSB2ZWN0b3JcblxuICAgIHZhciBmb3JjZSA9IChub2RlMS5ub2RlUmVwdWxzaW9uICsgbm9kZTIubm9kZVJlcHVsc2lvbikgLyBkaXN0YW5jZVNxcjtcbiAgICB2YXIgZm9yY2VYID0gZm9yY2UgKiBkaXN0YW5jZVggLyBkaXN0YW5jZTtcbiAgICB2YXIgZm9yY2VZID0gZm9yY2UgKiBkaXN0YW5jZVkgLyBkaXN0YW5jZTtcbiAgfSAvLyBBcHBseSBmb3JjZVxuXG5cbiAgaWYgKCFub2RlMS5pc0xvY2tlZCkge1xuICAgIG5vZGUxLm9mZnNldFggLT0gZm9yY2VYO1xuICAgIG5vZGUxLm9mZnNldFkgLT0gZm9yY2VZO1xuICB9XG5cbiAgaWYgKCFub2RlMi5pc0xvY2tlZCkge1xuICAgIG5vZGUyLm9mZnNldFggKz0gZm9yY2VYO1xuICAgIG5vZGUyLm9mZnNldFkgKz0gZm9yY2VZO1xuICB9IC8vIHMgKz0gXCJcXG5Gb3JjZVg6IFwiICsgZm9yY2VYICsgXCIgRm9yY2VZOiBcIiArIGZvcmNlWTtcbiAgLy8gbG9nRGVidWcocyk7XG5cblxuICByZXR1cm47XG59O1xuLyoqXG4gKiBAYnJpZWYgIDogRGV0ZXJtaW5lcyB3aGV0aGVyIHR3byBub2RlcyBvdmVybGFwIG9yIG5vdFxuICogQHJldHVybiA6IEFtb3VudCBvZiBvdmVybGFwcGluZyAoMCA9PiBubyBvdmVybGFwKVxuICovXG5cblxudmFyIG5vZGVzT3ZlcmxhcCA9IGZ1bmN0aW9uIG5vZGVzT3ZlcmxhcChub2RlMSwgbm9kZTIsIGRYLCBkWSkge1xuICBpZiAoZFggPiAwKSB7XG4gICAgdmFyIG92ZXJsYXBYID0gbm9kZTEubWF4WCAtIG5vZGUyLm1pblg7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG92ZXJsYXBYID0gbm9kZTIubWF4WCAtIG5vZGUxLm1pblg7XG4gIH1cblxuICBpZiAoZFkgPiAwKSB7XG4gICAgdmFyIG92ZXJsYXBZID0gbm9kZTEubWF4WSAtIG5vZGUyLm1pblk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG92ZXJsYXBZID0gbm9kZTIubWF4WSAtIG5vZGUxLm1pblk7XG4gIH1cblxuICBpZiAob3ZlcmxhcFggPj0gMCAmJiBvdmVybGFwWSA+PSAwKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChvdmVybGFwWCAqIG92ZXJsYXBYICsgb3ZlcmxhcFkgKiBvdmVybGFwWSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG4vKipcbiAqIEBicmllZiA6IEZpbmRzIHRoZSBwb2ludCBpbiB3aGljaCBhbiBlZGdlIChkaXJlY3Rpb24gZFgsIGRZKSBpbnRlcnNlY3RzXG4gKiAgICAgICAgICB0aGUgcmVjdGFuZ3VsYXIgYm91bmRpbmcgYm94IG9mIGl0J3Mgc291cmNlL3RhcmdldCBub2RlXG4gKi9cblxuXG52YXIgZmluZENsaXBwaW5nUG9pbnQgPSBmdW5jdGlvbiBmaW5kQ2xpcHBpbmdQb2ludChub2RlLCBkWCwgZFkpIHtcbiAgLy8gU2hvcmN1dHNcbiAgdmFyIFggPSBub2RlLnBvc2l0aW9uWDtcbiAgdmFyIFkgPSBub2RlLnBvc2l0aW9uWTtcbiAgdmFyIEggPSBub2RlLmhlaWdodCB8fCAxO1xuICB2YXIgVyA9IG5vZGUud2lkdGggfHwgMTtcbiAgdmFyIGRpclNsb3BlID0gZFkgLyBkWDtcbiAgdmFyIG5vZGVTbG9wZSA9IEggLyBXOyAvLyB2YXIgcyA9ICdDb21wdXRpbmcgY2xpcHBpbmcgcG9pbnQgb2Ygbm9kZSAnICsgbm9kZS5pZCArXG4gIC8vICAgXCIgLiBIZWlnaHQ6ICBcIiArIEggKyBcIiwgV2lkdGg6IFwiICsgVyArXG4gIC8vICAgXCJcXG5EaXJlY3Rpb24gXCIgKyBkWCArIFwiLCBcIiArIGRZO1xuICAvL1xuICAvLyBDb21wdXRlIGludGVyc2VjdGlvblxuXG4gIHZhciByZXMgPSB7fTsgLy8gQ2FzZTogVmVydGljYWwgZGlyZWN0aW9uICh1cClcblxuICBpZiAoMCA9PT0gZFggJiYgMCA8IGRZKSB7XG4gICAgcmVzLnggPSBYOyAvLyBzICs9IFwiXFxuVXAgZGlyZWN0aW9uXCI7XG5cbiAgICByZXMueSA9IFkgKyBIIC8gMjtcbiAgICByZXR1cm4gcmVzO1xuICB9IC8vIENhc2U6IFZlcnRpY2FsIGRpcmVjdGlvbiAoZG93bilcblxuXG4gIGlmICgwID09PSBkWCAmJiAwID4gZFkpIHtcbiAgICByZXMueCA9IFg7XG4gICAgcmVzLnkgPSBZICsgSCAvIDI7IC8vIHMgKz0gXCJcXG5Eb3duIGRpcmVjdGlvblwiO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfSAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSByaWdodCBib3JkZXJcblxuXG4gIGlmICgwIDwgZFggJiYgLTEgKiBub2RlU2xvcGUgPD0gZGlyU2xvcGUgJiYgZGlyU2xvcGUgPD0gbm9kZVNsb3BlKSB7XG4gICAgcmVzLnggPSBYICsgVyAvIDI7XG4gICAgcmVzLnkgPSBZICsgVyAqIGRZIC8gMiAvIGRYOyAvLyBzICs9IFwiXFxuUmlnaHRib3JkZXJcIjtcblxuICAgIHJldHVybiByZXM7XG4gIH0gLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgbGVmdCBib3JkZXJcblxuXG4gIGlmICgwID4gZFggJiYgLTEgKiBub2RlU2xvcGUgPD0gZGlyU2xvcGUgJiYgZGlyU2xvcGUgPD0gbm9kZVNsb3BlKSB7XG4gICAgcmVzLnggPSBYIC0gVyAvIDI7XG4gICAgcmVzLnkgPSBZIC0gVyAqIGRZIC8gMiAvIGRYOyAvLyBzICs9IFwiXFxuTGVmdGJvcmRlclwiO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfSAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSB0b3AgYm9yZGVyXG5cblxuICBpZiAoMCA8IGRZICYmIChkaXJTbG9wZSA8PSAtMSAqIG5vZGVTbG9wZSB8fCBkaXJTbG9wZSA+PSBub2RlU2xvcGUpKSB7XG4gICAgcmVzLnggPSBYICsgSCAqIGRYIC8gMiAvIGRZO1xuICAgIHJlcy55ID0gWSArIEggLyAyOyAvLyBzICs9IFwiXFxuVG9wIGJvcmRlclwiO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfSAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSBib3R0b20gYm9yZGVyXG5cblxuICBpZiAoMCA+IGRZICYmIChkaXJTbG9wZSA8PSAtMSAqIG5vZGVTbG9wZSB8fCBkaXJTbG9wZSA+PSBub2RlU2xvcGUpKSB7XG4gICAgcmVzLnggPSBYIC0gSCAqIGRYIC8gMiAvIGRZO1xuICAgIHJlcy55ID0gWSAtIEggLyAyOyAvLyBzICs9IFwiXFxuQm90dG9tIGJvcmRlclwiO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfSAvLyBzICs9IFwiXFxuQ2xpcHBpbmcgcG9pbnQgZm91bmQgYXQgXCIgKyByZXMueCArIFwiLCBcIiArIHJlcy55O1xuICAvLyBsb2dEZWJ1ZyhzKTtcblxuXG4gIHJldHVybiByZXM7XG59O1xuLyoqXG4gKiBAYnJpZWYgOiBDYWxjdWxhdGVzIGFsbCBlZGdlIGZvcmNlc1xuICovXG5cblxudmFyIGNhbGN1bGF0ZUVkZ2VGb3JjZXMgPSBmdW5jdGlvbiBjYWxjdWxhdGVFZGdlRm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBlZGdlc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZWRnZVNpemU7IGkrKykge1xuICAgIC8vIEdldCBlZGdlLCBzb3VyY2UgJiB0YXJnZXQgbm9kZXNcbiAgICB2YXIgZWRnZSA9IGxheW91dEluZm8ubGF5b3V0RWRnZXNbaV07XG4gICAgdmFyIHNvdXJjZUl4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbZWRnZS5zb3VyY2VJZF07XG4gICAgdmFyIHNvdXJjZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbc291cmNlSXhdO1xuICAgIHZhciB0YXJnZXRJeCA9IGxheW91dEluZm8uaWRUb0luZGV4W2VkZ2UudGFyZ2V0SWRdO1xuICAgIHZhciB0YXJnZXQgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3RhcmdldEl4XTsgLy8gR2V0IGRpcmVjdGlvbiBvZiBsaW5lIGNvbm5lY3RpbmcgYm90aCBub2RlIGNlbnRlcnNcblxuICAgIHZhciBkaXJlY3Rpb25YID0gdGFyZ2V0LnBvc2l0aW9uWCAtIHNvdXJjZS5wb3NpdGlvblg7XG4gICAgdmFyIGRpcmVjdGlvblkgPSB0YXJnZXQucG9zaXRpb25ZIC0gc291cmNlLnBvc2l0aW9uWTsgLy8gSWYgYm90aCBjZW50ZXJzIGFyZSB0aGUgc2FtZSwgZG8gbm90aGluZy5cbiAgICAvLyBBIHJhbmRvbSBmb3JjZSBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgYXMgbm9kZSByZXB1bHNpb25cblxuICAgIGlmICgwID09PSBkaXJlY3Rpb25YICYmIDAgPT09IGRpcmVjdGlvblkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gR2V0IGNsaXBwaW5nIHBvaW50cyBmb3IgYm90aCBub2Rlc1xuXG5cbiAgICB2YXIgcG9pbnQxID0gZmluZENsaXBwaW5nUG9pbnQoc291cmNlLCBkaXJlY3Rpb25YLCBkaXJlY3Rpb25ZKTtcbiAgICB2YXIgcG9pbnQyID0gZmluZENsaXBwaW5nUG9pbnQodGFyZ2V0LCAtMSAqIGRpcmVjdGlvblgsIC0xICogZGlyZWN0aW9uWSk7XG4gICAgdmFyIGx4ID0gcG9pbnQyLnggLSBwb2ludDEueDtcbiAgICB2YXIgbHkgPSBwb2ludDIueSAtIHBvaW50MS55O1xuICAgIHZhciBsID0gTWF0aC5zcXJ0KGx4ICogbHggKyBseSAqIGx5KTtcbiAgICB2YXIgZm9yY2UgPSBNYXRoLnBvdyhlZGdlLmlkZWFsTGVuZ3RoIC0gbCwgMikgLyBlZGdlLmVsYXN0aWNpdHk7XG5cbiAgICBpZiAoMCAhPT0gbCkge1xuICAgICAgdmFyIGZvcmNlWCA9IGZvcmNlICogbHggLyBsO1xuICAgICAgdmFyIGZvcmNlWSA9IGZvcmNlICogbHkgLyBsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZm9yY2VYID0gMDtcbiAgICAgIHZhciBmb3JjZVkgPSAwO1xuICAgIH0gLy8gQWRkIHRoaXMgZm9yY2UgdG8gdGFyZ2V0IGFuZCBzb3VyY2Ugbm9kZXNcblxuXG4gICAgaWYgKCFzb3VyY2UuaXNMb2NrZWQpIHtcbiAgICAgIHNvdXJjZS5vZmZzZXRYICs9IGZvcmNlWDtcbiAgICAgIHNvdXJjZS5vZmZzZXRZICs9IGZvcmNlWTtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldC5pc0xvY2tlZCkge1xuICAgICAgdGFyZ2V0Lm9mZnNldFggLT0gZm9yY2VYO1xuICAgICAgdGFyZ2V0Lm9mZnNldFkgLT0gZm9yY2VZO1xuICAgIH0gLy8gdmFyIHMgPSAnRWRnZSBmb3JjZSBiZXR3ZWVuIG5vZGVzICcgKyBzb3VyY2UuaWQgKyAnIGFuZCAnICsgdGFyZ2V0LmlkO1xuICAgIC8vIHMgKz0gXCJcXG5EaXN0YW5jZTogXCIgKyBsICsgXCIgRm9yY2U6IChcIiArIGZvcmNlWCArIFwiLCBcIiArIGZvcmNlWSArIFwiKVwiO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gIH1cbn07XG4vKipcbiAqIEBicmllZiA6IENvbXB1dGVzIGdyYXZpdHkgZm9yY2VzIGZvciBhbGwgbm9kZXNcbiAqL1xuXG5cbnZhciBjYWxjdWxhdGVHcmF2aXR5Rm9yY2VzID0gZnVuY3Rpb24gY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmdyYXZpdHkgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGlzdFRocmVzaG9sZCA9IDE7IC8vIHZhciBzID0gJ2NhbGN1bGF0ZUdyYXZpdHlGb3JjZXMnO1xuICAvLyBsb2dEZWJ1ZyhzKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZ3JhcGhTZXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZ3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2ldO1xuICAgIHZhciBudW1Ob2RlcyA9IGdyYXBoLmxlbmd0aDsgLy8gcyA9IFwiU2V0OiBcIiArIGdyYXBoLnRvU3RyaW5nKCk7XG4gICAgLy8gbG9nRGVidWcocyk7XG4gICAgLy8gQ29tcHV0ZSBncmFwaCBjZW50ZXJcblxuICAgIGlmICgwID09PSBpKSB7XG4gICAgICB2YXIgY2VudGVyWCA9IGxheW91dEluZm8uY2xpZW50SGVpZ2h0IC8gMjtcbiAgICAgIHZhciBjZW50ZXJZID0gbGF5b3V0SW5mby5jbGllbnRXaWR0aCAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEdldCBQYXJlbnQgbm9kZSBmb3IgdGhpcyBncmFwaCwgYW5kIHVzZSBpdHMgcG9zaXRpb24gYXMgY2VudGVyXG4gICAgICB2YXIgdGVtcCA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbMF1dXTtcbiAgICAgIHZhciBwYXJlbnQgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3RlbXAucGFyZW50SWRdXTtcbiAgICAgIHZhciBjZW50ZXJYID0gcGFyZW50LnBvc2l0aW9uWDtcbiAgICAgIHZhciBjZW50ZXJZID0gcGFyZW50LnBvc2l0aW9uWTtcbiAgICB9IC8vIHMgPSBcIkNlbnRlciBmb3VuZCBhdDogXCIgKyBjZW50ZXJYICsgXCIsIFwiICsgY2VudGVyWTtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAvLyBBcHBseSBmb3JjZSB0byBhbGwgbm9kZXMgaW4gZ3JhcGhcblxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7XG4gICAgICB2YXIgbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbal1dXTsgLy8gcyA9IFwiTm9kZTogXCIgKyBub2RlLmlkO1xuXG4gICAgICBpZiAobm9kZS5pc0xvY2tlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGR4ID0gY2VudGVyWCAtIG5vZGUucG9zaXRpb25YO1xuICAgICAgdmFyIGR5ID0gY2VudGVyWSAtIG5vZGUucG9zaXRpb25ZO1xuICAgICAgdmFyIGQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICBpZiAoZCA+IGRpc3RUaHJlc2hvbGQpIHtcbiAgICAgICAgdmFyIGZ4ID0gb3B0aW9ucy5ncmF2aXR5ICogZHggLyBkO1xuICAgICAgICB2YXIgZnkgPSBvcHRpb25zLmdyYXZpdHkgKiBkeSAvIGQ7XG4gICAgICAgIG5vZGUub2Zmc2V0WCArPSBmeDtcbiAgICAgICAgbm9kZS5vZmZzZXRZICs9IGZ5OyAvLyBzICs9IFwiOiBBcHBsaWVkIGZvcmNlOiBcIiArIGZ4ICsgXCIsIFwiICsgZnk7XG4gICAgICB9IC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiBAYnJpZWYgICAgICAgICAgOiBUaGlzIGZ1bmN0aW9uIHByb3BhZ2F0ZXMgdGhlIGV4aXN0aW5nIG9mZnNldHMgZnJvbVxuICogICAgICAgICAgICAgICAgICAgcGFyZW50IG5vZGVzIHRvIGl0cyBkZXNjZW5kZW50cy5cbiAqIEBhcmcgbGF5b3V0SW5mbyA6IGxheW91dEluZm8gT2JqZWN0XG4gKiBAYXJnIGN5ICAgICAgICAgOiBjeXRvc2NhcGUgT2JqZWN0XG4gKiBAYXJnIG9wdGlvbnMgICAgOiBMYXlvdXQgb3B0aW9uc1xuICovXG5cblxudmFyIHByb3BhZ2F0ZUZvcmNlcyA9IGZ1bmN0aW9uIHByb3BhZ2F0ZUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gIC8vIElubGluZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHF1ZXVlLCB1c2VkIGZvciB0cmF2ZXJzaW5nIHRoZSBncmFwaCBpbiBCRlMgb3JkZXJcbiAgdmFyIHF1ZXVlID0gW107XG4gIHZhciBzdGFydCA9IDA7IC8vIFBvaW50cyB0byB0aGUgc3RhcnQgdGhlIHF1ZXVlXG5cbiAgdmFyIGVuZCA9IC0xOyAvLyBQb2ludHMgdG8gdGhlIGVuZCBvZiB0aGUgcXVldWVcbiAgLy8gbG9nRGVidWcoJ3Byb3BhZ2F0ZUZvcmNlcycpO1xuICAvLyBTdGFydCBieSB2aXNpdGluZyB0aGUgbm9kZXMgaW4gdGhlIHJvb3QgZ3JhcGhcblxuICBxdWV1ZS5wdXNoLmFwcGx5KHF1ZXVlLCBsYXlvdXRJbmZvLmdyYXBoU2V0WzBdKTtcbiAgZW5kICs9IGxheW91dEluZm8uZ3JhcGhTZXRbMF0ubGVuZ3RoOyAvLyBUcmF2ZXJzZSB0aGUgZ3JhcGgsIGxldmVsIGJ5IGxldmVsLFxuXG4gIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICAvLyBHZXQgdGhlIG5vZGUgdG8gdmlzaXQgYW5kIHJlbW92ZSBpdCBmcm9tIHF1ZXVlXG4gICAgdmFyIG5vZGVJZCA9IHF1ZXVlW3N0YXJ0KytdO1xuICAgIHZhciBub2RlSW5kZXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlSWRdO1xuICAgIHZhciBub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tub2RlSW5kZXhdO1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47IC8vIFdlIG9ubHkgbmVlZCB0byBwcm9jZXNzIHRoZSBub2RlIGlmIGl0J3MgY29tcG91bmRcblxuICAgIGlmICgwIDwgY2hpbGRyZW4ubGVuZ3RoICYmICFub2RlLmlzTG9ja2VkKSB7XG4gICAgICB2YXIgb2ZmWCA9IG5vZGUub2Zmc2V0WDtcbiAgICAgIHZhciBvZmZZID0gbm9kZS5vZmZzZXRZOyAvLyB2YXIgcyA9IFwiUHJvcGFnYXRpbmcgb2Zmc2V0IGZyb20gcGFyZW50IG5vZGUgOiBcIiArIG5vZGUuaWQgK1xuICAgICAgLy8gICBcIi4gT2Zmc2V0WDogXCIgKyBvZmZYICsgXCIuIE9mZnNldFk6IFwiICsgb2ZmWTtcbiAgICAgIC8vIHMgKz0gXCJcXG4gQ2hpbGRyZW46IFwiICsgY2hpbGRyZW4udG9TdHJpbmcoKTtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2NoaWxkcmVuW2ldXV07IC8vIFByb3BhZ2F0ZSBvZmZzZXRcblxuICAgICAgICBjaGlsZE5vZGUub2Zmc2V0WCArPSBvZmZYO1xuICAgICAgICBjaGlsZE5vZGUub2Zmc2V0WSArPSBvZmZZOyAvLyBBZGQgY2hpbGRyZW4gdG8gcXVldWUgdG8gYmUgdmlzaXRlZFxuXG4gICAgICAgIHF1ZXVlWysrZW5kXSA9IGNoaWxkcmVuW2ldO1xuICAgICAgfSAvLyBSZXNldCBwYXJlbnQgb2Zmc2V0c1xuXG5cbiAgICAgIG5vZGUub2Zmc2V0WCA9IDA7XG4gICAgICBub2RlLm9mZnNldFkgPSAwO1xuICAgIH1cbiAgfVxufTtcbi8qKlxuICogQGJyaWVmIDogVXBkYXRlcyB0aGUgbGF5b3V0IG1vZGVsIHBvc2l0aW9ucywgYmFzZWQgb25cbiAqICAgICAgICAgIHRoZSBhY2N1bXVsYXRlZCBmb3JjZXNcbiAqL1xuXG5cbnZhciB1cGRhdGVQb3NpdGlvbnMgPSBmdW5jdGlvbiB1cGRhdGVQb3NpdGlvbnMobGF5b3V0SW5mbywgb3B0aW9ucykge1xuICAvLyB2YXIgcyA9ICdVcGRhdGluZyBwb3NpdGlvbnMnO1xuICAvLyBsb2dEZWJ1ZyhzKTtcbiAgLy8gUmVzZXQgYm91bmRhcmllcyBmb3IgY29tcG91bmQgbm9kZXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG5cbiAgICBpZiAoMCA8IG4uY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAvLyBsb2dEZWJ1ZyhcIlJlc2V0dGluZyBib3VuZGFyaWVzIG9mIGNvbXBvdW5kIG5vZGU6IFwiICsgbi5pZCk7XG4gICAgICBuLm1heFggPSB1bmRlZmluZWQ7XG4gICAgICBuLm1pblggPSB1bmRlZmluZWQ7XG4gICAgICBuLm1heFkgPSB1bmRlZmluZWQ7XG4gICAgICBuLm1pblkgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG5cbiAgICBpZiAoMCA8IG4uY2hpbGRyZW4ubGVuZ3RoIHx8IG4uaXNMb2NrZWQpIHtcbiAgICAgIC8vIE5vIG5lZWQgdG8gc2V0IGNvbXBvdW5kIG9yIGxvY2tlZCBub2RlIHBvc2l0aW9uXG4gICAgICAvLyBsb2dEZWJ1ZyhcIlNraXBwaW5nIHBvc2l0aW9uIHVwZGF0ZSBvZiBub2RlOiBcIiArIG4uaWQpO1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBzID0gXCJOb2RlOiBcIiArIG4uaWQgKyBcIiBQcmV2aW91cyBwb3NpdGlvbjogKFwiICtcbiAgICAvLyBuLnBvc2l0aW9uWCArIFwiLCBcIiArIG4ucG9zaXRpb25ZICsgXCIpLlwiO1xuICAgIC8vIExpbWl0IGRpc3BsYWNlbWVudCBpbiBvcmRlciB0byBpbXByb3ZlIHN0YWJpbGl0eVxuXG5cbiAgICB2YXIgdGVtcEZvcmNlID0gbGltaXRGb3JjZShuLm9mZnNldFgsIG4ub2Zmc2V0WSwgbGF5b3V0SW5mby50ZW1wZXJhdHVyZSk7XG4gICAgbi5wb3NpdGlvblggKz0gdGVtcEZvcmNlLng7XG4gICAgbi5wb3NpdGlvblkgKz0gdGVtcEZvcmNlLnk7XG4gICAgbi5vZmZzZXRYID0gMDtcbiAgICBuLm9mZnNldFkgPSAwO1xuICAgIG4ubWluWCA9IG4ucG9zaXRpb25YIC0gbi53aWR0aDtcbiAgICBuLm1heFggPSBuLnBvc2l0aW9uWCArIG4ud2lkdGg7XG4gICAgbi5taW5ZID0gbi5wb3NpdGlvblkgLSBuLmhlaWdodDtcbiAgICBuLm1heFkgPSBuLnBvc2l0aW9uWSArIG4uaGVpZ2h0OyAvLyBzICs9IFwiIE5ldyBQb3NpdGlvbjogKFwiICsgbi5wb3NpdGlvblggKyBcIiwgXCIgKyBuLnBvc2l0aW9uWSArIFwiKS5cIjtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAvLyBVcGRhdGUgYW5jZXN0cnkgYm91ZGFyaWVzXG5cbiAgICB1cGRhdGVBbmNlc3RyeUJvdW5kYXJpZXMobiwgbGF5b3V0SW5mbyk7XG4gIH0gLy8gVXBkYXRlIHNpemUsIHBvc2l0aW9uIG9mIGNvbXB1bmQgbm9kZXNcblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuXG4gICAgaWYgKDAgPCBuLmNoaWxkcmVuLmxlbmd0aCAmJiAhbi5pc0xvY2tlZCkge1xuICAgICAgbi5wb3NpdGlvblggPSAobi5tYXhYICsgbi5taW5YKSAvIDI7XG4gICAgICBuLnBvc2l0aW9uWSA9IChuLm1heFkgKyBuLm1pblkpIC8gMjtcbiAgICAgIG4ud2lkdGggPSBuLm1heFggLSBuLm1pblg7XG4gICAgICBuLmhlaWdodCA9IG4ubWF4WSAtIG4ubWluWTsgLy8gcyA9IFwiVXBkYXRpbmcgcG9zaXRpb24sIHNpemUgb2YgY29tcG91bmQgbm9kZSBcIiArIG4uaWQ7XG4gICAgICAvLyBzICs9IFwiXFxuUG9zaXRpb25YOiBcIiArIG4ucG9zaXRpb25YICsgXCIsIFBvc2l0aW9uWTogXCIgKyBuLnBvc2l0aW9uWTtcbiAgICAgIC8vIHMgKz0gXCJcXG5XaWR0aDogXCIgKyBuLndpZHRoICsgXCIsIEhlaWdodDogXCIgKyBuLmhlaWdodDtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgIH1cbiAgfVxufTtcbi8qKlxuICogQGJyaWVmIDogTGltaXRzIGEgZm9yY2UgKGZvcmNlWCwgZm9yY2VZKSB0byBiZSBub3RcbiAqICAgICAgICAgIGdyZWF0ZXIgKGluIG1vZHVsbykgdGhhbiBtYXguXG4gOCAgICAgICAgICBQcmVzZXJ2ZXMgZm9yY2UgZGlyZWN0aW9uLlxuICAqL1xuXG5cbnZhciBsaW1pdEZvcmNlID0gZnVuY3Rpb24gbGltaXRGb3JjZShmb3JjZVgsIGZvcmNlWSwgbWF4KSB7XG4gIC8vIHZhciBzID0gXCJMaW1pdGluZyBmb3JjZTogKFwiICsgZm9yY2VYICsgXCIsIFwiICsgZm9yY2VZICsgXCIpLiBNYXg6IFwiICsgbWF4O1xuICB2YXIgZm9yY2UgPSBNYXRoLnNxcnQoZm9yY2VYICogZm9yY2VYICsgZm9yY2VZICogZm9yY2VZKTtcblxuICBpZiAoZm9yY2UgPiBtYXgpIHtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgeDogbWF4ICogZm9yY2VYIC8gZm9yY2UsXG4gICAgICB5OiBtYXggKiBmb3JjZVkgLyBmb3JjZVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlcyA9IHtcbiAgICAgIHg6IGZvcmNlWCxcbiAgICAgIHk6IGZvcmNlWVxuICAgIH07XG4gIH0gLy8gcyArPSBcIi5cXG5SZXN1bHQ6IChcIiArIHJlcy54ICsgXCIsIFwiICsgcmVzLnkgKyBcIilcIjtcbiAgLy8gbG9nRGVidWcocyk7XG5cblxuICByZXR1cm4gcmVzO1xufTtcbi8qKlxuICogQGJyaWVmIDogRnVuY3Rpb24gdXNlZCBmb3Iga2VlcGluZyB0cmFjayBvZiBjb21wb3VuZCBub2RlXG4gKiAgICAgICAgICBzaXplcywgc2luY2UgdGhleSBzaG91bGQgYm91bmQgYWxsIHRoZWlyIHN1Ym5vZGVzLlxuICovXG5cblxudmFyIHVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyA9IGZ1bmN0aW9uIHVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyhub2RlLCBsYXlvdXRJbmZvKSB7XG4gIC8vIHZhciBzID0gXCJQcm9wYWdhdGluZyBuZXcgcG9zaXRpb24vc2l6ZSBvZiBub2RlIFwiICsgbm9kZS5pZDtcbiAgdmFyIHBhcmVudElkID0gbm9kZS5wYXJlbnRJZDtcblxuICBpZiAobnVsbCA9PSBwYXJlbnRJZCkge1xuICAgIC8vIElmIHRoZXJlJ3Mgbm8gcGFyZW50LCB3ZSBhcmUgZG9uZVxuICAgIC8vIHMgKz0gXCIuIE5vIHBhcmVudCBub2RlLlwiO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgIHJldHVybjtcbiAgfSAvLyBHZXQgUGFyZW50IE5vZGVcblxuXG4gIHZhciBwID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtwYXJlbnRJZF1dO1xuICB2YXIgZmxhZyA9IGZhbHNlOyAvLyBNYXhYXG5cbiAgaWYgKG51bGwgPT0gcC5tYXhYIHx8IG5vZGUubWF4WCArIHAucGFkUmlnaHQgPiBwLm1heFgpIHtcbiAgICBwLm1heFggPSBub2RlLm1heFggKyBwLnBhZFJpZ2h0O1xuICAgIGZsYWcgPSB0cnVlOyAvLyBzICs9IFwiXFxuTmV3IG1heFggZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWF4WDtcbiAgfSAvLyBNaW5YXG5cblxuICBpZiAobnVsbCA9PSBwLm1pblggfHwgbm9kZS5taW5YIC0gcC5wYWRMZWZ0IDwgcC5taW5YKSB7XG4gICAgcC5taW5YID0gbm9kZS5taW5YIC0gcC5wYWRMZWZ0O1xuICAgIGZsYWcgPSB0cnVlOyAvLyBzICs9IFwiXFxuTmV3IG1pblggZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWluWDtcbiAgfSAvLyBNYXhZXG5cblxuICBpZiAobnVsbCA9PSBwLm1heFkgfHwgbm9kZS5tYXhZICsgcC5wYWRCb3R0b20gPiBwLm1heFkpIHtcbiAgICBwLm1heFkgPSBub2RlLm1heFkgKyBwLnBhZEJvdHRvbTtcbiAgICBmbGFnID0gdHJ1ZTsgLy8gcyArPSBcIlxcbk5ldyBtYXhZIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1heFk7XG4gIH0gLy8gTWluWVxuXG5cbiAgaWYgKG51bGwgPT0gcC5taW5ZIHx8IG5vZGUubWluWSAtIHAucGFkVG9wIDwgcC5taW5ZKSB7XG4gICAgcC5taW5ZID0gbm9kZS5taW5ZIC0gcC5wYWRUb3A7XG4gICAgZmxhZyA9IHRydWU7IC8vIHMgKz0gXCJcXG5OZXcgbWluWSBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5taW5ZO1xuICB9IC8vIElmIHVwZGF0ZWQgYm91bmRhcmllcywgcHJvcGFnYXRlIGNoYW5nZXMgdXB3YXJkXG5cblxuICBpZiAoZmxhZykge1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgIHJldHVybiB1cGRhdGVBbmNlc3RyeUJvdW5kYXJpZXMocCwgbGF5b3V0SW5mbyk7XG4gIH0gLy8gcyArPSBcIi4gTm8gY2hhbmdlcyBpbiBib3VuZGFyaWVzL3Bvc2l0aW9uIG9mIHBhcmVudCBub2RlIFwiICsgcC5pZDtcbiAgLy8gbG9nRGVidWcocyk7XG5cblxuICByZXR1cm47XG59O1xuXG52YXIgc2VwYXJhdGVDb21wb25lbnRzID0gZnVuY3Rpb24gc2VwYXJhdGVDb21wb25lbnRzKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgdmFyIG5vZGVzID0gbGF5b3V0SW5mby5sYXlvdXROb2RlcztcbiAgdmFyIGNvbXBvbmVudHMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICB2YXIgY2lkID0gbm9kZS5jbXB0SWQ7XG4gICAgdmFyIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbY2lkXSA9IGNvbXBvbmVudHNbY2lkXSB8fCBbXTtcbiAgICBjb21wb25lbnQucHVzaChub2RlKTtcbiAgfVxuXG4gIHZhciB0b3RhbEEgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjID0gY29tcG9uZW50c1tpXTtcblxuICAgIGlmICghYykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgYy54MSA9IEluZmluaXR5O1xuICAgIGMueDIgPSAtSW5maW5pdHk7XG4gICAgYy55MSA9IEluZmluaXR5O1xuICAgIGMueTIgPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBuID0gY1tqXTtcbiAgICAgIGMueDEgPSBNYXRoLm1pbihjLngxLCBuLnBvc2l0aW9uWCAtIG4ud2lkdGggLyAyKTtcbiAgICAgIGMueDIgPSBNYXRoLm1heChjLngyLCBuLnBvc2l0aW9uWCArIG4ud2lkdGggLyAyKTtcbiAgICAgIGMueTEgPSBNYXRoLm1pbihjLnkxLCBuLnBvc2l0aW9uWSAtIG4uaGVpZ2h0IC8gMik7XG4gICAgICBjLnkyID0gTWF0aC5tYXgoYy55Miwgbi5wb3NpdGlvblkgKyBuLmhlaWdodCAvIDIpO1xuICAgIH1cblxuICAgIGMudyA9IGMueDIgLSBjLngxO1xuICAgIGMuaCA9IGMueTIgLSBjLnkxO1xuICAgIHRvdGFsQSArPSBjLncgKiBjLmg7XG4gIH1cblxuICBjb21wb25lbnRzLnNvcnQoZnVuY3Rpb24gKGMxLCBjMikge1xuICAgIHJldHVybiBjMi53ICogYzIuaCAtIGMxLncgKiBjMS5oO1xuICB9KTtcbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7XG4gIHZhciB1c2VkVyA9IDA7XG4gIHZhciByb3dIID0gMDtcbiAgdmFyIG1heFJvd1cgPSBNYXRoLnNxcnQodG90YWxBKSAqIGxheW91dEluZm8uY2xpZW50V2lkdGggLyBsYXlvdXRJbmZvLmNsaWVudEhlaWdodDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYyA9IGNvbXBvbmVudHNbaV07XG5cbiAgICBpZiAoIWMpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIG4gPSBjW2pdO1xuXG4gICAgICBpZiAoIW4uaXNMb2NrZWQpIHtcbiAgICAgICAgbi5wb3NpdGlvblggKz0geCAtIGMueDE7XG4gICAgICAgIG4ucG9zaXRpb25ZICs9IHkgLSBjLnkxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHggKz0gYy53ICsgb3B0aW9ucy5jb21wb25lbnRTcGFjaW5nO1xuICAgIHVzZWRXICs9IGMudyArIG9wdGlvbnMuY29tcG9uZW50U3BhY2luZztcbiAgICByb3dIID0gTWF0aC5tYXgocm93SCwgYy5oKTtcblxuICAgIGlmICh1c2VkVyA+IG1heFJvd1cpIHtcbiAgICAgIHkgKz0gcm93SCArIG9wdGlvbnMuY29tcG9uZW50U3BhY2luZztcbiAgICAgIHggPSAwO1xuICAgICAgdXNlZFcgPSAwO1xuICAgICAgcm93SCA9IDA7XG4gICAgfVxuICB9XG59O1xuXG52YXIgZGVmYXVsdHMkMyA9IHtcbiAgZml0OiB0cnVlLFxuICAvLyB3aGV0aGVyIHRvIGZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIGdyYXBoXG4gIHBhZGRpbmc6IDMwLFxuICAvLyBwYWRkaW5nIHVzZWQgb24gZml0XG4gIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsXG4gIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICBhdm9pZE92ZXJsYXA6IHRydWUsXG4gIC8vIHByZXZlbnRzIG5vZGUgb3ZlcmxhcCwgbWF5IG92ZXJmbG93IGJvdW5kaW5nQm94IGlmIG5vdCBlbm91Z2ggc3BhY2VcbiAgYXZvaWRPdmVybGFwUGFkZGluZzogMTAsXG4gIC8vIGV4dHJhIHNwYWNpbmcgYXJvdW5kIG5vZGVzIHdoZW4gYXZvaWRPdmVybGFwOiB0cnVlXG4gIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2UsXG4gIC8vIEV4Y2x1ZGVzIHRoZSBsYWJlbCB3aGVuIGNhbGN1bGF0aW5nIG5vZGUgYm91bmRpbmcgYm94ZXMgZm9yIHRoZSBsYXlvdXQgYWxnb3JpdGhtXG4gIHNwYWNpbmdGYWN0b3I6IHVuZGVmaW5lZCxcbiAgLy8gQXBwbGllcyBhIG11bHRpcGxpY2F0aXZlIGZhY3RvciAoPjApIHRvIGV4cGFuZCBvciBjb21wcmVzcyB0aGUgb3ZlcmFsbCBhcmVhIHRoYXQgdGhlIG5vZGVzIHRha2UgdXBcbiAgY29uZGVuc2U6IGZhbHNlLFxuICAvLyB1c2VzIGFsbCBhdmFpbGFibGUgc3BhY2Ugb24gZmFsc2UsIHVzZXMgbWluaW1hbCBzcGFjZSBvbiB0cnVlXG4gIHJvd3M6IHVuZGVmaW5lZCxcbiAgLy8gZm9yY2UgbnVtIG9mIHJvd3MgaW4gdGhlIGdyaWRcbiAgY29sczogdW5kZWZpbmVkLFxuICAvLyBmb3JjZSBudW0gb2YgY29sdW1ucyBpbiB0aGUgZ3JpZFxuICBwb3NpdGlvbjogZnVuY3Rpb24gcG9zaXRpb24obm9kZSkge30sXG4gIC8vIHJldHVybnMgeyByb3csIGNvbCB9IGZvciBlbGVtZW50XG4gIHNvcnQ6IHVuZGVmaW5lZCxcbiAgLy8gYSBzb3J0aW5nIGZ1bmN0aW9uIHRvIG9yZGVyIHRoZSBub2RlczsgZS5nLiBmdW5jdGlvbihhLCBiKXsgcmV0dXJuIGEuZGF0YSgnd2VpZ2h0JykgLSBiLmRhdGEoJ3dlaWdodCcpIH1cbiAgYW5pbWF0ZTogZmFsc2UsXG4gIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgLy8gYSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWQuICBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWQuICBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICByZWFkeTogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0gLy8gdHJhbnNmb3JtIGEgZ2l2ZW4gbm9kZSBwb3NpdGlvbi4gVXNlZnVsIGZvciBjaGFuZ2luZyBmbG93IGRpcmVjdGlvbiBpbiBkaXNjcmV0ZSBsYXlvdXRzIFxuXG59O1xuXG5mdW5jdGlvbiBHcmlkTGF5b3V0KG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cyQzLCBvcHRpb25zKTtcbn1cblxuR3JpZExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFyYW1zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHBhcmFtcztcbiAgdmFyIGN5ID0gcGFyYW1zLmN5O1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuXG4gIGlmIChvcHRpb25zLnNvcnQpIHtcbiAgICBub2RlcyA9IG5vZGVzLnNvcnQob3B0aW9ucy5zb3J0KTtcbiAgfVxuXG4gIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveChvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICB4MTogMCxcbiAgICB5MTogMCxcbiAgICB3OiBjeS53aWR0aCgpLFxuICAgIGg6IGN5LmhlaWdodCgpXG4gIH0pO1xuXG4gIGlmIChiYi5oID09PSAwIHx8IGJiLncgPT09IDApIHtcbiAgICBlbGVzLm5vZGVzKCkubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGJiLngxLFxuICAgICAgICB5OiBiYi55MVxuICAgICAgfTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyB3aWR0aC9oZWlnaHQgKiBzcGxpdHNeMiA9IGNlbGxzIHdoZXJlIHNwbGl0cyBpcyBudW1iZXIgb2YgdGltZXMgdG8gc3BsaXQgd2lkdGhcbiAgICB2YXIgY2VsbHMgPSBub2Rlcy5zaXplKCk7XG4gICAgdmFyIHNwbGl0cyA9IE1hdGguc3FydChjZWxscyAqIGJiLmggLyBiYi53KTtcbiAgICB2YXIgcm93cyA9IE1hdGgucm91bmQoc3BsaXRzKTtcbiAgICB2YXIgY29scyA9IE1hdGgucm91bmQoYmIudyAvIGJiLmggKiBzcGxpdHMpO1xuXG4gICAgdmFyIHNtYWxsID0gZnVuY3Rpb24gc21hbGwodmFsKSB7XG4gICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHJvd3MsIGNvbHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHJvd3MsIGNvbHMpO1xuXG4gICAgICAgIGlmIChtaW4gPT0gcm93cykge1xuICAgICAgICAgIHJvd3MgPSB2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29scyA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbGFyZ2UgPSBmdW5jdGlvbiBsYXJnZSh2YWwpIHtcbiAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgocm93cywgY29scyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXgocm93cywgY29scyk7XG5cbiAgICAgICAgaWYgKG1heCA9PSByb3dzKSB7XG4gICAgICAgICAgcm93cyA9IHZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2xzID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBvUm93cyA9IG9wdGlvbnMucm93cztcbiAgICB2YXIgb0NvbHMgPSBvcHRpb25zLmNvbHMgIT0gbnVsbCA/IG9wdGlvbnMuY29scyA6IG9wdGlvbnMuY29sdW1uczsgLy8gaWYgcm93cyBvciBjb2x1bW5zIHdlcmUgc2V0IGluIG9wdGlvbnMsIHVzZSB0aG9zZSB2YWx1ZXNcblxuICAgIGlmIChvUm93cyAhPSBudWxsICYmIG9Db2xzICE9IG51bGwpIHtcbiAgICAgIHJvd3MgPSBvUm93cztcbiAgICAgIGNvbHMgPSBvQ29scztcbiAgICB9IGVsc2UgaWYgKG9Sb3dzICE9IG51bGwgJiYgb0NvbHMgPT0gbnVsbCkge1xuICAgICAgcm93cyA9IG9Sb3dzO1xuICAgICAgY29scyA9IE1hdGguY2VpbChjZWxscyAvIHJvd3MpO1xuICAgIH0gZWxzZSBpZiAob1Jvd3MgPT0gbnVsbCAmJiBvQ29scyAhPSBudWxsKSB7XG4gICAgICBjb2xzID0gb0NvbHM7XG4gICAgICByb3dzID0gTWF0aC5jZWlsKGNlbGxzIC8gY29scyk7XG4gICAgfSAvLyBvdGhlcndpc2UgdXNlIHRoZSBhdXRvbWF0aWMgdmFsdWVzIGFuZCBhZGp1c3QgYWNjb3JkaW5nbHlcbiAgICAvLyBpZiByb3VuZGluZyB3YXMgdXAsIHNlZSBpZiB3ZSBjYW4gcmVkdWNlIHJvd3Mgb3IgY29sdW1uc1xuICAgIGVsc2UgaWYgKGNvbHMgKiByb3dzID4gY2VsbHMpIHtcbiAgICAgIHZhciBzbSA9IHNtYWxsKCk7XG4gICAgICB2YXIgbGcgPSBsYXJnZSgpOyAvLyByZWR1Y2luZyB0aGUgc21hbGwgc2lkZSB0YWtlcyBhd2F5IHRoZSBtb3N0IGNlbGxzLCBzbyB0cnkgaXQgZmlyc3RcblxuICAgICAgaWYgKChzbSAtIDEpICogbGcgPj0gY2VsbHMpIHtcbiAgICAgICAgc21hbGwoc20gLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoKGxnIC0gMSkgKiBzbSA+PSBjZWxscykge1xuICAgICAgICBsYXJnZShsZyAtIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiByb3VuZGluZyB3YXMgdG9vIGxvdywgYWRkIHJvd3Mgb3IgY29sdW1uc1xuICAgICAgd2hpbGUgKGNvbHMgKiByb3dzIDwgY2VsbHMpIHtcbiAgICAgICAgdmFyIF9zbSA9IHNtYWxsKCk7XG5cbiAgICAgICAgdmFyIF9sZyA9IGxhcmdlKCk7IC8vIHRyeSB0byBhZGQgdG8gbGFyZ2VyIHNpZGUgZmlyc3QgKGFkZHMgbGVzcyBpbiBtdWx0aXBsaWNhdGlvbilcblxuXG4gICAgICAgIGlmICgoX2xnICsgMSkgKiBfc20gPj0gY2VsbHMpIHtcbiAgICAgICAgICBsYXJnZShfbGcgKyAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzbWFsbChfc20gKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjZWxsV2lkdGggPSBiYi53IC8gY29scztcbiAgICB2YXIgY2VsbEhlaWdodCA9IGJiLmggLyByb3dzO1xuXG4gICAgaWYgKG9wdGlvbnMuY29uZGVuc2UpIHtcbiAgICAgIGNlbGxXaWR0aCA9IDA7XG4gICAgICBjZWxsSGVpZ2h0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hdm9pZE92ZXJsYXApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIHBvcyA9IG5vZGUuX3ByaXZhdGUucG9zaXRpb247XG5cbiAgICAgICAgaWYgKHBvcy54ID09IG51bGwgfHwgcG9zLnkgPT0gbnVsbCkge1xuICAgICAgICAgIC8vIGZvciBiYlxuICAgICAgICAgIHBvcy54ID0gMDtcbiAgICAgICAgICBwb3MueSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmJiID0gbm9kZS5sYXlvdXREaW1lbnNpb25zKG9wdGlvbnMpO1xuICAgICAgICB2YXIgcCA9IG9wdGlvbnMuYXZvaWRPdmVybGFwUGFkZGluZztcbiAgICAgICAgdmFyIHcgPSBuYmIudyArIHA7XG4gICAgICAgIHZhciBoID0gbmJiLmggKyBwO1xuICAgICAgICBjZWxsV2lkdGggPSBNYXRoLm1heChjZWxsV2lkdGgsIHcpO1xuICAgICAgICBjZWxsSGVpZ2h0ID0gTWF0aC5tYXgoY2VsbEhlaWdodCwgaCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNlbGxVc2VkID0ge307IC8vIGUuZy4gJ2MtMC0yJyA9PiB0cnVlXG5cbiAgICB2YXIgdXNlZCA9IGZ1bmN0aW9uIHVzZWQocm93LCBjb2wpIHtcbiAgICAgIHJldHVybiBjZWxsVXNlZFsnYy0nICsgcm93ICsgJy0nICsgY29sXSA/IHRydWUgOiBmYWxzZTtcbiAgICB9O1xuXG4gICAgdmFyIHVzZSA9IGZ1bmN0aW9uIHVzZShyb3csIGNvbCkge1xuICAgICAgY2VsbFVzZWRbJ2MtJyArIHJvdyArICctJyArIGNvbF0gPSB0cnVlO1xuICAgIH07IC8vIHRvIGtlZXAgdHJhY2sgb2YgY3VycmVudCBjZWxsIHBvc2l0aW9uXG5cblxuICAgIHZhciByb3cgPSAwO1xuICAgIHZhciBjb2wgPSAwO1xuXG4gICAgdmFyIG1vdmVUb05leHRDZWxsID0gZnVuY3Rpb24gbW92ZVRvTmV4dENlbGwoKSB7XG4gICAgICBjb2wrKztcblxuICAgICAgaWYgKGNvbCA+PSBjb2xzKSB7XG4gICAgICAgIGNvbCA9IDA7XG4gICAgICAgIHJvdysrO1xuICAgICAgfVxuICAgIH07IC8vIGdldCBhIGNhY2hlIG9mIGFsbCB0aGUgbWFudWFsIHBvc2l0aW9uc1xuXG5cbiAgICB2YXIgaWQybWFuUG9zID0ge307XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbm9kZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX25vZGUgPSBub2Rlc1tfaV07XG4gICAgICB2YXIgcmNQb3MgPSBvcHRpb25zLnBvc2l0aW9uKF9ub2RlKTtcblxuICAgICAgaWYgKHJjUG9zICYmIChyY1Bvcy5yb3cgIT09IHVuZGVmaW5lZCB8fCByY1Bvcy5jb2wgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgLy8gbXVzdCBoYXZlIGF0IGxlYXN0IHJvdyBvciBjb2wgZGVmJ2RcbiAgICAgICAgdmFyIF9wb3MgPSB7XG4gICAgICAgICAgcm93OiByY1Bvcy5yb3csXG4gICAgICAgICAgY29sOiByY1Bvcy5jb2xcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoX3Bvcy5jb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGZpbmQgdW51c2VkIGNvbFxuICAgICAgICAgIF9wb3MuY29sID0gMDtcblxuICAgICAgICAgIHdoaWxlICh1c2VkKF9wb3Mucm93LCBfcG9zLmNvbCkpIHtcbiAgICAgICAgICAgIF9wb3MuY29sKys7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKF9wb3Mucm93ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBmaW5kIHVudXNlZCByb3dcbiAgICAgICAgICBfcG9zLnJvdyA9IDA7XG5cbiAgICAgICAgICB3aGlsZSAodXNlZChfcG9zLnJvdywgX3Bvcy5jb2wpKSB7XG4gICAgICAgICAgICBfcG9zLnJvdysrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlkMm1hblBvc1tfbm9kZS5pZCgpXSA9IF9wb3M7XG4gICAgICAgIHVzZShfcG9zLnJvdywgX3Bvcy5jb2wpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBnZXRQb3MgPSBmdW5jdGlvbiBnZXRQb3MoZWxlbWVudCwgaSkge1xuICAgICAgdmFyIHgsIHk7XG5cbiAgICAgIGlmIChlbGVtZW50LmxvY2tlZCgpIHx8IGVsZW1lbnQuaXNQYXJlbnQoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIHNlZSBpZiB3ZSBoYXZlIGEgbWFudWFsIHBvc2l0aW9uIHNldFxuXG5cbiAgICAgIHZhciByY1BvcyA9IGlkMm1hblBvc1tlbGVtZW50LmlkKCldO1xuXG4gICAgICBpZiAocmNQb3MpIHtcbiAgICAgICAgeCA9IHJjUG9zLmNvbCAqIGNlbGxXaWR0aCArIGNlbGxXaWR0aCAvIDIgKyBiYi54MTtcbiAgICAgICAgeSA9IHJjUG9zLnJvdyAqIGNlbGxIZWlnaHQgKyBjZWxsSGVpZ2h0IC8gMiArIGJiLnkxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHNldCBhdXRvbWF0aWNhbGx5XG4gICAgICAgIHdoaWxlICh1c2VkKHJvdywgY29sKSkge1xuICAgICAgICAgIG1vdmVUb05leHRDZWxsKCk7XG4gICAgICAgIH1cblxuICAgICAgICB4ID0gY29sICogY2VsbFdpZHRoICsgY2VsbFdpZHRoIC8gMiArIGJiLngxO1xuICAgICAgICB5ID0gcm93ICogY2VsbEhlaWdodCArIGNlbGxIZWlnaHQgLyAyICsgYmIueTE7XG4gICAgICAgIHVzZShyb3csIGNvbCk7XG4gICAgICAgIG1vdmVUb05leHRDZWxsKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICAgIH07XG4gICAgfTtcblxuICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBnZXRQb3MpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG52YXIgZGVmYXVsdHMkMiA9IHtcbiAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge30sXG4gIC8vIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7fSAvLyBvbiBsYXlvdXRzdG9wXG5cbn07IC8vIGNvbnN0cnVjdG9yXG4vLyBvcHRpb25zIDogb2JqZWN0IGNvbnRhaW5pbmcgbGF5b3V0IG9wdGlvbnNcblxuZnVuY3Rpb24gTnVsbExheW91dChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMkMiwgb3B0aW9ucyk7XG59IC8vIHJ1bnMgdGhlIGxheW91dFxuXG5cbk51bGxMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzOyAvLyBlbGVtZW50cyB0byBjb25zaWRlciBpbiB0aGUgbGF5b3V0XG5cbiAgdmFyIGxheW91dCA9IHRoaXM7IC8vIGN5IGlzIGF1dG9tYXRpY2FsbHkgcG9wdWxhdGVkIGZvciB1cyBpbiB0aGUgY29uc3RydWN0b3JcbiAgLy8gKGRpc2FibGUgZXNsaW50IGZvciBuZXh0IGxpbmUgYXMgdGhpcyBzZXJ2ZXMgYXMgZXhhbXBsZSBsYXlvdXQgY29kZSB0byBleHRlcm5hbCBkZXZlbG9wZXJzKVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICBvcHRpb25zLmN5O1xuICBsYXlvdXQuZW1pdCgnbGF5b3V0c3RhcnQnKTsgLy8gcHV0cyBhbGwgbm9kZXMgYXQgKDAsIDApXG4gIC8vIG4uYi4gbW9zdCBsYXlvdXRzIHdvdWxkIHVzZSBsYXlvdXRQb3NpdGlvbnMoKSwgaW5zdGVhZCBvZiBwb3NpdGlvbnMoKSBhbmQgbWFudWFsIGV2ZW50c1xuXG4gIGVsZXMubm9kZXMoKS5wb3NpdGlvbnMoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gIH0pOyAvLyB0cmlnZ2VyIGxheW91dHJlYWR5IHdoZW4gZWFjaCBub2RlIGhhcyBoYWQgaXRzIHBvc2l0aW9uIHNldCBhdCBsZWFzdCBvbmNlXG5cbiAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgbGF5b3V0LmVtaXQoJ2xheW91dHJlYWR5Jyk7IC8vIHRyaWdnZXIgbGF5b3V0c3RvcCB3aGVuIHRoZSBsYXlvdXQgc3RvcHMgKGUuZy4gZmluaXNoZXMpXG5cbiAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gIGxheW91dC5lbWl0KCdsYXlvdXRzdG9wJyk7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTsgLy8gY2FsbGVkIG9uIGNvbnRpbnVvdXMgbGF5b3V0cyB0byBzdG9wIHRoZW0gYmVmb3JlIHRoZXkgZmluaXNoXG5cblxuTnVsbExheW91dC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG52YXIgZGVmYXVsdHMkMSA9IHtcbiAgcG9zaXRpb25zOiB1bmRlZmluZWQsXG4gIC8vIG1hcCBvZiAobm9kZSBpZCkgPT4gKHBvc2l0aW9uIG9iaik7IG9yIGZ1bmN0aW9uKG5vZGUpeyByZXR1cm4gc29tUG9zOyB9XG4gIHpvb206IHVuZGVmaW5lZCxcbiAgLy8gdGhlIHpvb20gbGV2ZWwgdG8gc2V0IChwcm9iIHdhbnQgZml0ID0gZmFsc2UgaWYgc2V0KVxuICBwYW46IHVuZGVmaW5lZCxcbiAgLy8gdGhlIHBhbiBsZXZlbCB0byBzZXQgKHByb2Igd2FudCBmaXQgPSBmYWxzZSBpZiBzZXQpXG4gIGZpdDogdHJ1ZSxcbiAgLy8gd2hldGhlciB0byBmaXQgdG8gdmlld3BvcnRcbiAgcGFkZGluZzogMzAsXG4gIC8vIHBhZGRpbmcgb24gZml0XG4gIGFuaW1hdGU6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG4gIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWRcbiAgYW5pbWF0ZUZpbHRlcjogZnVuY3Rpb24gYW5pbWF0ZUZpbHRlcihub2RlLCBpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIC8vIGEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGFuaW1hdGVkLiAgQWxsIG5vZGVzIGFuaW1hdGVkIGJ5IGRlZmF1bHQgb24gYW5pbWF0ZSBlbmFibGVkLiAgTm9uLWFuaW1hdGVkIG5vZGVzIGFyZSBwb3NpdGlvbmVkIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGxheW91dCBzdGFydHNcbiAgcmVhZHk6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9IC8vIHRyYW5zZm9ybSBhIGdpdmVuIG5vZGUgcG9zaXRpb24uIFVzZWZ1bCBmb3IgY2hhbmdpbmcgZmxvdyBkaXJlY3Rpb24gaW4gZGlzY3JldGUgbGF5b3V0c1xuXG59O1xuXG5mdW5jdGlvbiBQcmVzZXRMYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJDEsIG9wdGlvbnMpO1xufVxuXG5QcmVzZXRMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCk7XG4gIHZhciBwb3NJc0ZuID0gZm4kNihvcHRpb25zLnBvc2l0aW9ucyk7XG5cbiAgZnVuY3Rpb24gZ2V0UG9zaXRpb24obm9kZSkge1xuICAgIGlmIChvcHRpb25zLnBvc2l0aW9ucyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29weVBvc2l0aW9uKG5vZGUucG9zaXRpb24oKSk7XG4gICAgfVxuXG4gICAgaWYgKHBvc0lzRm4pIHtcbiAgICAgIHJldHVybiBvcHRpb25zLnBvc2l0aW9ucyhub2RlKTtcbiAgICB9XG5cbiAgICB2YXIgcG9zID0gb3B0aW9ucy5wb3NpdGlvbnNbbm9kZS5fcHJpdmF0ZS5kYXRhLmlkXTtcblxuICAgIGlmIChwb3MgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvcztcbiAgfVxuXG4gIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbiAobm9kZSwgaSkge1xuICAgIHZhciBwb3NpdGlvbiA9IGdldFBvc2l0aW9uKG5vZGUpO1xuXG4gICAgaWYgKG5vZGUubG9ja2VkKCkgfHwgcG9zaXRpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfSk7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxudmFyIGRlZmF1bHRzID0ge1xuICBmaXQ6IHRydWUsXG4gIC8vIHdoZXRoZXIgdG8gZml0IHRvIHZpZXdwb3J0XG4gIHBhZGRpbmc6IDMwLFxuICAvLyBmaXQgcGFkZGluZ1xuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLFxuICAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYW5pbWF0ZTogZmFsc2UsXG4gIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgLy8gYSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWQuICBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWQuICBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICByZWFkeTogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0gLy8gdHJhbnNmb3JtIGEgZ2l2ZW4gbm9kZSBwb3NpdGlvbi4gVXNlZnVsIGZvciBjaGFuZ2luZyBmbG93IGRpcmVjdGlvbiBpbiBkaXNjcmV0ZSBsYXlvdXRzIFxuXG59O1xuXG5mdW5jdGlvbiBSYW5kb21MYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbn1cblxuUmFuZG9tTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgY3kgPSBvcHRpb25zLmN5O1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgdmFyIGJiID0gbWFrZUJvdW5kaW5nQm94KG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgIHgxOiAwLFxuICAgIHkxOiAwLFxuICAgIHc6IGN5LndpZHRoKCksXG4gICAgaDogY3kuaGVpZ2h0KClcbiAgfSk7XG5cbiAgdmFyIGdldFBvcyA9IGZ1bmN0aW9uIGdldFBvcyhub2RlLCBpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGJiLngxICsgTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogYmIudyksXG4gICAgICB5OiBiYi55MSArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIGJiLmgpXG4gICAgfTtcbiAgfTtcblxuICBlbGVzLm5vZGVzKCkubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGdldFBvcyk7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxudmFyIGxheW91dCA9IFt7XG4gIG5hbWU6ICdicmVhZHRoZmlyc3QnLFxuICBpbXBsOiBCcmVhZHRoRmlyc3RMYXlvdXRcbn0sIHtcbiAgbmFtZTogJ2NpcmNsZScsXG4gIGltcGw6IENpcmNsZUxheW91dFxufSwge1xuICBuYW1lOiAnY29uY2VudHJpYycsXG4gIGltcGw6IENvbmNlbnRyaWNMYXlvdXRcbn0sIHtcbiAgbmFtZTogJ2Nvc2UnLFxuICBpbXBsOiBDb3NlTGF5b3V0XG59LCB7XG4gIG5hbWU6ICdncmlkJyxcbiAgaW1wbDogR3JpZExheW91dFxufSwge1xuICBuYW1lOiAnbnVsbCcsXG4gIGltcGw6IE51bGxMYXlvdXRcbn0sIHtcbiAgbmFtZTogJ3ByZXNldCcsXG4gIGltcGw6IFByZXNldExheW91dFxufSwge1xuICBuYW1lOiAncmFuZG9tJyxcbiAgaW1wbDogUmFuZG9tTGF5b3V0XG59XTtcblxuZnVuY3Rpb24gTnVsbFJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5ub3RpZmljYXRpb25zID0gMDsgLy8gZm9yIHRlc3Rpbmdcbn1cblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbnZhciB0aHJvd0ltZ0VyciA9IGZ1bmN0aW9uIHRocm93SW1nRXJyKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0EgaGVhZGxlc3MgaW5zdGFuY2UgY2FuIG5vdCByZW5kZXIgaW1hZ2VzJyk7XG59O1xuXG5OdWxsUmVuZGVyZXIucHJvdG90eXBlID0ge1xuICByZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGU6IG5vb3AsXG4gIG5vdGlmeTogZnVuY3Rpb24gbm90aWZ5KCkge1xuICAgIHRoaXMubm90aWZpY2F0aW9ucysrO1xuICB9LFxuICBpbml0OiBub29wLFxuICBpc0hlYWRsZXNzOiBmdW5jdGlvbiBpc0hlYWRsZXNzKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBwbmc6IHRocm93SW1nRXJyLFxuICBqcGc6IHRocm93SW1nRXJyXG59O1xuXG52YXIgQlJwJGYgPSB7fTtcbkJScCRmLmFycm93U2hhcGVXaWR0aCA9IDAuMztcblxuQlJwJGYucmVnaXN0ZXJBcnJvd1NoYXBlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFycm93U2hhcGVzID0gdGhpcy5hcnJvd1NoYXBlcyA9IHt9O1xuICB2YXIgcmVuZGVyZXIgPSB0aGlzOyAvLyBDb250cmFjdCBmb3IgYXJyb3cgc2hhcGVzOlxuICAvLyAwLCAwIGlzIGFycm93IHRpcFxuICAvLyAoMCwgMSkgaXMgZGlyZWN0aW9uIHRvd2FyZHMgbm9kZVxuICAvLyAoMSwgMCkgaXMgcmlnaHRcbiAgLy9cbiAgLy8gZnVuY3Rpb25hbCBhcGk6XG4gIC8vIGNvbGxpZGU6IGNoZWNrIHgsIHkgaW4gc2hhcGVcbiAgLy8gcm91Z2hDb2xsaWRlOiBjYWxsZWQgYmVmb3JlIGNvbGxpZGUsIG5vIGZhbHNlIG5lZ2F0aXZlc1xuICAvLyBkcmF3OiBkcmF3XG4gIC8vIHNwYWNpbmc6IGRpc3QoYXJyb3dUaXAsIG5vZGVCb3VuZGFyeSlcbiAgLy8gZ2FwOiBkaXN0KGVkZ2VUaXAsIG5vZGVCb3VuZGFyeSksIGVkZ2VUaXAgbWF5ICE9IGFycm93VGlwXG5cbiAgdmFyIGJiQ29sbGlkZSA9IGZ1bmN0aW9uIGJiQ29sbGlkZSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCwgcGFkZGluZykge1xuICAgIHZhciB4MSA9IHRyYW5zbGF0aW9uLnggLSBzaXplIC8gMiAtIHBhZGRpbmc7XG4gICAgdmFyIHgyID0gdHJhbnNsYXRpb24ueCArIHNpemUgLyAyICsgcGFkZGluZztcbiAgICB2YXIgeTEgPSB0cmFuc2xhdGlvbi55IC0gc2l6ZSAvIDIgLSBwYWRkaW5nO1xuICAgIHZhciB5MiA9IHRyYW5zbGF0aW9uLnkgKyBzaXplIC8gMiArIHBhZGRpbmc7XG4gICAgdmFyIGluc2lkZSA9IHgxIDw9IHggJiYgeCA8PSB4MiAmJiB5MSA8PSB5ICYmIHkgPD0geTI7XG4gICAgcmV0dXJuIGluc2lkZTtcbiAgfTtcblxuICB2YXIgdHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikge1xuICAgIHZhciB4Um90YXRlZCA9IHggKiBNYXRoLmNvcyhhbmdsZSkgLSB5ICogTWF0aC5zaW4oYW5nbGUpO1xuICAgIHZhciB5Um90YXRlZCA9IHggKiBNYXRoLnNpbihhbmdsZSkgKyB5ICogTWF0aC5jb3MoYW5nbGUpO1xuICAgIHZhciB4U2NhbGVkID0geFJvdGF0ZWQgKiBzaXplO1xuICAgIHZhciB5U2NhbGVkID0geVJvdGF0ZWQgKiBzaXplO1xuICAgIHZhciB4VHJhbnNsYXRlZCA9IHhTY2FsZWQgKyB0cmFuc2xhdGlvbi54O1xuICAgIHZhciB5VHJhbnNsYXRlZCA9IHlTY2FsZWQgKyB0cmFuc2xhdGlvbi55O1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4VHJhbnNsYXRlZCxcbiAgICAgIHk6IHlUcmFuc2xhdGVkXG4gICAgfTtcbiAgfTtcblxuICB2YXIgdHJhbnNmb3JtUG9pbnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtUG9pbnRzKHB0cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSB7XG4gICAgdmFyIHJldFB0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHZhciB4ID0gcHRzW2ldO1xuICAgICAgdmFyIHkgPSBwdHNbaSArIDFdO1xuICAgICAgcmV0UHRzLnB1c2godHJhbnNmb3JtKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgIH1cblxuICAgIHJldHVybiByZXRQdHM7XG4gIH07XG5cbiAgdmFyIHBvaW50c1RvQXJyID0gZnVuY3Rpb24gcG9pbnRzVG9BcnIocHRzKSB7XG4gICAgdmFyIHJldCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gcHRzW2ldO1xuICAgICAgcmV0LnB1c2gocC54LCBwLnkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgdmFyIHN0YW5kYXJkR2FwID0gZnVuY3Rpb24gc3RhbmRhcmRHYXAoZWRnZSkge1xuICAgIHJldHVybiBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlICogZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykucGZWYWx1ZSAqIDI7XG4gIH07XG5cbiAgdmFyIGRlZmluZUFycm93U2hhcGUgPSBmdW5jdGlvbiBkZWZpbmVBcnJvd1NoYXBlKG5hbWUsIGRlZm4pIHtcbiAgICBpZiAoc3RyaW5nKGRlZm4pKSB7XG4gICAgICBkZWZuID0gYXJyb3dTaGFwZXNbZGVmbl07XG4gICAgfVxuXG4gICAgYXJyb3dTaGFwZXNbbmFtZV0gPSBleHRlbmQoe1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHBvaW50czogWy0wLjE1LCAtMC4zLCAwLjE1LCAtMC4zLCAwLjE1LCAwLjMsIC0wLjE1LCAwLjNdLFxuICAgICAgY29sbGlkZTogZnVuY3Rpb24gY29sbGlkZSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIHBhZGRpbmcpIHtcbiAgICAgICAgdmFyIHBvaW50cyA9IHBvaW50c1RvQXJyKHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICAgICAgdmFyIGluc2lkZSA9IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBwb2ludHMpO1xuICAgICAgICByZXR1cm4gaW5zaWRlO1xuICAgICAgfSxcbiAgICAgIHJvdWdoQ29sbGlkZTogYmJDb2xsaWRlLFxuICAgICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pIHtcbiAgICAgICAgdmFyIHBvaW50cyA9IHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwoJ3BvbHlnb24nKShjb250ZXh0LCBwb2ludHMpO1xuICAgICAgfSxcbiAgICAgIHNwYWNpbmc6IGZ1bmN0aW9uIHNwYWNpbmcoZWRnZSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sXG4gICAgICBnYXA6IHN0YW5kYXJkR2FwXG4gICAgfSwgZGVmbik7XG4gIH07XG5cbiAgZGVmaW5lQXJyb3dTaGFwZSgnbm9uZScsIHtcbiAgICBjb2xsaWRlOiBmYWxzaWZ5LFxuICAgIHJvdWdoQ29sbGlkZTogZmFsc2lmeSxcbiAgICBkcmF3OiBub29wJDEsXG4gICAgc3BhY2luZzogemVyb2lmeSxcbiAgICBnYXA6IHplcm9pZnlcbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ3RyaWFuZ2xlJywge1xuICAgIHBvaW50czogWy0wLjE1LCAtMC4zLCAwLCAwLCAwLjE1LCAtMC4zXVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgnYXJyb3cnLCAndHJpYW5nbGUnKTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgndHJpYW5nbGUtYmFja2N1cnZlJywge1xuICAgIHBvaW50czogYXJyb3dTaGFwZXNbJ3RyaWFuZ2xlJ10ucG9pbnRzLFxuICAgIGNvbnRyb2xQb2ludDogWzAsIC0wLjE1XSxcbiAgICByb3VnaENvbGxpZGU6IGJiQ29sbGlkZSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoKSB7XG4gICAgICB2YXIgcHRzVHJhbnMgPSB0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICB2YXIgY3RybFB0ID0gdGhpcy5jb250cm9sUG9pbnQ7XG4gICAgICB2YXIgY3RybFB0VHJhbnMgPSB0cmFuc2Zvcm0oY3RybFB0WzBdLCBjdHJsUHRbMV0sIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCh0aGlzLm5hbWUpKGNvbnRleHQsIHB0c1RyYW5zLCBjdHJsUHRUcmFucyk7XG4gICAgfSxcbiAgICBnYXA6IGZ1bmN0aW9uIGdhcChlZGdlKSB7XG4gICAgICByZXR1cm4gc3RhbmRhcmRHYXAoZWRnZSkgKiAwLjg7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgndHJpYW5nbGUtdGVlJywge1xuICAgIHBvaW50czogWzAsIDAsIDAuMTUsIC0wLjMsIC0wLjE1LCAtMC4zLCAwLCAwXSxcbiAgICBwb2ludHNUZWU6IFstMC4xNSwgLTAuNCwgLTAuMTUsIC0wLjUsIDAuMTUsIC0wLjUsIDAuMTUsIC0wLjRdLFxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uIGNvbGxpZGUoeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgsIHBhZGRpbmcpIHtcbiAgICAgIHZhciB0cmlQdHMgPSBwb2ludHNUb0Fycih0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUgKyAyICogcGFkZGluZywgYW5nbGUsIHRyYW5zbGF0aW9uKSk7XG4gICAgICB2YXIgdGVlUHRzID0gcG9pbnRzVG9BcnIodHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzVGVlLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgICAgdmFyIGluc2lkZSA9IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCB0cmlQdHMpIHx8IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCB0ZWVQdHMpO1xuICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgpIHtcbiAgICAgIHZhciB0cmlQdHMgPSB0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICB2YXIgdGVlUHRzID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzVGVlLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwodGhpcy5uYW1lKShjb250ZXh0LCB0cmlQdHMsIHRlZVB0cyk7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgnY2lyY2xlLXRyaWFuZ2xlJywge1xuICAgIHJhZGl1czogMC4xNSxcbiAgICBwb2ludHNUcjogWzAsIC0wLjE1LCAwLjE1LCAtMC40NSwgLTAuMTUsIC0wLjQ1LCAwLCAtMC4xNV0sXG4gICAgY29sbGlkZTogZnVuY3Rpb24gY29sbGlkZSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCwgcGFkZGluZykge1xuICAgICAgdmFyIHQgPSB0cmFuc2xhdGlvbjtcbiAgICAgIHZhciBjaXJjbGVJbnNpZGUgPSBNYXRoLnBvdyh0LnggLSB4LCAyKSArIE1hdGgucG93KHQueSAtIHksIDIpIDw9IE1hdGgucG93KChzaXplICsgMiAqIHBhZGRpbmcpICogdGhpcy5yYWRpdXMsIDIpO1xuICAgICAgdmFyIHRyaVB0cyA9IHBvaW50c1RvQXJyKHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICAgIHJldHVybiBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgdHJpUHRzKSB8fCBjaXJjbGVJbnNpZGU7XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoKSB7XG4gICAgICB2YXIgdHJpUHRzID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzVHIsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCh0aGlzLm5hbWUpKGNvbnRleHQsIHRyaVB0cywgdHJhbnNsYXRpb24ueCwgdHJhbnNsYXRpb24ueSwgdGhpcy5yYWRpdXMgKiBzaXplKTtcbiAgICB9LFxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uIHNwYWNpbmcoZWRnZSkge1xuICAgICAgcmV0dXJuIHJlbmRlcmVyLmdldEFycm93V2lkdGgoZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSwgZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWUpICogdGhpcy5yYWRpdXM7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgndHJpYW5nbGUtY3Jvc3MnLCB7XG4gICAgcG9pbnRzOiBbMCwgMCwgMC4xNSwgLTAuMywgLTAuMTUsIC0wLjMsIDAsIDBdLFxuICAgIGJhc2VDcm9zc0xpbmVQdHM6IFstMC4xNSwgLTAuNCwgLy8gZmlyc3QgaGFsZiBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgLTAuMTUsIC0wLjQsIDAuMTUsIC0wLjQsIC8vIHNlY29uZCBoYWxmIG9mIHRoZSByZWN0YW5nbGVcbiAgICAwLjE1LCAtMC40XSxcbiAgICBjcm9zc0xpbmVQdHM6IGZ1bmN0aW9uIGNyb3NzTGluZVB0cyhzaXplLCBlZGdlV2lkdGgpIHtcbiAgICAgIC8vIHNoaWZ0IHBvaW50cyBzbyB0aGF0IHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBjcm9zcyBwb2ludHMgbWF0Y2hlcyBlZGdlIHdpZHRoXG4gICAgICB2YXIgcCA9IHRoaXMuYmFzZUNyb3NzTGluZVB0cy5zbGljZSgpO1xuICAgICAgdmFyIHNoaWZ0RmFjdG9yID0gZWRnZVdpZHRoIC8gc2l6ZTtcbiAgICAgIHZhciB5MCA9IDM7XG4gICAgICB2YXIgeTEgPSA1O1xuICAgICAgcFt5MF0gPSBwW3kwXSAtIHNoaWZ0RmFjdG9yO1xuICAgICAgcFt5MV0gPSBwW3kxXSAtIHNoaWZ0RmFjdG9yO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcbiAgICBjb2xsaWRlOiBmdW5jdGlvbiBjb2xsaWRlKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgdHJpUHRzID0gcG9pbnRzVG9BcnIodHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgICAgdmFyIHRlZVB0cyA9IHBvaW50c1RvQXJyKHRyYW5zZm9ybVBvaW50cyh0aGlzLmNyb3NzTGluZVB0cyhzaXplLCBlZGdlV2lkdGgpLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgICAgdmFyIGluc2lkZSA9IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCB0cmlQdHMpIHx8IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCB0ZWVQdHMpO1xuICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgpIHtcbiAgICAgIHZhciB0cmlQdHMgPSB0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICB2YXIgY3Jvc3NMaW5lUHRzID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMuY3Jvc3NMaW5lUHRzKHNpemUsIGVkZ2VXaWR0aCksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCh0aGlzLm5hbWUpKGNvbnRleHQsIHRyaVB0cywgY3Jvc3NMaW5lUHRzKTtcbiAgICB9XG4gIH0pO1xuICBkZWZpbmVBcnJvd1NoYXBlKCd2ZWUnLCB7XG4gICAgcG9pbnRzOiBbLTAuMTUsIC0wLjMsIDAsIDAsIDAuMTUsIC0wLjMsIDAsIC0wLjE1XSxcbiAgICBnYXA6IGZ1bmN0aW9uIGdhcChlZGdlKSB7XG4gICAgICByZXR1cm4gc3RhbmRhcmRHYXAoZWRnZSkgKiAwLjUyNTtcbiAgICB9XG4gIH0pO1xuICBkZWZpbmVBcnJvd1NoYXBlKCdjaXJjbGUnLCB7XG4gICAgcmFkaXVzOiAwLjE1LFxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uIGNvbGxpZGUoeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgsIHBhZGRpbmcpIHtcbiAgICAgIHZhciB0ID0gdHJhbnNsYXRpb247XG4gICAgICB2YXIgaW5zaWRlID0gTWF0aC5wb3codC54IC0geCwgMikgKyBNYXRoLnBvdyh0LnkgLSB5LCAyKSA8PSBNYXRoLnBvdygoc2l6ZSArIDIgKiBwYWRkaW5nKSAqIHRoaXMucmFkaXVzLCAyKTtcbiAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoKSB7XG4gICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCh0aGlzLm5hbWUpKGNvbnRleHQsIHRyYW5zbGF0aW9uLngsIHRyYW5zbGF0aW9uLnksIHRoaXMucmFkaXVzICogc2l6ZSk7XG4gICAgfSxcbiAgICBzcGFjaW5nOiBmdW5jdGlvbiBzcGFjaW5nKGVkZ2UpIHtcbiAgICAgIHJldHVybiByZW5kZXJlci5nZXRBcnJvd1dpZHRoKGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUsIGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlKSAqIHRoaXMucmFkaXVzO1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ3RlZScsIHtcbiAgICBwb2ludHM6IFstMC4xNSwgMCwgLTAuMTUsIC0wLjEsIDAuMTUsIC0wLjEsIDAuMTUsIDBdLFxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uIHNwYWNpbmcoZWRnZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSxcbiAgICBnYXA6IGZ1bmN0aW9uIGdhcChlZGdlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0pO1xuICBkZWZpbmVBcnJvd1NoYXBlKCdzcXVhcmUnLCB7XG4gICAgcG9pbnRzOiBbLTAuMTUsIDAuMDAsIDAuMTUsIDAuMDAsIDAuMTUsIC0wLjMsIC0wLjE1LCAtMC4zXVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgnZGlhbW9uZCcsIHtcbiAgICBwb2ludHM6IFstMC4xNSwgLTAuMTUsIDAsIC0wLjMsIDAuMTUsIC0wLjE1LCAwLCAwXSxcbiAgICBnYXA6IGZ1bmN0aW9uIGdhcChlZGdlKSB7XG4gICAgICByZXR1cm4gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSAqIGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ2NoZXZyb24nLCB7XG4gICAgcG9pbnRzOiBbMCwgMCwgLTAuMTUsIC0wLjE1LCAtMC4xLCAtMC4yLCAwLCAtMC4xLCAwLjEsIC0wLjIsIDAuMTUsIC0wLjE1XSxcbiAgICBnYXA6IGZ1bmN0aW9uIGdhcChlZGdlKSB7XG4gICAgICByZXR1cm4gMC45NSAqIGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUgKiBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIEJScCRlID0ge307IC8vIFByb2plY3QgbW91c2VcblxuQlJwJGUucHJvamVjdEludG9WaWV3cG9ydCA9IGZ1bmN0aW9uIChjbGllbnRYLCBjbGllbnRZKSB7XG4gIHZhciBjeSA9IHRoaXMuY3k7XG4gIHZhciBvZmZzZXRzID0gdGhpcy5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gIHZhciBvZmZzZXRMZWZ0ID0gb2Zmc2V0c1swXTtcbiAgdmFyIG9mZnNldFRvcCA9IG9mZnNldHNbMV07XG4gIHZhciBzY2FsZSA9IG9mZnNldHNbNF07XG4gIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gIHZhciB4ID0gKChjbGllbnRYIC0gb2Zmc2V0TGVmdCkgLyBzY2FsZSAtIHBhbi54KSAvIHpvb207XG4gIHZhciB5ID0gKChjbGllbnRZIC0gb2Zmc2V0VG9wKSAvIHNjYWxlIC0gcGFuLnkpIC8gem9vbTtcbiAgcmV0dXJuIFt4LCB5XTtcbn07XG5cbkJScCRlLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNvbnRhaW5lckJCKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyQkI7XG4gIH1cblxuICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gIHZhciByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc3R5bGUgPSB0aGlzLmN5LndpbmRvdygpLmdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKTtcblxuICB2YXIgc3R5bGVWYWx1ZSA9IGZ1bmN0aW9uIHN0eWxlVmFsdWUobmFtZSkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUobmFtZSkpO1xuICB9O1xuXG4gIHZhciBwYWRkaW5nID0ge1xuICAgIGxlZnQ6IHN0eWxlVmFsdWUoJ3BhZGRpbmctbGVmdCcpLFxuICAgIHJpZ2h0OiBzdHlsZVZhbHVlKCdwYWRkaW5nLXJpZ2h0JyksXG4gICAgdG9wOiBzdHlsZVZhbHVlKCdwYWRkaW5nLXRvcCcpLFxuICAgIGJvdHRvbTogc3R5bGVWYWx1ZSgncGFkZGluZy1ib3R0b20nKVxuICB9O1xuICB2YXIgYm9yZGVyID0ge1xuICAgIGxlZnQ6IHN0eWxlVmFsdWUoJ2JvcmRlci1sZWZ0LXdpZHRoJyksXG4gICAgcmlnaHQ6IHN0eWxlVmFsdWUoJ2JvcmRlci1yaWdodC13aWR0aCcpLFxuICAgIHRvcDogc3R5bGVWYWx1ZSgnYm9yZGVyLXRvcC13aWR0aCcpLFxuICAgIGJvdHRvbTogc3R5bGVWYWx1ZSgnYm9yZGVyLWJvdHRvbS13aWR0aCcpXG4gIH07XG4gIHZhciBjbGllbnRXaWR0aCA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgdmFyIGNsaWVudEhlaWdodCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG4gIHZhciBwYWRkaW5nSG9yID0gcGFkZGluZy5sZWZ0ICsgcGFkZGluZy5yaWdodDtcbiAgdmFyIHBhZGRpbmdWZXIgPSBwYWRkaW5nLnRvcCArIHBhZGRpbmcuYm90dG9tO1xuICB2YXIgYm9yZGVySG9yID0gYm9yZGVyLmxlZnQgKyBib3JkZXIucmlnaHQ7XG4gIHZhciBzY2FsZSA9IHJlY3Qud2lkdGggLyAoY2xpZW50V2lkdGggKyBib3JkZXJIb3IpO1xuICB2YXIgdW5zY2FsZWRXID0gY2xpZW50V2lkdGggLSBwYWRkaW5nSG9yO1xuICB2YXIgdW5zY2FsZWRIID0gY2xpZW50SGVpZ2h0IC0gcGFkZGluZ1ZlcjtcbiAgdmFyIGxlZnQgPSByZWN0LmxlZnQgKyBwYWRkaW5nLmxlZnQgKyBib3JkZXIubGVmdDtcbiAgdmFyIHRvcCA9IHJlY3QudG9wICsgcGFkZGluZy50b3AgKyBib3JkZXIudG9wO1xuICByZXR1cm4gdGhpcy5jb250YWluZXJCQiA9IFtsZWZ0LCB0b3AsIHVuc2NhbGVkVywgdW5zY2FsZWRILCBzY2FsZV07XG59O1xuXG5CUnAkZS5pbnZhbGlkYXRlQ29udGFpbmVyQ2xpZW50Q29vcmRzQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY29udGFpbmVyQkIgPSBudWxsO1xufTtcblxuQlJwJGUuZmluZE5lYXJlc3RFbGVtZW50ID0gZnVuY3Rpb24gKHgsIHksIGludGVyYWN0aXZlRWxlbWVudHNPbmx5LCBpc1RvdWNoKSB7XG4gIHJldHVybiB0aGlzLmZpbmROZWFyZXN0RWxlbWVudHMoeCwgeSwgaW50ZXJhY3RpdmVFbGVtZW50c09ubHksIGlzVG91Y2gpWzBdO1xufTtcblxuQlJwJGUuZmluZE5lYXJlc3RFbGVtZW50cyA9IGZ1bmN0aW9uICh4LCB5LCBpbnRlcmFjdGl2ZUVsZW1lbnRzT25seSwgaXNUb3VjaCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGVsZXMgPSByLmdldENhY2hlZFpTb3J0ZWRFbGVzKCk7XG4gIHZhciBuZWFyID0gW107IC8vIDEgbm9kZSBtYXgsIDEgZWRnZSBtYXhcblxuICB2YXIgem9vbSA9IHIuY3kuem9vbSgpO1xuICB2YXIgaGFzQ29tcG91bmRzID0gci5jeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gIHZhciBlZGdlVGhyZXNob2xkID0gKGlzVG91Y2ggPyAyNCA6IDgpIC8gem9vbTtcbiAgdmFyIG5vZGVUaHJlc2hvbGQgPSAoaXNUb3VjaCA/IDggOiAyKSAvIHpvb207XG4gIHZhciBsYWJlbFRocmVzaG9sZCA9IChpc1RvdWNoID8gOCA6IDIpIC8gem9vbTtcbiAgdmFyIG1pblNxRGlzdCA9IEluZmluaXR5O1xuICB2YXIgbmVhckVkZ2U7XG4gIHZhciBuZWFyTm9kZTtcblxuICBpZiAoaW50ZXJhY3RpdmVFbGVtZW50c09ubHkpIHtcbiAgICBlbGVzID0gZWxlcy5pbnRlcmFjdGl2ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEVsZShlbGUsIHNxRGlzdCkge1xuICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgIGlmIChuZWFyTm9kZSkge1xuICAgICAgICByZXR1cm47IC8vIGNhbid0IHJlcGxhY2Ugbm9kZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmVhck5vZGUgPSBlbGU7XG4gICAgICAgIG5lYXIucHVzaChlbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbGUuaXNFZGdlKCkgJiYgKHNxRGlzdCA9PSBudWxsIHx8IHNxRGlzdCA8IG1pblNxRGlzdCkpIHtcbiAgICAgIGlmIChuZWFyRWRnZSkge1xuICAgICAgICAvLyB0aGVuIHJlcGxhY2UgZXhpc3RpbmcgZWRnZVxuICAgICAgICAvLyBjYW4gcmVwbGFjZSBvbmx5IGlmIHNhbWUgei1pbmRleFxuICAgICAgICBpZiAobmVhckVkZ2UucHN0eWxlKCd6LWNvbXBvdW5kLWRlcHRoJykudmFsdWUgPT09IGVsZS5wc3R5bGUoJ3otY29tcG91bmQtZGVwdGgnKS52YWx1ZSAmJiBuZWFyRWRnZS5wc3R5bGUoJ3otY29tcG91bmQtZGVwdGgnKS52YWx1ZSA9PT0gZWxlLnBzdHlsZSgnei1jb21wb3VuZC1kZXB0aCcpLnZhbHVlKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZWFyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobmVhcltpXS5pc0VkZ2UoKSkge1xuICAgICAgICAgICAgICBuZWFyW2ldID0gZWxlO1xuICAgICAgICAgICAgICBuZWFyRWRnZSA9IGVsZTtcbiAgICAgICAgICAgICAgbWluU3FEaXN0ID0gc3FEaXN0ICE9IG51bGwgPyBzcURpc3QgOiBtaW5TcURpc3Q7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmVhci5wdXNoKGVsZSk7XG4gICAgICAgIG5lYXJFZGdlID0gZWxlO1xuICAgICAgICBtaW5TcURpc3QgPSBzcURpc3QgIT0gbnVsbCA/IHNxRGlzdCA6IG1pblNxRGlzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja05vZGUobm9kZSkge1xuICAgIHZhciB3aWR0aCA9IG5vZGUub3V0ZXJXaWR0aCgpICsgMiAqIG5vZGVUaHJlc2hvbGQ7XG4gICAgdmFyIGhlaWdodCA9IG5vZGUub3V0ZXJIZWlnaHQoKSArIDIgKiBub2RlVGhyZXNob2xkO1xuICAgIHZhciBodyA9IHdpZHRoIC8gMjtcbiAgICB2YXIgaGggPSBoZWlnaHQgLyAyO1xuICAgIHZhciBwb3MgPSBub2RlLnBvc2l0aW9uKCk7XG5cbiAgICBpZiAocG9zLnggLSBodyA8PSB4ICYmIHggPD0gcG9zLnggKyBodyAvLyBiYiBjaGVjayB4XG4gICAgJiYgcG9zLnkgLSBoaCA8PSB5ICYmIHkgPD0gcG9zLnkgKyBoaCAvLyBiYiBjaGVjayB5XG4gICAgKSB7XG4gICAgICB2YXIgc2hhcGUgPSByLm5vZGVTaGFwZXNbc2VsZi5nZXROb2RlU2hhcGUobm9kZSldO1xuXG4gICAgICBpZiAoc2hhcGUuY2hlY2tQb2ludCh4LCB5LCAwLCB3aWR0aCwgaGVpZ2h0LCBwb3MueCwgcG9zLnkpKSB7XG4gICAgICAgIGFkZEVsZShub2RlLCAwKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tFZGdlKGVkZ2UpIHtcbiAgICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICAgIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICAgIHZhciBzdHlsZVdpZHRoID0gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcbiAgICB2YXIgc2NhbGUgPSBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZTtcbiAgICB2YXIgd2lkdGggPSBzdHlsZVdpZHRoIC8gMiArIGVkZ2VUaHJlc2hvbGQ7IC8vIG1vcmUgbGlrZSBhIGRpc3RhbmNlIHJhZGl1cyBmcm9tIGNlbnRyZVxuXG4gICAgdmFyIHdpZHRoU3EgPSB3aWR0aCAqIHdpZHRoO1xuICAgIHZhciB3aWR0aDIgPSB3aWR0aCAqIDI7XG4gICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICB2YXIgdGd0ID0gX3AudGFyZ2V0O1xuICAgIHZhciBzcURpc3Q7XG5cbiAgICBpZiAocnMuZWRnZVR5cGUgPT09ICdzZWdtZW50cycgfHwgcnMuZWRnZVR5cGUgPT09ICdzdHJhaWdodCcgfHwgcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjaycpIHtcbiAgICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpICsgMyA8IHB0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBpZiAoaW5MaW5lVmljaW5pdHkoeCwgeSwgcHRzW2ldLCBwdHNbaSArIDFdLCBwdHNbaSArIDJdLCBwdHNbaSArIDNdLCB3aWR0aDIpICYmIHdpZHRoU3EgPiAoc3FEaXN0ID0gc3FkaXN0VG9GaW5pdGVMaW5lKHgsIHksIHB0c1tpXSwgcHRzW2kgKyAxXSwgcHRzW2kgKyAyXSwgcHRzW2kgKyAzXSkpKSB7XG4gICAgICAgICAgYWRkRWxlKGVkZ2UsIHNxRGlzdCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ211bHRpYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnIHx8IHJzLmVkZ2VUeXBlID09PSAnY29tcG91bmQnKSB7XG4gICAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSArIDUgPCBycy5hbGxwdHMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgaWYgKGluQmV6aWVyVmljaW5pdHkoeCwgeSwgcHRzW2ldLCBwdHNbaSArIDFdLCBwdHNbaSArIDJdLCBwdHNbaSArIDNdLCBwdHNbaSArIDRdLCBwdHNbaSArIDVdLCB3aWR0aDIpICYmIHdpZHRoU3EgPiAoc3FEaXN0ID0gc3FkaXN0VG9RdWFkcmF0aWNCZXppZXIoeCwgeSwgcHRzW2ldLCBwdHNbaSArIDFdLCBwdHNbaSArIDJdLCBwdHNbaSArIDNdLCBwdHNbaSArIDRdLCBwdHNbaSArIDVdKSkpIHtcbiAgICAgICAgICBhZGRFbGUoZWRnZSwgc3FEaXN0KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gaWYgd2UncmUgY2xvc2UgdG8gdGhlIGVkZ2UgYnV0IGRpZG4ndCBoaXQgaXQsIG1heWJlIHdlIGhpdCBpdHMgYXJyb3dzXG5cblxuICAgIHZhciBzcmMgPSBzcmMgfHwgX3Auc291cmNlO1xuICAgIHZhciB0Z3QgPSB0Z3QgfHwgX3AudGFyZ2V0O1xuICAgIHZhciBhclNpemUgPSBzZWxmLmdldEFycm93V2lkdGgoc3R5bGVXaWR0aCwgc2NhbGUpO1xuICAgIHZhciBhcnJvd3MgPSBbe1xuICAgICAgbmFtZTogJ3NvdXJjZScsXG4gICAgICB4OiBycy5hcnJvd1N0YXJ0WCxcbiAgICAgIHk6IHJzLmFycm93U3RhcnRZLFxuICAgICAgYW5nbGU6IHJzLnNyY0Fycm93QW5nbGVcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGFyZ2V0JyxcbiAgICAgIHg6IHJzLmFycm93RW5kWCxcbiAgICAgIHk6IHJzLmFycm93RW5kWSxcbiAgICAgIGFuZ2xlOiBycy50Z3RBcnJvd0FuZ2xlXG4gICAgfSwge1xuICAgICAgbmFtZTogJ21pZC1zb3VyY2UnLFxuICAgICAgeDogcnMubWlkWCxcbiAgICAgIHk6IHJzLm1pZFksXG4gICAgICBhbmdsZTogcnMubWlkc3JjQXJyb3dBbmdsZVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdtaWQtdGFyZ2V0JyxcbiAgICAgIHg6IHJzLm1pZFgsXG4gICAgICB5OiBycy5taWRZLFxuICAgICAgYW5nbGU6IHJzLm1pZHRndEFycm93QW5nbGVcbiAgICB9XTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYXIgPSBhcnJvd3NbaV07XG4gICAgICB2YXIgc2hhcGUgPSByLmFycm93U2hhcGVzW2VkZ2UucHN0eWxlKGFyLm5hbWUgKyAnLWFycm93LXNoYXBlJykudmFsdWVdO1xuICAgICAgdmFyIGVkZ2VXaWR0aCA9IGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG5cbiAgICAgIGlmIChzaGFwZS5yb3VnaENvbGxpZGUoeCwgeSwgYXJTaXplLCBhci5hbmdsZSwge1xuICAgICAgICB4OiBhci54LFxuICAgICAgICB5OiBhci55XG4gICAgICB9LCBlZGdlV2lkdGgsIGVkZ2VUaHJlc2hvbGQpICYmIHNoYXBlLmNvbGxpZGUoeCwgeSwgYXJTaXplLCBhci5hbmdsZSwge1xuICAgICAgICB4OiBhci54LFxuICAgICAgICB5OiBhci55XG4gICAgICB9LCBlZGdlV2lkdGgsIGVkZ2VUaHJlc2hvbGQpKSB7XG4gICAgICAgIGFkZEVsZShlZGdlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSAvLyBmb3IgY29tcG91bmQgZ3JhcGhzLCBoaXR0aW5nIGVkZ2UgbWF5IGFjdHVhbGx5IHdhbnQgYSBjb25uZWN0ZWQgbm9kZSBpbnN0ZWFkIChiL2MgZWRnZSBtYXkgaGF2ZSBncmVhdGVyIHotaW5kZXggcHJlY2VkZW5jZSlcblxuXG4gICAgaWYgKGhhc0NvbXBvdW5kcyAmJiBuZWFyLmxlbmd0aCA+IDApIHtcbiAgICAgIGNoZWNrTm9kZShzcmMpO1xuICAgICAgY2hlY2tOb2RlKHRndCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJlcHJvcChvYmosIG5hbWUsIHByZSkge1xuICAgIHJldHVybiBnZXRQcmVmaXhlZFByb3BlcnR5KG9iaiwgbmFtZSwgcHJlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrTGFiZWwoZWxlLCBwcmVmaXgpIHtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIHRoID0gbGFiZWxUaHJlc2hvbGQ7XG4gICAgdmFyIHByZWZpeERhc2g7XG5cbiAgICBpZiAocHJlZml4KSB7XG4gICAgICBwcmVmaXhEYXNoID0gcHJlZml4ICsgJy0nO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVmaXhEYXNoID0gJyc7XG4gICAgfVxuXG4gICAgZWxlLmJvdW5kaW5nQm94KCk7XG4gICAgdmFyIGJiID0gX3AubGFiZWxCb3VuZHNbcHJlZml4IHx8ICdtYWluJ107XG4gICAgdmFyIHRleHQgPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAnbGFiZWwnKS52YWx1ZTtcbiAgICB2YXIgZXZlbnRzRW5hYmxlZCA9IGVsZS5wc3R5bGUoJ3RleHQtZXZlbnRzJykuc3RyVmFsdWUgPT09ICd5ZXMnO1xuXG4gICAgaWYgKCFldmVudHNFbmFibGVkIHx8ICF0ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGx4ID0gcHJlcHJvcChfcC5yc2NyYXRjaCwgJ2xhYmVsWCcsIHByZWZpeCk7XG4gICAgdmFyIGx5ID0gcHJlcHJvcChfcC5yc2NyYXRjaCwgJ2xhYmVsWScsIHByZWZpeCk7XG4gICAgdmFyIHRoZXRhID0gcHJlcHJvcChfcC5yc2NyYXRjaCwgJ2xhYmVsQW5nbGUnLCBwcmVmaXgpO1xuICAgIHZhciBveCA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICd0ZXh0LW1hcmdpbi14JykucGZWYWx1ZTtcbiAgICB2YXIgb3kgPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1tYXJnaW4teScpLnBmVmFsdWU7XG4gICAgdmFyIGx4MSA9IGJiLngxIC0gdGggLSBveDsgLy8gKC1veCwgLW95KSBhcyBiYiBhbHJlYWR5IGluY2x1ZGVzIG1hcmdpblxuXG4gICAgdmFyIGx4MiA9IGJiLngyICsgdGggLSBveDsgLy8gYW5kIHJvdGF0aW9uIGlzIGFib3V0IChseCwgbHkpXG5cbiAgICB2YXIgbHkxID0gYmIueTEgLSB0aCAtIG95O1xuICAgIHZhciBseTIgPSBiYi55MiArIHRoIC0gb3k7XG5cbiAgICBpZiAodGhldGEpIHtcbiAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICB2YXIgc2luID0gTWF0aC5zaW4odGhldGEpO1xuXG4gICAgICB2YXIgcm90YXRlID0gZnVuY3Rpb24gcm90YXRlKHgsIHkpIHtcbiAgICAgICAgeCA9IHggLSBseDtcbiAgICAgICAgeSA9IHkgLSBseTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB4ICogY29zIC0geSAqIHNpbiArIGx4LFxuICAgICAgICAgIHk6IHggKiBzaW4gKyB5ICogY29zICsgbHlcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBweDF5MSA9IHJvdGF0ZShseDEsIGx5MSk7XG4gICAgICB2YXIgcHgxeTIgPSByb3RhdGUobHgxLCBseTIpO1xuICAgICAgdmFyIHB4MnkxID0gcm90YXRlKGx4MiwgbHkxKTtcbiAgICAgIHZhciBweDJ5MiA9IHJvdGF0ZShseDIsIGx5Mik7XG4gICAgICB2YXIgcG9pbnRzID0gWy8vIHdpdGggdGhlIG1hcmdpbiBhZGRlZCBhZnRlciB0aGUgcm90YXRpb24gaXMgYXBwbGllZFxuICAgICAgcHgxeTEueCArIG94LCBweDF5MS55ICsgb3ksIHB4MnkxLnggKyBveCwgcHgyeTEueSArIG95LCBweDJ5Mi54ICsgb3gsIHB4MnkyLnkgKyBveSwgcHgxeTIueCArIG94LCBweDF5Mi55ICsgb3ldO1xuXG4gICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHBvaW50cykpIHtcbiAgICAgICAgYWRkRWxlKGVsZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkbyBhIGNoZWFwZXIgYmIgY2hlY2tcbiAgICAgIGlmIChpbkJvdW5kaW5nQm94KGJiLCB4LCB5KSkge1xuICAgICAgICBhZGRFbGUoZWxlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IGVsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAvLyByZXZlcnNlIG9yZGVyIGZvciBwcmVjZWRlbmNlXG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICBjaGVja05vZGUoZWxlKSB8fCBjaGVja0xhYmVsKGVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoZW4gZWRnZVxuICAgICAgY2hlY2tFZGdlKGVsZSkgfHwgY2hlY2tMYWJlbChlbGUpIHx8IGNoZWNrTGFiZWwoZWxlLCAnc291cmNlJykgfHwgY2hlY2tMYWJlbChlbGUsICd0YXJnZXQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVhcjtcbn07IC8vICdHaXZlIG1lIGV2ZXJ5dGhpbmcgZnJvbSB0aGlzIGJveCdcblxuXG5CUnAkZS5nZXRBbGxJbkJveCA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICB2YXIgZWxlcyA9IHRoaXMuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKS5pbnRlcmFjdGl2ZTtcbiAgdmFyIGJveCA9IFtdO1xuICB2YXIgeDFjID0gTWF0aC5taW4oeDEsIHgyKTtcbiAgdmFyIHgyYyA9IE1hdGgubWF4KHgxLCB4Mik7XG4gIHZhciB5MWMgPSBNYXRoLm1pbih5MSwgeTIpO1xuICB2YXIgeTJjID0gTWF0aC5tYXgoeTEsIHkyKTtcbiAgeDEgPSB4MWM7XG4gIHgyID0geDJjO1xuICB5MSA9IHkxYztcbiAgeTIgPSB5MmM7XG4gIHZhciBib3hCYiA9IG1ha2VCb3VuZGluZ0JveCh7XG4gICAgeDE6IHgxLFxuICAgIHkxOiB5MSxcbiAgICB4MjogeDIsXG4gICAgeTI6IHkyXG4gIH0pO1xuXG4gIGZvciAodmFyIGUgPSAwOyBlIDwgZWxlcy5sZW5ndGg7IGUrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2VdO1xuXG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgdmFyIG5vZGUgPSBlbGU7XG4gICAgICB2YXIgbm9kZUJiID0gbm9kZS5ib3VuZGluZ0JveCh7XG4gICAgICAgIGluY2x1ZGVOb2RlczogdHJ1ZSxcbiAgICAgICAgaW5jbHVkZUVkZ2VzOiBmYWxzZSxcbiAgICAgICAgaW5jbHVkZUxhYmVsczogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoYm91bmRpbmdCb3hlc0ludGVyc2VjdChib3hCYiwgbm9kZUJiKSAmJiAhYm91bmRpbmdCb3hJbkJvdW5kaW5nQm94KG5vZGVCYiwgYm94QmIpKSB7XG4gICAgICAgIGJveC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZWRnZSA9IGVsZTtcbiAgICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcblxuICAgICAgaWYgKHJzLnN0YXJ0WCAhPSBudWxsICYmIHJzLnN0YXJ0WSAhPSBudWxsICYmICFpbkJvdW5kaW5nQm94KGJveEJiLCBycy5zdGFydFgsIHJzLnN0YXJ0WSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChycy5lbmRYICE9IG51bGwgJiYgcnMuZW5kWSAhPSBudWxsICYmICFpbkJvdW5kaW5nQm94KGJveEJiLCBycy5lbmRYLCBycy5lbmRZKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ211bHRpYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnIHx8IHJzLmVkZ2VUeXBlID09PSAnY29tcG91bmQnIHx8IHJzLmVkZ2VUeXBlID09PSAnc2VnbWVudHMnIHx8IHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snKSB7XG4gICAgICAgIHZhciBwdHMgPSBfcC5yc3R5bGUuYmV6aWVyUHRzIHx8IF9wLnJzdHlsZS5saW5lUHRzIHx8IF9wLnJzdHlsZS5oYXlzdGFja1B0cztcbiAgICAgICAgdmFyIGFsbEluc2lkZSA9IHRydWU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoIXBvaW50SW5Cb3VuZGluZ0JveChib3hCYiwgcHRzW2ldKSkge1xuICAgICAgICAgICAgYWxsSW5zaWRlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWxsSW5zaWRlKSB7XG4gICAgICAgICAgYm94LnB1c2goZWRnZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjaycgfHwgcnMuZWRnZVR5cGUgPT09ICdzdHJhaWdodCcpIHtcbiAgICAgICAgYm94LnB1c2goZWRnZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJveDtcbn07XG5cbnZhciBCUnAkZCA9IHt9O1xuXG5CUnAkZC5jYWxjdWxhdGVBcnJvd0FuZ2xlcyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBpc0hheXN0YWNrID0gcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjayc7XG4gIHZhciBpc0JlemllciA9IHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJztcbiAgdmFyIGlzTXVsdGliZXppZXIgPSBycy5lZGdlVHlwZSA9PT0gJ211bHRpYmV6aWVyJztcbiAgdmFyIGlzU2VnbWVudHMgPSBycy5lZGdlVHlwZSA9PT0gJ3NlZ21lbnRzJztcbiAgdmFyIGlzQ29tcG91bmQgPSBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJztcbiAgdmFyIGlzU2VsZiA9IHJzLmVkZ2VUeXBlID09PSAnc2VsZic7IC8vIERpc3BsYWNlbWVudCBnaXZlcyBkaXJlY3Rpb24gZm9yIGFycm93aGVhZCBvcmllbnRhdGlvblxuXG4gIHZhciBkaXNwWCwgZGlzcFk7XG4gIHZhciBzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSwgbWlkWCwgbWlkWTtcblxuICBpZiAoaXNIYXlzdGFjaykge1xuICAgIHN0YXJ0WCA9IHJzLmhheXN0YWNrUHRzWzBdO1xuICAgIHN0YXJ0WSA9IHJzLmhheXN0YWNrUHRzWzFdO1xuICAgIGVuZFggPSBycy5oYXlzdGFja1B0c1syXTtcbiAgICBlbmRZID0gcnMuaGF5c3RhY2tQdHNbM107XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRYID0gcnMuYXJyb3dTdGFydFg7XG4gICAgc3RhcnRZID0gcnMuYXJyb3dTdGFydFk7XG4gICAgZW5kWCA9IHJzLmFycm93RW5kWDtcbiAgICBlbmRZID0gcnMuYXJyb3dFbmRZO1xuICB9XG5cbiAgbWlkWCA9IHJzLm1pZFg7XG4gIG1pZFkgPSBycy5taWRZOyAvLyBzb3VyY2VcbiAgLy9cblxuICBpZiAoaXNTZWdtZW50cykge1xuICAgIGRpc3BYID0gc3RhcnRYIC0gcnMuc2VncHRzWzBdO1xuICAgIGRpc3BZID0gc3RhcnRZIC0gcnMuc2VncHRzWzFdO1xuICB9IGVsc2UgaWYgKGlzTXVsdGliZXppZXIgfHwgaXNDb21wb3VuZCB8fCBpc1NlbGYgfHwgaXNCZXppZXIpIHtcbiAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuICAgIHZhciBiWCA9IHFiZXppZXJBdChwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCAwLjEpO1xuICAgIHZhciBiWSA9IHFiZXppZXJBdChwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCAwLjEpO1xuICAgIGRpc3BYID0gc3RhcnRYIC0gYlg7XG4gICAgZGlzcFkgPSBzdGFydFkgLSBiWTtcbiAgfSBlbHNlIHtcbiAgICBkaXNwWCA9IHN0YXJ0WCAtIG1pZFg7XG4gICAgZGlzcFkgPSBzdGFydFkgLSBtaWRZO1xuICB9XG5cbiAgcnMuc3JjQXJyb3dBbmdsZSA9IGdldEFuZ2xlRnJvbURpc3AoZGlzcFgsIGRpc3BZKTsgLy8gbWlkIHRhcmdldFxuICAvL1xuXG4gIHZhciBtaWRYID0gcnMubWlkWDtcbiAgdmFyIG1pZFkgPSBycy5taWRZO1xuXG4gIGlmIChpc0hheXN0YWNrKSB7XG4gICAgbWlkWCA9IChzdGFydFggKyBlbmRYKSAvIDI7XG4gICAgbWlkWSA9IChzdGFydFkgKyBlbmRZKSAvIDI7XG4gIH1cblxuICBkaXNwWCA9IGVuZFggLSBzdGFydFg7XG4gIGRpc3BZID0gZW5kWSAtIHN0YXJ0WTtcblxuICBpZiAoaXNTZWdtZW50cykge1xuICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG5cbiAgICBpZiAocHRzLmxlbmd0aCAvIDIgJSAyID09PSAwKSB7XG4gICAgICB2YXIgaTIgPSBwdHMubGVuZ3RoIC8gMjtcbiAgICAgIHZhciBpMSA9IGkyIC0gMjtcbiAgICAgIGRpc3BYID0gcHRzW2kyXSAtIHB0c1tpMV07XG4gICAgICBkaXNwWSA9IHB0c1tpMiArIDFdIC0gcHRzW2kxICsgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpMiA9IHB0cy5sZW5ndGggLyAyIC0gMTtcbiAgICAgIHZhciBpMSA9IGkyIC0gMjtcbiAgICAgIHZhciBpMyA9IGkyICsgMjtcbiAgICAgIGRpc3BYID0gcHRzW2kyXSAtIHB0c1tpMV07XG4gICAgICBkaXNwWSA9IHB0c1tpMiArIDFdIC0gcHRzW2kxICsgMV07XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzTXVsdGliZXppZXIgfHwgaXNDb21wb3VuZCB8fCBpc1NlbGYpIHtcbiAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuICAgIHZhciBjcHRzID0gcnMuY3RybHB0cztcbiAgICB2YXIgYnAweCwgYnAweTtcbiAgICB2YXIgYnAxeCwgYnAxeTtcblxuICAgIGlmIChjcHRzLmxlbmd0aCAvIDIgJSAyID09PSAwKSB7XG4gICAgICB2YXIgcDAgPSBwdHMubGVuZ3RoIC8gMiAtIDE7IC8vIHN0YXJ0cHRcblxuICAgICAgdmFyIGljID0gcDAgKyAyO1xuICAgICAgdmFyIHAxID0gaWMgKyAyO1xuICAgICAgYnAweCA9IHFiZXppZXJBdChwdHNbcDBdLCBwdHNbaWNdLCBwdHNbcDFdLCAwLjApO1xuICAgICAgYnAweSA9IHFiZXppZXJBdChwdHNbcDAgKyAxXSwgcHRzW2ljICsgMV0sIHB0c1twMSArIDFdLCAwLjApO1xuICAgICAgYnAxeCA9IHFiZXppZXJBdChwdHNbcDBdLCBwdHNbaWNdLCBwdHNbcDFdLCAwLjAwMDEpO1xuICAgICAgYnAxeSA9IHFiZXppZXJBdChwdHNbcDAgKyAxXSwgcHRzW2ljICsgMV0sIHB0c1twMSArIDFdLCAwLjAwMDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaWMgPSBwdHMubGVuZ3RoIC8gMiAtIDE7IC8vIGN0cnB0XG5cbiAgICAgIHZhciBwMCA9IGljIC0gMjsgLy8gc3RhcnRwdFxuXG4gICAgICB2YXIgcDEgPSBpYyArIDI7IC8vIGVuZHB0XG5cbiAgICAgIGJwMHggPSBxYmV6aWVyQXQocHRzW3AwXSwgcHRzW2ljXSwgcHRzW3AxXSwgMC40OTk5KTtcbiAgICAgIGJwMHkgPSBxYmV6aWVyQXQocHRzW3AwICsgMV0sIHB0c1tpYyArIDFdLCBwdHNbcDEgKyAxXSwgMC40OTk5KTtcbiAgICAgIGJwMXggPSBxYmV6aWVyQXQocHRzW3AwXSwgcHRzW2ljXSwgcHRzW3AxXSwgMC41KTtcbiAgICAgIGJwMXkgPSBxYmV6aWVyQXQocHRzW3AwICsgMV0sIHB0c1tpYyArIDFdLCBwdHNbcDEgKyAxXSwgMC41KTtcbiAgICB9XG5cbiAgICBkaXNwWCA9IGJwMXggLSBicDB4O1xuICAgIGRpc3BZID0gYnAxeSAtIGJwMHk7XG4gIH1cblxuICBycy5taWR0Z3RBcnJvd0FuZ2xlID0gZ2V0QW5nbGVGcm9tRGlzcChkaXNwWCwgZGlzcFkpO1xuICBycy5taWREaXNwWCA9IGRpc3BYO1xuICBycy5taWREaXNwWSA9IGRpc3BZOyAvLyBtaWQgc291cmNlXG4gIC8vXG5cbiAgZGlzcFggKj0gLTE7XG4gIGRpc3BZICo9IC0xO1xuXG4gIGlmIChpc1NlZ21lbnRzKSB7XG4gICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcblxuICAgIGlmIChwdHMubGVuZ3RoIC8gMiAlIDIgPT09IDApIDsgZWxzZSB7XG4gICAgICB2YXIgaTIgPSBwdHMubGVuZ3RoIC8gMiAtIDE7XG4gICAgICB2YXIgaTMgPSBpMiArIDI7XG4gICAgICBkaXNwWCA9IC0ocHRzW2kzXSAtIHB0c1tpMl0pO1xuICAgICAgZGlzcFkgPSAtKHB0c1tpMyArIDFdIC0gcHRzW2kyICsgMV0pO1xuICAgIH1cbiAgfVxuXG4gIHJzLm1pZHNyY0Fycm93QW5nbGUgPSBnZXRBbmdsZUZyb21EaXNwKGRpc3BYLCBkaXNwWSk7IC8vIHRhcmdldFxuICAvL1xuXG4gIGlmIChpc1NlZ21lbnRzKSB7XG4gICAgZGlzcFggPSBlbmRYIC0gcnMuc2VncHRzW3JzLnNlZ3B0cy5sZW5ndGggLSAyXTtcbiAgICBkaXNwWSA9IGVuZFkgLSBycy5zZWdwdHNbcnMuc2VncHRzLmxlbmd0aCAtIDFdO1xuICB9IGVsc2UgaWYgKGlzTXVsdGliZXppZXIgfHwgaXNDb21wb3VuZCB8fCBpc1NlbGYgfHwgaXNCZXppZXIpIHtcbiAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuICAgIHZhciBsID0gcHRzLmxlbmd0aDtcbiAgICB2YXIgYlggPSBxYmV6aWVyQXQocHRzW2wgLSA2XSwgcHRzW2wgLSA0XSwgcHRzW2wgLSAyXSwgMC45KTtcbiAgICB2YXIgYlkgPSBxYmV6aWVyQXQocHRzW2wgLSA1XSwgcHRzW2wgLSAzXSwgcHRzW2wgLSAxXSwgMC45KTtcbiAgICBkaXNwWCA9IGVuZFggLSBiWDtcbiAgICBkaXNwWSA9IGVuZFkgLSBiWTtcbiAgfSBlbHNlIHtcbiAgICBkaXNwWCA9IGVuZFggLSBtaWRYO1xuICAgIGRpc3BZID0gZW5kWSAtIG1pZFk7XG4gIH1cblxuICBycy50Z3RBcnJvd0FuZ2xlID0gZ2V0QW5nbGVGcm9tRGlzcChkaXNwWCwgZGlzcFkpO1xufTtcblxuQlJwJGQuZ2V0QXJyb3dXaWR0aCA9IEJScCRkLmdldEFycm93SGVpZ2h0ID0gZnVuY3Rpb24gKGVkZ2VXaWR0aCwgc2NhbGUpIHtcbiAgdmFyIGNhY2hlID0gdGhpcy5hcnJvd1dpZHRoQ2FjaGUgPSB0aGlzLmFycm93V2lkdGhDYWNoZSB8fCB7fTtcbiAgdmFyIGNhY2hlZFZhbCA9IGNhY2hlW2VkZ2VXaWR0aCArICcsICcgKyBzY2FsZV07XG5cbiAgaWYgKGNhY2hlZFZhbCkge1xuICAgIHJldHVybiBjYWNoZWRWYWw7XG4gIH1cblxuICBjYWNoZWRWYWwgPSBNYXRoLm1heChNYXRoLnBvdyhlZGdlV2lkdGggKiAxMy4zNywgMC45KSwgMjkpICogc2NhbGU7XG4gIGNhY2hlW2VkZ2VXaWR0aCArICcsICcgKyBzY2FsZV0gPSBjYWNoZWRWYWw7XG4gIHJldHVybiBjYWNoZWRWYWw7XG59O1xuXG52YXIgQlJwJGMgPSB7fTtcblxuQlJwJGMuZmluZEhheXN0YWNrUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2VzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG5cbiAgICBpZiAoIXJzLmhheXN0YWNrKSB7XG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG4gICAgICBycy5zb3VyY2UgPSB7XG4gICAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgeTogTWF0aC5zaW4oYW5nbGUpXG4gICAgICB9O1xuICAgICAgYW5nbGUgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG4gICAgICBycy50YXJnZXQgPSB7XG4gICAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgeTogTWF0aC5zaW4oYW5nbGUpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgdmFyIHRndCA9IF9wLnRhcmdldDtcbiAgICB2YXIgc3JjUG9zID0gc3JjLnBvc2l0aW9uKCk7XG4gICAgdmFyIHRndFBvcyA9IHRndC5wb3NpdGlvbigpO1xuICAgIHZhciBzcmNXID0gc3JjLndpZHRoKCk7XG4gICAgdmFyIHRndFcgPSB0Z3Qud2lkdGgoKTtcbiAgICB2YXIgc3JjSCA9IHNyYy5oZWlnaHQoKTtcbiAgICB2YXIgdGd0SCA9IHRndC5oZWlnaHQoKTtcbiAgICB2YXIgcmFkaXVzID0gZWRnZS5wc3R5bGUoJ2hheXN0YWNrLXJhZGl1cycpLnZhbHVlO1xuICAgIHZhciBoYWxmUmFkaXVzID0gcmFkaXVzIC8gMjsgLy8gYi9jIGhhdmUgdG8gaGFsZiB3aWR0aC9oZWlnaHRcblxuICAgIHJzLmhheXN0YWNrUHRzID0gcnMuYWxscHRzID0gW3JzLnNvdXJjZS54ICogc3JjVyAqIGhhbGZSYWRpdXMgKyBzcmNQb3MueCwgcnMuc291cmNlLnkgKiBzcmNIICogaGFsZlJhZGl1cyArIHNyY1Bvcy55LCBycy50YXJnZXQueCAqIHRndFcgKiBoYWxmUmFkaXVzICsgdGd0UG9zLngsIHJzLnRhcmdldC55ICogdGd0SCAqIGhhbGZSYWRpdXMgKyB0Z3RQb3MueV07XG4gICAgcnMubWlkWCA9IChycy5hbGxwdHNbMF0gKyBycy5hbGxwdHNbMl0pIC8gMjtcbiAgICBycy5taWRZID0gKHJzLmFsbHB0c1sxXSArIHJzLmFsbHB0c1szXSkgLyAyOyAvLyBhbHdheXMgb3ZlcnJpZGUgYXMgaGF5c3RhY2sgaW4gY2FzZSBzZXQgdG8gZGlmZmVyZW50IHR5cGUgcHJldmlvdXNseVxuXG4gICAgcnMuZWRnZVR5cGUgPSAnaGF5c3RhY2snO1xuICAgIHJzLmhheXN0YWNrID0gdHJ1ZTtcbiAgICB0aGlzLnN0b3JlRWRnZVByb2plY3Rpb25zKGVkZ2UpO1xuICAgIHRoaXMuY2FsY3VsYXRlQXJyb3dBbmdsZXMoZWRnZSk7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb25zKGVkZ2UpO1xuICAgIHRoaXMuY2FsY3VsYXRlTGFiZWxBbmdsZXMoZWRnZSk7XG4gIH1cbn07XG5cbkJScCRjLmZpbmRTZWdtZW50c1BvaW50cyA9IGZ1bmN0aW9uIChlZGdlLCBwYWlySW5mbykge1xuICAvLyBTZWdtZW50cyAobXVsdGlwbGUgc3RyYWlnaHQgbGluZXMpXG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBwb3NQdHMgPSBwYWlySW5mby5wb3NQdHMsXG4gICAgICBpbnRlcnNlY3Rpb25QdHMgPSBwYWlySW5mby5pbnRlcnNlY3Rpb25QdHMsXG4gICAgICB2ZWN0b3JOb3JtSW52ZXJzZSA9IHBhaXJJbmZvLnZlY3Rvck5vcm1JbnZlcnNlO1xuICB2YXIgZWRnZURpc3RhbmNlcyA9IGVkZ2UucHN0eWxlKCdlZGdlLWRpc3RhbmNlcycpLnZhbHVlO1xuICB2YXIgc2VnbWVudFdzID0gZWRnZS5wc3R5bGUoJ3NlZ21lbnQtd2VpZ2h0cycpO1xuICB2YXIgc2VnbWVudERzID0gZWRnZS5wc3R5bGUoJ3NlZ21lbnQtZGlzdGFuY2VzJyk7XG4gIHZhciBzZWdtZW50c04gPSBNYXRoLm1pbihzZWdtZW50V3MucGZWYWx1ZS5sZW5ndGgsIHNlZ21lbnREcy5wZlZhbHVlLmxlbmd0aCk7XG4gIHJzLmVkZ2VUeXBlID0gJ3NlZ21lbnRzJztcbiAgcnMuc2VncHRzID0gW107XG5cbiAgZm9yICh2YXIgcyA9IDA7IHMgPCBzZWdtZW50c047IHMrKykge1xuICAgIHZhciB3ID0gc2VnbWVudFdzLnBmVmFsdWVbc107XG4gICAgdmFyIGQgPSBzZWdtZW50RHMucGZWYWx1ZVtzXTtcbiAgICB2YXIgdzEgPSAxIC0gdztcbiAgICB2YXIgdzIgPSB3O1xuICAgIHZhciBtaWRwdFB0cyA9IGVkZ2VEaXN0YW5jZXMgPT09ICdub2RlLXBvc2l0aW9uJyA/IHBvc1B0cyA6IGludGVyc2VjdGlvblB0cztcbiAgICB2YXIgYWRqdXN0ZWRNaWRwdCA9IHtcbiAgICAgIHg6IG1pZHB0UHRzLngxICogdzEgKyBtaWRwdFB0cy54MiAqIHcyLFxuICAgICAgeTogbWlkcHRQdHMueTEgKiB3MSArIG1pZHB0UHRzLnkyICogdzJcbiAgICB9O1xuICAgIHJzLnNlZ3B0cy5wdXNoKGFkanVzdGVkTWlkcHQueCArIHZlY3Rvck5vcm1JbnZlcnNlLnggKiBkLCBhZGp1c3RlZE1pZHB0LnkgKyB2ZWN0b3JOb3JtSW52ZXJzZS55ICogZCk7XG4gIH1cbn07XG5cbkJScCRjLmZpbmRMb29wUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UsIHBhaXJJbmZvLCBpLCBlZGdlSXNVbmJ1bmRsZWQpIHtcbiAgLy8gU2VsZi1lZGdlXG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBkaXJDb3VudHMgPSBwYWlySW5mby5kaXJDb3VudHMsXG4gICAgICBzcmNQb3MgPSBwYWlySW5mby5zcmNQb3M7XG4gIHZhciBjdHJscHREaXN0cyA9IGVkZ2UucHN0eWxlKCdjb250cm9sLXBvaW50LWRpc3RhbmNlcycpO1xuICB2YXIgY3RybHB0RGlzdCA9IGN0cmxwdERpc3RzID8gY3RybHB0RGlzdHMucGZWYWx1ZVswXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGxvb3BEaXIgPSBlZGdlLnBzdHlsZSgnbG9vcC1kaXJlY3Rpb24nKS5wZlZhbHVlO1xuICB2YXIgbG9vcFN3cCA9IGVkZ2UucHN0eWxlKCdsb29wLXN3ZWVwJykucGZWYWx1ZTtcbiAgdmFyIHN0ZXBTaXplID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJykucGZWYWx1ZTtcbiAgcnMuZWRnZVR5cGUgPSAnc2VsZic7XG4gIHZhciBqID0gaTtcbiAgdmFyIGxvb3BEaXN0ID0gc3RlcFNpemU7XG5cbiAgaWYgKGVkZ2VJc1VuYnVuZGxlZCkge1xuICAgIGogPSAwO1xuICAgIGxvb3BEaXN0ID0gY3RybHB0RGlzdDtcbiAgfVxuXG4gIHZhciBsb29wQW5nbGUgPSBsb29wRGlyIC0gTWF0aC5QSSAvIDI7XG4gIHZhciBvdXRBbmdsZSA9IGxvb3BBbmdsZSAtIGxvb3BTd3AgLyAyO1xuICB2YXIgaW5BbmdsZSA9IGxvb3BBbmdsZSArIGxvb3BTd3AgLyAyOyAvLyBpbmNyZWFzZSBieSBzdGVwIHNpemUgZm9yIG92ZXJsYXBwaW5nIGxvb3BzLCBrZXllZCBvbiBkaXJlY3Rpb24gYW5kIHN3ZWVwIHZhbHVlc1xuXG4gIHZhciBkYyA9IFN0cmluZyhsb29wRGlyICsgJ18nICsgbG9vcFN3cCk7XG4gIGogPSBkaXJDb3VudHNbZGNdID09PSB1bmRlZmluZWQgPyBkaXJDb3VudHNbZGNdID0gMCA6ICsrZGlyQ291bnRzW2RjXTtcbiAgcnMuY3RybHB0cyA9IFtzcmNQb3MueCArIE1hdGguY29zKG91dEFuZ2xlKSAqIDEuNCAqIGxvb3BEaXN0ICogKGogLyAzICsgMSksIHNyY1Bvcy55ICsgTWF0aC5zaW4ob3V0QW5nbGUpICogMS40ICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKSwgc3JjUG9zLnggKyBNYXRoLmNvcyhpbkFuZ2xlKSAqIDEuNCAqIGxvb3BEaXN0ICogKGogLyAzICsgMSksIHNyY1Bvcy55ICsgTWF0aC5zaW4oaW5BbmdsZSkgKiAxLjQgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpXTtcbn07XG5cbkJScCRjLmZpbmRDb21wb3VuZExvb3BQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSwgcGFpckluZm8sIGksIGVkZ2VJc1VuYnVuZGxlZCkge1xuICAvLyBDb21wb3VuZCBlZGdlXG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHJzLmVkZ2VUeXBlID0gJ2NvbXBvdW5kJztcbiAgdmFyIHNyY1BvcyA9IHBhaXJJbmZvLnNyY1BvcyxcbiAgICAgIHRndFBvcyA9IHBhaXJJbmZvLnRndFBvcyxcbiAgICAgIHNyY1cgPSBwYWlySW5mby5zcmNXLFxuICAgICAgc3JjSCA9IHBhaXJJbmZvLnNyY0gsXG4gICAgICB0Z3RXID0gcGFpckluZm8udGd0VyxcbiAgICAgIHRndEggPSBwYWlySW5mby50Z3RIO1xuICB2YXIgc3RlcFNpemUgPSBlZGdlLnBzdHlsZSgnY29udHJvbC1wb2ludC1zdGVwLXNpemUnKS5wZlZhbHVlO1xuICB2YXIgY3RybHB0RGlzdHMgPSBlZGdlLnBzdHlsZSgnY29udHJvbC1wb2ludC1kaXN0YW5jZXMnKTtcbiAgdmFyIGN0cmxwdERpc3QgPSBjdHJscHREaXN0cyA/IGN0cmxwdERpc3RzLnBmVmFsdWVbMF0gOiB1bmRlZmluZWQ7XG4gIHZhciBqID0gaTtcbiAgdmFyIGxvb3BEaXN0ID0gc3RlcFNpemU7XG5cbiAgaWYgKGVkZ2VJc1VuYnVuZGxlZCkge1xuICAgIGogPSAwO1xuICAgIGxvb3BEaXN0ID0gY3RybHB0RGlzdDtcbiAgfVxuXG4gIHZhciBsb29wVyA9IDUwO1xuICB2YXIgbG9vcGFQb3MgPSB7XG4gICAgeDogc3JjUG9zLnggLSBzcmNXIC8gMixcbiAgICB5OiBzcmNQb3MueSAtIHNyY0ggLyAyXG4gIH07XG4gIHZhciBsb29wYlBvcyA9IHtcbiAgICB4OiB0Z3RQb3MueCAtIHRndFcgLyAyLFxuICAgIHk6IHRndFBvcy55IC0gdGd0SCAvIDJcbiAgfTtcbiAgdmFyIGxvb3BQb3MgPSB7XG4gICAgeDogTWF0aC5taW4obG9vcGFQb3MueCwgbG9vcGJQb3MueCksXG4gICAgeTogTWF0aC5taW4obG9vcGFQb3MueSwgbG9vcGJQb3MueSlcbiAgfTsgLy8gYXZvaWRzIGNhc2VzIHdpdGggaW1wb3NzaWJsZSBiZXppZXJzXG5cbiAgdmFyIG1pbkNvbXBvdW5kU3RyZXRjaCA9IDAuNTtcbiAgdmFyIGNvbXBvdW5kU3RyZXRjaEEgPSBNYXRoLm1heChtaW5Db21wb3VuZFN0cmV0Y2gsIE1hdGgubG9nKHNyY1cgKiAwLjAxKSk7XG4gIHZhciBjb21wb3VuZFN0cmV0Y2hCID0gTWF0aC5tYXgobWluQ29tcG91bmRTdHJldGNoLCBNYXRoLmxvZyh0Z3RXICogMC4wMSkpO1xuICBycy5jdHJscHRzID0gW2xvb3BQb3MueCwgbG9vcFBvcy55IC0gKDEgKyBNYXRoLnBvdyhsb29wVywgMS4xMikgLyAxMDApICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKSAqIGNvbXBvdW5kU3RyZXRjaEEsIGxvb3BQb3MueCAtICgxICsgTWF0aC5wb3cobG9vcFcsIDEuMTIpIC8gMTAwKSAqIGxvb3BEaXN0ICogKGogLyAzICsgMSkgKiBjb21wb3VuZFN0cmV0Y2hCLCBsb29wUG9zLnldO1xufTtcblxuQlJwJGMuZmluZFN0cmFpZ2h0RWRnZVBvaW50cyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIC8vIFN0cmFpZ2h0IGVkZ2Ugd2l0aGluIGJ1bmRsZVxuICBlZGdlLl9wcml2YXRlLnJzY3JhdGNoLmVkZ2VUeXBlID0gJ3N0cmFpZ2h0Jztcbn07XG5cbkJScCRjLmZpbmRCZXppZXJQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSwgcGFpckluZm8sIGksIGVkZ2VJc1VuYnVuZGxlZCwgZWRnZUlzU3dhcHBlZCkge1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgdmVjdG9yTm9ybUludmVyc2UgPSBwYWlySW5mby52ZWN0b3JOb3JtSW52ZXJzZSxcbiAgICAgIHBvc1B0cyA9IHBhaXJJbmZvLnBvc1B0cyxcbiAgICAgIGludGVyc2VjdGlvblB0cyA9IHBhaXJJbmZvLmludGVyc2VjdGlvblB0cztcbiAgdmFyIGVkZ2VEaXN0YW5jZXMgPSBlZGdlLnBzdHlsZSgnZWRnZS1kaXN0YW5jZXMnKS52YWx1ZTtcbiAgdmFyIHN0ZXBTaXplID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJykucGZWYWx1ZTtcbiAgdmFyIGN0cmxwdERpc3RzID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2VzJyk7XG4gIHZhciBjdHJscHRXcyA9IGVkZ2UucHN0eWxlKCdjb250cm9sLXBvaW50LXdlaWdodHMnKTtcbiAgdmFyIGJlemllck4gPSBjdHJscHREaXN0cyAmJiBjdHJscHRXcyA/IE1hdGgubWluKGN0cmxwdERpc3RzLnZhbHVlLmxlbmd0aCwgY3RybHB0V3MudmFsdWUubGVuZ3RoKSA6IDE7XG4gIHZhciBjdHJscHREaXN0ID0gY3RybHB0RGlzdHMgPyBjdHJscHREaXN0cy5wZlZhbHVlWzBdIDogdW5kZWZpbmVkO1xuICB2YXIgY3RybHB0V2VpZ2h0ID0gY3RybHB0V3MudmFsdWVbMF07IC8vIChNdWx0aSliZXppZXJcblxuICB2YXIgbXVsdGkgPSBlZGdlSXNVbmJ1bmRsZWQ7XG4gIHJzLmVkZ2VUeXBlID0gbXVsdGkgPyAnbXVsdGliZXppZXInIDogJ2Jlemllcic7XG4gIHJzLmN0cmxwdHMgPSBbXTtcblxuICBmb3IgKHZhciBiID0gMDsgYiA8IGJlemllck47IGIrKykge1xuICAgIHZhciBub3JtY3RybHB0RGlzdCA9ICgwLjUgLSBwYWlySW5mby5lbGVzLmxlbmd0aCAvIDIgKyBpKSAqIHN0ZXBTaXplICogKGVkZ2VJc1N3YXBwZWQgPyAtMSA6IDEpO1xuICAgIHZhciBtYW5jdHJscHREaXN0ID0gdm9pZCAwO1xuICAgIHZhciBzaWduID0gc2lnbnVtKG5vcm1jdHJscHREaXN0KTtcblxuICAgIGlmIChtdWx0aSkge1xuICAgICAgY3RybHB0RGlzdCA9IGN0cmxwdERpc3RzID8gY3RybHB0RGlzdHMucGZWYWx1ZVtiXSA6IHN0ZXBTaXplOyAvLyBmYWxsIGJhY2sgb24gc3RlcCBzaXplXG5cbiAgICAgIGN0cmxwdFdlaWdodCA9IGN0cmxwdFdzLnZhbHVlW2JdO1xuICAgIH1cblxuICAgIGlmIChlZGdlSXNVbmJ1bmRsZWQpIHtcbiAgICAgIC8vIG11bHRpIG9yIHNpbmdsZSB1bmJ1bmRsZWRcbiAgICAgIG1hbmN0cmxwdERpc3QgPSBjdHJscHREaXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBtYW5jdHJscHREaXN0ID0gY3RybHB0RGlzdCAhPT0gdW5kZWZpbmVkID8gc2lnbiAqIGN0cmxwdERpc3QgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIGRpc3RhbmNlRnJvbU1pZHBvaW50ID0gbWFuY3RybHB0RGlzdCAhPT0gdW5kZWZpbmVkID8gbWFuY3RybHB0RGlzdCA6IG5vcm1jdHJscHREaXN0O1xuICAgIHZhciB3MSA9IDEgLSBjdHJscHRXZWlnaHQ7XG4gICAgdmFyIHcyID0gY3RybHB0V2VpZ2h0O1xuICAgIHZhciBtaWRwdFB0cyA9IGVkZ2VEaXN0YW5jZXMgPT09ICdub2RlLXBvc2l0aW9uJyA/IHBvc1B0cyA6IGludGVyc2VjdGlvblB0cztcbiAgICB2YXIgYWRqdXN0ZWRNaWRwdCA9IHtcbiAgICAgIHg6IG1pZHB0UHRzLngxICogdzEgKyBtaWRwdFB0cy54MiAqIHcyLFxuICAgICAgeTogbWlkcHRQdHMueTEgKiB3MSArIG1pZHB0UHRzLnkyICogdzJcbiAgICB9O1xuICAgIHJzLmN0cmxwdHMucHVzaChhZGp1c3RlZE1pZHB0LnggKyB2ZWN0b3JOb3JtSW52ZXJzZS54ICogZGlzdGFuY2VGcm9tTWlkcG9pbnQsIGFkanVzdGVkTWlkcHQueSArIHZlY3Rvck5vcm1JbnZlcnNlLnkgKiBkaXN0YW5jZUZyb21NaWRwb2ludCk7XG4gIH1cbn07XG5cbkJScCRjLmZpbmRUYXhpUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UsIHBhaXJJbmZvKSB7XG4gIC8vIFRheGljYWIgZ2VvbWV0cnkgd2l0aCB0d28gdHVybnMgbWF4aW11bVxuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICBycy5lZGdlVHlwZSA9ICdzZWdtZW50cyc7XG4gIHZhciBWRVJUSUNBTCA9ICd2ZXJ0aWNhbCc7XG4gIHZhciBIT1JJWk9OVEFMID0gJ2hvcml6b250YWwnO1xuICB2YXIgTEVGVFdBUkQgPSAnbGVmdHdhcmQnO1xuICB2YXIgUklHSFRXQVJEID0gJ3JpZ2h0d2FyZCc7XG4gIHZhciBET1dOV0FSRCA9ICdkb3dud2FyZCc7XG4gIHZhciBVUFdBUkQgPSAndXB3YXJkJztcbiAgdmFyIEFVVE8gPSAnYXV0byc7XG4gIHZhciBwb3NQdHMgPSBwYWlySW5mby5wb3NQdHMsXG4gICAgICBzcmNXID0gcGFpckluZm8uc3JjVyxcbiAgICAgIHNyY0ggPSBwYWlySW5mby5zcmNILFxuICAgICAgdGd0VyA9IHBhaXJJbmZvLnRndFcsXG4gICAgICB0Z3RIID0gcGFpckluZm8udGd0SDtcbiAgdmFyIGVkZ2VEaXN0YW5jZXMgPSBlZGdlLnBzdHlsZSgnZWRnZS1kaXN0YW5jZXMnKS52YWx1ZTtcbiAgdmFyIGRJbmNsdWRlc05vZGVCb2R5ID0gZWRnZURpc3RhbmNlcyAhPT0gJ25vZGUtcG9zaXRpb24nO1xuICB2YXIgdGF4aURpciA9IGVkZ2UucHN0eWxlKCd0YXhpLWRpcmVjdGlvbicpLnZhbHVlO1xuICB2YXIgcmF3VGF4aURpciA9IHRheGlEaXI7IC8vIHVucHJvY2Vzc2VkIHZhbHVlXG5cbiAgdmFyIHRheGlUdXJuID0gZWRnZS5wc3R5bGUoJ3RheGktdHVybicpO1xuICB2YXIgdHVybklzUGVyY2VudCA9IHRheGlUdXJuLnVuaXRzID09PSAnJSc7XG4gIHZhciB0YXhpVHVyblBmVmFsID0gdGF4aVR1cm4ucGZWYWx1ZTtcbiAgdmFyIHR1cm5Jc05lZ2F0aXZlID0gdGF4aVR1cm5QZlZhbCA8IDA7IC8vIGkuZS4gZnJvbSB0YXJnZXQgc2lkZVxuXG4gIHZhciBtaW5EID0gZWRnZS5wc3R5bGUoJ3RheGktdHVybi1taW4tZGlzdGFuY2UnKS5wZlZhbHVlO1xuICB2YXIgZHcgPSBkSW5jbHVkZXNOb2RlQm9keSA/IChzcmNXICsgdGd0VykgLyAyIDogMDtcbiAgdmFyIGRoID0gZEluY2x1ZGVzTm9kZUJvZHkgPyAoc3JjSCArIHRndEgpIC8gMiA6IDA7XG4gIHZhciBwZHggPSBwb3NQdHMueDIgLSBwb3NQdHMueDE7XG4gIHZhciBwZHkgPSBwb3NQdHMueTIgLSBwb3NQdHMueTE7IC8vIHRha2UgYXdheSB0aGUgZWZmZWN0aXZlIHcvaCBmcm9tIHRoZSBtYWduaXR1ZGUgb2YgdGhlIGRlbHRhIHZhbHVlXG5cbiAgdmFyIHN1YkRXSCA9IGZ1bmN0aW9uIHN1YkRXSChkeHksIGR3aCkge1xuICAgIGlmIChkeHkgPiAwKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoZHh5IC0gZHdoLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1hdGgubWluKGR4eSArIGR3aCwgMCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBkeCA9IHN1YkRXSChwZHgsIGR3KTtcbiAgdmFyIGR5ID0gc3ViRFdIKHBkeSwgZGgpO1xuICB2YXIgaXNFeHBsaWNpdERpciA9IGZhbHNlO1xuXG4gIGlmIChyYXdUYXhpRGlyID09PSBBVVRPKSB7XG4gICAgdGF4aURpciA9IE1hdGguYWJzKGR4KSA+IE1hdGguYWJzKGR5KSA/IEhPUklaT05UQUwgOiBWRVJUSUNBTDtcbiAgfSBlbHNlIGlmIChyYXdUYXhpRGlyID09PSBVUFdBUkQgfHwgcmF3VGF4aURpciA9PT0gRE9XTldBUkQpIHtcbiAgICB0YXhpRGlyID0gVkVSVElDQUw7XG4gICAgaXNFeHBsaWNpdERpciA9IHRydWU7XG4gIH0gZWxzZSBpZiAocmF3VGF4aURpciA9PT0gTEVGVFdBUkQgfHwgcmF3VGF4aURpciA9PT0gUklHSFRXQVJEKSB7XG4gICAgdGF4aURpciA9IEhPUklaT05UQUw7XG4gICAgaXNFeHBsaWNpdERpciA9IHRydWU7XG4gIH1cblxuICB2YXIgaXNWZXJ0ID0gdGF4aURpciA9PT0gVkVSVElDQUw7XG4gIHZhciBsID0gaXNWZXJ0ID8gZHkgOiBkeDtcbiAgdmFyIHBsID0gaXNWZXJ0ID8gcGR5IDogcGR4O1xuICB2YXIgc2duTCA9IHNpZ251bShwbCk7XG4gIHZhciBmb3JjZWREaXIgPSBmYWxzZTtcblxuICBpZiAoIShpc0V4cGxpY2l0RGlyICYmICh0dXJuSXNQZXJjZW50IHx8IHR1cm5Jc05lZ2F0aXZlKSkgLy8gZm9yY2luZyBpbiB0aGlzIGNhc2Ugd291bGQgY2F1c2Ugd2VpcmQgZ3Jvd2luZyBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uXG4gICYmIChyYXdUYXhpRGlyID09PSBET1dOV0FSRCAmJiBwbCA8IDAgfHwgcmF3VGF4aURpciA9PT0gVVBXQVJEICYmIHBsID4gMCB8fCByYXdUYXhpRGlyID09PSBMRUZUV0FSRCAmJiBwbCA+IDAgfHwgcmF3VGF4aURpciA9PT0gUklHSFRXQVJEICYmIHBsIDwgMCkpIHtcbiAgICBzZ25MICo9IC0xO1xuICAgIGwgPSBzZ25MICogTWF0aC5hYnMobCk7XG4gICAgZm9yY2VkRGlyID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBkO1xuXG4gIGlmICh0dXJuSXNQZXJjZW50KSB7XG4gICAgdmFyIHAgPSB0YXhpVHVyblBmVmFsIDwgMCA/IDEgKyB0YXhpVHVyblBmVmFsIDogdGF4aVR1cm5QZlZhbDtcbiAgICBkID0gcCAqIGw7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGsgPSB0YXhpVHVyblBmVmFsIDwgMCA/IGwgOiAwO1xuICAgIGQgPSBrICsgdGF4aVR1cm5QZlZhbCAqIHNnbkw7XG4gIH1cblxuICB2YXIgZ2V0SXNUb29DbG9zZSA9IGZ1bmN0aW9uIGdldElzVG9vQ2xvc2UoZCkge1xuICAgIHJldHVybiBNYXRoLmFicyhkKSA8IG1pbkQgfHwgTWF0aC5hYnMoZCkgPj0gTWF0aC5hYnMobCk7XG4gIH07XG5cbiAgdmFyIGlzVG9vQ2xvc2VTcmMgPSBnZXRJc1Rvb0Nsb3NlKGQpO1xuICB2YXIgaXNUb29DbG9zZVRndCA9IGdldElzVG9vQ2xvc2UoTWF0aC5hYnMobCkgLSBNYXRoLmFicyhkKSk7XG4gIHZhciBpc1Rvb0Nsb3NlID0gaXNUb29DbG9zZVNyYyB8fCBpc1Rvb0Nsb3NlVGd0O1xuXG4gIGlmIChpc1Rvb0Nsb3NlICYmICFmb3JjZWREaXIpIHtcbiAgICAvLyBub24taWRlYWwgcm91dGluZ1xuICAgIGlmIChpc1ZlcnQpIHtcbiAgICAgIC8vIHZlcnRpY2FsIGZhbGxiYWNrc1xuICAgICAgdmFyIGxTaGFwZUluc2lkZVNyYyA9IE1hdGguYWJzKHBsKSA8PSBzcmNIIC8gMjtcbiAgICAgIHZhciBsU2hhcGVJbnNpZGVUZ3QgPSBNYXRoLmFicyhwZHgpIDw9IHRndFcgLyAyO1xuXG4gICAgICBpZiAobFNoYXBlSW5zaWRlU3JjKSB7XG4gICAgICAgIC8vIGhvcml6b250YWwgWi1zaGFwZSAoZGlyZWN0aW9uIG5vdCByZXNwZWN0ZWQpXG4gICAgICAgIHZhciB4ID0gKHBvc1B0cy54MSArIHBvc1B0cy54MikgLyAyO1xuICAgICAgICB2YXIgeTEgPSBwb3NQdHMueTEsXG4gICAgICAgICAgICB5MiA9IHBvc1B0cy55MjtcbiAgICAgICAgcnMuc2VncHRzID0gW3gsIHkxLCB4LCB5Ml07XG4gICAgICB9IGVsc2UgaWYgKGxTaGFwZUluc2lkZVRndCkge1xuICAgICAgICAvLyB2ZXJ0aWNhbCBaLXNoYXBlIChkaXN0YW5jZSBub3QgcmVzcGVjdGVkKVxuICAgICAgICB2YXIgeSA9IChwb3NQdHMueTEgKyBwb3NQdHMueTIpIC8gMjtcbiAgICAgICAgdmFyIHgxID0gcG9zUHRzLngxLFxuICAgICAgICAgICAgeDIgPSBwb3NQdHMueDI7XG4gICAgICAgIHJzLnNlZ3B0cyA9IFt4MSwgeSwgeDIsIHldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTC1zaGFwZSBmYWxsYmFjayAodHVybiBkaXN0YW5jZSBub3QgcmVzcGVjdGVkLCBidXQgd29ya3Mgd2VsbCB3aXRoIHRyZWUgc2libGluZ3MpXG4gICAgICAgIHJzLnNlZ3B0cyA9IFtwb3NQdHMueDEsIHBvc1B0cy55Ml07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvcml6b250YWwgZmFsbGJhY2tzXG4gICAgICB2YXIgX2xTaGFwZUluc2lkZVNyYyA9IE1hdGguYWJzKHBsKSA8PSBzcmNXIC8gMjtcblxuICAgICAgdmFyIF9sU2hhcGVJbnNpZGVUZ3QgPSBNYXRoLmFicyhwZHkpIDw9IHRndEggLyAyO1xuXG4gICAgICBpZiAoX2xTaGFwZUluc2lkZVNyYykge1xuICAgICAgICAvLyB2ZXJ0aWNhbCBaLXNoYXBlIChkaXJlY3Rpb24gbm90IHJlc3BlY3RlZClcbiAgICAgICAgdmFyIF95ID0gKHBvc1B0cy55MSArIHBvc1B0cy55MikgLyAyO1xuXG4gICAgICAgIHZhciBfeCA9IHBvc1B0cy54MSxcbiAgICAgICAgICAgIF94MiA9IHBvc1B0cy54MjtcbiAgICAgICAgcnMuc2VncHRzID0gW194LCBfeSwgX3gyLCBfeV07XG4gICAgICB9IGVsc2UgaWYgKF9sU2hhcGVJbnNpZGVUZ3QpIHtcbiAgICAgICAgLy8gaG9yaXpvbnRhbCBaLXNoYXBlICh0dXJuIGRpc3RhbmNlIG5vdCByZXNwZWN0ZWQpXG4gICAgICAgIHZhciBfeDMgPSAocG9zUHRzLngxICsgcG9zUHRzLngyKSAvIDI7XG5cbiAgICAgICAgdmFyIF95MiA9IHBvc1B0cy55MSxcbiAgICAgICAgICAgIF95MyA9IHBvc1B0cy55MjtcbiAgICAgICAgcnMuc2VncHRzID0gW194MywgX3kyLCBfeDMsIF95M107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBMLXNoYXBlICh0dXJuIGRpc3RhbmNlIG5vdCByZXNwZWN0ZWQsIGJ1dCB3b3JrcyB3ZWxsIGZvciB0cmVlIHNpYmxpbmdzKVxuICAgICAgICBycy5zZWdwdHMgPSBbcG9zUHRzLngyLCBwb3NQdHMueTFdO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBpZGVhbCByb3V0aW5nXG4gICAgaWYgKGlzVmVydCkge1xuICAgICAgdmFyIF95NCA9IHBvc1B0cy55MSArIGQgKyAoZEluY2x1ZGVzTm9kZUJvZHkgPyBzcmNIIC8gMiAqIHNnbkwgOiAwKTtcblxuICAgICAgdmFyIF94NCA9IHBvc1B0cy54MSxcbiAgICAgICAgICBfeDUgPSBwb3NQdHMueDI7XG4gICAgICBycy5zZWdwdHMgPSBbX3g0LCBfeTQsIF94NSwgX3k0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9yaXpvbnRhbFxuICAgICAgdmFyIF94NiA9IHBvc1B0cy54MSArIGQgKyAoZEluY2x1ZGVzTm9kZUJvZHkgPyBzcmNXIC8gMiAqIHNnbkwgOiAwKTtcblxuICAgICAgdmFyIF95NSA9IHBvc1B0cy55MSxcbiAgICAgICAgICBfeTYgPSBwb3NQdHMueTI7XG4gICAgICBycy5zZWdwdHMgPSBbX3g2LCBfeTUsIF94NiwgX3k2XTtcbiAgICB9XG4gIH1cbn07XG5cbkJScCRjLnRyeVRvQ29ycmVjdEludmFsaWRQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSwgcGFpckluZm8pIHtcbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDsgLy8gY2FuIG9ubHkgY29ycmVjdCBiZXppZXJzIGZvciBub3cuLi5cblxuICBpZiAocnMuZWRnZVR5cGUgPT09ICdiZXppZXInKSB7XG4gICAgdmFyIHNyY1BvcyA9IHBhaXJJbmZvLnNyY1BvcyxcbiAgICAgICAgdGd0UG9zID0gcGFpckluZm8udGd0UG9zLFxuICAgICAgICBzcmNXID0gcGFpckluZm8uc3JjVyxcbiAgICAgICAgc3JjSCA9IHBhaXJJbmZvLnNyY0gsXG4gICAgICAgIHRndFcgPSBwYWlySW5mby50Z3RXLFxuICAgICAgICB0Z3RIID0gcGFpckluZm8udGd0SCxcbiAgICAgICAgc3JjU2hhcGUgPSBwYWlySW5mby5zcmNTaGFwZSxcbiAgICAgICAgdGd0U2hhcGUgPSBwYWlySW5mby50Z3RTaGFwZTtcbiAgICB2YXIgYmFkU3RhcnQgPSAhbnVtYmVyJDEocnMuc3RhcnRYKSB8fCAhbnVtYmVyJDEocnMuc3RhcnRZKTtcbiAgICB2YXIgYmFkQVN0YXJ0ID0gIW51bWJlciQxKHJzLmFycm93U3RhcnRYKSB8fCAhbnVtYmVyJDEocnMuYXJyb3dTdGFydFkpO1xuICAgIHZhciBiYWRFbmQgPSAhbnVtYmVyJDEocnMuZW5kWCkgfHwgIW51bWJlciQxKHJzLmVuZFkpO1xuICAgIHZhciBiYWRBRW5kID0gIW51bWJlciQxKHJzLmFycm93RW5kWCkgfHwgIW51bWJlciQxKHJzLmFycm93RW5kWSk7XG4gICAgdmFyIG1pbkNwQURpc3RGYWN0b3IgPSAzO1xuICAgIHZhciBhcnJvd1cgPSB0aGlzLmdldEFycm93V2lkdGgoZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSwgZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWUpICogdGhpcy5hcnJvd1NoYXBlV2lkdGg7XG4gICAgdmFyIG1pbkNwQURpc3QgPSBtaW5DcEFEaXN0RmFjdG9yICogYXJyb3dXO1xuICAgIHZhciBzdGFydEFDcERpc3QgPSBkaXN0KHtcbiAgICAgIHg6IHJzLmN0cmxwdHNbMF0sXG4gICAgICB5OiBycy5jdHJscHRzWzFdXG4gICAgfSwge1xuICAgICAgeDogcnMuc3RhcnRYLFxuICAgICAgeTogcnMuc3RhcnRZXG4gICAgfSk7XG4gICAgdmFyIGNsb3NlU3RhcnRBQ3AgPSBzdGFydEFDcERpc3QgPCBtaW5DcEFEaXN0O1xuICAgIHZhciBlbmRBQ3BEaXN0ID0gZGlzdCh7XG4gICAgICB4OiBycy5jdHJscHRzWzBdLFxuICAgICAgeTogcnMuY3RybHB0c1sxXVxuICAgIH0sIHtcbiAgICAgIHg6IHJzLmVuZFgsXG4gICAgICB5OiBycy5lbmRZXG4gICAgfSk7XG4gICAgdmFyIGNsb3NlRW5kQUNwID0gZW5kQUNwRGlzdCA8IG1pbkNwQURpc3Q7XG4gICAgdmFyIG92ZXJsYXBwaW5nID0gZmFsc2U7XG5cbiAgICBpZiAoYmFkU3RhcnQgfHwgYmFkQVN0YXJ0IHx8IGNsb3NlU3RhcnRBQ3ApIHtcbiAgICAgIG92ZXJsYXBwaW5nID0gdHJ1ZTsgLy8gcHJvamVjdCBjb250cm9sIHBvaW50IGFsb25nIGxpbmUgZnJvbSBzcmMgY2VudHJlIHRvIG91dHNpZGUgdGhlIHNyYyBzaGFwZVxuICAgICAgLy8gKG90aGVyd2lzZSBpbnRlcnNlY3Rpb24gd2lsbCB5aWVsZCBub3RoaW5nKVxuXG4gICAgICB2YXIgY3BEID0ge1xuICAgICAgICAvLyBkZWx0YVxuICAgICAgICB4OiBycy5jdHJscHRzWzBdIC0gc3JjUG9zLngsXG4gICAgICAgIHk6IHJzLmN0cmxwdHNbMV0gLSBzcmNQb3MueVxuICAgICAgfTtcbiAgICAgIHZhciBjcEwgPSBNYXRoLnNxcnQoY3BELnggKiBjcEQueCArIGNwRC55ICogY3BELnkpOyAvLyBsZW5ndGggb2YgbGluZVxuXG4gICAgICB2YXIgY3BNID0ge1xuICAgICAgICAvLyBub3JtYWxpc2VkIGRlbHRhXG4gICAgICAgIHg6IGNwRC54IC8gY3BMLFxuICAgICAgICB5OiBjcEQueSAvIGNwTFxuICAgICAgfTtcbiAgICAgIHZhciByYWRpdXMgPSBNYXRoLm1heChzcmNXLCBzcmNIKTtcbiAgICAgIHZhciBjcFByb2ogPSB7XG4gICAgICAgIC8vICoyIHJhZGl1cyBndWFyYW50ZWVzIG91dHNpZGUgc2hhcGVcbiAgICAgICAgeDogcnMuY3RybHB0c1swXSArIGNwTS54ICogMiAqIHJhZGl1cyxcbiAgICAgICAgeTogcnMuY3RybHB0c1sxXSArIGNwTS55ICogMiAqIHJhZGl1c1xuICAgICAgfTtcbiAgICAgIHZhciBzcmNDdHJsUHRJbnRuID0gc3JjU2hhcGUuaW50ZXJzZWN0TGluZShzcmNQb3MueCwgc3JjUG9zLnksIHNyY1csIHNyY0gsIGNwUHJvai54LCBjcFByb2oueSwgMCk7XG5cbiAgICAgIGlmIChjbG9zZVN0YXJ0QUNwKSB7XG4gICAgICAgIHJzLmN0cmxwdHNbMF0gPSBycy5jdHJscHRzWzBdICsgY3BNLnggKiAobWluQ3BBRGlzdCAtIHN0YXJ0QUNwRGlzdCk7XG4gICAgICAgIHJzLmN0cmxwdHNbMV0gPSBycy5jdHJscHRzWzFdICsgY3BNLnkgKiAobWluQ3BBRGlzdCAtIHN0YXJ0QUNwRGlzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBycy5jdHJscHRzWzBdID0gc3JjQ3RybFB0SW50blswXSArIGNwTS54ICogbWluQ3BBRGlzdDtcbiAgICAgICAgcnMuY3RybHB0c1sxXSA9IHNyY0N0cmxQdEludG5bMV0gKyBjcE0ueSAqIG1pbkNwQURpc3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJhZEVuZCB8fCBiYWRBRW5kIHx8IGNsb3NlRW5kQUNwKSB7XG4gICAgICBvdmVybGFwcGluZyA9IHRydWU7IC8vIHByb2plY3QgY29udHJvbCBwb2ludCBhbG9uZyBsaW5lIGZyb20gdGd0IGNlbnRyZSB0byBvdXRzaWRlIHRoZSB0Z3Qgc2hhcGVcbiAgICAgIC8vIChvdGhlcndpc2UgaW50ZXJzZWN0aW9uIHdpbGwgeWllbGQgbm90aGluZylcblxuICAgICAgdmFyIF9jcEQgPSB7XG4gICAgICAgIC8vIGRlbHRhXG4gICAgICAgIHg6IHJzLmN0cmxwdHNbMF0gLSB0Z3RQb3MueCxcbiAgICAgICAgeTogcnMuY3RybHB0c1sxXSAtIHRndFBvcy55XG4gICAgICB9O1xuXG4gICAgICB2YXIgX2NwTCA9IE1hdGguc3FydChfY3BELnggKiBfY3BELnggKyBfY3BELnkgKiBfY3BELnkpOyAvLyBsZW5ndGggb2YgbGluZVxuXG5cbiAgICAgIHZhciBfY3BNID0ge1xuICAgICAgICAvLyBub3JtYWxpc2VkIGRlbHRhXG4gICAgICAgIHg6IF9jcEQueCAvIF9jcEwsXG4gICAgICAgIHk6IF9jcEQueSAvIF9jcExcbiAgICAgIH07XG5cbiAgICAgIHZhciBfcmFkaXVzID0gTWF0aC5tYXgoc3JjVywgc3JjSCk7XG5cbiAgICAgIHZhciBfY3BQcm9qID0ge1xuICAgICAgICAvLyAqMiByYWRpdXMgZ3VhcmFudGVlcyBvdXRzaWRlIHNoYXBlXG4gICAgICAgIHg6IHJzLmN0cmxwdHNbMF0gKyBfY3BNLnggKiAyICogX3JhZGl1cyxcbiAgICAgICAgeTogcnMuY3RybHB0c1sxXSArIF9jcE0ueSAqIDIgKiBfcmFkaXVzXG4gICAgICB9O1xuICAgICAgdmFyIHRndEN0cmxQdEludG4gPSB0Z3RTaGFwZS5pbnRlcnNlY3RMaW5lKHRndFBvcy54LCB0Z3RQb3MueSwgdGd0VywgdGd0SCwgX2NwUHJvai54LCBfY3BQcm9qLnksIDApO1xuXG4gICAgICBpZiAoY2xvc2VFbmRBQ3ApIHtcbiAgICAgICAgcnMuY3RybHB0c1swXSA9IHJzLmN0cmxwdHNbMF0gKyBfY3BNLnggKiAobWluQ3BBRGlzdCAtIGVuZEFDcERpc3QpO1xuICAgICAgICBycy5jdHJscHRzWzFdID0gcnMuY3RybHB0c1sxXSArIF9jcE0ueSAqIChtaW5DcEFEaXN0IC0gZW5kQUNwRGlzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBycy5jdHJscHRzWzBdID0gdGd0Q3RybFB0SW50blswXSArIF9jcE0ueCAqIG1pbkNwQURpc3Q7XG4gICAgICAgIHJzLmN0cmxwdHNbMV0gPSB0Z3RDdHJsUHRJbnRuWzFdICsgX2NwTS55ICogbWluQ3BBRGlzdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3ZlcmxhcHBpbmcpIHtcbiAgICAgIC8vIHJlY2FsYyBlbmRwdHNcbiAgICAgIHRoaXMuZmluZEVuZHBvaW50cyhlZGdlKTtcbiAgICB9XG4gIH1cbn07XG5cbkJScCRjLnN0b3JlQWxscHRzID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcblxuICBpZiAocnMuZWRnZVR5cGUgPT09ICdtdWx0aWJlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdiZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnc2VsZicgfHwgcnMuZWRnZVR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICBycy5hbGxwdHMgPSBbXTtcbiAgICBycy5hbGxwdHMucHVzaChycy5zdGFydFgsIHJzLnN0YXJ0WSk7XG5cbiAgICBmb3IgKHZhciBiID0gMDsgYiArIDEgPCBycy5jdHJscHRzLmxlbmd0aDsgYiArPSAyKSB7XG4gICAgICAvLyBjdHJsIHB0IGl0c2VsZlxuICAgICAgcnMuYWxscHRzLnB1c2gocnMuY3RybHB0c1tiXSwgcnMuY3RybHB0c1tiICsgMV0pOyAvLyB0aGUgbWlkcHQgYmV0d2VlbiBjdHJscHRzIGFzIGludGVybWVkaWF0ZSBkZXN0aW5hdGlvbiBwdHNcblxuICAgICAgaWYgKGIgKyAzIDwgcnMuY3RybHB0cy5sZW5ndGgpIHtcbiAgICAgICAgcnMuYWxscHRzLnB1c2goKHJzLmN0cmxwdHNbYl0gKyBycy5jdHJscHRzW2IgKyAyXSkgLyAyLCAocnMuY3RybHB0c1tiICsgMV0gKyBycy5jdHJscHRzW2IgKyAzXSkgLyAyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBycy5hbGxwdHMucHVzaChycy5lbmRYLCBycy5lbmRZKTtcbiAgICB2YXIgbSwgbXQ7XG5cbiAgICBpZiAocnMuY3RybHB0cy5sZW5ndGggLyAyICUgMiA9PT0gMCkge1xuICAgICAgbSA9IHJzLmFsbHB0cy5sZW5ndGggLyAyIC0gMTtcbiAgICAgIHJzLm1pZFggPSBycy5hbGxwdHNbbV07XG4gICAgICBycy5taWRZID0gcnMuYWxscHRzW20gKyAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHJzLmFsbHB0cy5sZW5ndGggLyAyIC0gMztcbiAgICAgIG10ID0gMC41O1xuICAgICAgcnMubWlkWCA9IHFiZXppZXJBdChycy5hbGxwdHNbbV0sIHJzLmFsbHB0c1ttICsgMl0sIHJzLmFsbHB0c1ttICsgNF0sIG10KTtcbiAgICAgIHJzLm1pZFkgPSBxYmV6aWVyQXQocnMuYWxscHRzW20gKyAxXSwgcnMuYWxscHRzW20gKyAzXSwgcnMuYWxscHRzW20gKyA1XSwgbXQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PT0gJ3N0cmFpZ2h0Jykge1xuICAgIC8vIG5lZWQgdG8gY2FsYyB0aGVzZSBhZnRlciBlbmRwdHNcbiAgICBycy5hbGxwdHMgPSBbcnMuc3RhcnRYLCBycy5zdGFydFksIHJzLmVuZFgsIHJzLmVuZFldOyAvLyBkZWZhdWx0IG1pZHB0IGZvciBsYWJlbHMgZXRjXG5cbiAgICBycy5taWRYID0gKHJzLnN0YXJ0WCArIHJzLmVuZFggKyBycy5hcnJvd1N0YXJ0WCArIHJzLmFycm93RW5kWCkgLyA0O1xuICAgIHJzLm1pZFkgPSAocnMuc3RhcnRZICsgcnMuZW5kWSArIHJzLmFycm93U3RhcnRZICsgcnMuYXJyb3dFbmRZKSAvIDQ7XG4gIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT09ICdzZWdtZW50cycpIHtcbiAgICBycy5hbGxwdHMgPSBbXTtcbiAgICBycy5hbGxwdHMucHVzaChycy5zdGFydFgsIHJzLnN0YXJ0WSk7XG4gICAgcnMuYWxscHRzLnB1c2guYXBwbHkocnMuYWxscHRzLCBycy5zZWdwdHMpO1xuICAgIHJzLmFsbHB0cy5wdXNoKHJzLmVuZFgsIHJzLmVuZFkpO1xuXG4gICAgaWYgKHJzLnNlZ3B0cy5sZW5ndGggJSA0ID09PSAwKSB7XG4gICAgICB2YXIgaTIgPSBycy5zZWdwdHMubGVuZ3RoIC8gMjtcbiAgICAgIHZhciBpMSA9IGkyIC0gMjtcbiAgICAgIHJzLm1pZFggPSAocnMuc2VncHRzW2kxXSArIHJzLnNlZ3B0c1tpMl0pIC8gMjtcbiAgICAgIHJzLm1pZFkgPSAocnMuc2VncHRzW2kxICsgMV0gKyBycy5zZWdwdHNbaTIgKyAxXSkgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2kgPSBycy5zZWdwdHMubGVuZ3RoIC8gMiAtIDE7XG5cbiAgICAgIHJzLm1pZFggPSBycy5zZWdwdHNbX2ldO1xuICAgICAgcnMubWlkWSA9IHJzLnNlZ3B0c1tfaSArIDFdO1xuICAgIH1cbiAgfVxufTtcblxuQlJwJGMuY2hlY2tGb3JJbnZhbGlkRWRnZVdhcm5pbmcgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgcnMgPSBlZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuXG4gIGlmIChycy5ub2Rlc092ZXJsYXAgfHwgbnVtYmVyJDEocnMuc3RhcnRYKSAmJiBudW1iZXIkMShycy5zdGFydFkpICYmIG51bWJlciQxKHJzLmVuZFgpICYmIG51bWJlciQxKHJzLmVuZFkpKSB7XG4gICAgcnMubG9nZ2VkRXJyID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFycy5sb2dnZWRFcnIpIHtcbiAgICAgIHJzLmxvZ2dlZEVyciA9IHRydWU7XG4gICAgICB3YXJuKCdFZGdlIGAnICsgZWRnZS5pZCgpICsgJ2AgaGFzIGludmFsaWQgZW5kcG9pbnRzIGFuZCBzbyBpdCBpcyBpbXBvc3NpYmxlIHRvIGRyYXcuICBBZGp1c3QgeW91ciBlZGdlIHN0eWxlIChlLmcuIGNvbnRyb2wgcG9pbnRzKSBhY2NvcmRpbmdseSBvciB1c2UgYW4gYWx0ZXJuYXRpdmUgZWRnZSB0eXBlLiAgVGhpcyBpcyBleHBlY3RlZCBiZWhhdmlvdXIgd2hlbiB0aGUgc291cmNlIG5vZGUgYW5kIHRoZSB0YXJnZXQgbm9kZSBvdmVybGFwLicpO1xuICAgIH1cbiAgfVxufTtcblxuQlJwJGMuZmluZEVkZ2VDb250cm9sUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2VzKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKCFlZGdlcyB8fCBlZGdlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgciA9IHRoaXM7XG4gIHZhciBjeSA9IHIuY3k7XG4gIHZhciBoYXNDb21wb3VuZHMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gIHZhciBoYXNoVGFibGUgPSB7XG4gICAgbWFwOiBuZXcgTWFwJDEoKSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldChwYWlySWQpIHtcbiAgICAgIHZhciBtYXAyID0gdGhpcy5tYXAuZ2V0KHBhaXJJZFswXSk7XG5cbiAgICAgIGlmIChtYXAyICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG1hcDIuZ2V0KHBhaXJJZFsxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHBhaXJJZCwgdmFsKSB7XG4gICAgICB2YXIgbWFwMiA9IHRoaXMubWFwLmdldChwYWlySWRbMF0pO1xuXG4gICAgICBpZiAobWFwMiA9PSBudWxsKSB7XG4gICAgICAgIG1hcDIgPSBuZXcgTWFwJDEoKTtcbiAgICAgICAgdGhpcy5tYXAuc2V0KHBhaXJJZFswXSwgbWFwMik7XG4gICAgICB9XG5cbiAgICAgIG1hcDIuc2V0KHBhaXJJZFsxXSwgdmFsKTtcbiAgICB9XG4gIH07XG4gIHZhciBwYWlySWRzID0gW107XG4gIHZhciBoYXlzdGFja0VkZ2VzID0gW107IC8vIGNyZWF0ZSBhIHRhYmxlIG9mIGVkZ2UgKHNyYywgdGd0KSA9PiBsaXN0IG9mIGVkZ2VzIGJldHdlZW4gdGhlbVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgdmFyIGN1cnZlU3R5bGUgPSBlZGdlLnBzdHlsZSgnY3VydmUtc3R5bGUnKS52YWx1ZTsgLy8gaWdub3JlIGVkZ2VzIHdobyBhcmUgbm90IHRvIGJlIGRpc3BsYXllZFxuICAgIC8vIHRoZXkgc2hvdWxkbid0IHRha2UgdXAgc3BhY2VcblxuICAgIGlmIChlZGdlLnJlbW92ZWQoKSB8fCAhZWRnZS50YWtlc1VwU3BhY2UoKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGN1cnZlU3R5bGUgPT09ICdoYXlzdGFjaycpIHtcbiAgICAgIGhheXN0YWNrRWRnZXMucHVzaChlZGdlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBlZGdlSXNVbmJ1bmRsZWQgPSBjdXJ2ZVN0eWxlID09PSAndW5idW5kbGVkLWJlemllcicgfHwgY3VydmVTdHlsZSA9PT0gJ3NlZ21lbnRzJyB8fCBjdXJ2ZVN0eWxlID09PSAnc3RyYWlnaHQnIHx8IGN1cnZlU3R5bGUgPT09ICdzdHJhaWdodC10cmlhbmdsZScgfHwgY3VydmVTdHlsZSA9PT0gJ3RheGknO1xuICAgIHZhciBlZGdlSXNCZXppZXIgPSBjdXJ2ZVN0eWxlID09PSAndW5idW5kbGVkLWJlemllcicgfHwgY3VydmVTdHlsZSA9PT0gJ2Jlemllcic7XG4gICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICB2YXIgdGd0ID0gX3AudGFyZ2V0O1xuICAgIHZhciBzcmNJbmRleCA9IHNyYy5wb29sSW5kZXgoKTtcbiAgICB2YXIgdGd0SW5kZXggPSB0Z3QucG9vbEluZGV4KCk7XG4gICAgdmFyIHBhaXJJZCA9IFtzcmNJbmRleCwgdGd0SW5kZXhdLnNvcnQoKTtcbiAgICB2YXIgdGFibGVFbnRyeSA9IGhhc2hUYWJsZS5nZXQocGFpcklkKTtcblxuICAgIGlmICh0YWJsZUVudHJ5ID09IG51bGwpIHtcbiAgICAgIHRhYmxlRW50cnkgPSB7XG4gICAgICAgIGVsZXM6IFtdXG4gICAgICB9O1xuICAgICAgaGFzaFRhYmxlLnNldChwYWlySWQsIHRhYmxlRW50cnkpO1xuICAgICAgcGFpcklkcy5wdXNoKHBhaXJJZCk7XG4gICAgfVxuXG4gICAgdGFibGVFbnRyeS5lbGVzLnB1c2goZWRnZSk7XG5cbiAgICBpZiAoZWRnZUlzVW5idW5kbGVkKSB7XG4gICAgICB0YWJsZUVudHJ5Lmhhc1VuYnVuZGxlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGVkZ2VJc0Jlemllcikge1xuICAgICAgdGFibGVFbnRyeS5oYXNCZXppZXIgPSB0cnVlO1xuICAgIH1cbiAgfSAvLyBmb3IgZWFjaCBwYWlyIChzcmMsIHRndCksIGNyZWF0ZSB0aGUgY3RybCBwdHNcbiAgLy8gTmVzdGVkIGZvciBsb29wIGlzIE9LOyB0b3RhbCBudW1iZXIgb2YgaXRlcmF0aW9ucyBmb3IgYm90aCBsb29wcyA9IGVkZ2VDb3VudFxuXG5cbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AocCkge1xuICAgIHZhciBwYWlySWQgPSBwYWlySWRzW3BdO1xuICAgIHZhciBwYWlySW5mbyA9IGhhc2hUYWJsZS5nZXQocGFpcklkKTtcbiAgICB2YXIgc3dhcHBlZHBhaXJJbmZvID0gdm9pZCAwO1xuXG4gICAgaWYgKCFwYWlySW5mby5oYXNVbmJ1bmRsZWQpIHtcbiAgICAgIHZhciBwbGxFZGdlcyA9IHBhaXJJbmZvLmVsZXNbMF0ucGFyYWxsZWxFZGdlcygpLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZS5pc0J1bmRsZWRCZXppZXIoKTtcbiAgICAgIH0pO1xuICAgICAgY2xlYXJBcnJheShwYWlySW5mby5lbGVzKTtcbiAgICAgIHBsbEVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIHBhaXJJbmZvLmVsZXMucHVzaChlZGdlKTtcbiAgICAgIH0pOyAvLyBmb3IgZWFjaCBwYWlyIGlkLCB0aGUgZWRnZXMgc2hvdWxkIGJlIHNvcnRlZCBieSBpbmRleFxuXG4gICAgICBwYWlySW5mby5lbGVzLnNvcnQoZnVuY3Rpb24gKGVkZ2UxLCBlZGdlMikge1xuICAgICAgICByZXR1cm4gZWRnZTEucG9vbEluZGV4KCkgLSBlZGdlMi5wb29sSW5kZXgoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBmaXJzdEVkZ2UgPSBwYWlySW5mby5lbGVzWzBdO1xuICAgIHZhciBzcmMgPSBmaXJzdEVkZ2Uuc291cmNlKCk7XG4gICAgdmFyIHRndCA9IGZpcnN0RWRnZS50YXJnZXQoKTsgLy8gbWFrZSBzdXJlIHNyYy90Z3QgZGlzdGluY3Rpb24gaXMgY29uc2lzdGVudCB3LnIudC4gcGFpcklkXG5cbiAgICBpZiAoc3JjLnBvb2xJbmRleCgpID4gdGd0LnBvb2xJbmRleCgpKSB7XG4gICAgICB2YXIgdGVtcCA9IHNyYztcbiAgICAgIHNyYyA9IHRndDtcbiAgICAgIHRndCA9IHRlbXA7XG4gICAgfVxuXG4gICAgdmFyIHNyY1BvcyA9IHBhaXJJbmZvLnNyY1BvcyA9IHNyYy5wb3NpdGlvbigpO1xuICAgIHZhciB0Z3RQb3MgPSBwYWlySW5mby50Z3RQb3MgPSB0Z3QucG9zaXRpb24oKTtcbiAgICB2YXIgc3JjVyA9IHBhaXJJbmZvLnNyY1cgPSBzcmMub3V0ZXJXaWR0aCgpO1xuICAgIHZhciBzcmNIID0gcGFpckluZm8uc3JjSCA9IHNyYy5vdXRlckhlaWdodCgpO1xuICAgIHZhciB0Z3RXID0gcGFpckluZm8udGd0VyA9IHRndC5vdXRlcldpZHRoKCk7XG4gICAgdmFyIHRndEggPSBwYWlySW5mby50Z3RIID0gdGd0Lm91dGVySGVpZ2h0KCk7XG5cbiAgICB2YXIgc3JjU2hhcGUgPSBwYWlySW5mby5zcmNTaGFwZSA9IHIubm9kZVNoYXBlc1tfdGhpcy5nZXROb2RlU2hhcGUoc3JjKV07XG5cbiAgICB2YXIgdGd0U2hhcGUgPSBwYWlySW5mby50Z3RTaGFwZSA9IHIubm9kZVNoYXBlc1tfdGhpcy5nZXROb2RlU2hhcGUodGd0KV07XG5cbiAgICBwYWlySW5mby5kaXJDb3VudHMgPSB7XG4gICAgICAnbm9ydGgnOiAwLFxuICAgICAgJ3dlc3QnOiAwLFxuICAgICAgJ3NvdXRoJzogMCxcbiAgICAgICdlYXN0JzogMCxcbiAgICAgICdub3J0aHdlc3QnOiAwLFxuICAgICAgJ3NvdXRod2VzdCc6IDAsXG4gICAgICAnbm9ydGhlYXN0JzogMCxcbiAgICAgICdzb3V0aGVhc3QnOiAwXG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHBhaXJJbmZvLmVsZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgdmFyIF9lZGdlID0gcGFpckluZm8uZWxlc1tfaTJdO1xuICAgICAgdmFyIHJzID0gX2VkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG5cbiAgICAgIHZhciBfY3VydmVTdHlsZSA9IF9lZGdlLnBzdHlsZSgnY3VydmUtc3R5bGUnKS52YWx1ZTtcblxuICAgICAgdmFyIF9lZGdlSXNVbmJ1bmRsZWQgPSBfY3VydmVTdHlsZSA9PT0gJ3VuYnVuZGxlZC1iZXppZXInIHx8IF9jdXJ2ZVN0eWxlID09PSAnc2VnbWVudHMnIHx8IF9jdXJ2ZVN0eWxlID09PSAndGF4aSc7IC8vIHdoZXRoZXIgdGhlIG5vcm1hbGlzZWQgcGFpciBvcmRlciBpcyB0aGUgcmV2ZXJzZSBvZiB0aGUgZWRnZSdzIHNyYy10Z3Qgb3JkZXJcblxuXG4gICAgICB2YXIgZWRnZUlzU3dhcHBlZCA9ICFzcmMuc2FtZShfZWRnZS5zb3VyY2UoKSk7XG5cbiAgICAgIGlmICghcGFpckluZm8uY2FsY3VsYXRlZEludGVyc2VjdGlvbiAmJiBzcmMgIT09IHRndCAmJiAocGFpckluZm8uaGFzQmV6aWVyIHx8IHBhaXJJbmZvLmhhc1VuYnVuZGxlZCkpIHtcbiAgICAgICAgcGFpckluZm8uY2FsY3VsYXRlZEludGVyc2VjdGlvbiA9IHRydWU7IC8vIHB0IG91dHNpZGUgc3JjIHNoYXBlIHRvIGNhbGMgZGlzdGFuY2UvZGlzcGxhY2VtZW50IGZyb20gc3JjIHRvIHRndFxuXG4gICAgICAgIHZhciBzcmNPdXRzaWRlID0gc3JjU2hhcGUuaW50ZXJzZWN0TGluZShzcmNQb3MueCwgc3JjUG9zLnksIHNyY1csIHNyY0gsIHRndFBvcy54LCB0Z3RQb3MueSwgMCk7XG4gICAgICAgIHZhciBzcmNJbnRuID0gcGFpckluZm8uc3JjSW50biA9IHNyY091dHNpZGU7IC8vIHB0IG91dHNpZGUgdGd0IHNoYXBlIHRvIGNhbGMgZGlzdGFuY2UvZGlzcGxhY2VtZW50IGZyb20gc3JjIHRvIHRndFxuXG4gICAgICAgIHZhciB0Z3RPdXRzaWRlID0gdGd0U2hhcGUuaW50ZXJzZWN0TGluZSh0Z3RQb3MueCwgdGd0UG9zLnksIHRndFcsIHRndEgsIHNyY1Bvcy54LCBzcmNQb3MueSwgMCk7XG4gICAgICAgIHZhciB0Z3RJbnRuID0gcGFpckluZm8udGd0SW50biA9IHRndE91dHNpZGU7XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb25QdHMgPSBwYWlySW5mby5pbnRlcnNlY3Rpb25QdHMgPSB7XG4gICAgICAgICAgeDE6IHNyY091dHNpZGVbMF0sXG4gICAgICAgICAgeDI6IHRndE91dHNpZGVbMF0sXG4gICAgICAgICAgeTE6IHNyY091dHNpZGVbMV0sXG4gICAgICAgICAgeTI6IHRndE91dHNpZGVbMV1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHBvc1B0cyA9IHBhaXJJbmZvLnBvc1B0cyA9IHtcbiAgICAgICAgICB4MTogc3JjUG9zLngsXG4gICAgICAgICAgeDI6IHRndFBvcy54LFxuICAgICAgICAgIHkxOiBzcmNQb3MueSxcbiAgICAgICAgICB5MjogdGd0UG9zLnlcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGR5ID0gdGd0T3V0c2lkZVsxXSAtIHNyY091dHNpZGVbMV07XG4gICAgICAgIHZhciBkeCA9IHRndE91dHNpZGVbMF0gLSBzcmNPdXRzaWRlWzBdO1xuICAgICAgICB2YXIgbCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIHZhciB2ZWN0b3IgPSBwYWlySW5mby52ZWN0b3IgPSB7XG4gICAgICAgICAgeDogZHgsXG4gICAgICAgICAgeTogZHlcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHZlY3Rvck5vcm0gPSBwYWlySW5mby52ZWN0b3JOb3JtID0ge1xuICAgICAgICAgIHg6IHZlY3Rvci54IC8gbCxcbiAgICAgICAgICB5OiB2ZWN0b3IueSAvIGxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHZlY3Rvck5vcm1JbnZlcnNlID0ge1xuICAgICAgICAgIHg6IC12ZWN0b3JOb3JtLnksXG4gICAgICAgICAgeTogdmVjdG9yTm9ybS54XG4gICAgICAgIH07IC8vIGlmIG5vZGUgc2hhcGVzIG92ZXJsYXAsIHRoZW4gbm8gY3RybCBwdHMgdG8gZHJhd1xuXG4gICAgICAgIHBhaXJJbmZvLm5vZGVzT3ZlcmxhcCA9ICFudW1iZXIkMShsKSB8fCB0Z3RTaGFwZS5jaGVja1BvaW50KHNyY091dHNpZGVbMF0sIHNyY091dHNpZGVbMV0sIDAsIHRndFcsIHRndEgsIHRndFBvcy54LCB0Z3RQb3MueSkgfHwgc3JjU2hhcGUuY2hlY2tQb2ludCh0Z3RPdXRzaWRlWzBdLCB0Z3RPdXRzaWRlWzFdLCAwLCBzcmNXLCBzcmNILCBzcmNQb3MueCwgc3JjUG9zLnkpO1xuICAgICAgICBwYWlySW5mby52ZWN0b3JOb3JtSW52ZXJzZSA9IHZlY3Rvck5vcm1JbnZlcnNlO1xuICAgICAgICBzd2FwcGVkcGFpckluZm8gPSB7XG4gICAgICAgICAgbm9kZXNPdmVybGFwOiBwYWlySW5mby5ub2Rlc092ZXJsYXAsXG4gICAgICAgICAgZGlyQ291bnRzOiBwYWlySW5mby5kaXJDb3VudHMsXG4gICAgICAgICAgY2FsY3VsYXRlZEludGVyc2VjdGlvbjogdHJ1ZSxcbiAgICAgICAgICBoYXNCZXppZXI6IHBhaXJJbmZvLmhhc0JlemllcixcbiAgICAgICAgICBoYXNVbmJ1bmRsZWQ6IHBhaXJJbmZvLmhhc1VuYnVuZGxlZCxcbiAgICAgICAgICBlbGVzOiBwYWlySW5mby5lbGVzLFxuICAgICAgICAgIHNyY1BvczogdGd0UG9zLFxuICAgICAgICAgIHRndFBvczogc3JjUG9zLFxuICAgICAgICAgIHNyY1c6IHRndFcsXG4gICAgICAgICAgc3JjSDogdGd0SCxcbiAgICAgICAgICB0Z3RXOiBzcmNXLFxuICAgICAgICAgIHRndEg6IHNyY0gsXG4gICAgICAgICAgc3JjSW50bjogdGd0SW50bixcbiAgICAgICAgICB0Z3RJbnRuOiBzcmNJbnRuLFxuICAgICAgICAgIHNyY1NoYXBlOiB0Z3RTaGFwZSxcbiAgICAgICAgICB0Z3RTaGFwZTogc3JjU2hhcGUsXG4gICAgICAgICAgcG9zUHRzOiB7XG4gICAgICAgICAgICB4MTogcG9zUHRzLngyLFxuICAgICAgICAgICAgeTE6IHBvc1B0cy55MixcbiAgICAgICAgICAgIHgyOiBwb3NQdHMueDEsXG4gICAgICAgICAgICB5MjogcG9zUHRzLnkxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnRlcnNlY3Rpb25QdHM6IHtcbiAgICAgICAgICAgIHgxOiBpbnRlcnNlY3Rpb25QdHMueDIsXG4gICAgICAgICAgICB5MTogaW50ZXJzZWN0aW9uUHRzLnkyLFxuICAgICAgICAgICAgeDI6IGludGVyc2VjdGlvblB0cy54MSxcbiAgICAgICAgICAgIHkyOiBpbnRlcnNlY3Rpb25QdHMueTFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHZlY3Rvcjoge1xuICAgICAgICAgICAgeDogLXZlY3Rvci54LFxuICAgICAgICAgICAgeTogLXZlY3Rvci55XG4gICAgICAgICAgfSxcbiAgICAgICAgICB2ZWN0b3JOb3JtOiB7XG4gICAgICAgICAgICB4OiAtdmVjdG9yTm9ybS54LFxuICAgICAgICAgICAgeTogLXZlY3Rvck5vcm0ueVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdmVjdG9yTm9ybUludmVyc2U6IHtcbiAgICAgICAgICAgIHg6IC12ZWN0b3JOb3JtSW52ZXJzZS54LFxuICAgICAgICAgICAgeTogLXZlY3Rvck5vcm1JbnZlcnNlLnlcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXNzZWRQYWlySW5mbyA9IGVkZ2VJc1N3YXBwZWQgPyBzd2FwcGVkcGFpckluZm8gOiBwYWlySW5mbztcbiAgICAgIHJzLm5vZGVzT3ZlcmxhcCA9IHBhc3NlZFBhaXJJbmZvLm5vZGVzT3ZlcmxhcDtcbiAgICAgIHJzLnNyY0ludG4gPSBwYXNzZWRQYWlySW5mby5zcmNJbnRuO1xuICAgICAgcnMudGd0SW50biA9IHBhc3NlZFBhaXJJbmZvLnRndEludG47XG5cbiAgICAgIGlmIChoYXNDb21wb3VuZHMgJiYgKHNyYy5pc1BhcmVudCgpIHx8IHNyYy5pc0NoaWxkKCkgfHwgdGd0LmlzUGFyZW50KCkgfHwgdGd0LmlzQ2hpbGQoKSkgJiYgKHNyYy5wYXJlbnRzKCkuYW55U2FtZSh0Z3QpIHx8IHRndC5wYXJlbnRzKCkuYW55U2FtZShzcmMpIHx8IHNyYy5zYW1lKHRndCkgJiYgc3JjLmlzUGFyZW50KCkpKSB7XG4gICAgICAgIF90aGlzLmZpbmRDb21wb3VuZExvb3BQb2ludHMoX2VkZ2UsIHBhc3NlZFBhaXJJbmZvLCBfaTIsIF9lZGdlSXNVbmJ1bmRsZWQpO1xuICAgICAgfSBlbHNlIGlmIChzcmMgPT09IHRndCkge1xuICAgICAgICBfdGhpcy5maW5kTG9vcFBvaW50cyhfZWRnZSwgcGFzc2VkUGFpckluZm8sIF9pMiwgX2VkZ2VJc1VuYnVuZGxlZCk7XG4gICAgICB9IGVsc2UgaWYgKF9jdXJ2ZVN0eWxlID09PSAnc2VnbWVudHMnKSB7XG4gICAgICAgIF90aGlzLmZpbmRTZWdtZW50c1BvaW50cyhfZWRnZSwgcGFzc2VkUGFpckluZm8pO1xuICAgICAgfSBlbHNlIGlmIChfY3VydmVTdHlsZSA9PT0gJ3RheGknKSB7XG4gICAgICAgIF90aGlzLmZpbmRUYXhpUG9pbnRzKF9lZGdlLCBwYXNzZWRQYWlySW5mbyk7XG4gICAgICB9IGVsc2UgaWYgKF9jdXJ2ZVN0eWxlID09PSAnc3RyYWlnaHQnIHx8ICFfZWRnZUlzVW5idW5kbGVkICYmIHBhaXJJbmZvLmVsZXMubGVuZ3RoICUgMiA9PT0gMSAmJiBfaTIgPT09IE1hdGguZmxvb3IocGFpckluZm8uZWxlcy5sZW5ndGggLyAyKSkge1xuICAgICAgICBfdGhpcy5maW5kU3RyYWlnaHRFZGdlUG9pbnRzKF9lZGdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLmZpbmRCZXppZXJQb2ludHMoX2VkZ2UsIHBhc3NlZFBhaXJJbmZvLCBfaTIsIF9lZGdlSXNVbmJ1bmRsZWQsIGVkZ2VJc1N3YXBwZWQpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5maW5kRW5kcG9pbnRzKF9lZGdlKTtcblxuICAgICAgX3RoaXMudHJ5VG9Db3JyZWN0SW52YWxpZFBvaW50cyhfZWRnZSwgcGFzc2VkUGFpckluZm8pO1xuXG4gICAgICBfdGhpcy5jaGVja0ZvckludmFsaWRFZGdlV2FybmluZyhfZWRnZSk7XG5cbiAgICAgIF90aGlzLnN0b3JlQWxscHRzKF9lZGdlKTtcblxuICAgICAgX3RoaXMuc3RvcmVFZGdlUHJvamVjdGlvbnMoX2VkZ2UpO1xuXG4gICAgICBfdGhpcy5jYWxjdWxhdGVBcnJvd0FuZ2xlcyhfZWRnZSk7XG5cbiAgICAgIF90aGlzLnJlY2FsY3VsYXRlRWRnZUxhYmVsUHJvamVjdGlvbnMoX2VkZ2UpO1xuXG4gICAgICBfdGhpcy5jYWxjdWxhdGVMYWJlbEFuZ2xlcyhfZWRnZSk7XG4gICAgfSAvLyBmb3IgcGFpciBlZGdlc1xuXG4gIH07XG5cbiAgZm9yICh2YXIgcCA9IDA7IHAgPCBwYWlySWRzLmxlbmd0aDsgcCsrKSB7XG4gICAgX2xvb3AocCk7XG4gIH0gLy8gZm9yIHBhaXIgaWRzXG4gIC8vIGhheXN0YWNrcyBhdm9pZCB0aGUgZXhwZW5zZSBvZiBwYWlySW5mbyBzdHVmZiAoaW50ZXJzZWN0aW9ucyBldGMuKVxuXG5cbiAgdGhpcy5maW5kSGF5c3RhY2tQb2ludHMoaGF5c3RhY2tFZGdlcyk7XG59O1xuXG5mdW5jdGlvbiBnZXRQdHMocHRzKSB7XG4gIHZhciByZXRQdHMgPSBbXTtcblxuICBpZiAocHRzID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciB4ID0gcHRzW2ldO1xuICAgIHZhciB5ID0gcHRzW2kgKyAxXTtcbiAgICByZXRQdHMucHVzaCh7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJldFB0cztcbn1cblxuQlJwJGMuZ2V0U2VnbWVudFBvaW50cyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBycyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciB0eXBlID0gcnMuZWRnZVR5cGU7XG5cbiAgaWYgKHR5cGUgPT09ICdzZWdtZW50cycpIHtcbiAgICB0aGlzLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZShlZGdlKTtcbiAgICByZXR1cm4gZ2V0UHRzKHJzLnNlZ3B0cyk7XG4gIH1cbn07XG5cbkJScCRjLmdldENvbnRyb2xQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgcnMgPSBlZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgdHlwZSA9IHJzLmVkZ2VUeXBlO1xuXG4gIGlmICh0eXBlID09PSAnYmV6aWVyJyB8fCB0eXBlID09PSAnbXVsdGliZXppZXInIHx8IHR5cGUgPT09ICdzZWxmJyB8fCB0eXBlID09PSAnY29tcG91bmQnKSB7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoZWRnZSk7XG4gICAgcmV0dXJuIGdldFB0cyhycy5jdHJscHRzKTtcbiAgfVxufTtcblxuQlJwJGMuZ2V0RWRnZU1pZHBvaW50ID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIHJzID0gZWRnZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdGhpcy5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoZWRnZSk7XG4gIHJldHVybiB7XG4gICAgeDogcnMubWlkWCxcbiAgICB5OiBycy5taWRZXG4gIH07XG59O1xuXG52YXIgQlJwJGIgPSB7fTtcblxuQlJwJGIubWFudWFsRW5kcHRUb1B4ID0gZnVuY3Rpb24gKG5vZGUsIHByb3ApIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgbnBvcyA9IG5vZGUucG9zaXRpb24oKTtcbiAgdmFyIHcgPSBub2RlLm91dGVyV2lkdGgoKTtcbiAgdmFyIGggPSBub2RlLm91dGVySGVpZ2h0KCk7XG5cbiAgaWYgKHByb3AudmFsdWUubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHAgPSBbcHJvcC5wZlZhbHVlWzBdLCBwcm9wLnBmVmFsdWVbMV1dO1xuXG4gICAgaWYgKHByb3AudW5pdHNbMF0gPT09ICclJykge1xuICAgICAgcFswXSA9IHBbMF0gKiB3O1xuICAgIH1cblxuICAgIGlmIChwcm9wLnVuaXRzWzFdID09PSAnJScpIHtcbiAgICAgIHBbMV0gPSBwWzFdICogaDtcbiAgICB9XG5cbiAgICBwWzBdICs9IG5wb3MueDtcbiAgICBwWzFdICs9IG5wb3MueTtcbiAgICByZXR1cm4gcDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYW5nbGUgPSBwcm9wLnBmVmFsdWVbMF07XG4gICAgYW5nbGUgPSAtTWF0aC5QSSAvIDIgKyBhbmdsZTsgLy8gc3RhcnQgYXQgMTIgbydjbG9ja1xuXG4gICAgdmFyIGwgPSAyICogTWF0aC5tYXgodywgaCk7XG4gICAgdmFyIF9wID0gW25wb3MueCArIE1hdGguY29zKGFuZ2xlKSAqIGwsIG5wb3MueSArIE1hdGguc2luKGFuZ2xlKSAqIGxdO1xuICAgIHJldHVybiByLm5vZGVTaGFwZXNbdGhpcy5nZXROb2RlU2hhcGUobm9kZSldLmludGVyc2VjdExpbmUobnBvcy54LCBucG9zLnksIHcsIGgsIF9wWzBdLCBfcFsxXSwgMCk7XG4gIH1cbn07XG5cbkJScCRiLmZpbmRFbmRwb2ludHMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBpbnRlcnNlY3Q7XG4gIHZhciBzb3VyY2UgPSBlZGdlLnNvdXJjZSgpWzBdO1xuICB2YXIgdGFyZ2V0ID0gZWRnZS50YXJnZXQoKVswXTtcbiAgdmFyIHNyY1BvcyA9IHNvdXJjZS5wb3NpdGlvbigpO1xuICB2YXIgdGd0UG9zID0gdGFyZ2V0LnBvc2l0aW9uKCk7XG4gIHZhciB0Z3RBclNoYXBlID0gZWRnZS5wc3R5bGUoJ3RhcmdldC1hcnJvdy1zaGFwZScpLnZhbHVlO1xuICB2YXIgc3JjQXJTaGFwZSA9IGVkZ2UucHN0eWxlKCdzb3VyY2UtYXJyb3ctc2hhcGUnKS52YWx1ZTtcbiAgdmFyIHRndERpc3QgPSBlZGdlLnBzdHlsZSgndGFyZ2V0LWRpc3RhbmNlLWZyb20tbm9kZScpLnBmVmFsdWU7XG4gIHZhciBzcmNEaXN0ID0gZWRnZS5wc3R5bGUoJ3NvdXJjZS1kaXN0YW5jZS1mcm9tLW5vZGUnKS5wZlZhbHVlO1xuICB2YXIgY3VydmVTdHlsZSA9IGVkZ2UucHN0eWxlKCdjdXJ2ZS1zdHlsZScpLnZhbHVlO1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgZXQgPSBycy5lZGdlVHlwZTtcbiAgdmFyIHRheGkgPSBjdXJ2ZVN0eWxlID09PSAndGF4aSc7XG4gIHZhciBzZWxmID0gZXQgPT09ICdzZWxmJyB8fCBldCA9PT0gJ2NvbXBvdW5kJztcbiAgdmFyIGJlemllciA9IGV0ID09PSAnYmV6aWVyJyB8fCBldCA9PT0gJ211bHRpYmV6aWVyJyB8fCBzZWxmO1xuICB2YXIgbXVsdGkgPSBldCAhPT0gJ2Jlemllcic7XG4gIHZhciBsaW5lcyA9IGV0ID09PSAnc3RyYWlnaHQnIHx8IGV0ID09PSAnc2VnbWVudHMnO1xuICB2YXIgc2VnbWVudHMgPSBldCA9PT0gJ3NlZ21lbnRzJztcbiAgdmFyIGhhc0VuZHB0cyA9IGJlemllciB8fCBtdWx0aSB8fCBsaW5lcztcbiAgdmFyIG92ZXJyaWRlRW5kcHRzID0gc2VsZiB8fCB0YXhpO1xuICB2YXIgc3JjTWFuRW5kcHQgPSBlZGdlLnBzdHlsZSgnc291cmNlLWVuZHBvaW50Jyk7XG4gIHZhciBzcmNNYW5FbmRwdFZhbCA9IG92ZXJyaWRlRW5kcHRzID8gJ291dHNpZGUtdG8tbm9kZScgOiBzcmNNYW5FbmRwdC52YWx1ZTtcbiAgdmFyIHRndE1hbkVuZHB0ID0gZWRnZS5wc3R5bGUoJ3RhcmdldC1lbmRwb2ludCcpO1xuICB2YXIgdGd0TWFuRW5kcHRWYWwgPSBvdmVycmlkZUVuZHB0cyA/ICdvdXRzaWRlLXRvLW5vZGUnIDogdGd0TWFuRW5kcHQudmFsdWU7XG4gIHJzLnNyY01hbkVuZHB0ID0gc3JjTWFuRW5kcHQ7XG4gIHJzLnRndE1hbkVuZHB0ID0gdGd0TWFuRW5kcHQ7XG4gIHZhciBwMTsgLy8gbGFzdCBrbm93biBwb2ludCBvZiBlZGdlIG9uIHRhcmdldCBzaWRlXG5cbiAgdmFyIHAyOyAvLyBsYXN0IGtub3duIHBvaW50IG9mIGVkZ2Ugb24gc291cmNlIHNpZGVcblxuICB2YXIgcDFfaTsgLy8gcG9pbnQgdG8gaW50ZXJzZWN0IHdpdGggdGFyZ2V0IHNoYXBlXG5cbiAgdmFyIHAyX2k7IC8vIHBvaW50IHRvIGludGVyc2VjdCB3aXRoIHNvdXJjZSBzaGFwZVxuXG4gIGlmIChiZXppZXIpIHtcbiAgICB2YXIgY3BTdGFydCA9IFtycy5jdHJscHRzWzBdLCBycy5jdHJscHRzWzFdXTtcbiAgICB2YXIgY3BFbmQgPSBtdWx0aSA/IFtycy5jdHJscHRzW3JzLmN0cmxwdHMubGVuZ3RoIC0gMl0sIHJzLmN0cmxwdHNbcnMuY3RybHB0cy5sZW5ndGggLSAxXV0gOiBjcFN0YXJ0O1xuICAgIHAxID0gY3BFbmQ7XG4gICAgcDIgPSBjcFN0YXJ0O1xuICB9IGVsc2UgaWYgKGxpbmVzKSB7XG4gICAgdmFyIHNyY0Fycm93RnJvbVB0ID0gIXNlZ21lbnRzID8gW3RndFBvcy54LCB0Z3RQb3MueV0gOiBycy5zZWdwdHMuc2xpY2UoMCwgMik7XG4gICAgdmFyIHRndEFycm93RnJvbVB0ID0gIXNlZ21lbnRzID8gW3NyY1Bvcy54LCBzcmNQb3MueV0gOiBycy5zZWdwdHMuc2xpY2UocnMuc2VncHRzLmxlbmd0aCAtIDIpO1xuICAgIHAxID0gdGd0QXJyb3dGcm9tUHQ7XG4gICAgcDIgPSBzcmNBcnJvd0Zyb21QdDtcbiAgfVxuXG4gIGlmICh0Z3RNYW5FbmRwdFZhbCA9PT0gJ2luc2lkZS10by1ub2RlJykge1xuICAgIGludGVyc2VjdCA9IFt0Z3RQb3MueCwgdGd0UG9zLnldO1xuICB9IGVsc2UgaWYgKHRndE1hbkVuZHB0LnVuaXRzKSB7XG4gICAgaW50ZXJzZWN0ID0gdGhpcy5tYW51YWxFbmRwdFRvUHgodGFyZ2V0LCB0Z3RNYW5FbmRwdCk7XG4gIH0gZWxzZSBpZiAodGd0TWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUnKSB7XG4gICAgaW50ZXJzZWN0ID0gcnMudGd0SW50bjsgLy8gdXNlIGNhY2hlZCB2YWx1ZSBmcm9tIGN0cmxwdCBjYWxjXG4gIH0gZWxzZSB7XG4gICAgaWYgKHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1ub2RlJyB8fCB0Z3RNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbm9kZS1vci1sYWJlbCcpIHtcbiAgICAgIHAxX2kgPSBwMTtcbiAgICB9IGVsc2UgaWYgKHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lJyB8fCB0Z3RNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZS1vci1sYWJlbCcpIHtcbiAgICAgIHAxX2kgPSBbc3JjUG9zLngsIHNyY1Bvcy55XTtcbiAgICB9XG5cbiAgICBpbnRlcnNlY3QgPSByLm5vZGVTaGFwZXNbdGhpcy5nZXROb2RlU2hhcGUodGFyZ2V0KV0uaW50ZXJzZWN0TGluZSh0Z3RQb3MueCwgdGd0UG9zLnksIHRhcmdldC5vdXRlcldpZHRoKCksIHRhcmdldC5vdXRlckhlaWdodCgpLCBwMV9pWzBdLCBwMV9pWzFdLCAwKTtcblxuICAgIGlmICh0Z3RNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbm9kZS1vci1sYWJlbCcgfHwgdGd0TWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUtb3ItbGFiZWwnKSB7XG4gICAgICB2YXIgdHJzID0gdGFyZ2V0Ll9wcml2YXRlLnJzY3JhdGNoO1xuICAgICAgdmFyIGx3ID0gdHJzLmxhYmVsV2lkdGg7XG4gICAgICB2YXIgbGggPSB0cnMubGFiZWxIZWlnaHQ7XG4gICAgICB2YXIgbHggPSB0cnMubGFiZWxYO1xuICAgICAgdmFyIGx5ID0gdHJzLmxhYmVsWTtcbiAgICAgIHZhciBsdzIgPSBsdyAvIDI7XG4gICAgICB2YXIgbGgyID0gbGggLyAyO1xuICAgICAgdmFyIHZhID0gdGFyZ2V0LnBzdHlsZSgndGV4dC12YWxpZ24nKS52YWx1ZTtcblxuICAgICAgaWYgKHZhID09PSAndG9wJykge1xuICAgICAgICBseSAtPSBsaDI7XG4gICAgICB9IGVsc2UgaWYgKHZhID09PSAnYm90dG9tJykge1xuICAgICAgICBseSArPSBsaDI7XG4gICAgICB9XG5cbiAgICAgIHZhciBoYSA9IHRhcmdldC5wc3R5bGUoJ3RleHQtaGFsaWduJykudmFsdWU7XG5cbiAgICAgIGlmIChoYSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIGx4IC09IGx3MjtcbiAgICAgIH0gZWxzZSBpZiAoaGEgPT09ICdyaWdodCcpIHtcbiAgICAgICAgbHggKz0gbHcyO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGFiZWxJbnRlcnNlY3QgPSBwb2x5Z29uSW50ZXJzZWN0TGluZShwMV9pWzBdLCBwMV9pWzFdLCBbbHggLSBsdzIsIGx5IC0gbGgyLCBseCArIGx3MiwgbHkgLSBsaDIsIGx4ICsgbHcyLCBseSArIGxoMiwgbHggLSBsdzIsIGx5ICsgbGgyXSwgdGd0UG9zLngsIHRndFBvcy55KTtcblxuICAgICAgaWYgKGxhYmVsSW50ZXJzZWN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHJlZlB0ID0gc3JjUG9zO1xuICAgICAgICB2YXIgaW50U3FkaXN0ID0gc3FkaXN0KHJlZlB0LCBhcnJheTJwb2ludChpbnRlcnNlY3QpKTtcbiAgICAgICAgdmFyIGxhYkludFNxZGlzdCA9IHNxZGlzdChyZWZQdCwgYXJyYXkycG9pbnQobGFiZWxJbnRlcnNlY3QpKTtcbiAgICAgICAgdmFyIG1pblNxRGlzdCA9IGludFNxZGlzdDtcblxuICAgICAgICBpZiAobGFiSW50U3FkaXN0IDwgaW50U3FkaXN0KSB7XG4gICAgICAgICAgaW50ZXJzZWN0ID0gbGFiZWxJbnRlcnNlY3Q7XG4gICAgICAgICAgbWluU3FEaXN0ID0gbGFiSW50U3FkaXN0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhYmVsSW50ZXJzZWN0Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICB2YXIgbGFiSW50MlNxRGlzdCA9IHNxZGlzdChyZWZQdCwge1xuICAgICAgICAgICAgeDogbGFiZWxJbnRlcnNlY3RbMl0sXG4gICAgICAgICAgICB5OiBsYWJlbEludGVyc2VjdFszXVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGxhYkludDJTcURpc3QgPCBtaW5TcURpc3QpIHtcbiAgICAgICAgICAgIGludGVyc2VjdCA9IFtsYWJlbEludGVyc2VjdFsyXSwgbGFiZWxJbnRlcnNlY3RbM11dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBhcnJvd0VuZCA9IHNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBwMSwgci5hcnJvd1NoYXBlc1t0Z3RBclNoYXBlXS5zcGFjaW5nKGVkZ2UpICsgdGd0RGlzdCk7XG4gIHZhciBlZGdlRW5kID0gc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsIHAxLCByLmFycm93U2hhcGVzW3RndEFyU2hhcGVdLmdhcChlZGdlKSArIHRndERpc3QpO1xuICBycy5lbmRYID0gZWRnZUVuZFswXTtcbiAgcnMuZW5kWSA9IGVkZ2VFbmRbMV07XG4gIHJzLmFycm93RW5kWCA9IGFycm93RW5kWzBdO1xuICBycy5hcnJvd0VuZFkgPSBhcnJvd0VuZFsxXTtcblxuICBpZiAoc3JjTWFuRW5kcHRWYWwgPT09ICdpbnNpZGUtdG8tbm9kZScpIHtcbiAgICBpbnRlcnNlY3QgPSBbc3JjUG9zLngsIHNyY1Bvcy55XTtcbiAgfSBlbHNlIGlmIChzcmNNYW5FbmRwdC51bml0cykge1xuICAgIGludGVyc2VjdCA9IHRoaXMubWFudWFsRW5kcHRUb1B4KHNvdXJjZSwgc3JjTWFuRW5kcHQpO1xuICB9IGVsc2UgaWYgKHNyY01hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lJykge1xuICAgIGludGVyc2VjdCA9IHJzLnNyY0ludG47IC8vIHVzZSBjYWNoZWQgdmFsdWUgZnJvbSBjdHJscHQgY2FsY1xuICB9IGVsc2Uge1xuICAgIGlmIChzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbm9kZScgfHwgc3JjTWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLW5vZGUtb3ItbGFiZWwnKSB7XG4gICAgICBwMl9pID0gcDI7XG4gICAgfSBlbHNlIGlmIChzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZScgfHwgc3JjTWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUtb3ItbGFiZWwnKSB7XG4gICAgICBwMl9pID0gW3RndFBvcy54LCB0Z3RQb3MueV07XG4gICAgfVxuXG4gICAgaW50ZXJzZWN0ID0gci5ub2RlU2hhcGVzW3RoaXMuZ2V0Tm9kZVNoYXBlKHNvdXJjZSldLmludGVyc2VjdExpbmUoc3JjUG9zLngsIHNyY1Bvcy55LCBzb3VyY2Uub3V0ZXJXaWR0aCgpLCBzb3VyY2Uub3V0ZXJIZWlnaHQoKSwgcDJfaVswXSwgcDJfaVsxXSwgMCk7XG5cbiAgICBpZiAoc3JjTWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLW5vZGUtb3ItbGFiZWwnIHx8IHNyY01hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lLW9yLWxhYmVsJykge1xuICAgICAgdmFyIHNycyA9IHNvdXJjZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICAgIHZhciBfbHcgPSBzcnMubGFiZWxXaWR0aDtcbiAgICAgIHZhciBfbGggPSBzcnMubGFiZWxIZWlnaHQ7XG4gICAgICB2YXIgX2x4ID0gc3JzLmxhYmVsWDtcbiAgICAgIHZhciBfbHkgPSBzcnMubGFiZWxZO1xuXG4gICAgICB2YXIgX2x3MiA9IF9sdyAvIDI7XG5cbiAgICAgIHZhciBfbGgyID0gX2xoIC8gMjtcblxuICAgICAgdmFyIF92YSA9IHNvdXJjZS5wc3R5bGUoJ3RleHQtdmFsaWduJykudmFsdWU7XG5cbiAgICAgIGlmIChfdmEgPT09ICd0b3AnKSB7XG4gICAgICAgIF9seSAtPSBfbGgyO1xuICAgICAgfSBlbHNlIGlmIChfdmEgPT09ICdib3R0b20nKSB7XG4gICAgICAgIF9seSArPSBfbGgyO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2hhID0gc291cmNlLnBzdHlsZSgndGV4dC1oYWxpZ24nKS52YWx1ZTtcblxuICAgICAgaWYgKF9oYSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIF9seCAtPSBfbHcyO1xuICAgICAgfSBlbHNlIGlmIChfaGEgPT09ICdyaWdodCcpIHtcbiAgICAgICAgX2x4ICs9IF9sdzI7XG4gICAgICB9XG5cbiAgICAgIHZhciBfbGFiZWxJbnRlcnNlY3QgPSBwb2x5Z29uSW50ZXJzZWN0TGluZShwMl9pWzBdLCBwMl9pWzFdLCBbX2x4IC0gX2x3MiwgX2x5IC0gX2xoMiwgX2x4ICsgX2x3MiwgX2x5IC0gX2xoMiwgX2x4ICsgX2x3MiwgX2x5ICsgX2xoMiwgX2x4IC0gX2x3MiwgX2x5ICsgX2xoMl0sIHNyY1Bvcy54LCBzcmNQb3MueSk7XG5cbiAgICAgIGlmIChfbGFiZWxJbnRlcnNlY3QubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgX3JlZlB0ID0gdGd0UG9zO1xuXG4gICAgICAgIHZhciBfaW50U3FkaXN0ID0gc3FkaXN0KF9yZWZQdCwgYXJyYXkycG9pbnQoaW50ZXJzZWN0KSk7XG5cbiAgICAgICAgdmFyIF9sYWJJbnRTcWRpc3QgPSBzcWRpc3QoX3JlZlB0LCBhcnJheTJwb2ludChfbGFiZWxJbnRlcnNlY3QpKTtcblxuICAgICAgICB2YXIgX21pblNxRGlzdCA9IF9pbnRTcWRpc3Q7XG5cbiAgICAgICAgaWYgKF9sYWJJbnRTcWRpc3QgPCBfaW50U3FkaXN0KSB7XG4gICAgICAgICAgaW50ZXJzZWN0ID0gW19sYWJlbEludGVyc2VjdFswXSwgX2xhYmVsSW50ZXJzZWN0WzFdXTtcbiAgICAgICAgICBfbWluU3FEaXN0ID0gX2xhYkludFNxZGlzdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfbGFiZWxJbnRlcnNlY3QubGVuZ3RoID4gMikge1xuICAgICAgICAgIHZhciBfbGFiSW50MlNxRGlzdCA9IHNxZGlzdChfcmVmUHQsIHtcbiAgICAgICAgICAgIHg6IF9sYWJlbEludGVyc2VjdFsyXSxcbiAgICAgICAgICAgIHk6IF9sYWJlbEludGVyc2VjdFszXVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKF9sYWJJbnQyU3FEaXN0IDwgX21pblNxRGlzdCkge1xuICAgICAgICAgICAgaW50ZXJzZWN0ID0gW19sYWJlbEludGVyc2VjdFsyXSwgX2xhYmVsSW50ZXJzZWN0WzNdXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgYXJyb3dTdGFydCA9IHNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBwMiwgci5hcnJvd1NoYXBlc1tzcmNBclNoYXBlXS5zcGFjaW5nKGVkZ2UpICsgc3JjRGlzdCk7XG4gIHZhciBlZGdlU3RhcnQgPSBzaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgcDIsIHIuYXJyb3dTaGFwZXNbc3JjQXJTaGFwZV0uZ2FwKGVkZ2UpICsgc3JjRGlzdCk7XG4gIHJzLnN0YXJ0WCA9IGVkZ2VTdGFydFswXTtcbiAgcnMuc3RhcnRZID0gZWRnZVN0YXJ0WzFdO1xuICBycy5hcnJvd1N0YXJ0WCA9IGFycm93U3RhcnRbMF07XG4gIHJzLmFycm93U3RhcnRZID0gYXJyb3dTdGFydFsxXTtcblxuICBpZiAoaGFzRW5kcHRzKSB7XG4gICAgaWYgKCFudW1iZXIkMShycy5zdGFydFgpIHx8ICFudW1iZXIkMShycy5zdGFydFkpIHx8ICFudW1iZXIkMShycy5lbmRYKSB8fCAhbnVtYmVyJDEocnMuZW5kWSkpIHtcbiAgICAgIHJzLmJhZExpbmUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBycy5iYWRMaW5lID0gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuXG5CUnAkYi5nZXRTb3VyY2VFbmRwb2ludCA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBycyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHRoaXMucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKGVkZ2UpO1xuXG4gIHN3aXRjaCAocnMuZWRnZVR5cGUpIHtcbiAgICBjYXNlICdoYXlzdGFjayc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBycy5oYXlzdGFja1B0c1swXSxcbiAgICAgICAgeTogcnMuaGF5c3RhY2tQdHNbMV1cbiAgICAgIH07XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcnMuYXJyb3dTdGFydFgsXG4gICAgICAgIHk6IHJzLmFycm93U3RhcnRZXG4gICAgICB9O1xuICB9XG59O1xuXG5CUnAkYi5nZXRUYXJnZXRFbmRwb2ludCA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBycyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHRoaXMucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKGVkZ2UpO1xuXG4gIHN3aXRjaCAocnMuZWRnZVR5cGUpIHtcbiAgICBjYXNlICdoYXlzdGFjayc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBycy5oYXlzdGFja1B0c1syXSxcbiAgICAgICAgeTogcnMuaGF5c3RhY2tQdHNbM11cbiAgICAgIH07XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcnMuYXJyb3dFbmRYLFxuICAgICAgICB5OiBycy5hcnJvd0VuZFlcbiAgICAgIH07XG4gIH1cbn07XG5cbnZhciBCUnAkYSA9IHt9O1xuXG5mdW5jdGlvbiBwdXNoQmV6aWVyUHRzKHIsIGVkZ2UsIHB0cykge1xuICB2YXIgcWJlemllckF0JDEgPSBmdW5jdGlvbiBxYmV6aWVyQXQkMShwMSwgcDIsIHAzLCB0KSB7XG4gICAgcmV0dXJuIHFiZXppZXJBdChwMSwgcDIsIHAzLCB0KTtcbiAgfTtcblxuICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICB2YXIgYnB0cyA9IF9wLnJzdHlsZS5iZXppZXJQdHM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByLmJlemllclByb2pQY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSByLmJlemllclByb2pQY3RzW2ldO1xuICAgIGJwdHMucHVzaCh7XG4gICAgICB4OiBxYmV6aWVyQXQkMShwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCBwKSxcbiAgICAgIHk6IHFiZXppZXJBdCQxKHB0c1sxXSwgcHRzWzNdLCBwdHNbNV0sIHApXG4gICAgfSk7XG4gIH1cbn1cblxuQlJwJGEuc3RvcmVFZGdlUHJvamVjdGlvbnMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgdmFyIGV0ID0gcnMuZWRnZVR5cGU7IC8vIGNsZWFyIHRoZSBjYWNoZWQgcG9pbnRzIHN0YXRlXG5cbiAgX3AucnN0eWxlLmJlemllclB0cyA9IG51bGw7XG4gIF9wLnJzdHlsZS5saW5lUHRzID0gbnVsbDtcbiAgX3AucnN0eWxlLmhheXN0YWNrUHRzID0gbnVsbDtcblxuICBpZiAoZXQgPT09ICdtdWx0aWJlemllcicgfHwgZXQgPT09ICdiZXppZXInIHx8IGV0ID09PSAnc2VsZicgfHwgZXQgPT09ICdjb21wb3VuZCcpIHtcbiAgICBfcC5yc3R5bGUuYmV6aWVyUHRzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSArIDUgPCBycy5hbGxwdHMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIHB1c2hCZXppZXJQdHModGhpcywgZWRnZSwgcnMuYWxscHRzLnNsaWNlKGksIGkgKyA2KSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV0ID09PSAnc2VnbWVudHMnKSB7XG4gICAgdmFyIGxwdHMgPSBfcC5yc3R5bGUubGluZVB0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgKyAxIDwgcnMuYWxscHRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBscHRzLnB1c2goe1xuICAgICAgICB4OiBycy5hbGxwdHNbaV0sXG4gICAgICAgIHk6IHJzLmFsbHB0c1tpICsgMV1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChldCA9PT0gJ2hheXN0YWNrJykge1xuICAgIHZhciBocHRzID0gcnMuaGF5c3RhY2tQdHM7XG4gICAgX3AucnN0eWxlLmhheXN0YWNrUHRzID0gW3tcbiAgICAgIHg6IGhwdHNbMF0sXG4gICAgICB5OiBocHRzWzFdXG4gICAgfSwge1xuICAgICAgeDogaHB0c1syXSxcbiAgICAgIHk6IGhwdHNbM11cbiAgICB9XTtcbiAgfVxuXG4gIF9wLnJzdHlsZS5hcnJvd1dpZHRoID0gdGhpcy5nZXRBcnJvd1dpZHRoKGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUsIGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlKSAqIHRoaXMuYXJyb3dTaGFwZVdpZHRoO1xufTtcblxuQlJwJGEucmVjYWxjdWxhdGVFZGdlUHJvamVjdGlvbnMgPSBmdW5jdGlvbiAoZWRnZXMpIHtcbiAgdGhpcy5maW5kRWRnZUNvbnRyb2xQb2ludHMoZWRnZXMpO1xufTtcblxuLyogZ2xvYmFsIGRvY3VtZW50ICovXG5cbnZhciBCUnAkOSA9IHt9O1xuXG5CUnAkOS5yZWNhbGN1bGF0ZU5vZGVMYWJlbFByb2plY3Rpb24gPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgY29udGVudCA9IG5vZGUucHN0eWxlKCdsYWJlbCcpLnN0clZhbHVlO1xuXG4gIGlmIChlbXB0eVN0cmluZyhjb250ZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0ZXh0WCwgdGV4dFk7XG4gIHZhciBfcCA9IG5vZGUuX3ByaXZhdGU7XG4gIHZhciBub2RlV2lkdGggPSBub2RlLndpZHRoKCk7XG4gIHZhciBub2RlSGVpZ2h0ID0gbm9kZS5oZWlnaHQoKTtcbiAgdmFyIHBhZGRpbmcgPSBub2RlLnBhZGRpbmcoKTtcbiAgdmFyIG5vZGVQb3MgPSBub2RlLnBvc2l0aW9uKCk7XG4gIHZhciB0ZXh0SGFsaWduID0gbm9kZS5wc3R5bGUoJ3RleHQtaGFsaWduJykuc3RyVmFsdWU7XG4gIHZhciB0ZXh0VmFsaWduID0gbm9kZS5wc3R5bGUoJ3RleHQtdmFsaWduJykuc3RyVmFsdWU7XG4gIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuXG4gIHN3aXRjaCAodGV4dEhhbGlnbikge1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgdGV4dFggPSBub2RlUG9zLnggLSBub2RlV2lkdGggLyAyIC0gcGFkZGluZztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgdGV4dFggPSBub2RlUG9zLnggKyBub2RlV2lkdGggLyAyICsgcGFkZGluZztcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGUuZy4gY2VudGVyXG4gICAgICB0ZXh0WCA9IG5vZGVQb3MueDtcbiAgfVxuXG4gIHN3aXRjaCAodGV4dFZhbGlnbikge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgICB0ZXh0WSA9IG5vZGVQb3MueSAtIG5vZGVIZWlnaHQgLyAyIC0gcGFkZGluZztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIHRleHRZID0gbm9kZVBvcy55ICsgbm9kZUhlaWdodCAvIDIgKyBwYWRkaW5nO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZS5nLiBtaWRkbGVcbiAgICAgIHRleHRZID0gbm9kZVBvcy55O1xuICB9XG5cbiAgcnMubGFiZWxYID0gdGV4dFg7XG4gIHJzLmxhYmVsWSA9IHRleHRZO1xuICByc3R5bGUubGFiZWxYID0gdGV4dFg7XG4gIHJzdHlsZS5sYWJlbFkgPSB0ZXh0WTtcbiAgdGhpcy5jYWxjdWxhdGVMYWJlbEFuZ2xlcyhub2RlKTtcbiAgdGhpcy5hcHBseUxhYmVsRGltZW5zaW9ucyhub2RlKTtcbn07XG5cbnZhciBsaW5lQW5nbGVGcm9tRGVsdGEgPSBmdW5jdGlvbiBsaW5lQW5nbGVGcm9tRGVsdGEoZHgsIGR5KSB7XG4gIHZhciBhbmdsZSA9IE1hdGguYXRhbihkeSAvIGR4KTtcblxuICBpZiAoZHggPT09IDAgJiYgYW5nbGUgPCAwKSB7XG4gICAgYW5nbGUgPSBhbmdsZSAqIC0xO1xuICB9XG5cbiAgcmV0dXJuIGFuZ2xlO1xufTtcblxudmFyIGxpbmVBbmdsZSA9IGZ1bmN0aW9uIGxpbmVBbmdsZShwMCwgcDEpIHtcbiAgdmFyIGR4ID0gcDEueCAtIHAwLng7XG4gIHZhciBkeSA9IHAxLnkgLSBwMC55O1xuICByZXR1cm4gbGluZUFuZ2xlRnJvbURlbHRhKGR4LCBkeSk7XG59O1xuXG52YXIgYmV6aWVyQW5nbGUgPSBmdW5jdGlvbiBiZXppZXJBbmdsZShwMCwgcDEsIHAyLCB0KSB7XG4gIHZhciB0MCA9IGJvdW5kKDAsIHQgLSAwLjAwMSwgMSk7XG4gIHZhciB0MSA9IGJvdW5kKDAsIHQgKyAwLjAwMSwgMSk7XG4gIHZhciBscDAgPSBxYmV6aWVyUHRBdChwMCwgcDEsIHAyLCB0MCk7XG4gIHZhciBscDEgPSBxYmV6aWVyUHRBdChwMCwgcDEsIHAyLCB0MSk7XG4gIHJldHVybiBsaW5lQW5nbGUobHAwLCBscDEpO1xufTtcblxuQlJwJDkucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9ucyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBwO1xuICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgY29udGVudCA9IHtcbiAgICBtaWQ6IGVkZ2UucHN0eWxlKCdsYWJlbCcpLnN0clZhbHVlLFxuICAgIHNvdXJjZTogZWRnZS5wc3R5bGUoJ3NvdXJjZS1sYWJlbCcpLnN0clZhbHVlLFxuICAgIHRhcmdldDogZWRnZS5wc3R5bGUoJ3RhcmdldC1sYWJlbCcpLnN0clZhbHVlXG4gIH07XG5cbiAgaWYgKGNvbnRlbnQubWlkIHx8IGNvbnRlbnQuc291cmNlIHx8IGNvbnRlbnQudGFyZ2V0KSA7IGVsc2Uge1xuICAgIHJldHVybjsgLy8gbm8gbGFiZWxzID0+IG5vIGNhbGNzXG4gIH0gLy8gYWRkIGNlbnRlciBwb2ludCB0byBzdHlsZSBzbyBib3VuZGluZyBib3ggY2FsY3VsYXRpb25zIGNhbiB1c2UgaXRcbiAgLy9cblxuXG4gIHAgPSB7XG4gICAgeDogcnMubWlkWCxcbiAgICB5OiBycy5taWRZXG4gIH07XG5cbiAgdmFyIHNldFJzID0gZnVuY3Rpb24gc2V0UnMocHJvcE5hbWUsIHByZWZpeCwgdmFsdWUpIHtcbiAgICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCBwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSk7XG4gICAgc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc3R5bGUsIHByb3BOYW1lLCBwcmVmaXgsIHZhbHVlKTtcbiAgfTtcblxuICBzZXRScygnbGFiZWxYJywgbnVsbCwgcC54KTtcbiAgc2V0UnMoJ2xhYmVsWScsIG51bGwsIHAueSk7XG4gIHZhciBtaWRBbmdsZSA9IGxpbmVBbmdsZUZyb21EZWx0YShycy5taWREaXNwWCwgcnMubWlkRGlzcFkpO1xuICBzZXRScygnbGFiZWxBdXRvQW5nbGUnLCBudWxsLCBtaWRBbmdsZSk7XG5cbiAgdmFyIGNyZWF0ZUNvbnRyb2xQb2ludEluZm8gPSBmdW5jdGlvbiBjcmVhdGVDb250cm9sUG9pbnRJbmZvKCkge1xuICAgIGlmIChjcmVhdGVDb250cm9sUG9pbnRJbmZvLmNhY2hlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQ29udHJvbFBvaW50SW5mby5jYWNoZTtcbiAgICB9IC8vIHVzZSBjYWNoZSBzbyBvbmx5IDF4IHBlciBlZGdlXG5cblxuICAgIHZhciBjdHJscHRzID0gW107IC8vIHN0b3JlIGVhY2ggY3RybHB0IGluZm8gaW5pdFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgKyA1IDwgcnMuYWxscHRzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICB2YXIgcDAgPSB7XG4gICAgICAgIHg6IHJzLmFsbHB0c1tpXSxcbiAgICAgICAgeTogcnMuYWxscHRzW2kgKyAxXVxuICAgICAgfTtcbiAgICAgIHZhciBwMSA9IHtcbiAgICAgICAgeDogcnMuYWxscHRzW2kgKyAyXSxcbiAgICAgICAgeTogcnMuYWxscHRzW2kgKyAzXVxuICAgICAgfTsgLy8gY3RybHB0XG5cbiAgICAgIHZhciBwMiA9IHtcbiAgICAgICAgeDogcnMuYWxscHRzW2kgKyA0XSxcbiAgICAgICAgeTogcnMuYWxscHRzW2kgKyA1XVxuICAgICAgfTtcbiAgICAgIGN0cmxwdHMucHVzaCh7XG4gICAgICAgIHAwOiBwMCxcbiAgICAgICAgcDE6IHAxLFxuICAgICAgICBwMjogcDIsXG4gICAgICAgIHN0YXJ0RGlzdDogMCxcbiAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgICBzZWdtZW50czogW11cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBicHRzID0gX3AucnN0eWxlLmJlemllclB0cztcbiAgICB2YXIgblByb2pzID0gci5iZXppZXJQcm9qUGN0cy5sZW5ndGg7XG5cbiAgICBmdW5jdGlvbiBhZGRTZWdtZW50KGNwLCBwMCwgcDEsIHQwLCB0MSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGRpc3QocDAsIHAxKTtcbiAgICAgIHZhciBwcmV2U2VnbWVudCA9IGNwLnNlZ21lbnRzW2NwLnNlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIHNlZ21lbnQgPSB7XG4gICAgICAgIHAwOiBwMCxcbiAgICAgICAgcDE6IHAxLFxuICAgICAgICB0MDogdDAsXG4gICAgICAgIHQxOiB0MSxcbiAgICAgICAgc3RhcnREaXN0OiBwcmV2U2VnbWVudCA/IHByZXZTZWdtZW50LnN0YXJ0RGlzdCArIHByZXZTZWdtZW50Lmxlbmd0aCA6IDAsXG4gICAgICAgIGxlbmd0aDogbGVuZ3RoXG4gICAgICB9O1xuICAgICAgY3Auc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICAgIGNwLmxlbmd0aCArPSBsZW5ndGg7XG4gICAgfSAvLyB1cGRhdGUgZWFjaCBjdHJscHQgd2l0aCBzZWdtZW50IGluZm9cblxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGN0cmxwdHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgY3AgPSBjdHJscHRzW19pXTtcbiAgICAgIHZhciBwcmV2Q3AgPSBjdHJscHRzW19pIC0gMV07XG5cbiAgICAgIGlmIChwcmV2Q3ApIHtcbiAgICAgICAgY3Auc3RhcnREaXN0ID0gcHJldkNwLnN0YXJ0RGlzdCArIHByZXZDcC5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGFkZFNlZ21lbnQoY3AsIGNwLnAwLCBicHRzW19pICogblByb2pzXSwgMCwgci5iZXppZXJQcm9qUGN0c1swXSk7IC8vIGZpcnN0XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgblByb2pzIC0gMTsgaisrKSB7XG4gICAgICAgIGFkZFNlZ21lbnQoY3AsIGJwdHNbX2kgKiBuUHJvanMgKyBqXSwgYnB0c1tfaSAqIG5Qcm9qcyArIGogKyAxXSwgci5iZXppZXJQcm9qUGN0c1tqXSwgci5iZXppZXJQcm9qUGN0c1tqICsgMV0pO1xuICAgICAgfVxuXG4gICAgICBhZGRTZWdtZW50KGNwLCBicHRzW19pICogblByb2pzICsgblByb2pzIC0gMV0sIGNwLnAyLCByLmJlemllclByb2pQY3RzW25Qcm9qcyAtIDFdLCAxKTsgLy8gbGFzdFxuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDb250cm9sUG9pbnRJbmZvLmNhY2hlID0gY3RybHB0cztcbiAgfTtcblxuICB2YXIgY2FsY3VsYXRlRW5kUHJvamVjdGlvbiA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUVuZFByb2plY3Rpb24ocHJlZml4KSB7XG4gICAgdmFyIGFuZ2xlO1xuICAgIHZhciBpc1NyYyA9IHByZWZpeCA9PT0gJ3NvdXJjZSc7XG5cbiAgICBpZiAoIWNvbnRlbnRbcHJlZml4XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvZmZzZXQgPSBlZGdlLnBzdHlsZShwcmVmaXggKyAnLXRleHQtb2Zmc2V0JykucGZWYWx1ZTtcblxuICAgIHN3aXRjaCAocnMuZWRnZVR5cGUpIHtcbiAgICAgIGNhc2UgJ3NlbGYnOlxuICAgICAgY2FzZSAnY29tcG91bmQnOlxuICAgICAgY2FzZSAnYmV6aWVyJzpcbiAgICAgIGNhc2UgJ211bHRpYmV6aWVyJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBjcHMgPSBjcmVhdGVDb250cm9sUG9pbnRJbmZvKCk7XG4gICAgICAgICAgdmFyIHNlbGVjdGVkO1xuICAgICAgICAgIHZhciBzdGFydERpc3QgPSAwO1xuICAgICAgICAgIHZhciB0b3RhbERpc3QgPSAwOyAvLyBmaW5kIHRoZSBzZWdtZW50IHdlJ3JlIG9uXG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIF9jcCA9IGNwc1tpc1NyYyA/IGkgOiBjcHMubGVuZ3RoIC0gMSAtIGldO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IF9jcC5zZWdtZW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICB2YXIgX3NlZyA9IF9jcC5zZWdtZW50c1tpc1NyYyA/IGogOiBfY3Auc2VnbWVudHMubGVuZ3RoIC0gMSAtIGpdO1xuICAgICAgICAgICAgICB2YXIgbGFzdFNlZyA9IGkgPT09IGNwcy5sZW5ndGggLSAxICYmIGogPT09IF9jcC5zZWdtZW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICBzdGFydERpc3QgPSB0b3RhbERpc3Q7XG4gICAgICAgICAgICAgIHRvdGFsRGlzdCArPSBfc2VnLmxlbmd0aDtcblxuICAgICAgICAgICAgICBpZiAodG90YWxEaXN0ID49IG9mZnNldCB8fCBsYXN0U2VnKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSB7XG4gICAgICAgICAgICAgICAgICBjcDogX2NwLFxuICAgICAgICAgICAgICAgICAgc2VnbWVudDogX3NlZ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjcCA9IHNlbGVjdGVkLmNwO1xuICAgICAgICAgIHZhciBzZWcgPSBzZWxlY3RlZC5zZWdtZW50O1xuICAgICAgICAgIHZhciB0U2VnbWVudCA9IChvZmZzZXQgLSBzdGFydERpc3QpIC8gc2VnLmxlbmd0aDtcbiAgICAgICAgICB2YXIgc2VnRHQgPSBzZWcudDEgLSBzZWcudDA7XG4gICAgICAgICAgdmFyIHQgPSBpc1NyYyA/IHNlZy50MCArIHNlZ0R0ICogdFNlZ21lbnQgOiBzZWcudDEgLSBzZWdEdCAqIHRTZWdtZW50O1xuICAgICAgICAgIHQgPSBib3VuZCgwLCB0LCAxKTtcbiAgICAgICAgICBwID0gcWJlemllclB0QXQoY3AucDAsIGNwLnAxLCBjcC5wMiwgdCk7XG4gICAgICAgICAgYW5nbGUgPSBiZXppZXJBbmdsZShjcC5wMCwgY3AucDEsIGNwLnAyLCB0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdzdHJhaWdodCc6XG4gICAgICBjYXNlICdzZWdtZW50cyc6XG4gICAgICBjYXNlICdoYXlzdGFjayc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZCA9IDAsXG4gICAgICAgICAgICAgIGRpLFxuICAgICAgICAgICAgICBkMDtcbiAgICAgICAgICB2YXIgcDAsIHAxO1xuICAgICAgICAgIHZhciBsID0gcnMuYWxscHRzLmxlbmd0aDtcblxuICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiArIDMgPCBsOyBfaTIgKz0gMikge1xuICAgICAgICAgICAgaWYgKGlzU3JjKSB7XG4gICAgICAgICAgICAgIHAwID0ge1xuICAgICAgICAgICAgICAgIHg6IHJzLmFsbHB0c1tfaTJdLFxuICAgICAgICAgICAgICAgIHk6IHJzLmFsbHB0c1tfaTIgKyAxXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBwMSA9IHtcbiAgICAgICAgICAgICAgICB4OiBycy5hbGxwdHNbX2kyICsgMl0sXG4gICAgICAgICAgICAgICAgeTogcnMuYWxscHRzW19pMiArIDNdXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwMCA9IHtcbiAgICAgICAgICAgICAgICB4OiBycy5hbGxwdHNbbCAtIDIgLSBfaTJdLFxuICAgICAgICAgICAgICAgIHk6IHJzLmFsbHB0c1tsIC0gMSAtIF9pMl1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcDEgPSB7XG4gICAgICAgICAgICAgICAgeDogcnMuYWxscHRzW2wgLSA0IC0gX2kyXSxcbiAgICAgICAgICAgICAgICB5OiBycy5hbGxwdHNbbCAtIDMgLSBfaTJdXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRpID0gZGlzdChwMCwgcDEpO1xuICAgICAgICAgICAgZDAgPSBkO1xuICAgICAgICAgICAgZCArPSBkaTtcblxuICAgICAgICAgICAgaWYgKGQgPj0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwRCA9IG9mZnNldCAtIGQwO1xuXG4gICAgICAgICAgdmFyIF90ID0gcEQgLyBkaTtcblxuICAgICAgICAgIF90ID0gYm91bmQoMCwgX3QsIDEpO1xuICAgICAgICAgIHAgPSBsaW5lQXQocDAsIHAxLCBfdCk7XG4gICAgICAgICAgYW5nbGUgPSBsaW5lQW5nbGUocDAsIHAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFJzKCdsYWJlbFgnLCBwcmVmaXgsIHAueCk7XG4gICAgc2V0UnMoJ2xhYmVsWScsIHByZWZpeCwgcC55KTtcbiAgICBzZXRScygnbGFiZWxBdXRvQW5nbGUnLCBwcmVmaXgsIGFuZ2xlKTtcbiAgfTtcblxuICBjYWxjdWxhdGVFbmRQcm9qZWN0aW9uKCdzb3VyY2UnKTtcbiAgY2FsY3VsYXRlRW5kUHJvamVjdGlvbigndGFyZ2V0Jyk7XG4gIHRoaXMuYXBwbHlMYWJlbERpbWVuc2lvbnMoZWRnZSk7XG59O1xuXG5CUnAkOS5hcHBseUxhYmVsRGltZW5zaW9ucyA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdGhpcy5hcHBseVByZWZpeGVkTGFiZWxEaW1lbnNpb25zKGVsZSk7XG5cbiAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgIHRoaXMuYXBwbHlQcmVmaXhlZExhYmVsRGltZW5zaW9ucyhlbGUsICdzb3VyY2UnKTtcbiAgICB0aGlzLmFwcGx5UHJlZml4ZWRMYWJlbERpbWVuc2lvbnMoZWxlLCAndGFyZ2V0Jyk7XG4gIH1cbn07XG5cbkJScCQ5LmFwcGx5UHJlZml4ZWRMYWJlbERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoZWxlLCBwcmVmaXgpIHtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgdGV4dCA9IHRoaXMuZ2V0TGFiZWxUZXh0KGVsZSwgcHJlZml4KTtcbiAgdmFyIGxhYmVsRGltcyA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKGVsZSwgdGV4dCk7XG4gIHZhciBsaW5lSGVpZ2h0ID0gZWxlLnBzdHlsZSgnbGluZS1oZWlnaHQnKS5wZlZhbHVlO1xuICB2YXIgdGV4dFdyYXAgPSBlbGUucHN0eWxlKCd0ZXh0LXdyYXAnKS5zdHJWYWx1ZTtcbiAgdmFyIGxpbmVzID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc2NyYXRjaCwgJ2xhYmVsV3JhcENhY2hlZExpbmVzJywgcHJlZml4KSB8fCBbXTtcbiAgdmFyIG51bUxpbmVzID0gdGV4dFdyYXAgIT09ICd3cmFwJyA/IDEgOiBNYXRoLm1heChsaW5lcy5sZW5ndGgsIDEpO1xuICB2YXIgbm9ybVBlckxpbmVIZWlnaHQgPSBsYWJlbERpbXMuaGVpZ2h0IC8gbnVtTGluZXM7XG4gIHZhciBsYWJlbExpbmVIZWlnaHQgPSBub3JtUGVyTGluZUhlaWdodCAqIGxpbmVIZWlnaHQ7XG4gIHZhciB3aWR0aCA9IGxhYmVsRGltcy53aWR0aDtcbiAgdmFyIGhlaWdodCA9IGxhYmVsRGltcy5oZWlnaHQgKyAobnVtTGluZXMgLSAxKSAqIChsaW5lSGVpZ2h0IC0gMSkgKiBub3JtUGVyTGluZUhlaWdodDtcbiAgc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc3R5bGUsICdsYWJlbFdpZHRoJywgcHJlZml4LCB3aWR0aCk7XG4gIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsICdsYWJlbFdpZHRoJywgcHJlZml4LCB3aWR0aCk7XG4gIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnN0eWxlLCAnbGFiZWxIZWlnaHQnLCBwcmVmaXgsIGhlaWdodCk7XG4gIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsICdsYWJlbEhlaWdodCcsIHByZWZpeCwgaGVpZ2h0KTtcbiAgc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc2NyYXRjaCwgJ2xhYmVsTGluZUhlaWdodCcsIHByZWZpeCwgbGFiZWxMaW5lSGVpZ2h0KTtcbn07XG5cbkJScCQ5LmdldExhYmVsVGV4dCA9IGZ1bmN0aW9uIChlbGUsIHByZWZpeCkge1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBwZmQgPSBwcmVmaXggPyBwcmVmaXggKyAnLScgOiAnJztcbiAgdmFyIHRleHQgPSBlbGUucHN0eWxlKHBmZCArICdsYWJlbCcpLnN0clZhbHVlO1xuICB2YXIgdGV4dFRyYW5zZm9ybSA9IGVsZS5wc3R5bGUoJ3RleHQtdHJhbnNmb3JtJykudmFsdWU7XG5cbiAgdmFyIHJzY3JhdGNoID0gZnVuY3Rpb24gcnNjcmF0Y2gocHJvcE5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCBwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCBwcm9wTmFtZSwgcHJlZml4KTtcbiAgICB9XG4gIH07IC8vIGZvciBlbXB0eSB0ZXh0LCBza2lwIGFsbCBwcm9jZXNzaW5nXG5cblxuICBpZiAoIXRleHQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodGV4dFRyYW5zZm9ybSA9PSAnbm9uZScpIDsgZWxzZSBpZiAodGV4dFRyYW5zZm9ybSA9PSAndXBwZXJjYXNlJykge1xuICAgIHRleHQgPSB0ZXh0LnRvVXBwZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAodGV4dFRyYW5zZm9ybSA9PSAnbG93ZXJjYXNlJykge1xuICAgIHRleHQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICB2YXIgd3JhcFN0eWxlID0gZWxlLnBzdHlsZSgndGV4dC13cmFwJykudmFsdWU7XG5cbiAgaWYgKHdyYXBTdHlsZSA9PT0gJ3dyYXAnKSB7XG4gICAgdmFyIGxhYmVsS2V5ID0gcnNjcmF0Y2goJ2xhYmVsS2V5Jyk7IC8vIHNhdmUgcmVjYWxjIGlmIHRoZSBsYWJlbCBpcyB0aGUgc2FtZSBhcyBiZWZvcmVcblxuICAgIGlmIChsYWJlbEtleSAhPSBudWxsICYmIHJzY3JhdGNoKCdsYWJlbFdyYXBLZXknKSA9PT0gbGFiZWxLZXkpIHtcbiAgICAgIHJldHVybiByc2NyYXRjaCgnbGFiZWxXcmFwQ2FjaGVkVGV4dCcpO1xuICAgIH1cblxuICAgIHZhciB6d3NwID0gXCJcXHUyMDBCXCI7XG4gICAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgdmFyIG1heFcgPSBlbGUucHN0eWxlKCd0ZXh0LW1heC13aWR0aCcpLnBmVmFsdWU7XG4gICAgdmFyIG92ZXJmbG93ID0gZWxlLnBzdHlsZSgndGV4dC1vdmVyZmxvdy13cmFwJykudmFsdWU7XG4gICAgdmFyIG92ZXJmbG93QW55ID0gb3ZlcmZsb3cgPT09ICdhbnl3aGVyZSc7XG4gICAgdmFyIHdyYXBwZWRMaW5lcyA9IFtdO1xuICAgIHZhciB3b3Jkc1JlZ2V4ID0gL1tcXHNcXHUyMDBiXSsvO1xuICAgIHZhciB3b3JkU2VwYXJhdG9yID0gb3ZlcmZsb3dBbnkgPyAnJyA6ICcgJztcblxuICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbGluZXMubGVuZ3RoOyBsKyspIHtcbiAgICAgIHZhciBsaW5lID0gbGluZXNbbF07XG4gICAgICB2YXIgbGluZURpbXMgPSB0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyhlbGUsIGxpbmUpO1xuICAgICAgdmFyIGxpbmVXID0gbGluZURpbXMud2lkdGg7XG5cbiAgICAgIGlmIChvdmVyZmxvd0FueSkge1xuICAgICAgICB2YXIgcHJvY2Vzc2VkTGluZSA9IGxpbmUuc3BsaXQoJycpLmpvaW4oendzcCk7XG4gICAgICAgIGxpbmUgPSBwcm9jZXNzZWRMaW5lO1xuICAgICAgfVxuXG4gICAgICBpZiAobGluZVcgPiBtYXhXKSB7XG4gICAgICAgIC8vIGxpbmUgaXMgdG9vIGxvbmdcbiAgICAgICAgdmFyIHdvcmRzID0gbGluZS5zcGxpdCh3b3Jkc1JlZ2V4KTtcbiAgICAgICAgdmFyIHN1YmxpbmUgPSAnJztcblxuICAgICAgICBmb3IgKHZhciB3ID0gMDsgdyA8IHdvcmRzLmxlbmd0aDsgdysrKSB7XG4gICAgICAgICAgdmFyIHdvcmQgPSB3b3Jkc1t3XTtcbiAgICAgICAgICB2YXIgdGVzdExpbmUgPSBzdWJsaW5lLmxlbmd0aCA9PT0gMCA/IHdvcmQgOiBzdWJsaW5lICsgd29yZFNlcGFyYXRvciArIHdvcmQ7XG4gICAgICAgICAgdmFyIHRlc3REaW1zID0gdGhpcy5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMoZWxlLCB0ZXN0TGluZSk7XG4gICAgICAgICAgdmFyIHRlc3RXID0gdGVzdERpbXMud2lkdGg7XG5cbiAgICAgICAgICBpZiAodGVzdFcgPD0gbWF4Vykge1xuICAgICAgICAgICAgLy8gd29yZCBmaXRzIG9uIGN1cnJlbnQgbGluZVxuICAgICAgICAgICAgc3VibGluZSArPSB3b3JkICsgd29yZFNlcGFyYXRvcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gd29yZCBzdGFydHMgbmV3IGxpbmVcbiAgICAgICAgICAgIGlmIChzdWJsaW5lKSB7XG4gICAgICAgICAgICAgIHdyYXBwZWRMaW5lcy5wdXNoKHN1YmxpbmUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdWJsaW5lID0gd29yZCArIHdvcmRTZXBhcmF0b3I7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGlmIHRoZXJlJ3MgcmVtYWluaW5nIHRleHQsIHB1dCBpdCBpbiBhIHdyYXBwZWQgbGluZVxuXG5cbiAgICAgICAgaWYgKCFzdWJsaW5lLm1hdGNoKC9eW1xcc1xcdTIwMGJdKyQvKSkge1xuICAgICAgICAgIHdyYXBwZWRMaW5lcy5wdXNoKHN1YmxpbmUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBsaW5lIGlzIGFscmVhZHkgc2hvcnQgZW5vdWdoXG4gICAgICAgIHdyYXBwZWRMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgfVxuICAgIH0gLy8gZm9yXG5cblxuICAgIHJzY3JhdGNoKCdsYWJlbFdyYXBDYWNoZWRMaW5lcycsIHdyYXBwZWRMaW5lcyk7XG4gICAgdGV4dCA9IHJzY3JhdGNoKCdsYWJlbFdyYXBDYWNoZWRUZXh0Jywgd3JhcHBlZExpbmVzLmpvaW4oJ1xcbicpKTtcbiAgICByc2NyYXRjaCgnbGFiZWxXcmFwS2V5JywgbGFiZWxLZXkpO1xuICB9IGVsc2UgaWYgKHdyYXBTdHlsZSA9PT0gJ2VsbGlwc2lzJykge1xuICAgIHZhciBfbWF4VyA9IGVsZS5wc3R5bGUoJ3RleHQtbWF4LXdpZHRoJykucGZWYWx1ZTtcbiAgICB2YXIgZWxsaXBzaXplZCA9ICcnO1xuICAgIHZhciBlbGxpcHNpcyA9IFwiXFx1MjAyNlwiO1xuICAgIHZhciBpbmNMYXN0Q2ggPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyhlbGUsIHRleHQpLndpZHRoIDwgX21heFcpIHtcbiAgICAgIC8vIHRoZSBsYWJlbCBhbHJlYWR5IGZpdHNcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdpZHRoV2l0aE5leHRDaCA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKGVsZSwgZWxsaXBzaXplZCArIHRleHRbaV0gKyBlbGxpcHNpcykud2lkdGg7XG5cbiAgICAgIGlmICh3aWR0aFdpdGhOZXh0Q2ggPiBfbWF4Vykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZWxsaXBzaXplZCArPSB0ZXh0W2ldO1xuXG4gICAgICBpZiAoaSA9PT0gdGV4dC5sZW5ndGggLSAxKSB7XG4gICAgICAgIGluY0xhc3RDaCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpbmNMYXN0Q2gpIHtcbiAgICAgIGVsbGlwc2l6ZWQgKz0gZWxsaXBzaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsbGlwc2l6ZWQ7XG4gIH0gLy8gaWYgZWxsaXBzaXplXG5cblxuICByZXR1cm4gdGV4dDtcbn07XG5cbkJScCQ5LmdldExhYmVsSnVzdGlmaWNhdGlvbiA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdmFyIGp1c3RpZmljYXRpb24gPSBlbGUucHN0eWxlKCd0ZXh0LWp1c3RpZmljYXRpb24nKS5zdHJWYWx1ZTtcbiAgdmFyIHRleHRIYWxpZ24gPSBlbGUucHN0eWxlKCd0ZXh0LWhhbGlnbicpLnN0clZhbHVlO1xuXG4gIGlmIChqdXN0aWZpY2F0aW9uID09PSAnYXV0bycpIHtcbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICBzd2l0Y2ggKHRleHRIYWxpZ24pIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgcmV0dXJuICdyaWdodCc7XG5cbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIHJldHVybiAnbGVmdCc7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gJ2NlbnRlcic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnY2VudGVyJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGp1c3RpZmljYXRpb247XG4gIH1cbn07XG5cbkJScCQ5LmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyA9IGZ1bmN0aW9uIChlbGUsIHRleHQpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgY2FjaGVLZXkgPSBoYXNoU3RyaW5nKHRleHQsIGVsZS5fcHJpdmF0ZS5sYWJlbERpbXNLZXkpO1xuICB2YXIgY2FjaGUgPSByLmxhYmVsRGltQ2FjaGUgfHwgKHIubGFiZWxEaW1DYWNoZSA9IFtdKTtcbiAgdmFyIGV4aXN0aW5nVmFsID0gY2FjaGVbY2FjaGVLZXldO1xuXG4gIGlmIChleGlzdGluZ1ZhbCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGV4aXN0aW5nVmFsO1xuICB9XG5cbiAgdmFyIHBhZGRpbmcgPSAwOyAvLyBhZGQgcGFkZGluZyBhcm91bmQgdGV4dCBkaW1zLCBhcyB0aGUgbWVhc3VyZW1lbnQgaXNuJ3QgdGhhdCBhY2N1cmF0ZVxuXG4gIHZhciBmU3R5bGUgPSBlbGUucHN0eWxlKCdmb250LXN0eWxlJykuc3RyVmFsdWU7XG4gIHZhciBzaXplID0gZWxlLnBzdHlsZSgnZm9udC1zaXplJykucGZWYWx1ZTtcbiAgdmFyIGZhbWlseSA9IGVsZS5wc3R5bGUoJ2ZvbnQtZmFtaWx5Jykuc3RyVmFsdWU7XG4gIHZhciB3ZWlnaHQgPSBlbGUucHN0eWxlKCdmb250LXdlaWdodCcpLnN0clZhbHVlO1xuICB2YXIgY2FudmFzID0gdGhpcy5sYWJlbENhbGNDYW52YXM7XG4gIHZhciBjMmQgPSB0aGlzLmxhYmVsQ2FsY0NhbnZhc0NvbnRleHQ7XG5cbiAgaWYgKCFjYW52YXMpIHtcbiAgICBjYW52YXMgPSB0aGlzLmxhYmVsQ2FsY0NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGMyZCA9IHRoaXMubGFiZWxDYWxjQ2FudmFzQ29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciBkcyA9IGNhbnZhcy5zdHlsZTtcbiAgICBkcy5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZHMubGVmdCA9ICctOTk5OXB4JztcbiAgICBkcy50b3AgPSAnLTk5OTlweCc7XG4gICAgZHMuekluZGV4ID0gJy0xJztcbiAgICBkcy52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgZHMucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgfVxuXG4gIGMyZC5mb250ID0gXCJcIi5jb25jYXQoZlN0eWxlLCBcIiBcIikuY29uY2F0KHdlaWdodCwgXCIgXCIpLmNvbmNhdChzaXplLCBcInB4IFwiKS5jb25jYXQoZmFtaWx5KTtcbiAgdmFyIHdpZHRoID0gMDtcbiAgdmFyIGhlaWdodCA9IDA7XG4gIHZhciBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuICAgIHZhciBtZXRyaWNzID0gYzJkLm1lYXN1cmVUZXh0KGxpbmUpO1xuICAgIHZhciB3ID0gTWF0aC5jZWlsKG1ldHJpY3Mud2lkdGgpO1xuICAgIHZhciBoID0gc2l6ZTtcbiAgICB3aWR0aCA9IE1hdGgubWF4KHcsIHdpZHRoKTtcbiAgICBoZWlnaHQgKz0gaDtcbiAgfVxuXG4gIHdpZHRoICs9IHBhZGRpbmc7XG4gIGhlaWdodCArPSBwYWRkaW5nO1xuICByZXR1cm4gY2FjaGVbY2FjaGVLZXldID0ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufTtcblxuQlJwJDkuY2FsY3VsYXRlTGFiZWxBbmdsZSA9IGZ1bmN0aW9uIChlbGUsIHByZWZpeCkge1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICB2YXIgcHJlZml4RGFzaCA9IHByZWZpeCA/IHByZWZpeCArICctJyA6ICcnO1xuICB2YXIgcm90ID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ3RleHQtcm90YXRpb24nKTtcbiAgdmFyIHJvdFN0ciA9IHJvdC5zdHJWYWx1ZTtcblxuICBpZiAocm90U3RyID09PSAnbm9uZScpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChpc0VkZ2UgJiYgcm90U3RyID09PSAnYXV0b3JvdGF0ZScpIHtcbiAgICByZXR1cm4gcnMubGFiZWxBdXRvQW5nbGU7XG4gIH0gZWxzZSBpZiAocm90U3RyID09PSAnYXV0b3JvdGF0ZScpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcm90LnBmVmFsdWU7XG4gIH1cbn07XG5cbkJScCQ5LmNhbGN1bGF0ZUxhYmVsQW5nbGVzID0gZnVuY3Rpb24gKGVsZSkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gIHJzLmxhYmVsQW5nbGUgPSByLmNhbGN1bGF0ZUxhYmVsQW5nbGUoZWxlKTtcblxuICBpZiAoaXNFZGdlKSB7XG4gICAgcnMuc291cmNlTGFiZWxBbmdsZSA9IHIuY2FsY3VsYXRlTGFiZWxBbmdsZShlbGUsICdzb3VyY2UnKTtcbiAgICBycy50YXJnZXRMYWJlbEFuZ2xlID0gci5jYWxjdWxhdGVMYWJlbEFuZ2xlKGVsZSwgJ3RhcmdldCcpO1xuICB9XG59O1xuXG52YXIgQlJwJDggPSB7fTtcbnZhciBUT09fU01BTExfQ1VUX1JFQ1QgPSAyODtcbnZhciB3YXJuZWRDdXRSZWN0ID0gZmFsc2U7XG5cbkJScCQ4LmdldE5vZGVTaGFwZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIHNoYXBlID0gbm9kZS5wc3R5bGUoJ3NoYXBlJykudmFsdWU7XG5cbiAgaWYgKHNoYXBlID09PSAnY3V0cmVjdGFuZ2xlJyAmJiAobm9kZS53aWR0aCgpIDwgVE9PX1NNQUxMX0NVVF9SRUNUIHx8IG5vZGUuaGVpZ2h0KCkgPCBUT09fU01BTExfQ1VUX1JFQ1QpKSB7XG4gICAgaWYgKCF3YXJuZWRDdXRSZWN0KSB7XG4gICAgICB3YXJuKCdUaGUgYGN1dHJlY3RhbmdsZWAgbm9kZSBzaGFwZSBjYW4gbm90IGJlIHVzZWQgYXQgc21hbGwgc2l6ZXMgc28gYHJlY3RhbmdsZWAgaXMgdXNlZCBpbnN0ZWFkJyk7XG4gICAgICB3YXJuZWRDdXRSZWN0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gJ3JlY3RhbmdsZSc7XG4gIH1cblxuICBpZiAobm9kZS5pc1BhcmVudCgpKSB7XG4gICAgaWYgKHNoYXBlID09PSAncmVjdGFuZ2xlJyB8fCBzaGFwZSA9PT0gJ3JvdW5kcmVjdGFuZ2xlJyB8fCBzaGFwZSA9PT0gJ3JvdW5kLXJlY3RhbmdsZScgfHwgc2hhcGUgPT09ICdjdXRyZWN0YW5nbGUnIHx8IHNoYXBlID09PSAnY3V0LXJlY3RhbmdsZScgfHwgc2hhcGUgPT09ICdiYXJyZWwnKSB7XG4gICAgICByZXR1cm4gc2hhcGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAncmVjdGFuZ2xlJztcbiAgICB9XG4gIH1cblxuICBpZiAoc2hhcGUgPT09ICdwb2x5Z29uJykge1xuICAgIHZhciBwb2ludHMgPSBub2RlLnBzdHlsZSgnc2hhcGUtcG9seWdvbi1wb2ludHMnKS52YWx1ZTtcbiAgICByZXR1cm4gci5ub2RlU2hhcGVzLm1ha2VQb2x5Z29uKHBvaW50cykubmFtZTtcbiAgfVxuXG4gIHJldHVybiBzaGFwZTtcbn07XG5cbnZhciBCUnAkNyA9IHt9O1xuXG5CUnAkNy5yZWdpc3RlckNhbGN1bGF0aW9uTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY3kgPSB0aGlzLmN5O1xuICB2YXIgZWxlc1RvVXBkYXRlID0gY3kuY29sbGVjdGlvbigpO1xuICB2YXIgciA9IHRoaXM7XG5cbiAgdmFyIGVucXVldWUgPSBmdW5jdGlvbiBlbnF1ZXVlKGVsZXMpIHtcbiAgICB2YXIgZGlydHlTdHlsZUNhY2hlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICBlbGVzVG9VcGRhdGUubWVyZ2UoZWxlcyk7XG5cbiAgICBpZiAoZGlydHlTdHlsZUNhY2hlcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gICAgICAgIHJzdHlsZS5jbGVhbiA9IGZhbHNlO1xuICAgICAgICByc3R5bGUuY2xlYW5Db25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgci5iaW5kZXIoY3kpLm9uKCdib3VuZHMuKiBkaXJ0eS4qJywgZnVuY3Rpb24gb25EaXJ0eUJvdW5kcyhlKSB7XG4gICAgdmFyIGVsZSA9IGUudGFyZ2V0O1xuICAgIGVucXVldWUoZWxlKTtcbiAgfSkub24oJ3N0eWxlLiogYmFja2dyb3VuZC4qJywgZnVuY3Rpb24gb25EaXJ0eVN0eWxlKGUpIHtcbiAgICB2YXIgZWxlID0gZS50YXJnZXQ7XG4gICAgZW5xdWV1ZShlbGUsIGZhbHNlKTtcbiAgfSk7XG5cbiAgdmFyIHVwZGF0ZUVsZUNhbGNzID0gZnVuY3Rpb24gdXBkYXRlRWxlQ2FsY3Mod2lsbERyYXcpIHtcbiAgICBpZiAod2lsbERyYXcpIHtcbiAgICAgIHZhciBmbnMgPSByLm9uVXBkYXRlRWxlQ2FsY3NGbnM7IC8vIGJlY2F1c2Ugd2UgbmVlZCB0byBoYXZlIHVwLXRvLWRhdGUgc3R5bGUgKGUuZy4gc3R5bGVzaGVldCBtYXBwZXJzKVxuICAgICAgLy8gYmVmb3JlIGNhbGN1bGF0aW5nIHJlbmRlcmVkIHN0eWxlIChhbmQgcHN0eWxlIG1pZ2h0IG5vdCBiZSBjYWxsZWQgeWV0KVxuXG4gICAgICBlbGVzVG9VcGRhdGUuY2xlYW5TdHlsZSgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gZWxlc1RvVXBkYXRlW2ldO1xuICAgICAgICB2YXIgcnN0eWxlID0gZWxlLl9wcml2YXRlLnJzdHlsZTtcblxuICAgICAgICBpZiAoZWxlLmlzTm9kZSgpICYmICFyc3R5bGUuY2xlYW5Db25uZWN0ZWQpIHtcbiAgICAgICAgICBlbnF1ZXVlKGVsZS5jb25uZWN0ZWRFZGdlcygpKTtcbiAgICAgICAgICByc3R5bGUuY2xlYW5Db25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmbnMpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGZucy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICB2YXIgZm4gPSBmbnNbX2ldO1xuICAgICAgICAgIGZuKHdpbGxEcmF3LCBlbGVzVG9VcGRhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHIucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKGVsZXNUb1VwZGF0ZSk7XG4gICAgICBlbGVzVG9VcGRhdGUgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgfVxuICB9O1xuXG4gIHIuZmx1c2hSZW5kZXJlZFN0eWxlUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdXBkYXRlRWxlQ2FsY3ModHJ1ZSk7XG4gIH07XG5cbiAgci5iZWZvcmVSZW5kZXIodXBkYXRlRWxlQ2FsY3MsIHIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcy5lbGVDYWxjcyk7XG59O1xuXG5CUnAkNy5vblVwZGF0ZUVsZUNhbGNzID0gZnVuY3Rpb24gKGZuKSB7XG4gIHZhciBmbnMgPSB0aGlzLm9uVXBkYXRlRWxlQ2FsY3NGbnMgPSB0aGlzLm9uVXBkYXRlRWxlQ2FsY3NGbnMgfHwgW107XG4gIGZucy5wdXNoKGZuKTtcbn07XG5cbkJScCQ3LnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSA9IGZ1bmN0aW9uIChlbGVzLCB1c2VDYWNoZSkge1xuICB2YXIgaXNDbGVhbkNvbm5lY3RlZCA9IGZ1bmN0aW9uIGlzQ2xlYW5Db25uZWN0ZWQoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5yc3R5bGUuY2xlYW5Db25uZWN0ZWQ7XG4gIH07XG5cbiAgdmFyIGVkZ2VzID0gW107XG4gIHZhciBub2RlcyA9IFtdOyAvLyB0aGUgcmVuZGVyZXIgY2FuJ3QgYmUgdXNlZCBmb3IgY2FsY3Mgd2hlbiBkZXN0cm95ZWQsIGUuZy4gZWxlLmJvdW5kaW5nQm94KClcblxuICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gdXNlIGNhY2hlIGJ5IGRlZmF1bHQgZm9yIHBlcmZcblxuXG4gIGlmICh1c2VDYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdXNlQ2FjaGUgPSB0cnVlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7IC8vIGFuIGVkZ2UgbWF5IGJlIGltcGxpY2l0bHkgZGlydHkgYi9jIG9mIG9uZSBvZiBpdHMgY29ubmVjdGVkIG5vZGVzXG4gICAgLy8gKGFuZCBhIHJlcXVlc3QgZm9yIHJlY2FsYyBtYXkgY29tZSBpbiBiZXR3ZWVuIGZyYW1lcylcblxuICAgIGlmIChlbGUuaXNFZGdlKCkgJiYgKCFpc0NsZWFuQ29ubmVjdGVkKGVsZS5zb3VyY2UoKSkgfHwgIWlzQ2xlYW5Db25uZWN0ZWQoZWxlLnRhcmdldCgpKSkpIHtcbiAgICAgIHJzdHlsZS5jbGVhbiA9IGZhbHNlO1xuICAgIH0gLy8gb25seSB1cGRhdGUgaWYgZGlydHkgYW5kIGluIGdyYXBoXG5cblxuICAgIGlmICh1c2VDYWNoZSAmJiByc3R5bGUuY2xlYW4gfHwgZWxlLnJlbW92ZWQoKSkge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBvbmx5IHVwZGF0ZSBpZiBub3QgZGlzcGxheTogbm9uZVxuXG5cbiAgICBpZiAoZWxlLnBzdHlsZSgnZGlzcGxheScpLnZhbHVlID09PSAnbm9uZScpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChfcC5ncm91cCA9PT0gJ25vZGVzJykge1xuICAgICAgbm9kZXMucHVzaChlbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlZGdlc1xuICAgICAgZWRnZXMucHVzaChlbGUpO1xuICAgIH1cblxuICAgIHJzdHlsZS5jbGVhbiA9IHRydWU7XG4gIH0gLy8gdXBkYXRlIG5vZGUgZGF0YSBmcm9tIHByb2plY3Rpb25zXG5cblxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBub2Rlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIF9lbGUgPSBub2Rlc1tfaTJdO1xuICAgIHZhciBfcDIgPSBfZWxlLl9wcml2YXRlO1xuICAgIHZhciBfcnN0eWxlID0gX3AyLnJzdHlsZTtcblxuICAgIHZhciBwb3MgPSBfZWxlLnBvc2l0aW9uKCk7XG5cbiAgICB0aGlzLnJlY2FsY3VsYXRlTm9kZUxhYmVsUHJvamVjdGlvbihfZWxlKTtcbiAgICBfcnN0eWxlLm5vZGVYID0gcG9zLng7XG4gICAgX3JzdHlsZS5ub2RlWSA9IHBvcy55O1xuICAgIF9yc3R5bGUubm9kZVcgPSBfZWxlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuICAgIF9yc3R5bGUubm9kZUggPSBfZWxlLnBzdHlsZSgnaGVpZ2h0JykucGZWYWx1ZTtcbiAgfVxuXG4gIHRoaXMucmVjYWxjdWxhdGVFZGdlUHJvamVjdGlvbnMoZWRnZXMpOyAvLyB1cGRhdGUgZWRnZSBkYXRhIGZyb20gcHJvamVjdGlvbnNcblxuICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBlZGdlcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgdmFyIF9lbGUyID0gZWRnZXNbX2kzXTtcbiAgICB2YXIgX3AzID0gX2VsZTIuX3ByaXZhdGU7XG4gICAgdmFyIF9yc3R5bGUyID0gX3AzLnJzdHlsZTtcbiAgICB2YXIgcnMgPSBfcDMucnNjcmF0Y2g7IC8vIHVwZGF0ZSByc3R5bGUgcG9zaXRpb25zXG5cbiAgICBfcnN0eWxlMi5zcmNYID0gcnMuYXJyb3dTdGFydFg7XG4gICAgX3JzdHlsZTIuc3JjWSA9IHJzLmFycm93U3RhcnRZO1xuICAgIF9yc3R5bGUyLnRndFggPSBycy5hcnJvd0VuZFg7XG4gICAgX3JzdHlsZTIudGd0WSA9IHJzLmFycm93RW5kWTtcbiAgICBfcnN0eWxlMi5taWRYID0gcnMubWlkWDtcbiAgICBfcnN0eWxlMi5taWRZID0gcnMubWlkWTtcbiAgICBfcnN0eWxlMi5sYWJlbEFuZ2xlID0gcnMubGFiZWxBbmdsZTtcbiAgICBfcnN0eWxlMi5zb3VyY2VMYWJlbEFuZ2xlID0gcnMuc291cmNlTGFiZWxBbmdsZTtcbiAgICBfcnN0eWxlMi50YXJnZXRMYWJlbEFuZ2xlID0gcnMudGFyZ2V0TGFiZWxBbmdsZTtcbiAgfVxufTtcblxudmFyIEJScCQ2ID0ge307XG5cbkJScCQ2LnVwZGF0ZUNhY2hlZEdyYWJiZWRFbGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlcyA9IHRoaXMuY2FjaGVkWlNvcnRlZEVsZXM7XG5cbiAgaWYgKCFlbGVzKSB7XG4gICAgLy8ganVzdCBsZXQgdGhpcyBiZSByZWNhbGN1bGF0ZWQgb24gdGhlIG5leHQgeiBzb3J0IHRpY2tcbiAgICByZXR1cm47XG4gIH1cblxuICBlbGVzLmRyYWcgPSBbXTtcbiAgZWxlcy5ub25kcmFnID0gW107XG4gIHZhciBncmFiVGFyZ2V0cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcblxuICAgIGlmIChlbGUuZ3JhYmJlZCgpICYmICFlbGUuaXNQYXJlbnQoKSkge1xuICAgICAgZ3JhYlRhcmdldHMucHVzaChlbGUpO1xuICAgIH0gZWxzZSBpZiAocnMuaW5EcmFnTGF5ZXIpIHtcbiAgICAgIGVsZXMuZHJhZy5wdXNoKGVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZXMubm9uZHJhZy5wdXNoKGVsZSk7XG4gICAgfVxuICB9IC8vIHB1dCB0aGUgZ3JhYiB0YXJnZXQgbm9kZXMgbGFzdCBzbyBpdCdzIG9uIHRvcCBvZiBpdHMgbmVpZ2hib3VyaG9vZFxuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFiVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBncmFiVGFyZ2V0c1tpXTtcbiAgICBlbGVzLmRyYWcucHVzaChlbGUpO1xuICB9XG59O1xuXG5CUnAkNi5pbnZhbGlkYXRlQ2FjaGVkWlNvcnRlZEVsZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2FjaGVkWlNvcnRlZEVsZXMgPSBudWxsO1xufTtcblxuQlJwJDYuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMgPSBmdW5jdGlvbiAoZm9yY2VSZWNhbGMpIHtcbiAgaWYgKGZvcmNlUmVjYWxjIHx8ICF0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzKSB7XG4gICAgdmFyIGVsZXMgPSB0aGlzLmN5Lm11dGFibGVFbGVtZW50cygpLnRvQXJyYXkoKTtcbiAgICBlbGVzLnNvcnQoekluZGV4U29ydCk7XG4gICAgZWxlcy5pbnRlcmFjdGl2ZSA9IGVsZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaW50ZXJhY3RpdmUoKTtcbiAgICB9KTtcbiAgICB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzID0gZWxlcztcbiAgICB0aGlzLnVwZGF0ZUNhY2hlZEdyYWJiZWRFbGVzKCk7XG4gIH0gZWxzZSB7XG4gICAgZWxlcyA9IHRoaXMuY2FjaGVkWlNvcnRlZEVsZXM7XG4gIH1cblxuICByZXR1cm4gZWxlcztcbn07XG5cbnZhciBCUnAkNSA9IHt9O1xuW0JScCRlLCBCUnAkZCwgQlJwJGMsIEJScCRiLCBCUnAkYSwgQlJwJDksIEJScCQ4LCBCUnAkNywgQlJwJDZdLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gIGV4dGVuZChCUnAkNSwgcHJvcHMpO1xufSk7XG5cbnZhciBCUnAkNCA9IHt9O1xuXG5CUnAkNC5nZXRDYWNoZWRJbWFnZSA9IGZ1bmN0aW9uICh1cmwsIGNyb3NzT3JpZ2luLCBvbkxvYWQpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgaW1hZ2VDYWNoZSA9IHIuaW1hZ2VDYWNoZSA9IHIuaW1hZ2VDYWNoZSB8fCB7fTtcbiAgdmFyIGNhY2hlID0gaW1hZ2VDYWNoZVt1cmxdO1xuXG4gIGlmIChjYWNoZSkge1xuICAgIGlmICghY2FjaGUuaW1hZ2UuY29tcGxldGUpIHtcbiAgICAgIGNhY2hlLmltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQpO1xuICAgIH1cblxuICAgIHJldHVybiBjYWNoZS5pbWFnZTtcbiAgfSBlbHNlIHtcbiAgICBjYWNoZSA9IGltYWdlQ2FjaGVbdXJsXSA9IGltYWdlQ2FjaGVbdXJsXSB8fCB7fTtcbiAgICB2YXIgaW1hZ2UgPSBjYWNoZS5pbWFnZSA9IG5ldyBJbWFnZSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcbiAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGltYWdlLmVycm9yID0gdHJ1ZTtcbiAgICB9KTsgLy8gIzE1ODIgc2FmYXJpIGRvZXNuJ3QgbG9hZCBkYXRhIHVyaXMgd2l0aCBjcm9zc09yaWdpbiBwcm9wZXJseVxuICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjM5NzhcblxuICAgIHZhciBkYXRhVXJpUHJlZml4ID0gJ2RhdGE6JztcbiAgICB2YXIgaXNEYXRhVXJpID0gdXJsLnN1YnN0cmluZygwLCBkYXRhVXJpUHJlZml4Lmxlbmd0aCkudG9Mb3dlckNhc2UoKSA9PT0gZGF0YVVyaVByZWZpeDtcblxuICAgIGlmICghaXNEYXRhVXJpKSB7XG4gICAgICAvLyBpZiBjcm9zc29yaWdpbiBpcyAnbnVsbCcoc3RyaW5naWZpZWQpLCB0aGVuIG1hbnVhbGx5IHNldCBpdCB0byBudWxsIFxuICAgICAgY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbiA9PT0gJ251bGwnID8gbnVsbCA6IGNyb3NzT3JpZ2luO1xuICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjsgLy8gcHJldmVudCB0YWludGVkIGNhbnZhc1xuICAgIH1cblxuICAgIGltYWdlLnNyYyA9IHVybDtcbiAgICByZXR1cm4gaW1hZ2U7XG4gIH1cbn07XG5cbnZhciBCUnAkMyA9IHt9O1xuLyogZ2xvYmFsIGRvY3VtZW50LCB3aW5kb3csIFJlc2l6ZU9ic2VydmVyLCBNdXRhdGlvbk9ic2VydmVyICovXG5cbkJScCQzLnJlZ2lzdGVyQmluZGluZyA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50LCBoYW5kbGVyLCB1c2VDYXB0dXJlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzLCBbMV0pOyAvLyBjb3B5XG5cbiAgdmFyIGIgPSB0aGlzLmJpbmRlcih0YXJnZXQpO1xuICByZXR1cm4gYi5vbi5hcHBseShiLCBhcmdzKTtcbn07XG5cbkJScCQzLmJpbmRlciA9IGZ1bmN0aW9uICh0Z3QpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgY29udGFpbmVyV2luZG93ID0gci5jeS53aW5kb3coKTtcbiAgdmFyIHRndElzRG9tID0gdGd0ID09PSBjb250YWluZXJXaW5kb3cgfHwgdGd0ID09PSBjb250YWluZXJXaW5kb3cuZG9jdW1lbnQgfHwgdGd0ID09PSBjb250YWluZXJXaW5kb3cuZG9jdW1lbnQuYm9keSB8fCBkb21FbGVtZW50KHRndCk7XG5cbiAgaWYgKHIuc3VwcG9ydHNQYXNzaXZlRXZlbnRzID09IG51bGwpIHtcbiAgICAvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL0V2ZW50TGlzdGVuZXJPcHRpb25zL2Jsb2IvZ2gtcGFnZXMvZXhwbGFpbmVyLm1kI2ZlYXR1cmUtZGV0ZWN0aW9uXG4gICAgdmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb250YWluZXJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdHMpO1xuICAgIH0gY2F0Y2ggKGVycikgey8vIG5vdCBzdXBwb3J0ZWRcbiAgICB9XG5cbiAgICByLnN1cHBvcnRzUGFzc2l2ZUV2ZW50cyA9IHN1cHBvcnRzUGFzc2l2ZTtcbiAgfVxuXG4gIHZhciBvbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBoYW5kbGVyLCB1c2VDYXB0dXJlKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgaWYgKHRndElzRG9tICYmIHIuc3VwcG9ydHNQYXNzaXZlRXZlbnRzKSB7XG4gICAgICAvLyByZXBsYWNlIHVzZUNhcHR1cmUgdy8gb3B0cyBvYmpcbiAgICAgIGFyZ3NbMl0gPSB7XG4gICAgICAgIGNhcHR1cmU6IHVzZUNhcHR1cmUgIT0gbnVsbCA/IHVzZUNhcHR1cmUgOiBmYWxzZSxcbiAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgIG9uY2U6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cblxuICAgIHIuYmluZGluZ3MucHVzaCh7XG4gICAgICB0YXJnZXQ6IHRndCxcbiAgICAgIGFyZ3M6IGFyZ3NcbiAgICB9KTtcbiAgICAodGd0LmFkZEV2ZW50TGlzdGVuZXIgfHwgdGd0Lm9uKS5hcHBseSh0Z3QsIGFyZ3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgb246IG9uLFxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IG9uLFxuICAgIGFkZExpc3RlbmVyOiBvbixcbiAgICBiaW5kOiBvblxuICB9O1xufTtcblxuQlJwJDMubm9kZUlzRHJhZ2dhYmxlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS5pc05vZGUoKSAmJiAhbm9kZS5sb2NrZWQoKSAmJiBub2RlLmdyYWJiYWJsZSgpO1xufTtcblxuQlJwJDMubm9kZUlzR3JhYmJhYmxlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIHRoaXMubm9kZUlzRHJhZ2dhYmxlKG5vZGUpICYmIG5vZGUuaW50ZXJhY3RpdmUoKTtcbn07XG5cbkJScCQzLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGNvbnRhaW5lcldpbmRvdyA9IHIuY3kud2luZG93KCk7XG5cbiAgdmFyIGlzU2VsZWN0ZWQgPSBmdW5jdGlvbiBpc1NlbGVjdGVkKGVsZSkge1xuICAgIHJldHVybiBlbGUuc2VsZWN0ZWQoKTtcbiAgfTtcblxuICB2YXIgdHJpZ2dlckV2ZW50cyA9IGZ1bmN0aW9uIHRyaWdnZXJFdmVudHModGFyZ2V0LCBuYW1lcywgZSwgcG9zaXRpb24pIHtcbiAgICBpZiAodGFyZ2V0ID09IG51bGwpIHtcbiAgICAgIHRhcmdldCA9IHIuY3k7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgIHRhcmdldC5lbWl0KHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgdHlwZTogbmFtZSxcbiAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzTXVsdFNlbEtleURvd24gPSBmdW5jdGlvbiBpc011bHRTZWxLZXlEb3duKGUpIHtcbiAgICByZXR1cm4gZS5zaGlmdEtleSB8fCBlLm1ldGFLZXkgfHwgZS5jdHJsS2V5OyAvLyBtYXliZSBlLmFsdEtleVxuICB9O1xuXG4gIHZhciBhbGxvd1Bhbm5pbmdQYXNzdGhyb3VnaCA9IGZ1bmN0aW9uIGFsbG93UGFubmluZ1Bhc3N0aHJvdWdoKGRvd24sIGRvd25zKSB7XG4gICAgdmFyIGFsbG93UGFzc3Rocm91Z2ggPSB0cnVlO1xuXG4gICAgaWYgKHIuY3kuaGFzQ29tcG91bmROb2RlcygpICYmIGRvd24gJiYgZG93bi5wYW5uYWJsZSgpKSB7XG4gICAgICAvLyBhIGdyYWJiYWJsZSBjb21wb3VuZCBub2RlIGJlbG93IHRoZSBlbGUgPT4gbm8gcGFzc3Rocm91Z2ggcGFubmluZ1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGRvd25zICYmIGkgPCBkb3ducy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZG93biA9IGRvd25zW2ldOyAvL2lmIGFueSBwYXJlbnQgbm9kZSBpbiBldmVudCBoaWVyYXJjaHkgaXNuJ3QgcGFubmFibGUsIHJlamVjdCBwYXNzdGhyb3VnaFxuXG4gICAgICAgIGlmIChkb3duLmlzTm9kZSgpICYmIGRvd24uaXNQYXJlbnQoKSAmJiAhZG93bi5wYW5uYWJsZSgpKSB7XG4gICAgICAgICAgYWxsb3dQYXNzdGhyb3VnaCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsbG93UGFzc3Rocm91Z2ggPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBhbGxvd1Bhc3N0aHJvdWdoO1xuICB9O1xuXG4gIHZhciBzZXRHcmFiYmVkID0gZnVuY3Rpb24gc2V0R3JhYmJlZChlbGUpIHtcbiAgICBlbGVbMF0uX3ByaXZhdGUuZ3JhYmJlZCA9IHRydWU7XG4gIH07XG5cbiAgdmFyIHNldEZyZWVkID0gZnVuY3Rpb24gc2V0RnJlZWQoZWxlKSB7XG4gICAgZWxlWzBdLl9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTtcbiAgfTtcblxuICB2YXIgc2V0SW5EcmFnTGF5ZXIgPSBmdW5jdGlvbiBzZXRJbkRyYWdMYXllcihlbGUpIHtcbiAgICBlbGVbMF0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSB0cnVlO1xuICB9O1xuXG4gIHZhciBzZXRPdXREcmFnTGF5ZXIgPSBmdW5jdGlvbiBzZXRPdXREcmFnTGF5ZXIoZWxlKSB7XG4gICAgZWxlWzBdLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7XG4gIH07XG5cbiAgdmFyIHNldEdyYWJUYXJnZXQgPSBmdW5jdGlvbiBzZXRHcmFiVGFyZ2V0KGVsZSkge1xuICAgIGVsZVswXS5fcHJpdmF0ZS5yc2NyYXRjaC5pc0dyYWJUYXJnZXQgPSB0cnVlO1xuICB9O1xuXG4gIHZhciByZW1vdmVHcmFiVGFyZ2V0ID0gZnVuY3Rpb24gcmVtb3ZlR3JhYlRhcmdldChlbGUpIHtcbiAgICBlbGVbMF0uX3ByaXZhdGUucnNjcmF0Y2guaXNHcmFiVGFyZ2V0ID0gZmFsc2U7XG4gIH07XG5cbiAgdmFyIGFkZFRvRHJhZ0xpc3QgPSBmdW5jdGlvbiBhZGRUb0RyYWdMaXN0KGVsZSwgb3B0cykge1xuICAgIHZhciBsaXN0ID0gb3B0cy5hZGRUb0xpc3Q7XG4gICAgdmFyIGxpc3RIYXNFbGUgPSBsaXN0LmhhcyhlbGUpO1xuXG4gICAgaWYgKCFsaXN0SGFzRWxlICYmIGVsZS5ncmFiYmFibGUoKSAmJiAhZWxlLmxvY2tlZCgpKSB7XG4gICAgICBsaXN0Lm1lcmdlKGVsZSk7XG4gICAgICBzZXRHcmFiYmVkKGVsZSk7XG4gICAgfVxuICB9OyAvLyBoZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoaWNoIGNoaWxkIG5vZGVzIGFuZCBpbm5lciBlZGdlc1xuICAvLyBvZiBhIGNvbXBvdW5kIG5vZGUgdG8gYmUgZHJhZ2dlZCBhcyB3ZWxsIGFzIHRoZSBncmFiYmVkIGFuZCBzZWxlY3RlZCBub2Rlc1xuXG5cbiAgdmFyIGFkZERlc2NlbmRhbnRzVG9EcmFnID0gZnVuY3Rpb24gYWRkRGVzY2VuZGFudHNUb0RyYWcobm9kZSwgb3B0cykge1xuICAgIGlmICghbm9kZS5jeSgpLmhhc0NvbXBvdW5kTm9kZXMoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmluRHJhZ0xheWVyID09IG51bGwgJiYgb3B0cy5hZGRUb0xpc3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gbm90aGluZyB0byBkb1xuXG5cbiAgICB2YXIgaW5uZXJOb2RlcyA9IG5vZGUuZGVzY2VuZGFudHMoKTtcblxuICAgIGlmIChvcHRzLmluRHJhZ0xheWVyKSB7XG4gICAgICBpbm5lck5vZGVzLmZvckVhY2goc2V0SW5EcmFnTGF5ZXIpO1xuICAgICAgaW5uZXJOb2Rlcy5jb25uZWN0ZWRFZGdlcygpLmZvckVhY2goc2V0SW5EcmFnTGF5ZXIpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmFkZFRvTGlzdCkge1xuICAgICAgYWRkVG9EcmFnTGlzdChpbm5lck5vZGVzLCBvcHRzKTtcbiAgICB9XG4gIH07IC8vIGFkZHMgdGhlIGdpdmVuIG5vZGVzIGFuZCBpdHMgbmVpZ2hib3VyaG9vZCB0byB0aGUgZHJhZyBsYXllclxuXG5cbiAgdmFyIGFkZE5vZGVzVG9EcmFnID0gZnVuY3Rpb24gYWRkTm9kZXNUb0RyYWcobm9kZXMsIG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IG5vZGVzLmN5KCkuaGFzQ29tcG91bmROb2RlcygpO1xuXG4gICAgaWYgKG9wdHMuaW5EcmFnTGF5ZXIpIHtcbiAgICAgIG5vZGVzLmZvckVhY2goc2V0SW5EcmFnTGF5ZXIpO1xuICAgICAgbm9kZXMubmVpZ2hib3Job29kKCkuc3RkRmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgcmV0dXJuICFoYXNDb21wb3VuZE5vZGVzIHx8IGVsZS5pc0VkZ2UoKTtcbiAgICAgIH0pLmZvckVhY2goc2V0SW5EcmFnTGF5ZXIpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmFkZFRvTGlzdCkge1xuICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIGFkZFRvRHJhZ0xpc3QoZWxlLCBvcHRzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGFkZERlc2NlbmRhbnRzVG9EcmFnKG5vZGVzLCBvcHRzKTsgLy8gYWx3YXlzIGFkZCB0byBkcmFnXG4gICAgLy8gYWxzbyBhZGQgbm9kZXMgYW5kIGVkZ2VzIHJlbGF0ZWQgdG8gdGhlIHRvcG1vc3QgYW5jZXN0b3JcblxuICAgIHVwZGF0ZUFuY2VzdG9yc0luRHJhZ0xheWVyKG5vZGVzLCB7XG4gICAgICBpbkRyYWdMYXllcjogb3B0cy5pbkRyYWdMYXllclxuICAgIH0pO1xuICAgIHIudXBkYXRlQ2FjaGVkR3JhYmJlZEVsZXMoKTtcbiAgfTtcblxuICB2YXIgYWRkTm9kZVRvRHJhZyA9IGFkZE5vZGVzVG9EcmFnO1xuXG4gIHZhciBmcmVlRHJhZ2dlZEVsZW1lbnRzID0gZnVuY3Rpb24gZnJlZURyYWdnZWRFbGVtZW50cyhncmFiYmVkRWxlcykge1xuICAgIGlmICghZ3JhYmJlZEVsZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGp1c3QgZ28gb3ZlciBhbGwgZWxlbWVudHMgcmF0aGVyIHRoYW4gZG9pbmcgYSBidW5jaCBvZiAocG9zc2libHkgZXhwZW5zaXZlKSB0cmF2ZXJzYWxzXG5cblxuICAgIHIuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHNldEZyZWVkKGVsZSk7XG4gICAgICBzZXRPdXREcmFnTGF5ZXIoZWxlKTtcbiAgICAgIHJlbW92ZUdyYWJUYXJnZXQoZWxlKTtcbiAgICB9KTtcbiAgICByLnVwZGF0ZUNhY2hlZEdyYWJiZWRFbGVzKCk7XG4gIH07IC8vIGhlbHBlciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgd2hpY2ggYW5jZXN0b3Igbm9kZXMgYW5kIGVkZ2VzIHNob3VsZCBnb1xuICAvLyB0byB0aGUgZHJhZyBsYXllciAob3Igc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSBkcmFnIGxheWVyKS5cblxuXG4gIHZhciB1cGRhdGVBbmNlc3RvcnNJbkRyYWdMYXllciA9IGZ1bmN0aW9uIHVwZGF0ZUFuY2VzdG9yc0luRHJhZ0xheWVyKG5vZGUsIG9wdHMpIHtcbiAgICBpZiAob3B0cy5pbkRyYWdMYXllciA9PSBudWxsICYmIG9wdHMuYWRkVG9MaXN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIG5vdGhpbmcgdG8gZG9cblxuXG4gICAgaWYgKCFub2RlLmN5KCkuaGFzQ29tcG91bmROb2RlcygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBmaW5kIHRvcC1sZXZlbCBwYXJlbnRcblxuXG4gICAgdmFyIHBhcmVudCA9IG5vZGUuYW5jZXN0b3JzKCkub3JwaGFucygpOyAvLyBubyBwYXJlbnQgbm9kZTogbm8gbm9kZXMgdG8gYWRkIHRvIHRoZSBkcmFnIGxheWVyXG5cbiAgICBpZiAocGFyZW50LnNhbWUobm9kZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbm9kZXMgPSBwYXJlbnQuZGVzY2VuZGFudHMoKS5zcGF3blNlbGYoKS5tZXJnZShwYXJlbnQpLnVubWVyZ2Uobm9kZSkudW5tZXJnZShub2RlLmRlc2NlbmRhbnRzKCkpO1xuICAgIHZhciBlZGdlcyA9IG5vZGVzLmNvbm5lY3RlZEVkZ2VzKCk7XG5cbiAgICBpZiAob3B0cy5pbkRyYWdMYXllcikge1xuICAgICAgZWRnZXMuZm9yRWFjaChzZXRJbkRyYWdMYXllcik7XG4gICAgICBub2Rlcy5mb3JFYWNoKHNldEluRHJhZ0xheWVyKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5hZGRUb0xpc3QpIHtcbiAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICBhZGRUb0RyYWdMaXN0KGVsZSwgb3B0cyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGJsdXJBY3RpdmVEb21FbGVtZW50ID0gZnVuY3Rpb24gYmx1ckFjdGl2ZURvbUVsZW1lbnQoKSB7XG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT0gbnVsbCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIgIT0gbnVsbCkge1xuICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYXZlTXV0YXRpb25zQXBpID0gdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgaGF2ZVJlc2l6ZU9ic2VydmVyQXBpID0gdHlwZW9mIFJlc2l6ZU9ic2VydmVyICE9PSAndW5kZWZpbmVkJzsgLy8gd2F0Y2ggZm9yIHdoZW4gdGhlIGN5IGNvbnRhaW5lciBpcyByZW1vdmVkIGZyb20gdGhlIGRvbVxuXG4gIGlmIChoYXZlTXV0YXRpb25zQXBpKSB7XG4gICAgci5yZW1vdmVPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uIChtdXRucykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdXRucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbXV0biA9IG11dG5zW2ldO1xuICAgICAgICB2YXIgck5vZGVzID0gbXV0bi5yZW1vdmVkTm9kZXM7XG5cbiAgICAgICAgaWYgKHJOb2Rlcykge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgck5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgck5vZGUgPSByTm9kZXNbal07XG5cbiAgICAgICAgICAgIGlmIChyTm9kZSA9PT0gci5jb250YWluZXIpIHtcbiAgICAgICAgICAgICAgci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHIuY29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgIHIucmVtb3ZlT2JzZXJ2ZXIub2JzZXJ2ZShyLmNvbnRhaW5lci5wYXJlbnROb2RlLCB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnRE9NTm9kZVJlbW92ZWQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgci5kZXN0cm95KCk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgb25SZXNpemUgPSBkZWJvdW5jZV9fZGVmYXVsdFtcImRlZmF1bHRcIl0oZnVuY3Rpb24gKCkge1xuICAgIHIuY3kucmVzaXplKCk7XG4gIH0sIDEwMCk7XG5cbiAgaWYgKGhhdmVNdXRhdGlvbnNBcGkpIHtcbiAgICByLnN0eWxlT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihvblJlc2l6ZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgIHIuc3R5bGVPYnNlcnZlci5vYnNlcnZlKHIuY29udGFpbmVyLCB7XG4gICAgICBhdHRyaWJ1dGVzOiB0cnVlXG4gICAgfSk7XG4gIH0gLy8gYXV0byByZXNpemVcblxuXG4gIHIucmVnaXN0ZXJCaW5kaW5nKGNvbnRhaW5lcldpbmRvdywgJ3Jlc2l6ZScsIG9uUmVzaXplKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIGlmIChoYXZlUmVzaXplT2JzZXJ2ZXJBcGkpIHtcbiAgICByLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKG9uUmVzaXplKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgci5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHIuY29udGFpbmVyKTtcbiAgfVxuXG4gIHZhciBmb3JFYWNoVXAgPSBmdW5jdGlvbiBmb3JFYWNoVXAoZG9tRWxlLCBmbikge1xuICAgIHdoaWxlIChkb21FbGUgIT0gbnVsbCkge1xuICAgICAgZm4oZG9tRWxlKTtcbiAgICAgIGRvbUVsZSA9IGRvbUVsZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaW52YWxpZGF0ZUNvb3JkcyA9IGZ1bmN0aW9uIGludmFsaWRhdGVDb29yZHMoKSB7XG4gICAgci5pbnZhbGlkYXRlQ29udGFpbmVyQ2xpZW50Q29vcmRzQ2FjaGUoKTtcbiAgfTtcblxuICBmb3JFYWNoVXAoci5jb250YWluZXIsIGZ1bmN0aW9uIChkb21FbGUpIHtcbiAgICByLnJlZ2lzdGVyQmluZGluZyhkb21FbGUsICd0cmFuc2l0aW9uZW5kJywgaW52YWxpZGF0ZUNvb3Jkcyk7XG4gICAgci5yZWdpc3RlckJpbmRpbmcoZG9tRWxlLCAnYW5pbWF0aW9uZW5kJywgaW52YWxpZGF0ZUNvb3Jkcyk7XG4gICAgci5yZWdpc3RlckJpbmRpbmcoZG9tRWxlLCAnc2Nyb2xsJywgaW52YWxpZGF0ZUNvb3Jkcyk7XG4gIH0pOyAvLyBzdG9wIHJpZ2h0IGNsaWNrIG1lbnUgZnJvbSBhcHBlYXJpbmcgb24gY3lcblxuICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ2NvbnRleHRtZW51JywgZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuXG4gIHZhciBpbkJveFNlbGVjdGlvbiA9IGZ1bmN0aW9uIGluQm94U2VsZWN0aW9uKCkge1xuICAgIHJldHVybiByLnNlbGVjdGlvbls0XSAhPT0gMDtcbiAgfTtcblxuICB2YXIgZXZlbnRJbkNvbnRhaW5lciA9IGZ1bmN0aW9uIGV2ZW50SW5Db250YWluZXIoZSkge1xuICAgIC8vIHNhdmUgY3ljbGVzIGlmIG1vdXNlIGV2ZW50cyBhcmVuJ3QgdG8gYmUgY2FwdHVyZWRcbiAgICB2YXIgY29udGFpbmVyUGFnZUNvb3JkcyA9IHIuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICAgIHZhciB4ID0gY29udGFpbmVyUGFnZUNvb3Jkc1swXTtcbiAgICB2YXIgeSA9IGNvbnRhaW5lclBhZ2VDb29yZHNbMV07XG4gICAgdmFyIHdpZHRoID0gY29udGFpbmVyUGFnZUNvb3Jkc1syXTtcbiAgICB2YXIgaGVpZ2h0ID0gY29udGFpbmVyUGFnZUNvb3Jkc1szXTtcbiAgICB2YXIgcG9zaXRpb25zID0gZS50b3VjaGVzID8gZS50b3VjaGVzIDogW2VdO1xuICAgIHZhciBhdExlYXN0T25lUG9zSW5zaWRlID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSBwb3NpdGlvbnNbaV07XG5cbiAgICAgIGlmICh4IDw9IHAuY2xpZW50WCAmJiBwLmNsaWVudFggPD0geCArIHdpZHRoICYmIHkgPD0gcC5jbGllbnRZICYmIHAuY2xpZW50WSA8PSB5ICsgaGVpZ2h0KSB7XG4gICAgICAgIGF0TGVhc3RPbmVQb3NJbnNpZGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWF0TGVhc3RPbmVQb3NJbnNpZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY29udGFpbmVyID0gci5jb250YWluZXI7XG4gICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgIHZhciB0UGFyZW50ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgdmFyIGNvbnRhaW5lcklzVGFyZ2V0ID0gZmFsc2U7XG5cbiAgICB3aGlsZSAodFBhcmVudCkge1xuICAgICAgaWYgKHRQYXJlbnQgPT09IGNvbnRhaW5lcikge1xuICAgICAgICBjb250YWluZXJJc1RhcmdldCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0UGFyZW50ID0gdFBhcmVudC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIGlmICghY29udGFpbmVySXNUYXJnZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGlmIHRhcmdldCBpcyBvdXRpc2RlIGN5IGNvbnRhaW5lciwgdGhlbiB0aGlzIGV2ZW50IGlzIG5vdCBmb3IgdXNcblxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07IC8vIFByaW1hcnkga2V5XG5cblxuICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ21vdXNlZG93bicsIGZ1bmN0aW9uIG1vdXNlZG93bkhhbmRsZXIoZSkge1xuICAgIGlmICghZXZlbnRJbkNvbnRhaW5lcihlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBibHVyQWN0aXZlRG9tRWxlbWVudCgpO1xuICAgIHIuaG92ZXJEYXRhLmNhcHR1cmUgPSB0cnVlO1xuICAgIHIuaG92ZXJEYXRhLndoaWNoID0gZS53aGljaDtcbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHZhciBncG9zID0gW2UuY2xpZW50WCwgZS5jbGllbnRZXTtcbiAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGdwb3NbMF0sIGdwb3NbMV0pO1xuICAgIHZhciBzZWxlY3QgPSByLnNlbGVjdGlvbjtcbiAgICB2YXIgbmVhcnMgPSByLmZpbmROZWFyZXN0RWxlbWVudHMocG9zWzBdLCBwb3NbMV0sIHRydWUsIGZhbHNlKTtcbiAgICB2YXIgbmVhciA9IG5lYXJzWzBdO1xuICAgIHZhciBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzO1xuICAgIHIuaG92ZXJEYXRhLm1kb3duUG9zID0gcG9zO1xuICAgIHIuaG92ZXJEYXRhLm1kb3duR1BvcyA9IGdwb3M7XG5cbiAgICB2YXIgY2hlY2tGb3JUYXBob2xkID0gZnVuY3Rpb24gY2hlY2tGb3JUYXBob2xkKCkge1xuICAgICAgci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgY2xlYXJUaW1lb3V0KHIuaG92ZXJEYXRhLnRhcGhvbGRUaW1lb3V0KTtcbiAgICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbGUgPSByLmhvdmVyRGF0YS5kb3duO1xuXG4gICAgICAgICAgaWYgKGVsZSkge1xuICAgICAgICAgICAgZWxlLmVtaXQoe1xuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICB0eXBlOiAndGFwaG9sZCcsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3kuZW1pdCh7XG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICAgIHR5cGU6ICd0YXBob2xkJyxcbiAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgci50YXBob2xkRHVyYXRpb24pO1xuICAgIH07IC8vIFJpZ2h0IGNsaWNrIGJ1dHRvblxuXG5cbiAgICBpZiAoZS53aGljaCA9PSAzKSB7XG4gICAgICByLmhvdmVyRGF0YS5jeHRTdGFydGVkID0gdHJ1ZTtcbiAgICAgIHZhciBjeHRFdnQgPSB7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgIHR5cGU6ICdjeHR0YXBzdGFydCcsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAobmVhcikge1xuICAgICAgICBuZWFyLmFjdGl2YXRlKCk7XG4gICAgICAgIG5lYXIuZW1pdChjeHRFdnQpO1xuICAgICAgICByLmhvdmVyRGF0YS5kb3duID0gbmVhcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN5LmVtaXQoY3h0RXZ0KTtcbiAgICAgIH1cblxuICAgICAgci5ob3ZlckRhdGEuZG93blRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIHIuaG92ZXJEYXRhLmN4dERyYWdnZWQgPSBmYWxzZTsgLy8gUHJpbWFyeSBidXR0b25cbiAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT0gMSkge1xuICAgICAgaWYgKG5lYXIpIHtcbiAgICAgICAgbmVhci5hY3RpdmF0ZSgpO1xuICAgICAgfSAvLyBFbGVtZW50IGRyYWdnaW5nXG5cblxuICAgICAge1xuICAgICAgICAvLyBJZiBzb21ldGhpbmcgaXMgdW5kZXIgdGhlIGN1cnNvciBhbmQgaXQgaXMgZHJhZ2dhYmxlLCBwcmVwYXJlIHRvIGdyYWIgaXRcbiAgICAgICAgaWYgKG5lYXIgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyLm5vZGVJc0dyYWJiYWJsZShuZWFyKSkge1xuICAgICAgICAgICAgdmFyIG1ha2VFdmVudCA9IGZ1bmN0aW9uIG1ha2VFdmVudCh0eXBlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgdHJpZ2dlckdyYWIgPSBmdW5jdGlvbiB0cmlnZ2VyR3JhYihlbGUpIHtcbiAgICAgICAgICAgICAgZWxlLmVtaXQobWFrZUV2ZW50KCdncmFiJykpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc2V0R3JhYlRhcmdldChuZWFyKTtcblxuICAgICAgICAgICAgaWYgKCFuZWFyLnNlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgYWRkTm9kZVRvRHJhZyhuZWFyLCB7XG4gICAgICAgICAgICAgICAgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlbWVudHNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG5lYXIuZW1pdChtYWtlRXZlbnQoJ2dyYWJvbicpKS5lbWl0KG1ha2VFdmVudCgnZ3JhYicpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgICAgICAgIHZhciBzZWxlY3RlZE5vZGVzID0gY3kuJChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUuc2VsZWN0ZWQoKSAmJiByLm5vZGVJc0dyYWJiYWJsZShlbGUpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYWRkTm9kZXNUb0RyYWcoc2VsZWN0ZWROb2Rlcywge1xuICAgICAgICAgICAgICAgIGFkZFRvTGlzdDogZHJhZ2dlZEVsZW1lbnRzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBuZWFyLmVtaXQobWFrZUV2ZW50KCdncmFib24nKSk7XG4gICAgICAgICAgICAgIHNlbGVjdGVkTm9kZXMuZm9yRWFjaCh0cmlnZ2VyR3JhYik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgci5ob3ZlckRhdGEuZG93biA9IG5lYXI7XG4gICAgICAgIHIuaG92ZXJEYXRhLmRvd25zID0gbmVhcnM7XG4gICAgICAgIHIuaG92ZXJEYXRhLmRvd25UaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICB9XG4gICAgICB0cmlnZ2VyRXZlbnRzKG5lYXIsIFsnbW91c2Vkb3duJywgJ3RhcHN0YXJ0JywgJ3Ztb3VzZWRvd24nXSwgZSwge1xuICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgIHk6IHBvc1sxXVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChuZWFyID09IG51bGwpIHtcbiAgICAgICAgc2VsZWN0WzRdID0gMTtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0ge1xuICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgfTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH0gZWxzZSBpZiAobmVhci5wYW5uYWJsZSgpKSB7XG4gICAgICAgIHNlbGVjdFs0XSA9IDE7IC8vIGZvciBmdXR1cmUgcGFuXG4gICAgICB9XG5cbiAgICAgIGNoZWNrRm9yVGFwaG9sZCgpO1xuICAgIH0gLy8gSW5pdGlhbGl6ZSBzZWxlY3Rpb24gYm94IGNvb3JkaW5hdGVzXG5cblxuICAgIHNlbGVjdFswXSA9IHNlbGVjdFsyXSA9IHBvc1swXTtcbiAgICBzZWxlY3RbMV0gPSBzZWxlY3RbM10gPSBwb3NbMV07XG4gIH0sIGZhbHNlKTtcbiAgci5yZWdpc3RlckJpbmRpbmcoY29udGFpbmVyV2luZG93LCAnbW91c2Vtb3ZlJywgZnVuY3Rpb24gbW91c2Vtb3ZlSGFuZGxlcihlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHZhciBjYXB0dXJlID0gci5ob3ZlckRhdGEuY2FwdHVyZTtcblxuICAgIGlmICghY2FwdHVyZSAmJiAhZXZlbnRJbkNvbnRhaW5lcihlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIGdwb3MgPSBbZS5jbGllbnRYLCBlLmNsaWVudFldO1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZ3Bvc1swXSwgZ3Bvc1sxXSk7XG4gICAgdmFyIG1kb3duUG9zID0gci5ob3ZlckRhdGEubWRvd25Qb3M7XG4gICAgdmFyIG1kb3duR1BvcyA9IHIuaG92ZXJEYXRhLm1kb3duR1BvcztcbiAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG4gICAgdmFyIG5lYXIgPSBudWxsO1xuXG4gICAgaWYgKCFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgJiYgIXIuaG92ZXJEYXRhLmRyYWdnaW5nICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChwb3NbMF0sIHBvc1sxXSwgdHJ1ZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBsYXN0ID0gci5ob3ZlckRhdGEubGFzdDtcbiAgICB2YXIgZG93biA9IHIuaG92ZXJEYXRhLmRvd247XG4gICAgdmFyIGRpc3AgPSBbcG9zWzBdIC0gc2VsZWN0WzJdLCBwb3NbMV0gLSBzZWxlY3RbM11dO1xuICAgIHZhciBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzO1xuICAgIHZhciBpc092ZXJUaHJlc2hvbGREcmFnO1xuXG4gICAgaWYgKG1kb3duR1Bvcykge1xuICAgICAgdmFyIGR4ID0gZ3Bvc1swXSAtIG1kb3duR1Bvc1swXTtcbiAgICAgIHZhciBkeDIgPSBkeCAqIGR4O1xuICAgICAgdmFyIGR5ID0gZ3Bvc1sxXSAtIG1kb3duR1Bvc1sxXTtcbiAgICAgIHZhciBkeTIgPSBkeSAqIGR5O1xuICAgICAgdmFyIGRpc3QyID0gZHgyICsgZHkyO1xuICAgICAgci5ob3ZlckRhdGEuaXNPdmVyVGhyZXNob2xkRHJhZyA9IGlzT3ZlclRocmVzaG9sZERyYWcgPSBkaXN0MiA+PSByLmRlc2t0b3BUYXBUaHJlc2hvbGQyO1xuICAgIH1cblxuICAgIHZhciBtdWx0U2VsS2V5RG93biA9IGlzTXVsdFNlbEtleURvd24oZSk7XG5cbiAgICBpZiAoaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZURyYWdEZWx0YSA9IGZ1bmN0aW9uIHVwZGF0ZURyYWdEZWx0YSgpIHtcbiAgICAgIHZhciBkcmFnRGVsdGEgPSByLmhvdmVyRGF0YS5kcmFnRGVsdGEgPSByLmhvdmVyRGF0YS5kcmFnRGVsdGEgfHwgW107XG5cbiAgICAgIGlmIChkcmFnRGVsdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRyYWdEZWx0YS5wdXNoKGRpc3BbMF0pO1xuICAgICAgICBkcmFnRGVsdGEucHVzaChkaXNwWzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRyYWdEZWx0YVswXSArPSBkaXNwWzBdO1xuICAgICAgICBkcmFnRGVsdGFbMV0gKz0gZGlzcFsxXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgIHRyaWdnZXJFdmVudHMobmVhciwgWydtb3VzZW1vdmUnLCAndm1vdXNlbW92ZScsICd0YXBkcmFnJ10sIGUsIHtcbiAgICAgIHg6IHBvc1swXSxcbiAgICAgIHk6IHBvc1sxXVxuICAgIH0pO1xuXG4gICAgdmFyIGdvSW50b0JveE1vZGUgPSBmdW5jdGlvbiBnb0ludG9Cb3hNb2RlKCkge1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoIXIuaG92ZXJEYXRhLnNlbGVjdGluZykge1xuICAgICAgICBjeS5lbWl0KHtcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgIHR5cGU6ICdib3hzdGFydCcsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGVjdFs0XSA9IDE7XG4gICAgICByLmhvdmVyRGF0YS5zZWxlY3RpbmcgPSB0cnVlO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfTsgLy8gdHJpZ2dlciBjb250ZXh0IGRyYWcgaWYgcm1vdXNlIGRvd25cblxuXG4gICAgaWYgKHIuaG92ZXJEYXRhLndoaWNoID09PSAzKSB7XG4gICAgICAvLyBidXQgb25seSBpZiBvdmVyIHRocmVzaG9sZFxuICAgICAgaWYgKGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgICAgdmFyIGN4dEV2dCA9IHtcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgIHR5cGU6ICdjeHRkcmFnJyxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChkb3duKSB7XG4gICAgICAgICAgZG93bi5lbWl0KGN4dEV2dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kuZW1pdChjeHRFdnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKCFyLmhvdmVyRGF0YS5jeHRPdmVyIHx8IG5lYXIgIT09IHIuaG92ZXJEYXRhLmN4dE92ZXIpIHtcbiAgICAgICAgICBpZiAoci5ob3ZlckRhdGEuY3h0T3Zlcikge1xuICAgICAgICAgICAgci5ob3ZlckRhdGEuY3h0T3Zlci5lbWl0KHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdXQnLFxuICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci5ob3ZlckRhdGEuY3h0T3ZlciA9IG5lYXI7XG5cbiAgICAgICAgICBpZiAobmVhcikge1xuICAgICAgICAgICAgbmVhci5lbWl0KHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdmVyJyxcbiAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBDaGVjayBpZiB3ZSBhcmUgZHJhZyBwYW5uaW5nIHRoZSBlbnRpcmUgZ3JhcGhcblxuICAgIH0gZWxzZSBpZiAoci5ob3ZlckRhdGEuZHJhZ2dpbmcpIHtcbiAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcblxuICAgICAgaWYgKGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkpIHtcbiAgICAgICAgdmFyIGRlbHRhUDtcblxuICAgICAgICBpZiAoci5ob3ZlckRhdGEuanVzdFN0YXJ0ZWRQYW4pIHtcbiAgICAgICAgICB2YXIgbWRQb3MgPSByLmhvdmVyRGF0YS5tZG93blBvcztcbiAgICAgICAgICBkZWx0YVAgPSB7XG4gICAgICAgICAgICB4OiAocG9zWzBdIC0gbWRQb3NbMF0pICogem9vbSxcbiAgICAgICAgICAgIHk6IChwb3NbMV0gLSBtZFBvc1sxXSkgKiB6b29tXG4gICAgICAgICAgfTtcbiAgICAgICAgICByLmhvdmVyRGF0YS5qdXN0U3RhcnRlZFBhbiA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbHRhUCA9IHtcbiAgICAgICAgICAgIHg6IGRpc3BbMF0gKiB6b29tLFxuICAgICAgICAgICAgeTogZGlzcFsxXSAqIHpvb21cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY3kucGFuQnkoZGVsdGFQKTtcbiAgICAgICAgY3kuZW1pdCgnZHJhZ3BhbicpO1xuICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2VkID0gdHJ1ZTtcbiAgICAgIH0gLy8gTmVlZHMgcmVwcm9qZWN0IGR1ZSB0byBwYW4gY2hhbmdpbmcgdmlld3BvcnRcblxuXG4gICAgICBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpOyAvLyBDaGVja3MgcHJpbWFyeSBidXR0b24gZG93biAmIG91dCBvZiB0aW1lICYgbW91c2Ugbm90IG1vdmVkIG11Y2hcbiAgICB9IGVsc2UgaWYgKHNlbGVjdFs0XSA9PSAxICYmIChkb3duID09IG51bGwgfHwgZG93bi5wYW5uYWJsZSgpKSkge1xuICAgICAgaWYgKGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgICAgaWYgKCFyLmhvdmVyRGF0YS5kcmFnZ2luZyAmJiBjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgJiYgKG11bHRTZWxLZXlEb3duIHx8ICFjeS5wYW5uaW5nRW5hYmxlZCgpIHx8ICFjeS51c2VyUGFubmluZ0VuYWJsZWQoKSkpIHtcbiAgICAgICAgICBnb0ludG9Cb3hNb2RlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXIuaG92ZXJEYXRhLnNlbGVjdGluZyAmJiBjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpKSB7XG4gICAgICAgICAgdmFyIGFsbG93UGFzc3Rocm91Z2ggPSBhbGxvd1Bhbm5pbmdQYXNzdGhyb3VnaChkb3duLCByLmhvdmVyRGF0YS5kb3ducyk7XG5cbiAgICAgICAgICBpZiAoYWxsb3dQYXNzdGhyb3VnaCkge1xuICAgICAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgci5ob3ZlckRhdGEuanVzdFN0YXJ0ZWRQYW4gPSB0cnVlO1xuICAgICAgICAgICAgc2VsZWN0WzRdID0gMDtcbiAgICAgICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IGFycmF5MnBvaW50KG1kb3duUG9zKTtcbiAgICAgICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb3duICYmIGRvd24ucGFubmFibGUoKSAmJiBkb3duLmFjdGl2ZSgpKSB7XG4gICAgICAgICAgZG93bi51bmFjdGl2YXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRvd24gJiYgZG93bi5wYW5uYWJsZSgpICYmIGRvd24uYWN0aXZlKCkpIHtcbiAgICAgICAgZG93bi51bmFjdGl2YXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICgoIWRvd24gfHwgIWRvd24uZ3JhYmJlZCgpKSAmJiBuZWFyICE9IGxhc3QpIHtcbiAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICB0cmlnZ2VyRXZlbnRzKGxhc3QsIFsnbW91c2VvdXQnLCAndGFwZHJhZ291dCddLCBlLCB7XG4gICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZWFyKSB7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50cyhuZWFyLCBbJ21vdXNlb3ZlcicsICd0YXBkcmFnb3ZlciddLCBlLCB7XG4gICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIuaG92ZXJEYXRhLmxhc3QgPSBuZWFyO1xuICAgICAgfVxuXG4gICAgICBpZiAoZG93bikge1xuICAgICAgICBpZiAoaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgICAgIC8vIHRoZW4gd2UgY2FuIHRha2UgYWN0aW9uXG4gICAgICAgICAgaWYgKGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSAmJiBtdWx0U2VsS2V5RG93bikge1xuICAgICAgICAgICAgLy8gdGhlbiBzZWxlY3Rpb24gb3ZlcnJpZGVzXG4gICAgICAgICAgICBpZiAoZG93biAmJiBkb3duLmdyYWJiZWQoKSkge1xuICAgICAgICAgICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKGRyYWdnZWRFbGVtZW50cyk7XG4gICAgICAgICAgICAgIGRvd24uZW1pdCgnZnJlZW9uJyk7XG4gICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cy5lbWl0KCdmcmVlJyk7XG5cbiAgICAgICAgICAgICAgaWYgKHIuZHJhZ0RhdGEuZGlkRHJhZykge1xuICAgICAgICAgICAgICAgIGRvd24uZW1pdCgnZHJhZ2ZyZWVvbicpO1xuICAgICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cy5lbWl0KCdkcmFnZnJlZScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdvSW50b0JveE1vZGUoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRvd24gJiYgZG93bi5ncmFiYmVkKCkgJiYgci5ub2RlSXNEcmFnZ2FibGUoZG93bikpIHtcbiAgICAgICAgICAgIC8vIGRyYWcgbm9kZVxuICAgICAgICAgICAgdmFyIGp1c3RTdGFydGVkRHJhZyA9ICFyLmRyYWdEYXRhLmRpZERyYWc7XG5cbiAgICAgICAgICAgIGlmIChqdXN0U3RhcnRlZERyYWcpIHtcbiAgICAgICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IHRydWU7IC8vIGluZGljYXRlIHRoYXQgd2UgYWN0dWFsbHkgZGlkIGRyYWcgdGhlIG5vZGVcbiAgICAgICAgICAgIC8vIG5vdywgYWRkIHRoZSBlbGVtZW50cyB0byB0aGUgZHJhZyBsYXllciBpZiBub3QgZG9uZSBhbHJlYWR5XG5cbiAgICAgICAgICAgIGlmICghci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzKSB7XG4gICAgICAgICAgICAgIGFkZE5vZGVzVG9EcmFnKGRyYWdnZWRFbGVtZW50cywge1xuICAgICAgICAgICAgICAgIGluRHJhZ0xheWVyOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG90YWxTaGlmdCA9IHtcbiAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKG51bWJlciQxKGRpc3BbMF0pICYmIG51bWJlciQxKGRpc3BbMV0pKSB7XG4gICAgICAgICAgICAgIHRvdGFsU2hpZnQueCArPSBkaXNwWzBdO1xuICAgICAgICAgICAgICB0b3RhbFNoaWZ0LnkgKz0gZGlzcFsxXTtcblxuICAgICAgICAgICAgICBpZiAoanVzdFN0YXJ0ZWREcmFnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRyYWdEZWx0YSA9IHIuaG92ZXJEYXRhLmRyYWdEZWx0YTtcblxuICAgICAgICAgICAgICAgIGlmIChkcmFnRGVsdGEgJiYgbnVtYmVyJDEoZHJhZ0RlbHRhWzBdKSAmJiBudW1iZXIkMShkcmFnRGVsdGFbMV0pKSB7XG4gICAgICAgICAgICAgICAgICB0b3RhbFNoaWZ0LnggKz0gZHJhZ0RlbHRhWzBdO1xuICAgICAgICAgICAgICAgICAgdG90YWxTaGlmdC55ICs9IGRyYWdEZWx0YVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cy5zaWxlbnRTaGlmdCh0b3RhbFNoaWZ0KS5lbWl0KCdwb3NpdGlvbiBkcmFnJyk7XG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG90aGVyd2lzZSBzYXZlIGRyYWcgZGVsdGEgZm9yIHdoZW4gd2UgYWN0dWFsbHkgc3RhcnQgZHJhZ2dpbmcgc28gdGhlIHJlbGF0aXZlIGdyYWIgcG9zIGlzIGNvbnN0YW50XG4gICAgICAgICAgdXBkYXRlRHJhZ0RlbHRhKCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gcHJldmVudCB0aGUgZHJhZ2dpbmcgZnJvbSB0cmlnZ2VyaW5nIHRleHQgc2VsZWN0aW9uIG9uIHRoZSBwYWdlXG5cblxuICAgICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgIH1cblxuICAgIHNlbGVjdFsyXSA9IHBvc1swXTtcbiAgICBzZWxlY3RbM10gPSBwb3NbMV07XG5cbiAgICBpZiAocHJldmVudERlZmF1bHQpIHtcbiAgICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCBmYWxzZSk7XG4gIHZhciBjbGlja1RpbWVvdXQsIGRpZERvdWJsZUNsaWNrLCBwcmV2Q2xpY2tUaW1lU3RhbXA7XG4gIHIucmVnaXN0ZXJCaW5kaW5nKGNvbnRhaW5lcldpbmRvdywgJ21vdXNldXAnLCBmdW5jdGlvbiBtb3VzZXVwSGFuZGxlcihlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHZhciBjYXB0dXJlID0gci5ob3ZlckRhdGEuY2FwdHVyZTtcblxuICAgIGlmICghY2FwdHVyZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHIuaG92ZXJEYXRhLmNhcHR1cmUgPSBmYWxzZTtcbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgIHZhciBzZWxlY3QgPSByLnNlbGVjdGlvbjtcbiAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KHBvc1swXSwgcG9zWzFdLCB0cnVlLCBmYWxzZSk7XG4gICAgdmFyIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHM7XG4gICAgdmFyIGRvd24gPSByLmhvdmVyRGF0YS5kb3duO1xuICAgIHZhciBtdWx0U2VsS2V5RG93biA9IGlzTXVsdFNlbEtleURvd24oZSk7XG5cbiAgICBpZiAoci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uKSB7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgci5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICByLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7IC8vIG5vdCBhY3RpdmUgYmcgbm93XG5cbiAgICBpZiAoZG93bikge1xuICAgICAgZG93bi51bmFjdGl2YXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKHIuaG92ZXJEYXRhLndoaWNoID09PSAzKSB7XG4gICAgICB2YXIgY3h0RXZ0ID0ge1xuICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICB0eXBlOiAnY3h0dGFwZW5kJyxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChkb3duKSB7XG4gICAgICAgIGRvd24uZW1pdChjeHRFdnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3kuZW1pdChjeHRFdnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXIuaG92ZXJEYXRhLmN4dERyYWdnZWQpIHtcbiAgICAgICAgdmFyIGN4dFRhcCA9IHtcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgIHR5cGU6ICdjeHR0YXAnLFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGRvd24pIHtcbiAgICAgICAgICBkb3duLmVtaXQoY3h0VGFwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS5lbWl0KGN4dFRhcCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgci5ob3ZlckRhdGEud2hpY2ggPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoci5ob3ZlckRhdGEud2hpY2ggPT09IDEpIHtcbiAgICAgIHRyaWdnZXJFdmVudHMobmVhciwgWydtb3VzZXVwJywgJ3RhcGVuZCcsICd2bW91c2V1cCddLCBlLCB7XG4gICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgeTogcG9zWzFdXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyLmRyYWdEYXRhLmRpZERyYWcgJiYgLy8gZGlkbid0IG1vdmUgYSBub2RlIGFyb3VuZFxuICAgICAgIXIuaG92ZXJEYXRhLmRyYWdnZWQgJiYgLy8gZGlkbid0IHBhblxuICAgICAgIXIuaG92ZXJEYXRhLnNlbGVjdGluZyAmJiAvLyBub3QgYm94IHNlbGVjdGlvblxuICAgICAgIXIuaG92ZXJEYXRhLmlzT3ZlclRocmVzaG9sZERyYWcgLy8gZGlkbid0IG1vdmUgdG9vIG11Y2hcbiAgICAgICkge1xuICAgICAgICB0cmlnZ2VyRXZlbnRzKGRvd24sIFtcImNsaWNrXCIsIFwidGFwXCIsIFwidmNsaWNrXCJdLCBlLCB7XG4gICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICB9KTtcbiAgICAgICAgZGlkRG91YmxlQ2xpY2sgPSBmYWxzZTtcblxuICAgICAgICBpZiAoZS50aW1lU3RhbXAgLSBwcmV2Q2xpY2tUaW1lU3RhbXAgPD0gY3kubXVsdGlDbGlja0RlYm91bmNlVGltZSgpKSB7XG4gICAgICAgICAgY2xpY2tUaW1lb3V0ICYmIGNsZWFyVGltZW91dChjbGlja1RpbWVvdXQpO1xuICAgICAgICAgIGRpZERvdWJsZUNsaWNrID0gdHJ1ZTtcbiAgICAgICAgICBwcmV2Q2xpY2tUaW1lU3RhbXAgPSBudWxsO1xuICAgICAgICAgIHRyaWdnZXJFdmVudHMoZG93biwgW1wiZGJsY2xpY2tcIiwgXCJkYmx0YXBcIiwgXCJ2ZGJsY2xpY2tcIl0sIGUsIHtcbiAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsaWNrVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRpZERvdWJsZUNsaWNrKSByZXR1cm47XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnRzKGRvd24sIFtcIm9uZWNsaWNrXCIsIFwib25ldGFwXCIsIFwidm9uZWNsaWNrXCJdLCBlLCB7XG4gICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCBjeS5tdWx0aUNsaWNrRGVib3VuY2VUaW1lKCkpO1xuICAgICAgICAgIHByZXZDbGlja1RpbWVTdGFtcCA9IGUudGltZVN0YW1wO1xuICAgICAgICB9XG4gICAgICB9IC8vIERlc2VsZWN0IGFsbCBlbGVtZW50cyBpZiBub3RoaW5nIGlzIGN1cnJlbnRseSB1bmRlciB0aGUgbW91c2UgY3Vyc29yIGFuZCB3ZSBhcmVuJ3QgZHJhZ2dpbmcgc29tZXRoaW5nXG5cblxuICAgICAgaWYgKGRvd24gPT0gbnVsbCAvLyBub3QgbW91c2Vkb3duIG9uIG5vZGVcbiAgICAgICYmICFyLmRyYWdEYXRhLmRpZERyYWcgLy8gZGlkbid0IG1vdmUgdGhlIG5vZGUgYXJvdW5kXG4gICAgICAmJiAhci5ob3ZlckRhdGEuc2VsZWN0aW5nIC8vIG5vdCBib3ggc2VsZWN0aW9uXG4gICAgICAmJiAhci5ob3ZlckRhdGEuZHJhZ2dlZCAvLyBkaWRuJ3QgcGFuXG4gICAgICAmJiAhaXNNdWx0U2VsS2V5RG93bihlKSkge1xuICAgICAgICBjeS4kKGlzU2VsZWN0ZWQpLnVuc2VsZWN0KFsndGFwdW5zZWxlY3QnXSk7XG5cbiAgICAgICAgaWYgKGRyYWdnZWRFbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzID0gZHJhZ2dlZEVsZW1lbnRzID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgfSAvLyBTaW5nbGUgc2VsZWN0aW9uXG5cblxuICAgICAgaWYgKG5lYXIgPT0gZG93biAmJiAhci5kcmFnRGF0YS5kaWREcmFnICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgICAgaWYgKG5lYXIgIT0gbnVsbCAmJiBuZWFyLl9wcml2YXRlLnNlbGVjdGFibGUpIHtcbiAgICAgICAgICBpZiAoci5ob3ZlckRhdGEuZHJhZ2dpbmcpIDsgZWxzZSBpZiAoY3kuc2VsZWN0aW9uVHlwZSgpID09PSAnYWRkaXRpdmUnIHx8IG11bHRTZWxLZXlEb3duKSB7XG4gICAgICAgICAgICBpZiAobmVhci5zZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICAgIG5lYXIudW5zZWxlY3QoWyd0YXB1bnNlbGVjdCddKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5lYXIuc2VsZWN0KFsndGFwc2VsZWN0J10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW11bHRTZWxLZXlEb3duKSB7XG4gICAgICAgICAgICAgIGN5LiQoaXNTZWxlY3RlZCkudW5tZXJnZShuZWFyKS51bnNlbGVjdChbJ3RhcHVuc2VsZWN0J10pO1xuICAgICAgICAgICAgICBuZWFyLnNlbGVjdChbJ3RhcHNlbGVjdCddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoci5ob3ZlckRhdGEuc2VsZWN0aW5nKSB7XG4gICAgICAgIHZhciBib3ggPSBjeS5jb2xsZWN0aW9uKHIuZ2V0QWxsSW5Cb3goc2VsZWN0WzBdLCBzZWxlY3RbMV0sIHNlbGVjdFsyXSwgc2VsZWN0WzNdKSk7XG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKGJveC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjeS5lbWl0KHtcbiAgICAgICAgICB0eXBlOiAnYm94ZW5kJyxcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBlbGVXb3VsZEJlU2VsZWN0ZWQgPSBmdW5jdGlvbiBlbGVXb3VsZEJlU2VsZWN0ZWQoZWxlKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZS5zZWxlY3RhYmxlKCkgJiYgIWVsZS5zZWxlY3RlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChjeS5zZWxlY3Rpb25UeXBlKCkgPT09ICdhZGRpdGl2ZScpIHtcbiAgICAgICAgICBib3guZW1pdCgnYm94Jykuc3RkRmlsdGVyKGVsZVdvdWxkQmVTZWxlY3RlZCkuc2VsZWN0KCkuZW1pdCgnYm94c2VsZWN0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFtdWx0U2VsS2V5RG93bikge1xuICAgICAgICAgICAgY3kuJChpc1NlbGVjdGVkKS51bm1lcmdlKGJveCkudW5zZWxlY3QoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBib3guZW1pdCgnYm94Jykuc3RkRmlsdGVyKGVsZVdvdWxkQmVTZWxlY3RlZCkuc2VsZWN0KCkuZW1pdCgnYm94c2VsZWN0Jyk7XG4gICAgICAgIH0gLy8gYWx3YXlzIG5lZWQgcmVkcmF3IGluIGNhc2UgZWxlcyB1bnNlbGVjdGFibGVcblxuXG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9IC8vIENhbmNlbCBkcmFnIHBhblxuXG5cbiAgICAgIGlmIChyLmhvdmVyRGF0YS5kcmFnZ2luZykge1xuICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzZWxlY3RbNF0pIHtcbiAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICB2YXIgZG93bldhc0dyYWJiZWQgPSBkb3duICYmIGRvd24uZ3JhYmJlZCgpO1xuICAgICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKGRyYWdnZWRFbGVtZW50cyk7XG5cbiAgICAgICAgaWYgKGRvd25XYXNHcmFiYmVkKSB7XG4gICAgICAgICAgZG93bi5lbWl0KCdmcmVlb24nKTtcbiAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMuZW1pdCgnZnJlZScpO1xuXG4gICAgICAgICAgaWYgKHIuZHJhZ0RhdGEuZGlkRHJhZykge1xuICAgICAgICAgICAgZG93bi5lbWl0KCdkcmFnZnJlZW9uJyk7XG4gICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMuZW1pdCgnZHJhZ2ZyZWUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIGVsc2Ugbm90IHJpZ2h0IG1vdXNlXG5cblxuICAgIHNlbGVjdFs0XSA9IDA7XG4gICAgci5ob3ZlckRhdGEuZG93biA9IG51bGw7XG4gICAgci5ob3ZlckRhdGEuY3h0U3RhcnRlZCA9IGZhbHNlO1xuICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IGZhbHNlO1xuICAgIHIuaG92ZXJEYXRhLnNlbGVjdGluZyA9IGZhbHNlO1xuICAgIHIuaG92ZXJEYXRhLmlzT3ZlclRocmVzaG9sZERyYWcgPSBmYWxzZTtcbiAgICByLmRyYWdEYXRhLmRpZERyYWcgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5kcmFnZ2VkID0gZmFsc2U7XG4gICAgci5ob3ZlckRhdGEuZHJhZ0RlbHRhID0gW107XG4gICAgci5ob3ZlckRhdGEubWRvd25Qb3MgPSBudWxsO1xuICAgIHIuaG92ZXJEYXRhLm1kb3duR1BvcyA9IG51bGw7XG4gIH0sIGZhbHNlKTtcblxuICB2YXIgd2hlZWxIYW5kbGVyID0gZnVuY3Rpb24gd2hlZWxIYW5kbGVyKGUpIHtcbiAgICBpZiAoci5zY3JvbGxpbmdQYWdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyB3aGlsZSBzY3JvbGxpbmcsIGlnbm9yZSB3aGVlbC10by16b29tXG5cblxuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgIHZhciBycG9zID0gW3Bvc1swXSAqIHpvb20gKyBwYW4ueCwgcG9zWzFdICogem9vbSArIHBhbi55XTtcblxuICAgIGlmIChyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmcgfHwgci5ob3ZlckRhdGEuY3h0U3RhcnRlZCB8fCBpbkJveFNlbGVjdGlvbigpKSB7XG4gICAgICAvLyBpZiBwYW4gZHJhZ2dpbmcgb3IgY3h0IGRyYWdnaW5nLCB3aGVlbCBtb3ZlbWVudHMgbWFrZSBubyB6b29tXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkgJiYgY3kuem9vbWluZ0VuYWJsZWQoKSAmJiBjeS51c2VyWm9vbWluZ0VuYWJsZWQoKSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgci5kYXRhLndoZWVsWm9vbWluZyA9IHRydWU7XG4gICAgICBjbGVhclRpbWVvdXQoci5kYXRhLndoZWVsVGltZW91dCk7XG4gICAgICByLmRhdGEud2hlZWxUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHIuZGF0YS53aGVlbFpvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9LCAxNTApO1xuICAgICAgdmFyIGRpZmY7XG5cbiAgICAgIGlmIChlLmRlbHRhWSAhPSBudWxsKSB7XG4gICAgICAgIGRpZmYgPSBlLmRlbHRhWSAvIC0yNTA7XG4gICAgICB9IGVsc2UgaWYgKGUud2hlZWxEZWx0YVkgIT0gbnVsbCkge1xuICAgICAgICBkaWZmID0gZS53aGVlbERlbHRhWSAvIDEwMDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWZmID0gZS53aGVlbERlbHRhIC8gMTAwMDtcbiAgICAgIH1cblxuICAgICAgZGlmZiA9IGRpZmYgKiByLndoZWVsU2Vuc2l0aXZpdHk7XG4gICAgICB2YXIgbmVlZHNXaGVlbEZpeCA9IGUuZGVsdGFNb2RlID09PSAxO1xuXG4gICAgICBpZiAobmVlZHNXaGVlbEZpeCkge1xuICAgICAgICAvLyBmaXhlcyBzbG93IHdoZWVsIGV2ZW50cyBvbiBmZi9saW51eCBhbmQgZmYvd2luZG93c1xuICAgICAgICBkaWZmICo9IDMzO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3Wm9vbSA9IGN5Lnpvb20oKSAqIE1hdGgucG93KDEwLCBkaWZmKTtcblxuICAgICAgaWYgKGUudHlwZSA9PT0gJ2dlc3R1cmVjaGFuZ2UnKSB7XG4gICAgICAgIG5ld1pvb20gPSByLmdlc3R1cmVTdGFydFpvb20gKiBlLnNjYWxlO1xuICAgICAgfVxuXG4gICAgICBjeS56b29tKHtcbiAgICAgICAgbGV2ZWw6IG5ld1pvb20sXG4gICAgICAgIHJlbmRlcmVkUG9zaXRpb246IHtcbiAgICAgICAgICB4OiBycG9zWzBdLFxuICAgICAgICAgIHk6IHJwb3NbMV1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjeS5lbWl0KGUudHlwZSA9PT0gJ2dlc3R1cmVjaGFuZ2UnID8gJ3BpbmNoem9vbScgOiAnc2Nyb2xsem9vbScpO1xuICAgIH1cbiAgfTsgLy8gRnVuY3Rpb25zIHRvIGhlbHAgd2l0aCB3aGV0aGVyIG1vdXNlIHdoZWVsIHNob3VsZCB0cmlnZ2VyIHpvb21pbmdcbiAgLy8gLS1cblxuXG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnd2hlZWwnLCB3aGVlbEhhbmRsZXIsIHRydWUpOyAvLyBkaXNhYmxlIG5vbnN0YW5kYXJkIHdoZWVsIGV2ZW50c1xuICAvLyByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ21vdXNld2hlZWwnLCB3aGVlbEhhbmRsZXIsIHRydWUpO1xuICAvLyByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ0RPTU1vdXNlU2Nyb2xsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTtcbiAgLy8gci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdNb3pNb3VzZVBpeGVsU2Nyb2xsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTsgLy8gb2xkZXIgZmlyZWZveFxuXG4gIHIucmVnaXN0ZXJCaW5kaW5nKGNvbnRhaW5lcldpbmRvdywgJ3Njcm9sbCcsIGZ1bmN0aW9uIHNjcm9sbEhhbmRsZXIoZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICByLnNjcm9sbGluZ1BhZ2UgPSB0cnVlO1xuICAgIGNsZWFyVGltZW91dChyLnNjcm9sbGluZ1BhZ2VUaW1lb3V0KTtcbiAgICByLnNjcm9sbGluZ1BhZ2VUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByLnNjcm9sbGluZ1BhZ2UgPSBmYWxzZTtcbiAgICB9LCAyNTApO1xuICB9LCB0cnVlKTsgLy8gZGVza3RvcCBzYWZhcmkgcGluY2ggdG8gem9vbSBzdGFydFxuXG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnZ2VzdHVyZXN0YXJ0JywgZnVuY3Rpb24gZ2VzdHVyZVN0YXJ0SGFuZGxlcihlKSB7XG4gICAgci5nZXN0dXJlU3RhcnRab29tID0gci5jeS56b29tKCk7XG5cbiAgICBpZiAoIXIuaGFzVG91Y2hTdGFydGVkKSB7XG4gICAgICAvLyBkb24ndCBhZmZlY3QgdG91Y2ggZGV2aWNlcyBsaWtlIGlwaG9uZVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSwgdHJ1ZSk7XG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnZ2VzdHVyZWNoYW5nZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKCFyLmhhc1RvdWNoU3RhcnRlZCkge1xuICAgICAgLy8gZG9uJ3QgYWZmZWN0IHRvdWNoIGRldmljZXMgbGlrZSBpcGhvbmVcbiAgICAgIHdoZWVsSGFuZGxlcihlKTtcbiAgICB9XG4gIH0sIHRydWUpOyAvLyBGdW5jdGlvbnMgdG8gaGVscCB3aXRoIGhhbmRsaW5nIG1vdXNlb3V0L21vdXNlb3ZlciBvbiB0aGUgQ3l0b3NjYXBlIGNvbnRhaW5lclxuICAvLyBIYW5kbGUgbW91c2VvdXQgb24gQ3l0b3NjYXBlIGNvbnRhaW5lclxuXG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnbW91c2VvdXQnLCBmdW5jdGlvbiBtb3VzZU91dEhhbmRsZXIoZSkge1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgIHIuY3kuZW1pdCh7XG4gICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgdHlwZTogJ21vdXNlb3V0JyxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgeTogcG9zWzFdXG4gICAgICB9XG4gICAgfSk7XG4gIH0sIGZhbHNlKTtcbiAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdtb3VzZW92ZXInLCBmdW5jdGlvbiBtb3VzZU92ZXJIYW5kbGVyKGUpIHtcbiAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICByLmN5LmVtaXQoe1xuICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgIHR5cGU6ICdtb3VzZW92ZXInLFxuICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICB5OiBwb3NbMV1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgZmFsc2UpO1xuICB2YXIgZjF4MSwgZjF5MSwgZjJ4MSwgZjJ5MTsgLy8gc3RhcnRpbmcgcG9pbnRzIGZvciBwaW5jaC10by16b29tXG5cbiAgdmFyIGRpc3RhbmNlMSwgZGlzdGFuY2UxU3E7IC8vIGluaXRpYWwgZGlzdGFuY2UgYmV0d2VlbiBmaW5nZXIgMSBhbmQgZmluZ2VyIDIgZm9yIHBpbmNoLXRvLXpvb21cblxuICB2YXIgY2VudGVyMSwgbW9kZWxDZW50ZXIxOyAvLyBjZW50ZXIgcG9pbnQgb24gc3RhcnQgcGluY2ggdG8gem9vbVxuXG4gIHZhciBvZmZzZXRMZWZ0LCBvZmZzZXRUb3A7XG4gIHZhciBjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0O1xuICB2YXIgdHdvRmluZ2Vyc1N0YXJ0SW5zaWRlO1xuXG4gIHZhciBkaXN0YW5jZSA9IGZ1bmN0aW9uIGRpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCgoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSkpO1xuICB9O1xuXG4gIHZhciBkaXN0YW5jZVNxID0gZnVuY3Rpb24gZGlzdGFuY2VTcSh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiAoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSk7XG4gIH07XG5cbiAgdmFyIHRvdWNoc3RhcnRIYW5kbGVyO1xuICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0b3VjaHN0YXJ0SGFuZGxlciA9IGZ1bmN0aW9uIHRvdWNoc3RhcnRIYW5kbGVyKGUpIHtcbiAgICByLmhhc1RvdWNoU3RhcnRlZCA9IHRydWU7XG5cbiAgICBpZiAoIWV2ZW50SW5Db250YWluZXIoZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBibHVyQWN0aXZlRG9tRWxlbWVudCgpO1xuICAgIHIudG91Y2hEYXRhLmNhcHR1cmUgPSB0cnVlO1xuICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHZhciBub3cgPSByLnRvdWNoRGF0YS5ub3c7XG4gICAgdmFyIGVhcmxpZXIgPSByLnRvdWNoRGF0YS5lYXJsaWVyO1xuXG4gICAgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpO1xuICAgICAgbm93WzBdID0gcG9zWzBdO1xuICAgICAgbm93WzFdID0gcG9zWzFdO1xuICAgIH1cblxuICAgIGlmIChlLnRvdWNoZXNbMV0pIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTtcbiAgICAgIG5vd1syXSA9IHBvc1swXTtcbiAgICAgIG5vd1szXSA9IHBvc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSk7XG4gICAgICBub3dbNF0gPSBwb3NbMF07XG4gICAgICBub3dbNV0gPSBwb3NbMV07XG4gICAgfSAvLyByZWNvcmQgc3RhcnRpbmcgcG9pbnRzIGZvciBwaW5jaC10by16b29tXG5cblxuICAgIGlmIChlLnRvdWNoZXNbMV0pIHtcbiAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPSB0cnVlO1xuICAgICAgZnJlZURyYWdnZWRFbGVtZW50cyhyLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXMpO1xuICAgICAgdmFyIG9mZnNldHMgPSByLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcbiAgICAgIG9mZnNldExlZnQgPSBvZmZzZXRzWzBdO1xuICAgICAgb2Zmc2V0VG9wID0gb2Zmc2V0c1sxXTtcbiAgICAgIGNvbnRhaW5lcldpZHRoID0gb2Zmc2V0c1syXTtcbiAgICAgIGNvbnRhaW5lckhlaWdodCA9IG9mZnNldHNbM107XG4gICAgICBmMXgxID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBvZmZzZXRMZWZ0O1xuICAgICAgZjF5MSA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgZjJ4MSA9IGUudG91Y2hlc1sxXS5jbGllbnRYIC0gb2Zmc2V0TGVmdDtcbiAgICAgIGYyeTEgPSBlLnRvdWNoZXNbMV0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgIHR3b0ZpbmdlcnNTdGFydEluc2lkZSA9IDAgPD0gZjF4MSAmJiBmMXgxIDw9IGNvbnRhaW5lcldpZHRoICYmIDAgPD0gZjJ4MSAmJiBmMngxIDw9IGNvbnRhaW5lcldpZHRoICYmIDAgPD0gZjF5MSAmJiBmMXkxIDw9IGNvbnRhaW5lckhlaWdodCAmJiAwIDw9IGYyeTEgJiYgZjJ5MSA8PSBjb250YWluZXJIZWlnaHQ7XG4gICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICAgIGRpc3RhbmNlMSA9IGRpc3RhbmNlKGYxeDEsIGYxeTEsIGYyeDEsIGYyeTEpO1xuICAgICAgZGlzdGFuY2UxU3EgPSBkaXN0YW5jZVNxKGYxeDEsIGYxeTEsIGYyeDEsIGYyeTEpO1xuICAgICAgY2VudGVyMSA9IFsoZjF4MSArIGYyeDEpIC8gMiwgKGYxeTEgKyBmMnkxKSAvIDJdO1xuICAgICAgbW9kZWxDZW50ZXIxID0gWyhjZW50ZXIxWzBdIC0gcGFuLngpIC8gem9vbSwgKGNlbnRlcjFbMV0gLSBwYW4ueSkgLyB6b29tXTsgLy8gY29uc2lkZXIgY29udGV4dCB0YXBcblxuICAgICAgdmFyIGN4dERpc3RUaHJlc2hvbGQgPSAyMDA7XG4gICAgICB2YXIgY3h0RGlzdFRocmVzaG9sZFNxID0gY3h0RGlzdFRocmVzaG9sZCAqIGN4dERpc3RUaHJlc2hvbGQ7XG5cbiAgICAgIGlmIChkaXN0YW5jZTFTcSA8IGN4dERpc3RUaHJlc2hvbGRTcSAmJiAhZS50b3VjaGVzWzJdKSB7XG4gICAgICAgIHZhciBuZWFyMSA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgdmFyIG5lYXIyID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzJdLCBub3dbM10sIHRydWUsIHRydWUpO1xuXG4gICAgICAgIGlmIChuZWFyMSAmJiBuZWFyMS5pc05vZGUoKSkge1xuICAgICAgICAgIG5lYXIxLmFjdGl2YXRlKCkuZW1pdCh7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgdHlwZTogJ2N4dHRhcHN0YXJ0JyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBuZWFyMTtcbiAgICAgICAgfSBlbHNlIGlmIChuZWFyMiAmJiBuZWFyMi5pc05vZGUoKSkge1xuICAgICAgICAgIG5lYXIyLmFjdGl2YXRlKCkuZW1pdCh7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgdHlwZTogJ2N4dHRhcHN0YXJ0JyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBuZWFyMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS5lbWl0KHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICB0eXBlOiAnY3h0dGFwc3RhcnQnLFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyLnRvdWNoRGF0YS5zdGFydCkge1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0Ll9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIudG91Y2hEYXRhLmN4dCA9IHRydWU7XG4gICAgICAgIHIudG91Y2hEYXRhLmN4dERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGUudG91Y2hlc1syXSkge1xuICAgICAgLy8gaWdub3JlXG4gICAgICAvLyBzYWZhcmkgb24gaW9zIHBhbnMgdGhlIHBhZ2Ugb3RoZXJ3aXNlIChub3JtYWxseSB5b3Ugc2hvdWxkIGJlIGFibGUgdG8gcHJldmVudGRlZmF1bHQgb24gdG91Y2htb3ZlLi4uKVxuICAgICAgaWYgKGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlLnRvdWNoZXNbMV0pIDsgZWxzZSBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICB2YXIgbmVhcnMgPSByLmZpbmROZWFyZXN0RWxlbWVudHMobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuICAgICAgdmFyIG5lYXIgPSBuZWFyc1swXTtcblxuICAgICAgaWYgKG5lYXIgIT0gbnVsbCkge1xuICAgICAgICBuZWFyLmFjdGl2YXRlKCk7XG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbmVhcjtcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnRzID0gbmVhcnM7XG5cbiAgICAgICAgaWYgKHIubm9kZUlzR3JhYmJhYmxlKG5lYXIpKSB7XG4gICAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgICAgIHZhciBzZWxlY3RlZE5vZGVzID0gbnVsbDtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcblxuICAgICAgICAgIGlmIChuZWFyLnNlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgIC8vIHJlc2V0IGRyYWcgZWxlbWVudHMsIHNpbmNlIG5lYXIgd2lsbCBiZSBhZGRlZCBhZ2FpblxuICAgICAgICAgICAgc2VsZWN0ZWROb2RlcyA9IGN5LiQoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZWxlLnNlbGVjdGVkKCkgJiYgci5ub2RlSXNHcmFiYmFibGUoZWxlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWRkTm9kZXNUb0RyYWcoc2VsZWN0ZWROb2Rlcywge1xuICAgICAgICAgICAgICBhZGRUb0xpc3Q6IGRyYWdnZWRFbGVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkTm9kZVRvRHJhZyhuZWFyLCB7XG4gICAgICAgICAgICAgIGFkZFRvTGlzdDogZHJhZ2dlZEVsZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldEdyYWJUYXJnZXQobmVhcik7XG5cbiAgICAgICAgICB2YXIgbWFrZUV2ZW50ID0gZnVuY3Rpb24gbWFrZUV2ZW50KHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBuZWFyLmVtaXQobWFrZUV2ZW50KCdncmFib24nKSk7XG5cbiAgICAgICAgICBpZiAoc2VsZWN0ZWROb2Rlcykge1xuICAgICAgICAgICAgc2VsZWN0ZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgIG4uZW1pdChtYWtlRXZlbnQoJ2dyYWInKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmVhci5lbWl0KG1ha2VFdmVudCgnZ3JhYicpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHJpZ2dlckV2ZW50cyhuZWFyLCBbJ3RvdWNoc3RhcnQnLCAndGFwc3RhcnQnLCAndm1vdXNlZG93biddLCBlLCB7XG4gICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgeTogbm93WzFdXG4gICAgICB9KTtcblxuICAgICAgaWYgKG5lYXIgPT0gbnVsbCkge1xuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB7XG4gICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICB9O1xuICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfSAvLyBUYXAsIHRhcGhvbGRcbiAgICAgIC8vIC0tLS0tXG5cblxuICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9IGZhbHNlO1xuICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hTdGFydFRpbWUgPSArbmV3IERhdGUoKTtcbiAgICAgIGNsZWFyVGltZW91dChyLnRvdWNoRGF0YS50YXBob2xkVGltZW91dCk7XG4gICAgICByLnRvdWNoRGF0YS50YXBob2xkVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9PT0gZmFsc2UgJiYgIXIucGluY2hpbmcgLy8gaWYgcGluY2hpbmcsIHRoZW4gdGFwaG9sZCB1bnNlbGVjdCBzaG91bGRuJ3QgdGFrZSBlZmZlY3RcbiAgICAgICAgJiYgIXIudG91Y2hEYXRhLnNlbGVjdGluZyAvLyBib3ggc2VsZWN0aW9uIHNob3VsZG4ndCBhbGxvdyB0YXBob2xkIHRocm91Z2hcbiAgICAgICAgKSB7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50cyhyLnRvdWNoRGF0YS5zdGFydCwgWyd0YXBob2xkJ10sIGUsIHtcbiAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCByLnRhcGhvbGREdXJhdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPj0gMSkge1xuICAgICAgdmFyIHNQb3MgPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uID0gW251bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGxdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vdy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzUG9zW2ldID0gZWFybGllcltpXSA9IG5vd1tpXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvdWNoMCA9IGUudG91Y2hlc1swXTtcbiAgICAgIHIudG91Y2hEYXRhLnN0YXJ0R1Bvc2l0aW9uID0gW3RvdWNoMC5jbGllbnRYLCB0b3VjaDAuY2xpZW50WV07XG4gICAgfVxuICB9LCBmYWxzZSk7XG4gIHZhciB0b3VjaG1vdmVIYW5kbGVyO1xuICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICd0b3VjaG1vdmUnLCB0b3VjaG1vdmVIYW5kbGVyID0gZnVuY3Rpb24gdG91Y2htb3ZlSGFuZGxlcihlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHZhciBjYXB0dXJlID0gci50b3VjaERhdGEuY2FwdHVyZTtcblxuICAgIGlmICghY2FwdHVyZSAmJiAhZXZlbnRJbkNvbnRhaW5lcihlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzZWxlY3QgPSByLnNlbGVjdGlvbjtcbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHZhciBub3cgPSByLnRvdWNoRGF0YS5ub3c7XG4gICAgdmFyIGVhcmxpZXIgPSByLnRvdWNoRGF0YS5lYXJsaWVyO1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuXG4gICAgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpO1xuICAgICAgbm93WzBdID0gcG9zWzBdO1xuICAgICAgbm93WzFdID0gcG9zWzFdO1xuICAgIH1cblxuICAgIGlmIChlLnRvdWNoZXNbMV0pIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTtcbiAgICAgIG5vd1syXSA9IHBvc1swXTtcbiAgICAgIG5vd1szXSA9IHBvc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSk7XG4gICAgICBub3dbNF0gPSBwb3NbMF07XG4gICAgICBub3dbNV0gPSBwb3NbMV07XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0R1BvcyA9IHIudG91Y2hEYXRhLnN0YXJ0R1Bvc2l0aW9uO1xuICAgIHZhciBpc092ZXJUaHJlc2hvbGREcmFnO1xuXG4gICAgaWYgKGNhcHR1cmUgJiYgZS50b3VjaGVzWzBdICYmIHN0YXJ0R1Bvcykge1xuICAgICAgdmFyIGRpc3AgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub3cubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZGlzcFtqXSA9IG5vd1tqXSAtIGVhcmxpZXJbal07XG4gICAgICB9XG5cbiAgICAgIHZhciBkeCA9IGUudG91Y2hlc1swXS5jbGllbnRYIC0gc3RhcnRHUG9zWzBdO1xuICAgICAgdmFyIGR4MiA9IGR4ICogZHg7XG4gICAgICB2YXIgZHkgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIHN0YXJ0R1Bvc1sxXTtcbiAgICAgIHZhciBkeTIgPSBkeSAqIGR5O1xuICAgICAgdmFyIGRpc3QyID0gZHgyICsgZHkyO1xuICAgICAgaXNPdmVyVGhyZXNob2xkRHJhZyA9IGRpc3QyID49IHIudG91Y2hUYXBUaHJlc2hvbGQyO1xuICAgIH0gLy8gY29udGV4dCBzd2lwZSBjYW5jZWxsaW5nXG5cblxuICAgIGlmIChjYXB0dXJlICYmIHIudG91Y2hEYXRhLmN4dCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIGYxeDIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIG9mZnNldExlZnQsXG4gICAgICAgICAgZjF5MiA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgdmFyIGYyeDIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WCAtIG9mZnNldExlZnQsXG4gICAgICAgICAgZjJ5MiA9IGUudG91Y2hlc1sxXS5jbGllbnRZIC0gb2Zmc2V0VG9wOyAvLyB2YXIgZGlzdGFuY2UyID0gZGlzdGFuY2UoIGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIgKTtcblxuICAgICAgdmFyIGRpc3RhbmNlMlNxID0gZGlzdGFuY2VTcShmMXgyLCBmMXkyLCBmMngyLCBmMnkyKTtcbiAgICAgIHZhciBmYWN0b3JTcSA9IGRpc3RhbmNlMlNxIC8gZGlzdGFuY2UxU3E7XG4gICAgICB2YXIgZGlzdFRocmVzaG9sZCA9IDE1MDtcbiAgICAgIHZhciBkaXN0VGhyZXNob2xkU3EgPSBkaXN0VGhyZXNob2xkICogZGlzdFRocmVzaG9sZDtcbiAgICAgIHZhciBmYWN0b3JUaHJlc2hvbGQgPSAxLjU7XG4gICAgICB2YXIgZmFjdG9yVGhyZXNob2xkU3EgPSBmYWN0b3JUaHJlc2hvbGQgKiBmYWN0b3JUaHJlc2hvbGQ7IC8vIGNhbmNlbCBjdHggZ2VzdHVyZXMgaWYgdGhlIGRpc3RhbmNlIGIvdCB0aGUgZmluZ2VycyBpbmNyZWFzZXNcblxuICAgICAgaWYgKGZhY3RvclNxID49IGZhY3RvclRocmVzaG9sZFNxIHx8IGRpc3RhbmNlMlNxID49IGRpc3RUaHJlc2hvbGRTcSkge1xuICAgICAgICByLnRvdWNoRGF0YS5jeHQgPSBmYWxzZTtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICB2YXIgY3h0RXZ0ID0ge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgdHlwZTogJ2N4dHRhcGVuZCcsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydC51bmFjdGl2YXRlKCkuZW1pdChjeHRFdnQpO1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS5lbWl0KGN4dEV2dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIGNvbnRleHQgc3dpcGVcblxuXG4gICAgaWYgKGNhcHR1cmUgJiYgci50b3VjaERhdGEuY3h0KSB7XG4gICAgICB2YXIgY3h0RXZ0ID0ge1xuICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICB0eXBlOiAnY3h0ZHJhZycsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcblxuICAgICAgaWYgKHIudG91Y2hEYXRhLnN0YXJ0KSB7XG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0LmVtaXQoY3h0RXZ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN5LmVtaXQoY3h0RXZ0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHIudG91Y2hEYXRhLnN0YXJ0KSB7XG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0Ll9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgci50b3VjaERhdGEuY3h0RHJhZ2dlZCA9IHRydWU7XG4gICAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcblxuICAgICAgaWYgKCFyLnRvdWNoRGF0YS5jeHRPdmVyIHx8IG5lYXIgIT09IHIudG91Y2hEYXRhLmN4dE92ZXIpIHtcbiAgICAgICAgaWYgKHIudG91Y2hEYXRhLmN4dE92ZXIpIHtcbiAgICAgICAgICByLnRvdWNoRGF0YS5jeHRPdmVyLmVtaXQoe1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgIHR5cGU6ICdjeHRkcmFnb3V0JyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByLnRvdWNoRGF0YS5jeHRPdmVyID0gbmVhcjtcblxuICAgICAgICBpZiAobmVhcikge1xuICAgICAgICAgIG5lYXIuZW1pdCh7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdmVyJyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gYm94IHNlbGVjdGlvblxuXG4gICAgfSBlbHNlIGlmIChjYXB0dXJlICYmIGUudG91Y2hlc1syXSAmJiBjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMubGFzdFRocmVlVG91Y2ggPSArbmV3IERhdGUoKTtcblxuICAgICAgaWYgKCFyLnRvdWNoRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgICAgY3kuZW1pdCh7XG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICB0eXBlOiAnYm94c3RhcnQnLFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByLnRvdWNoRGF0YS5zZWxlY3RpbmcgPSB0cnVlO1xuICAgICAgci50b3VjaERhdGEuZGlkU2VsZWN0ID0gdHJ1ZTtcbiAgICAgIHNlbGVjdFs0XSA9IDE7XG5cbiAgICAgIGlmICghc2VsZWN0IHx8IHNlbGVjdC5sZW5ndGggPT09IDAgfHwgc2VsZWN0WzBdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2VsZWN0WzBdID0gKG5vd1swXSArIG5vd1syXSArIG5vd1s0XSkgLyAzO1xuICAgICAgICBzZWxlY3RbMV0gPSAobm93WzFdICsgbm93WzNdICsgbm93WzVdKSAvIDM7XG4gICAgICAgIHNlbGVjdFsyXSA9IChub3dbMF0gKyBub3dbMl0gKyBub3dbNF0pIC8gMyArIDE7XG4gICAgICAgIHNlbGVjdFszXSA9IChub3dbMV0gKyBub3dbM10gKyBub3dbNV0pIC8gMyArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RbMl0gPSAobm93WzBdICsgbm93WzJdICsgbm93WzRdKSAvIDM7XG4gICAgICAgIHNlbGVjdFszXSA9IChub3dbMV0gKyBub3dbM10gKyBub3dbNV0pIC8gMztcbiAgICAgIH1cblxuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgIHIucmVkcmF3KCk7IC8vIHBpbmNoIHRvIHpvb21cbiAgICB9IGVsc2UgaWYgKGNhcHR1cmUgJiYgZS50b3VjaGVzWzFdICYmICFyLnRvdWNoRGF0YS5kaWRTZWxlY3QgLy8gZG9uJ3QgYWxsb3cgYm94IHNlbGVjdGlvbiB0byBkZWdyYWRlIHRvIHBpbmNoLXRvLXpvb21cbiAgICAmJiBjeS56b29taW5nRW5hYmxlZCgpICYmIGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclpvb21pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkpIHtcbiAgICAgIC8vIHR3byBmaW5nZXJzID0+IHBpbmNoIHRvIHpvb21cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXM7XG5cbiAgICAgIGlmIChkcmFnZ2VkRWxlcykge1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRyYWdnZWRFbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGRlX3AgPSBkcmFnZ2VkRWxlc1tpXS5fcHJpdmF0ZTtcbiAgICAgICAgICBkZV9wLmdyYWJiZWQgPSBmYWxzZTtcbiAgICAgICAgICBkZV9wLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIF9zdGFydCA9IHIudG91Y2hEYXRhLnN0YXJ0OyAvLyAoeDIsIHkyKSBmb3IgZmluZ2VycyAxIGFuZCAyXG5cbiAgICAgIHZhciBmMXgyID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBvZmZzZXRMZWZ0LFxuICAgICAgICAgIGYxeTIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgIHZhciBmMngyID0gZS50b3VjaGVzWzFdLmNsaWVudFggLSBvZmZzZXRMZWZ0LFxuICAgICAgICAgIGYyeTIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgIHZhciBkaXN0YW5jZTIgPSBkaXN0YW5jZShmMXgyLCBmMXkyLCBmMngyLCBmMnkyKTsgLy8gdmFyIGRpc3RhbmNlMlNxID0gZGlzdGFuY2VTcSggZjF4MiwgZjF5MiwgZjJ4MiwgZjJ5MiApO1xuICAgICAgLy8gdmFyIGZhY3RvciA9IE1hdGguc3FydCggZGlzdGFuY2UyU3EgKSAvIE1hdGguc3FydCggZGlzdGFuY2UxU3EgKTtcblxuICAgICAgdmFyIGZhY3RvciA9IGRpc3RhbmNlMiAvIGRpc3RhbmNlMTtcblxuICAgICAgaWYgKHR3b0ZpbmdlcnNTdGFydEluc2lkZSkge1xuICAgICAgICAvLyBkZWx0YSBmaW5nZXIxXG4gICAgICAgIHZhciBkZjF4ID0gZjF4MiAtIGYxeDE7XG4gICAgICAgIHZhciBkZjF5ID0gZjF5MiAtIGYxeTE7IC8vIGRlbHRhIGZpbmdlciAyXG5cbiAgICAgICAgdmFyIGRmMnggPSBmMngyIC0gZjJ4MTtcbiAgICAgICAgdmFyIGRmMnkgPSBmMnkyIC0gZjJ5MTsgLy8gdHJhbnNsYXRpb24gaXMgdGhlIG5vcm1hbGlzZWQgdmVjdG9yIG9mIHRoZSB0d28gZmluZ2VycyBtb3ZlbWVudFxuICAgICAgICAvLyBpLmUuIHNvIHBpbmNoaW5nIGNhbmNlbHMgb3V0IGFuZCBtb3ZpbmcgdG9nZXRoZXIgcGFuc1xuXG4gICAgICAgIHZhciB0eCA9IChkZjF4ICsgZGYyeCkgLyAyO1xuICAgICAgICB2YXIgdHkgPSAoZGYxeSArIGRmMnkpIC8gMjsgLy8gbm93IGNhbGN1bGF0ZSB0aGUgem9vbVxuXG4gICAgICAgIHZhciB6b29tMSA9IGN5Lnpvb20oKTtcbiAgICAgICAgdmFyIHpvb20yID0gem9vbTEgKiBmYWN0b3I7XG4gICAgICAgIHZhciBwYW4xID0gY3kucGFuKCk7IC8vIHRoZSBtb2RlbCBjZW50ZXIgcG9pbnQgY29udmVydGVkIHRvIHRoZSBjdXJyZW50IHJlbmRlcmVkIHBvc1xuXG4gICAgICAgIHZhciBjdHJ4ID0gbW9kZWxDZW50ZXIxWzBdICogem9vbTEgKyBwYW4xLng7XG4gICAgICAgIHZhciBjdHJ5ID0gbW9kZWxDZW50ZXIxWzFdICogem9vbTEgKyBwYW4xLnk7XG4gICAgICAgIHZhciBwYW4yID0ge1xuICAgICAgICAgIHg6IC16b29tMiAvIHpvb20xICogKGN0cnggLSBwYW4xLnggLSB0eCkgKyBjdHJ4LFxuICAgICAgICAgIHk6IC16b29tMiAvIHpvb20xICogKGN0cnkgLSBwYW4xLnkgLSB0eSkgKyBjdHJ5XG4gICAgICAgIH07IC8vIHJlbW92ZSBkcmFnZ2VkIGVsZXNcblxuICAgICAgICBpZiAoX3N0YXJ0ICYmIF9zdGFydC5hY3RpdmUoKSkge1xuICAgICAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcztcbiAgICAgICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKGRyYWdnZWRFbGVzKTtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcblxuICAgICAgICAgIF9zdGFydC51bmFjdGl2YXRlKCkuZW1pdCgnZnJlZW9uJyk7XG5cbiAgICAgICAgICBkcmFnZ2VkRWxlcy5lbWl0KCdmcmVlJyk7XG5cbiAgICAgICAgICBpZiAoci5kcmFnRGF0YS5kaWREcmFnKSB7XG4gICAgICAgICAgICBfc3RhcnQuZW1pdCgnZHJhZ2ZyZWVvbicpO1xuXG4gICAgICAgICAgICBkcmFnZ2VkRWxlcy5lbWl0KCdkcmFnZnJlZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN5LnZpZXdwb3J0KHtcbiAgICAgICAgICB6b29tOiB6b29tMixcbiAgICAgICAgICBwYW46IHBhbjIsXG4gICAgICAgICAgY2FuY2VsT25GYWlsZWRab29tOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjeS5lbWl0KCdwaW5jaHpvb20nKTtcbiAgICAgICAgZGlzdGFuY2UxID0gZGlzdGFuY2UyO1xuICAgICAgICBmMXgxID0gZjF4MjtcbiAgICAgICAgZjF5MSA9IGYxeTI7XG4gICAgICAgIGYyeDEgPSBmMngyO1xuICAgICAgICBmMnkxID0gZjJ5MjtcbiAgICAgICAgci5waW5jaGluZyA9IHRydWU7XG4gICAgICB9IC8vIFJlLXByb2plY3RcblxuXG4gICAgICBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTtcbiAgICAgICAgbm93WzBdID0gcG9zWzBdO1xuICAgICAgICBub3dbMV0gPSBwb3NbMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChlLnRvdWNoZXNbMV0pIHtcbiAgICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkpO1xuICAgICAgICBub3dbMl0gPSBwb3NbMF07XG4gICAgICAgIG5vd1szXSA9IHBvc1sxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGUudG91Y2hlc1syXSkge1xuICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSk7XG4gICAgICAgIG5vd1s0XSA9IHBvc1swXTtcbiAgICAgICAgbm93WzVdID0gcG9zWzFdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzWzBdICYmICFyLnRvdWNoRGF0YS5kaWRTZWxlY3QgLy8gZG9uJ3QgYWxsb3cgYm94IHNlbGVjdGlvbiB0byBkZWdyYWRlIHRvIHNpbmdsZSBmaW5nZXIgZXZlbnRzIGxpa2UgcGFubmluZ1xuICAgICkge1xuICAgICAgdmFyIHN0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7XG4gICAgICB2YXIgbGFzdCA9IHIudG91Y2hEYXRhLmxhc3Q7XG4gICAgICB2YXIgbmVhcjtcblxuICAgICAgaWYgKCFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgJiYgIXIuc3dpcGVQYW5uaW5nKSB7XG4gICAgICAgIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYXB0dXJlICYmIHN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSAvLyBkcmFnZ2luZyBub2Rlc1xuXG5cbiAgICAgIGlmIChjYXB0dXJlICYmIHN0YXJ0ICE9IG51bGwgJiYgci5ub2RlSXNEcmFnZ2FibGUoc3RhcnQpKSB7XG4gICAgICAgIGlmIChpc092ZXJUaHJlc2hvbGREcmFnKSB7XG4gICAgICAgICAgLy8gdGhlbiBkcmFnZ2luZyBjYW4gaGFwcGVuXG4gICAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuICAgICAgICAgIHZhciBqdXN0U3RhcnRlZERyYWcgPSAhci5kcmFnRGF0YS5kaWREcmFnO1xuXG4gICAgICAgICAgaWYgKGp1c3RTdGFydGVkRHJhZykge1xuICAgICAgICAgICAgYWRkTm9kZXNUb0RyYWcoZHJhZ2dlZEVsZXMsIHtcbiAgICAgICAgICAgICAgaW5EcmFnTGF5ZXI6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IHRydWU7XG4gICAgICAgICAgdmFyIHRvdGFsU2hpZnQgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAobnVtYmVyJDEoZGlzcFswXSkgJiYgbnVtYmVyJDEoZGlzcFsxXSkpIHtcbiAgICAgICAgICAgIHRvdGFsU2hpZnQueCArPSBkaXNwWzBdO1xuICAgICAgICAgICAgdG90YWxTaGlmdC55ICs9IGRpc3BbMV07XG5cbiAgICAgICAgICAgIGlmIChqdXN0U3RhcnRlZERyYWcpIHtcbiAgICAgICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgICAgIHZhciBkcmFnRGVsdGEgPSByLnRvdWNoRGF0YS5kcmFnRGVsdGE7XG5cbiAgICAgICAgICAgICAgaWYgKGRyYWdEZWx0YSAmJiBudW1iZXIkMShkcmFnRGVsdGFbMF0pICYmIG51bWJlciQxKGRyYWdEZWx0YVsxXSkpIHtcbiAgICAgICAgICAgICAgICB0b3RhbFNoaWZ0LnggKz0gZHJhZ0RlbHRhWzBdO1xuICAgICAgICAgICAgICAgIHRvdGFsU2hpZnQueSArPSBkcmFnRGVsdGFbMV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSB0cnVlO1xuICAgICAgICAgIGRyYWdnZWRFbGVzLnNpbGVudFNoaWZ0KHRvdGFsU2hpZnQpLmVtaXQoJ3Bvc2l0aW9uIGRyYWcnKTtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcblxuICAgICAgICAgIGlmIChyLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzBdID09IGVhcmxpZXJbMF0gJiYgci50b3VjaERhdGEuc3RhcnRQb3NpdGlvblsxXSA9PSBlYXJsaWVyWzFdKSB7XG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG90aGVyd2lzZSBrZWVwIHRyYWNrIG9mIGRyYWcgZGVsdGEgZm9yIGxhdGVyXG4gICAgICAgICAgdmFyIGRyYWdEZWx0YSA9IHIudG91Y2hEYXRhLmRyYWdEZWx0YSA9IHIudG91Y2hEYXRhLmRyYWdEZWx0YSB8fCBbXTtcblxuICAgICAgICAgIGlmIChkcmFnRGVsdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkcmFnRGVsdGEucHVzaChkaXNwWzBdKTtcbiAgICAgICAgICAgIGRyYWdEZWx0YS5wdXNoKGRpc3BbMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkcmFnRGVsdGFbMF0gKz0gZGlzcFswXTtcbiAgICAgICAgICAgIGRyYWdEZWx0YVsxXSArPSBkaXNwWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyB0b3VjaG1vdmVcblxuXG4gICAgICB7XG4gICAgICAgIHRyaWdnZXJFdmVudHMoc3RhcnQgfHwgbmVhciwgWyd0b3VjaG1vdmUnLCAndGFwZHJhZycsICd2bW91c2Vtb3ZlJ10sIGUsIHtcbiAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgeTogbm93WzFdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICgoIXN0YXJ0IHx8ICFzdGFydC5ncmFiYmVkKCkpICYmIG5lYXIgIT0gbGFzdCkge1xuICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICBsYXN0LmVtaXQoe1xuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICB0eXBlOiAndGFwZHJhZ291dCcsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmVhcikge1xuICAgICAgICAgICAgbmVhci5lbWl0KHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgdHlwZTogJ3RhcGRyYWdvdmVyJyxcbiAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHIudG91Y2hEYXRhLmxhc3QgPSBuZWFyO1xuICAgICAgfSAvLyBjaGVjayB0byBjYW5jZWwgdGFwaG9sZFxuXG4gICAgICBpZiAoY2FwdHVyZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChub3dbaV0gJiYgci50b3VjaERhdGEuc3RhcnRQb3NpdGlvbltpXSAmJiBpc092ZXJUaHJlc2hvbGREcmFnKSB7XG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gcGFubmluZ1xuXG5cbiAgICAgIGlmIChjYXB0dXJlICYmIChzdGFydCA9PSBudWxsIHx8IHN0YXJ0LnBhbm5hYmxlKCkpICYmIGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkpIHtcbiAgICAgICAgdmFyIGFsbG93UGFzc3Rocm91Z2ggPSBhbGxvd1Bhbm5pbmdQYXNzdGhyb3VnaChzdGFydCwgci50b3VjaERhdGEuc3RhcnRzKTtcblxuICAgICAgICBpZiAoYWxsb3dQYXNzdGhyb3VnaCkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIGlmICghci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uKSB7XG4gICAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSBhcnJheTJwb2ludChyLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoci5zd2lwZVBhbm5pbmcpIHtcbiAgICAgICAgICAgIGN5LnBhbkJ5KHtcbiAgICAgICAgICAgICAgeDogZGlzcFswXSAqIHpvb20sXG4gICAgICAgICAgICAgIHk6IGRpc3BbMV0gKiB6b29tXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN5LmVtaXQoJ2RyYWdwYW4nKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgICAgICAgIHIuc3dpcGVQYW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGN5LnBhbkJ5KHtcbiAgICAgICAgICAgICAgeDogZHggKiB6b29tLFxuICAgICAgICAgICAgICB5OiBkeSAqIHpvb21cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3kuZW1pdCgnZHJhZ3BhbicpO1xuXG4gICAgICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFJlLXByb2plY3RcblxuXG4gICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTtcbiAgICAgICAgbm93WzBdID0gcG9zWzBdO1xuICAgICAgICBub3dbMV0gPSBwb3NbMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBub3cubGVuZ3RoOyBqKyspIHtcbiAgICAgIGVhcmxpZXJbal0gPSBub3dbal07XG4gICAgfSAvLyB0aGUgYWN0aXZlIGJnIGluZGljYXRvciBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIG1ha2luZyBhIHN3aXBlIHRoYXQgaXMgbmVpdGhlciBmb3IgZHJhZ2dpbmcgbm9kZXMgb3IgcGFubmluZ1xuXG5cbiAgICBpZiAoY2FwdHVyZSAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMCAmJiAhci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzICYmICFyLnN3aXBlUGFubmluZyAmJiByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gIT0gbnVsbCkge1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfVxuICB9LCBmYWxzZSk7XG4gIHZhciB0b3VjaGNhbmNlbEhhbmRsZXI7XG4gIHIucmVnaXN0ZXJCaW5kaW5nKGNvbnRhaW5lcldpbmRvdywgJ3RvdWNoY2FuY2VsJywgdG91Y2hjYW5jZWxIYW5kbGVyID0gZnVuY3Rpb24gdG91Y2hjYW5jZWxIYW5kbGVyKGUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHN0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7XG4gICAgci50b3VjaERhdGEuY2FwdHVyZSA9IGZhbHNlO1xuXG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgfVxuICB9KTtcbiAgdmFyIHRvdWNoZW5kSGFuZGxlciwgZGlkRG91YmxlVG91Y2gsIHRvdWNoVGltZW91dCwgcHJldlRvdWNoVGltZVN0YW1wO1xuICByLnJlZ2lzdGVyQmluZGluZyhjb250YWluZXJXaW5kb3csICd0b3VjaGVuZCcsIHRvdWNoZW5kSGFuZGxlciA9IGZ1bmN0aW9uIHRvdWNoZW5kSGFuZGxlcihlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciBzdGFydCA9IHIudG91Y2hEYXRhLnN0YXJ0O1xuICAgIHZhciBjYXB0dXJlID0gci50b3VjaERhdGEuY2FwdHVyZTtcblxuICAgIGlmIChjYXB0dXJlKSB7XG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByLnRvdWNoRGF0YS5jYXB0dXJlID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzZWxlY3QgPSByLnNlbGVjdGlvbjtcbiAgICByLnN3aXBlUGFubmluZyA9IGZhbHNlO1xuICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IGZhbHNlO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIG5vdyA9IHIudG91Y2hEYXRhLm5vdztcbiAgICB2YXIgZWFybGllciA9IHIudG91Y2hEYXRhLmVhcmxpZXI7XG5cbiAgICBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XG4gICAgICBub3dbMF0gPSBwb3NbMF07XG4gICAgICBub3dbMV0gPSBwb3NbMV07XG4gICAgfVxuXG4gICAgaWYgKGUudG91Y2hlc1sxXSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkpO1xuICAgICAgbm93WzJdID0gcG9zWzBdO1xuICAgICAgbm93WzNdID0gcG9zWzFdO1xuICAgIH1cblxuICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZKTtcbiAgICAgIG5vd1s0XSA9IHBvc1swXTtcbiAgICAgIG5vd1s1XSA9IHBvc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICB2YXIgY3R4VGFwZW5kO1xuXG4gICAgaWYgKHIudG91Y2hEYXRhLmN4dCkge1xuICAgICAgY3R4VGFwZW5kID0ge1xuICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICB0eXBlOiAnY3h0dGFwZW5kJyxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgeTogbm93WzFdXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChzdGFydCkge1xuICAgICAgICBzdGFydC5lbWl0KGN0eFRhcGVuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjeS5lbWl0KGN0eFRhcGVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghci50b3VjaERhdGEuY3h0RHJhZ2dlZCkge1xuICAgICAgICB2YXIgY3R4VGFwID0ge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgdHlwZTogJ2N4dHRhcCcsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICBzdGFydC5lbWl0KGN0eFRhcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kuZW1pdChjdHhUYXApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyLnRvdWNoRGF0YS5zdGFydCkge1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydC5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHIudG91Y2hEYXRhLmN4dCA9IGZhbHNlO1xuICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBudWxsO1xuICAgICAgci5yZWRyYXcoKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIG5vIG1vcmUgYm94IHNlbGVjdGlvbiBpZiB3ZSBkb24ndCBoYXZlIHRocmVlIGZpbmdlcnNcblxuXG4gICAgaWYgKCFlLnRvdWNoZXNbMl0gJiYgY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpICYmIHIudG91Y2hEYXRhLnNlbGVjdGluZykge1xuICAgICAgci50b3VjaERhdGEuc2VsZWN0aW5nID0gZmFsc2U7XG4gICAgICB2YXIgYm94ID0gY3kuY29sbGVjdGlvbihyLmdldEFsbEluQm94KHNlbGVjdFswXSwgc2VsZWN0WzFdLCBzZWxlY3RbMl0sIHNlbGVjdFszXSkpO1xuICAgICAgc2VsZWN0WzBdID0gdW5kZWZpbmVkO1xuICAgICAgc2VsZWN0WzFdID0gdW5kZWZpbmVkO1xuICAgICAgc2VsZWN0WzJdID0gdW5kZWZpbmVkO1xuICAgICAgc2VsZWN0WzNdID0gdW5kZWZpbmVkO1xuICAgICAgc2VsZWN0WzRdID0gMDtcbiAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICBjeS5lbWl0KHtcbiAgICAgICAgdHlwZTogJ2JveGVuZCcsXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdmFyIGVsZVdvdWxkQmVTZWxlY3RlZCA9IGZ1bmN0aW9uIGVsZVdvdWxkQmVTZWxlY3RlZChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5zZWxlY3RhYmxlKCkgJiYgIWVsZS5zZWxlY3RlZCgpO1xuICAgICAgfTtcblxuICAgICAgYm94LmVtaXQoJ2JveCcpLnN0ZEZpbHRlcihlbGVXb3VsZEJlU2VsZWN0ZWQpLnNlbGVjdCgpLmVtaXQoJ2JveHNlbGVjdCcpO1xuXG4gICAgICBpZiAoYm94Lm5vbmVtcHR5KCkpIHtcbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ICE9IG51bGwpIHtcbiAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzWzFdKSA7IGVsc2UgaWYgKGUudG91Y2hlc1swXSkgOyBlbHNlIGlmICghZS50b3VjaGVzWzBdKSB7XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuXG4gICAgICBpZiAoc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICB2YXIgc3RhcnRXYXNHcmFiYmVkID0gc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZDtcbiAgICAgICAgZnJlZURyYWdnZWRFbGVtZW50cyhkcmFnZ2VkRWxlcyk7XG4gICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcblxuICAgICAgICBpZiAoc3RhcnRXYXNHcmFiYmVkKSB7XG4gICAgICAgICAgc3RhcnQuZW1pdCgnZnJlZW9uJyk7XG4gICAgICAgICAgZHJhZ2dlZEVsZXMuZW1pdCgnZnJlZScpO1xuXG4gICAgICAgICAgaWYgKHIuZHJhZ0RhdGEuZGlkRHJhZykge1xuICAgICAgICAgICAgc3RhcnQuZW1pdCgnZHJhZ2ZyZWVvbicpO1xuICAgICAgICAgICAgZHJhZ2dlZEVsZXMuZW1pdCgnZHJhZ2ZyZWUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0cmlnZ2VyRXZlbnRzKHN0YXJ0LCBbJ3RvdWNoZW5kJywgJ3RhcGVuZCcsICd2bW91c2V1cCcsICd0YXBkcmFnb3V0J10sIGUsIHtcbiAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgeTogbm93WzFdXG4gICAgICAgIH0pO1xuICAgICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuICAgICAgICB0cmlnZ2VyRXZlbnRzKG5lYXIsIFsndG91Y2hlbmQnLCAndGFwZW5kJywgJ3Ztb3VzZXVwJywgJ3RhcGRyYWdvdXQnXSwgZSwge1xuICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkeCA9IHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMF0gLSBub3dbMF07XG4gICAgICB2YXIgZHgyID0gZHggKiBkeDtcbiAgICAgIHZhciBkeSA9IHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMV0gLSBub3dbMV07XG4gICAgICB2YXIgZHkyID0gZHkgKiBkeTtcbiAgICAgIHZhciBkaXN0MiA9IGR4MiArIGR5MjtcbiAgICAgIHZhciByZGlzdDIgPSBkaXN0MiAqIHpvb20gKiB6b29tOyAvLyBUYXAgZXZlbnQsIHJvdWdobHkgc2FtZSBhcyBtb3VzZSBjbGljayBldmVudCBmb3IgdG91Y2hcblxuICAgICAgaWYgKCFyLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkKSB7XG4gICAgICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgICBjeS4kKCc6c2VsZWN0ZWQnKS51bnNlbGVjdChbJ3RhcHVuc2VsZWN0J10pO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJpZ2dlckV2ZW50cyhzdGFydCwgWyd0YXAnLCAndmNsaWNrJ10sIGUsIHtcbiAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgeTogbm93WzFdXG4gICAgICAgIH0pO1xuICAgICAgICBkaWREb3VibGVUb3VjaCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChlLnRpbWVTdGFtcCAtIHByZXZUb3VjaFRpbWVTdGFtcCA8PSBjeS5tdWx0aUNsaWNrRGVib3VuY2VUaW1lKCkpIHtcbiAgICAgICAgICB0b3VjaFRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRvdWNoVGltZW91dCk7XG4gICAgICAgICAgZGlkRG91YmxlVG91Y2ggPSB0cnVlO1xuICAgICAgICAgIHByZXZUb3VjaFRpbWVTdGFtcCA9IG51bGw7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50cyhzdGFydCwgWydkYmx0YXAnLCAndmRibGNsaWNrJ10sIGUsIHtcbiAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvdWNoVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRpZERvdWJsZVRvdWNoKSByZXR1cm47XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnRzKHN0YXJ0LCBbJ29uZXRhcCcsICd2b25lY2xpY2snXSwgZSwge1xuICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgY3kubXVsdGlDbGlja0RlYm91bmNlVGltZSgpKTtcbiAgICAgICAgICBwcmV2VG91Y2hUaW1lU3RhbXAgPSBlLnRpbWVTdGFtcDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBQcmVwYXJlIHRvIHNlbGVjdCB0aGUgY3VycmVudGx5IHRvdWNoZWQgbm9kZSwgb25seSBpZiBpdCBoYXNuJ3QgYmVlbiBkcmFnZ2VkIHBhc3QgYSBjZXJ0YWluIGRpc3RhbmNlXG5cblxuICAgICAgaWYgKHN0YXJ0ICE9IG51bGwgJiYgIXIuZHJhZ0RhdGEuZGlkRHJhZyAvLyBkaWRuJ3QgZHJhZyBub2RlcyBhcm91bmRcbiAgICAgICYmIHN0YXJ0Ll9wcml2YXRlLnNlbGVjdGFibGUgJiYgcmRpc3QyIDwgci50b3VjaFRhcFRocmVzaG9sZDIgJiYgIXIucGluY2hpbmcgLy8gcGluY2ggdG8gem9vbSBzaG91bGQgbm90IGFmZmVjdCBzZWxlY3Rpb25cbiAgICAgICkge1xuICAgICAgICBpZiAoY3kuc2VsZWN0aW9uVHlwZSgpID09PSAnc2luZ2xlJykge1xuICAgICAgICAgIGN5LiQoaXNTZWxlY3RlZCkudW5tZXJnZShzdGFydCkudW5zZWxlY3QoWyd0YXB1bnNlbGVjdCddKTtcbiAgICAgICAgICBzdGFydC5zZWxlY3QoWyd0YXBzZWxlY3QnXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHN0YXJ0LnNlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgIHN0YXJ0LnVuc2VsZWN0KFsndGFwdW5zZWxlY3QnXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0LnNlbGVjdChbJ3RhcHNlbGVjdCddKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBub3cubGVuZ3RoOyBqKyspIHtcbiAgICAgIGVhcmxpZXJbal0gPSBub3dbal07XG4gICAgfVxuXG4gICAgci5kcmFnRGF0YS5kaWREcmFnID0gZmFsc2U7IC8vIHJlc2V0IGZvciBuZXh0IHRvdWNoc3RhcnRcblxuICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByLnRvdWNoRGF0YS5kcmFnRGVsdGEgPSBbXTtcbiAgICAgIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb24gPSBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF07XG4gICAgICByLnRvdWNoRGF0YS5zdGFydEdQb3NpdGlvbiA9IG51bGw7XG4gICAgICByLnRvdWNoRGF0YS5kaWRTZWxlY3QgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIHRoZSBvbGQgc3RhcnQgZ2xvYmFsIHBvcyduIG1heSBub3QgYmUgdGhlIHNhbWUgZmluZ2VyIHRoYXQgcmVtYWluc1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydEdQb3NpdGlvbiA9IFtlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFldO1xuICAgICAgfVxuXG4gICAgICByLnBpbmNoaW5nID0gZmFsc2U7XG4gICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfSAvL3IucmVkcmF3KCk7XG5cbiAgfSwgZmFsc2UpOyAvLyBmYWxsYmFjayBjb21wYXRpYmlsaXR5IGxheWVyIGZvciBtcyBwb2ludGVyIGV2ZW50c1xuXG4gIGlmICh0eXBlb2YgVG91Y2hFdmVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgcG9pbnRlcnMgPSBbXTtcblxuICAgIHZhciBtYWtlVG91Y2ggPSBmdW5jdGlvbiBtYWtlVG91Y2goZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2xpZW50WDogZS5jbGllbnRYLFxuICAgICAgICBjbGllbnRZOiBlLmNsaWVudFksXG4gICAgICAgIGZvcmNlOiAxLFxuICAgICAgICBpZGVudGlmaWVyOiBlLnBvaW50ZXJJZCxcbiAgICAgICAgcGFnZVg6IGUucGFnZVgsXG4gICAgICAgIHBhZ2VZOiBlLnBhZ2VZLFxuICAgICAgICByYWRpdXNYOiBlLndpZHRoIC8gMixcbiAgICAgICAgcmFkaXVzWTogZS5oZWlnaHQgLyAyLFxuICAgICAgICBzY3JlZW5YOiBlLnNjcmVlblgsXG4gICAgICAgIHNjcmVlblk6IGUuc2NyZWVuWSxcbiAgICAgICAgdGFyZ2V0OiBlLnRhcmdldFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIG1ha2VQb2ludGVyID0gZnVuY3Rpb24gbWFrZVBvaW50ZXIoZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgIHRvdWNoOiBtYWtlVG91Y2goZSlcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBhZGRQb2ludGVyID0gZnVuY3Rpb24gYWRkUG9pbnRlcihlKSB7XG4gICAgICBwb2ludGVycy5wdXNoKG1ha2VQb2ludGVyKGUpKTtcbiAgICB9O1xuXG4gICAgdmFyIHJlbW92ZVBvaW50ZXIgPSBmdW5jdGlvbiByZW1vdmVQb2ludGVyKGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHAgPSBwb2ludGVyc1tpXTtcblxuICAgICAgICBpZiAocC5ldmVudC5wb2ludGVySWQgPT09IGUucG9pbnRlcklkKSB7XG4gICAgICAgICAgcG9pbnRlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlUG9pbnRlciA9IGZ1bmN0aW9uIHVwZGF0ZVBvaW50ZXIoZSkge1xuICAgICAgdmFyIHAgPSBwb2ludGVycy5maWx0ZXIoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIHAuZXZlbnQucG9pbnRlcklkID09PSBlLnBvaW50ZXJJZDtcbiAgICAgIH0pWzBdO1xuICAgICAgcC5ldmVudCA9IGU7XG4gICAgICBwLnRvdWNoID0gbWFrZVRvdWNoKGUpO1xuICAgIH07XG5cbiAgICB2YXIgYWRkVG91Y2hlc1RvRXZlbnQgPSBmdW5jdGlvbiBhZGRUb3VjaGVzVG9FdmVudChlKSB7XG4gICAgICBlLnRvdWNoZXMgPSBwb2ludGVycy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIHAudG91Y2g7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIHBvaW50ZXJJc01vdXNlID0gZnVuY3Rpb24gcG9pbnRlcklzTW91c2UoZSkge1xuICAgICAgcmV0dXJuIGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZS5wb2ludGVyVHlwZSA9PT0gNDtcbiAgICB9O1xuXG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdwb2ludGVyZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAocG9pbnRlcklzTW91c2UoZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBtb3VzZSBhbHJlYWR5IGhhbmRsZWRcblxuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBhZGRQb2ludGVyKGUpO1xuICAgICAgYWRkVG91Y2hlc1RvRXZlbnQoZSk7XG4gICAgICB0b3VjaHN0YXJ0SGFuZGxlcihlKTtcbiAgICB9KTtcbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ3BvaW50ZXJ1cCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAocG9pbnRlcklzTW91c2UoZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBtb3VzZSBhbHJlYWR5IGhhbmRsZWRcblxuXG4gICAgICByZW1vdmVQb2ludGVyKGUpO1xuICAgICAgYWRkVG91Y2hlc1RvRXZlbnQoZSk7XG4gICAgICB0b3VjaGVuZEhhbmRsZXIoZSk7XG4gICAgfSk7XG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdwb2ludGVyY2FuY2VsJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChwb2ludGVySXNNb3VzZShlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIG1vdXNlIGFscmVhZHkgaGFuZGxlZFxuXG5cbiAgICAgIHJlbW92ZVBvaW50ZXIoZSk7XG4gICAgICBhZGRUb3VjaGVzVG9FdmVudChlKTtcbiAgICAgIHRvdWNoY2FuY2VsSGFuZGxlcihlKTtcbiAgICB9KTtcbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ3BvaW50ZXJtb3ZlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChwb2ludGVySXNNb3VzZShlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIG1vdXNlIGFscmVhZHkgaGFuZGxlZFxuXG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHVwZGF0ZVBvaW50ZXIoZSk7XG4gICAgICBhZGRUb3VjaGVzVG9FdmVudChlKTtcbiAgICAgIHRvdWNobW92ZUhhbmRsZXIoZSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBCUnAkMiA9IHt9O1xuXG5CUnAkMi5nZW5lcmF0ZVBvbHlnb24gPSBmdW5jdGlvbiAobmFtZSwgcG9pbnRzKSB7XG4gIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbbmFtZV0gPSB7XG4gICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgbmFtZTogbmFtZSxcbiAgICBwb2ludHM6IHBvaW50cyxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCgncG9seWdvbicsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHRoaXMucG9pbnRzKTtcbiAgICB9LFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nKSB7XG4gICAgICByZXR1cm4gcG9seWdvbkludGVyc2VjdExpbmUoeCwgeSwgdGhpcy5wb2ludHMsIG5vZGVYLCBub2RlWSwgd2lkdGggLyAyLCBoZWlnaHQgLyAyLCBwYWRkaW5nKTtcbiAgICB9LFxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgcmV0dXJuIHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZyk7XG4gICAgfVxuICB9O1xufTtcblxuQlJwJDIuZ2VuZXJhdGVFbGxpcHNlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2RlU2hhcGVzWydlbGxpcHNlJ10gPSB7XG4gICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgbmFtZTogJ2VsbGlwc2UnLFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKHRoaXMubmFtZSwgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSxcbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZykge1xuICAgICAgcmV0dXJuIGludGVyc2VjdExpbmVFbGxpcHNlKHgsIHksIG5vZGVYLCBub2RlWSwgd2lkdGggLyAyICsgcGFkZGluZywgaGVpZ2h0IC8gMiArIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICByZXR1cm4gY2hlY2tJbkVsbGlwc2UoeCwgeSwgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgcGFkZGluZyk7XG4gICAgfVxuICB9O1xufTtcblxuQlJwJDIuZ2VuZXJhdGVSb3VuZFBvbHlnb24gPSBmdW5jdGlvbiAobmFtZSwgcG9pbnRzKSB7XG4gIC8vIFByZS1jb21wdXRlIGNvbnRyb2wgcG9pbnRzXG4gIC8vIFNpbmNlIHRoZXNlIHBvaW50cyBkZXBlbmQgb24gdGhlIHJhZGl1cyBsZW5ndGggKHdoaWNoIGluIHR1cm5zIGRlcGVuZCBvbiB0aGUgd2lkdGgvaGVpZ2h0IG9mIHRoZSBub2RlKSB3ZSB3aWxsIG9ubHkgcHJlLWNvbXB1dGVcbiAgLy8gdGhlIHVuaXQgdmVjdG9ycy5cbiAgLy8gRm9yIHNpbXBsaWNpdHkgdGhlIGxheW91dCB3aWxsIGJlOlxuICAvLyBbIHAwLCBVbml0VmVjdG9yUDBQMSwgcDEsIFVuaVZlY3RvclAxUDIsIC4uLiwgcG4sIFVuaXRWZWN0b3JQblAwIF1cbiAgdmFyIGFsbFBvaW50cyA9IG5ldyBBcnJheShwb2ludHMubGVuZ3RoICogMik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZUluZGV4ID0gaSAqIDI7XG4gICAgdmFyIGRlc3RJbmRleCA9IHZvaWQgMDtcblxuICAgIGlmIChpIDwgcG9pbnRzLmxlbmd0aCAvIDIgLSAxKSB7XG4gICAgICBkZXN0SW5kZXggPSAoaSArIDEpICogMjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVzdEluZGV4ID0gMDtcbiAgICB9XG5cbiAgICBhbGxQb2ludHNbaSAqIDRdID0gcG9pbnRzW3NvdXJjZUluZGV4XTtcbiAgICBhbGxQb2ludHNbaSAqIDQgKyAxXSA9IHBvaW50c1tzb3VyY2VJbmRleCArIDFdO1xuICAgIHZhciB4RGVzdCA9IHBvaW50c1tkZXN0SW5kZXhdIC0gcG9pbnRzW3NvdXJjZUluZGV4XTtcbiAgICB2YXIgeURlc3QgPSBwb2ludHNbZGVzdEluZGV4ICsgMV0gLSBwb2ludHNbc291cmNlSW5kZXggKyAxXTtcbiAgICB2YXIgbm9ybSA9IE1hdGguc3FydCh4RGVzdCAqIHhEZXN0ICsgeURlc3QgKiB5RGVzdCk7XG4gICAgYWxsUG9pbnRzW2kgKiA0ICsgMl0gPSB4RGVzdCAvIG5vcm07XG4gICAgYWxsUG9pbnRzW2kgKiA0ICsgM10gPSB5RGVzdCAvIG5vcm07XG4gIH1cblxuICByZXR1cm4gdGhpcy5ub2RlU2hhcGVzW25hbWVdID0ge1xuICAgIHJlbmRlcmVyOiB0aGlzLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgcG9pbnRzOiBhbGxQb2ludHMsXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwoJ3JvdW5kLXBvbHlnb24nLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCB0aGlzLnBvaW50cyk7XG4gICAgfSxcbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZykge1xuICAgICAgcmV0dXJuIHJvdW5kUG9seWdvbkludGVyc2VjdExpbmUoeCwgeSwgdGhpcy5wb2ludHMsIG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSxcbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbiBjaGVja1BvaW50KHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgIHJldHVybiBwb2ludEluc2lkZVJvdW5kUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICB9O1xufTtcblxuQlJwJDIuZ2VuZXJhdGVSb3VuZFJlY3RhbmdsZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZVNoYXBlc1sncm91bmQtcmVjdGFuZ2xlJ10gPSB0aGlzLm5vZGVTaGFwZXNbJ3JvdW5kcmVjdGFuZ2xlJ10gPSB7XG4gICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgbmFtZTogJ3JvdW5kLXJlY3RhbmdsZScsXG4gICAgcG9pbnRzOiBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNCwgMCksXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwodGhpcy5uYW1lLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nKSB7XG4gICAgICByZXR1cm4gcm91bmRSZWN0YW5nbGVJbnRlcnNlY3RMaW5lKHgsIHksIG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZyk7XG4gICAgfSxcbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbiBjaGVja1BvaW50KHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgIHZhciBjb3JuZXJSYWRpdXMgPSBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHZhciBkaWFtID0gY29ybmVyUmFkaXVzICogMjsgLy8gQ2hlY2sgaEJveFxuXG4gICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0IC0gZGlhbSwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIENoZWNrIHZCb3hcblxuXG4gICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCAtIGRpYW0sIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIENoZWNrIHRvcCBsZWZ0IHF1YXJ0ZXIgY2lyY2xlXG5cblxuICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksIGRpYW0sIGRpYW0sIGNlbnRlclggLSB3aWR0aCAvIDIgKyBjb3JuZXJSYWRpdXMsIGNlbnRlclkgLSBoZWlnaHQgLyAyICsgY29ybmVyUmFkaXVzLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gQ2hlY2sgdG9wIHJpZ2h0IHF1YXJ0ZXIgY2lyY2xlXG5cblxuICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksIGRpYW0sIGRpYW0sIGNlbnRlclggKyB3aWR0aCAvIDIgLSBjb3JuZXJSYWRpdXMsIGNlbnRlclkgLSBoZWlnaHQgLyAyICsgY29ybmVyUmFkaXVzLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gQ2hlY2sgYm90dG9tIHJpZ2h0IHF1YXJ0ZXIgY2lyY2xlXG5cblxuICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksIGRpYW0sIGRpYW0sIGNlbnRlclggKyB3aWR0aCAvIDIgLSBjb3JuZXJSYWRpdXMsIGNlbnRlclkgKyBoZWlnaHQgLyAyIC0gY29ybmVyUmFkaXVzLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gQ2hlY2sgYm90dG9tIGxlZnQgcXVhcnRlciBjaXJjbGVcblxuXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSwgZGlhbSwgZGlhbSwgY2VudGVyWCAtIHdpZHRoIC8gMiArIGNvcm5lclJhZGl1cywgY2VudGVyWSArIGhlaWdodCAvIDIgLSBjb3JuZXJSYWRpdXMsIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xufTtcblxuQlJwJDIuZ2VuZXJhdGVDdXRSZWN0YW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbJ2N1dC1yZWN0YW5nbGUnXSA9IHRoaXMubm9kZVNoYXBlc1snY3V0cmVjdGFuZ2xlJ10gPSB7XG4gICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgbmFtZTogJ2N1dC1yZWN0YW5nbGUnLFxuICAgIGNvcm5lckxlbmd0aDogZ2V0Q3V0UmVjdGFuZ2xlQ29ybmVyTGVuZ3RoKCksXG4gICAgcG9pbnRzOiBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNCwgMCksXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwodGhpcy5uYW1lLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuICAgIGdlbmVyYXRlQ3V0VHJpYW5nbGVQdHM6IGZ1bmN0aW9uIGdlbmVyYXRlQ3V0VHJpYW5nbGVQdHMod2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgdmFyIGNsID0gdGhpcy5jb3JuZXJMZW5ndGg7XG4gICAgICB2YXIgaGggPSBoZWlnaHQgLyAyO1xuICAgICAgdmFyIGh3ID0gd2lkdGggLyAyO1xuICAgICAgdmFyIHhCZWdpbiA9IGNlbnRlclggLSBodztcbiAgICAgIHZhciB4RW5kID0gY2VudGVyWCArIGh3O1xuICAgICAgdmFyIHlCZWdpbiA9IGNlbnRlclkgLSBoaDtcbiAgICAgIHZhciB5RW5kID0gY2VudGVyWSArIGhoOyAvLyBwb2ludHMgYXJlIGluIGNsb2Nrd2lzZSBvcmRlciwgaW5uZXIgKGltYWdpbmFyeSkgdHJpYW5nbGUgcHQgb24gWzQsIDVdXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcExlZnQ6IFt4QmVnaW4sIHlCZWdpbiArIGNsLCB4QmVnaW4gKyBjbCwgeUJlZ2luLCB4QmVnaW4gKyBjbCwgeUJlZ2luICsgY2xdLFxuICAgICAgICB0b3BSaWdodDogW3hFbmQgLSBjbCwgeUJlZ2luLCB4RW5kLCB5QmVnaW4gKyBjbCwgeEVuZCAtIGNsLCB5QmVnaW4gKyBjbF0sXG4gICAgICAgIGJvdHRvbVJpZ2h0OiBbeEVuZCwgeUVuZCAtIGNsLCB4RW5kIC0gY2wsIHlFbmQsIHhFbmQgLSBjbCwgeUVuZCAtIGNsXSxcbiAgICAgICAgYm90dG9tTGVmdDogW3hCZWdpbiArIGNsLCB5RW5kLCB4QmVnaW4sIHlFbmQgLSBjbCwgeEJlZ2luICsgY2wsIHlFbmQgLSBjbF1cbiAgICAgIH07XG4gICAgfSxcbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZykge1xuICAgICAgdmFyIGNQdHMgPSB0aGlzLmdlbmVyYXRlQ3V0VHJpYW5nbGVQdHMod2lkdGggKyAyICogcGFkZGluZywgaGVpZ2h0ICsgMiAqIHBhZGRpbmcsIG5vZGVYLCBub2RlWSk7XG4gICAgICB2YXIgcHRzID0gW10uY29uY2F0LmFwcGx5KFtdLCBbY1B0cy50b3BMZWZ0LnNwbGljZSgwLCA0KSwgY1B0cy50b3BSaWdodC5zcGxpY2UoMCwgNCksIGNQdHMuYm90dG9tUmlnaHQuc3BsaWNlKDAsIDQpLCBjUHRzLmJvdHRvbUxlZnQuc3BsaWNlKDAsIDQpXSk7XG4gICAgICByZXR1cm4gcG9seWdvbkludGVyc2VjdExpbmUoeCwgeSwgcHRzLCBub2RlWCwgbm9kZVkpO1xuICAgIH0sXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICAvLyBDaGVjayBoQm94XG4gICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0IC0gMiAqIHRoaXMuY29ybmVyTGVuZ3RoLCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gQ2hlY2sgdkJveFxuXG5cbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoIC0gMiAqIHRoaXMuY29ybmVyTGVuZ3RoLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3V0VHJpYW5nbGVQdHMgPSB0aGlzLmdlbmVyYXRlQ3V0VHJpYW5nbGVQdHMod2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICByZXR1cm4gcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIGN1dFRyaWFuZ2xlUHRzLnRvcExlZnQpIHx8IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBjdXRUcmlhbmdsZVB0cy50b3BSaWdodCkgfHwgcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIGN1dFRyaWFuZ2xlUHRzLmJvdHRvbVJpZ2h0KSB8fCBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgY3V0VHJpYW5nbGVQdHMuYm90dG9tTGVmdCk7XG4gICAgfVxuICB9O1xufTtcblxuQlJwJDIuZ2VuZXJhdGVCYXJyZWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbJ2JhcnJlbCddID0ge1xuICAgIHJlbmRlcmVyOiB0aGlzLFxuICAgIG5hbWU6ICdiYXJyZWwnLFxuICAgIHBvaW50czogZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDQsIDApLFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKHRoaXMubmFtZSwgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSxcbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZykge1xuICAgICAgLy8gdXNlIHR3byBmaXhlZCB0IHZhbHVlcyBmb3IgdGhlIGJlemllciBjdXJ2ZSBhcHByb3hpbWF0aW9uXG4gICAgICB2YXIgdDAgPSAwLjE1O1xuICAgICAgdmFyIHQxID0gMC41O1xuICAgICAgdmFyIHQyID0gMC44NTtcbiAgICAgIHZhciBiUHRzID0gdGhpcy5nZW5lcmF0ZUJhcnJlbEJlemllclB0cyh3aWR0aCArIDIgKiBwYWRkaW5nLCBoZWlnaHQgKyAyICogcGFkZGluZywgbm9kZVgsIG5vZGVZKTtcblxuICAgICAgdmFyIGFwcHJveGltYXRlQmFycmVsQ3VydmVQdHMgPSBmdW5jdGlvbiBhcHByb3hpbWF0ZUJhcnJlbEN1cnZlUHRzKHB0cykge1xuICAgICAgICAvLyBhcHByb3hpbWF0ZSBjdXJ2ZSBwdHMgYmFzZWQgb24gdGhlIHR3byB0IHZhbHVlc1xuICAgICAgICB2YXIgbTAgPSBxYmV6aWVyUHRBdCh7XG4gICAgICAgICAgeDogcHRzWzBdLFxuICAgICAgICAgIHk6IHB0c1sxXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogcHRzWzJdLFxuICAgICAgICAgIHk6IHB0c1szXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogcHRzWzRdLFxuICAgICAgICAgIHk6IHB0c1s1XVxuICAgICAgICB9LCB0MCk7XG4gICAgICAgIHZhciBtMSA9IHFiZXppZXJQdEF0KHtcbiAgICAgICAgICB4OiBwdHNbMF0sXG4gICAgICAgICAgeTogcHRzWzFdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiBwdHNbMl0sXG4gICAgICAgICAgeTogcHRzWzNdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiBwdHNbNF0sXG4gICAgICAgICAgeTogcHRzWzVdXG4gICAgICAgIH0sIHQxKTtcbiAgICAgICAgdmFyIG0yID0gcWJlemllclB0QXQoe1xuICAgICAgICAgIHg6IHB0c1swXSxcbiAgICAgICAgICB5OiBwdHNbMV1cbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IHB0c1syXSxcbiAgICAgICAgICB5OiBwdHNbM11cbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IHB0c1s0XSxcbiAgICAgICAgICB5OiBwdHNbNV1cbiAgICAgICAgfSwgdDIpO1xuICAgICAgICByZXR1cm4gW3B0c1swXSwgcHRzWzFdLCBtMC54LCBtMC55LCBtMS54LCBtMS55LCBtMi54LCBtMi55LCBwdHNbNF0sIHB0c1s1XV07XG4gICAgICB9O1xuXG4gICAgICB2YXIgcHRzID0gW10uY29uY2F0KGFwcHJveGltYXRlQmFycmVsQ3VydmVQdHMoYlB0cy50b3BMZWZ0KSwgYXBwcm94aW1hdGVCYXJyZWxDdXJ2ZVB0cyhiUHRzLnRvcFJpZ2h0KSwgYXBwcm94aW1hdGVCYXJyZWxDdXJ2ZVB0cyhiUHRzLmJvdHRvbVJpZ2h0KSwgYXBwcm94aW1hdGVCYXJyZWxDdXJ2ZVB0cyhiUHRzLmJvdHRvbUxlZnQpKTtcbiAgICAgIHJldHVybiBwb2x5Z29uSW50ZXJzZWN0TGluZSh4LCB5LCBwdHMsIG5vZGVYLCBub2RlWSk7XG4gICAgfSxcbiAgICBnZW5lcmF0ZUJhcnJlbEJlemllclB0czogZnVuY3Rpb24gZ2VuZXJhdGVCYXJyZWxCZXppZXJQdHMod2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgdmFyIGhoID0gaGVpZ2h0IC8gMjtcbiAgICAgIHZhciBodyA9IHdpZHRoIC8gMjtcbiAgICAgIHZhciB4QmVnaW4gPSBjZW50ZXJYIC0gaHc7XG4gICAgICB2YXIgeEVuZCA9IGNlbnRlclggKyBodztcbiAgICAgIHZhciB5QmVnaW4gPSBjZW50ZXJZIC0gaGg7XG4gICAgICB2YXIgeUVuZCA9IGNlbnRlclkgKyBoaDtcbiAgICAgIHZhciBjdXJ2ZUNvbnN0YW50cyA9IGdldEJhcnJlbEN1cnZlQ29uc3RhbnRzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdmFyIGhPZmZzZXQgPSBjdXJ2ZUNvbnN0YW50cy5oZWlnaHRPZmZzZXQ7XG4gICAgICB2YXIgd09mZnNldCA9IGN1cnZlQ29uc3RhbnRzLndpZHRoT2Zmc2V0O1xuICAgICAgdmFyIGN0cmxQdFhPZmZzZXQgPSBjdXJ2ZUNvbnN0YW50cy5jdHJsUHRPZmZzZXRQY3QgKiB3aWR0aDsgLy8gcG9pbnRzIGFyZSBpbiBjbG9ja3dpc2Ugb3JkZXIsIGlubmVyIChpbWFnaW5hcnkpIGNvbnRyb2wgcHQgb24gWzQsIDVdXG5cbiAgICAgIHZhciBwdHMgPSB7XG4gICAgICAgIHRvcExlZnQ6IFt4QmVnaW4sIHlCZWdpbiArIGhPZmZzZXQsIHhCZWdpbiArIGN0cmxQdFhPZmZzZXQsIHlCZWdpbiwgeEJlZ2luICsgd09mZnNldCwgeUJlZ2luXSxcbiAgICAgICAgdG9wUmlnaHQ6IFt4RW5kIC0gd09mZnNldCwgeUJlZ2luLCB4RW5kIC0gY3RybFB0WE9mZnNldCwgeUJlZ2luLCB4RW5kLCB5QmVnaW4gKyBoT2Zmc2V0XSxcbiAgICAgICAgYm90dG9tUmlnaHQ6IFt4RW5kLCB5RW5kIC0gaE9mZnNldCwgeEVuZCAtIGN0cmxQdFhPZmZzZXQsIHlFbmQsIHhFbmQgLSB3T2Zmc2V0LCB5RW5kXSxcbiAgICAgICAgYm90dG9tTGVmdDogW3hCZWdpbiArIHdPZmZzZXQsIHlFbmQsIHhCZWdpbiArIGN0cmxQdFhPZmZzZXQsIHlFbmQsIHhCZWdpbiwgeUVuZCAtIGhPZmZzZXRdXG4gICAgICB9O1xuICAgICAgcHRzLnRvcExlZnQuaXNUb3AgPSB0cnVlO1xuICAgICAgcHRzLnRvcFJpZ2h0LmlzVG9wID0gdHJ1ZTtcbiAgICAgIHB0cy5ib3R0b21MZWZ0LmlzQm90dG9tID0gdHJ1ZTtcbiAgICAgIHB0cy5ib3R0b21SaWdodC5pc0JvdHRvbSA9IHRydWU7XG4gICAgICByZXR1cm4gcHRzO1xuICAgIH0sXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICB2YXIgY3VydmVDb25zdGFudHMgPSBnZXRCYXJyZWxDdXJ2ZUNvbnN0YW50cyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHZhciBoT2Zmc2V0ID0gY3VydmVDb25zdGFudHMuaGVpZ2h0T2Zmc2V0O1xuICAgICAgdmFyIHdPZmZzZXQgPSBjdXJ2ZUNvbnN0YW50cy53aWR0aE9mZnNldDsgLy8gQ2hlY2sgaEJveFxuXG4gICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0IC0gMiAqIGhPZmZzZXQsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBDaGVjayB2Qm94XG5cblxuICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLSAyICogd09mZnNldCwgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJhcnJlbEN1cnZlUHRzID0gdGhpcy5nZW5lcmF0ZUJhcnJlbEJlemllclB0cyh3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKTtcblxuICAgICAgdmFyIGdldEN1cnZlVCA9IGZ1bmN0aW9uIGdldEN1cnZlVCh4LCB5LCBjdXJ2ZVB0cykge1xuICAgICAgICB2YXIgeDAgPSBjdXJ2ZVB0c1s0XTtcbiAgICAgICAgdmFyIHgxID0gY3VydmVQdHNbMl07XG4gICAgICAgIHZhciB4MiA9IGN1cnZlUHRzWzBdO1xuICAgICAgICB2YXIgeTAgPSBjdXJ2ZVB0c1s1XTsgLy8gdmFyIHkxID0gY3VydmVQdHNbIDMgXTtcblxuICAgICAgICB2YXIgeTIgPSBjdXJ2ZVB0c1sxXTtcbiAgICAgICAgdmFyIHhNaW4gPSBNYXRoLm1pbih4MCwgeDIpO1xuICAgICAgICB2YXIgeE1heCA9IE1hdGgubWF4KHgwLCB4Mik7XG4gICAgICAgIHZhciB5TWluID0gTWF0aC5taW4oeTAsIHkyKTtcbiAgICAgICAgdmFyIHlNYXggPSBNYXRoLm1heCh5MCwgeTIpO1xuXG4gICAgICAgIGlmICh4TWluIDw9IHggJiYgeCA8PSB4TWF4ICYmIHlNaW4gPD0geSAmJiB5IDw9IHlNYXgpIHtcbiAgICAgICAgICB2YXIgY29lZmYgPSBiZXppZXJQdHNUb1F1YWRDb2VmZih4MCwgeDEsIHgyKTtcbiAgICAgICAgICB2YXIgcm9vdHMgPSBzb2x2ZVF1YWRyYXRpYyhjb2VmZlswXSwgY29lZmZbMV0sIGNvZWZmWzJdLCB4KTtcbiAgICAgICAgICB2YXIgdmFsaWRSb290cyA9IHJvb3RzLmZpbHRlcihmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgcmV0dXJuIDAgPD0gciAmJiByIDw9IDE7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAodmFsaWRSb290cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRSb290c1swXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIHZhciBjdXJ2ZVJlZ2lvbnMgPSBPYmplY3Qua2V5cyhiYXJyZWxDdXJ2ZVB0cyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VydmVSZWdpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb3JuZXIgPSBjdXJ2ZVJlZ2lvbnNbaV07XG4gICAgICAgIHZhciBjb3JuZXJQdHMgPSBiYXJyZWxDdXJ2ZVB0c1tjb3JuZXJdO1xuICAgICAgICB2YXIgdCA9IGdldEN1cnZlVCh4LCB5LCBjb3JuZXJQdHMpO1xuXG4gICAgICAgIGlmICh0ID09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB5MCA9IGNvcm5lclB0c1s1XTtcbiAgICAgICAgdmFyIHkxID0gY29ybmVyUHRzWzNdO1xuICAgICAgICB2YXIgeTIgPSBjb3JuZXJQdHNbMV07XG4gICAgICAgIHZhciBiZXpZID0gcWJlemllckF0KHkwLCB5MSwgeTIsIHQpO1xuXG4gICAgICAgIGlmIChjb3JuZXJQdHMuaXNUb3AgJiYgYmV6WSA8PSB5KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29ybmVyUHRzLmlzQm90dG9tICYmIHkgPD0gYmV6WSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG59O1xuXG5CUnAkMi5nZW5lcmF0ZUJvdHRvbVJvdW5kcmVjdGFuZ2xlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2RlU2hhcGVzWydib3R0b20tcm91bmQtcmVjdGFuZ2xlJ10gPSB0aGlzLm5vZGVTaGFwZXNbJ2JvdHRvbXJvdW5kcmVjdGFuZ2xlJ10gPSB7XG4gICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgbmFtZTogJ2JvdHRvbS1yb3VuZC1yZWN0YW5nbGUnLFxuICAgIHBvaW50czogZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDQsIDApLFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKHRoaXMubmFtZSwgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSxcbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZykge1xuICAgICAgdmFyIHRvcFN0YXJ0WCA9IG5vZGVYIC0gKHdpZHRoIC8gMiArIHBhZGRpbmcpO1xuICAgICAgdmFyIHRvcFN0YXJ0WSA9IG5vZGVZIC0gKGhlaWdodCAvIDIgKyBwYWRkaW5nKTtcbiAgICAgIHZhciB0b3BFbmRZID0gdG9wU3RhcnRZO1xuICAgICAgdmFyIHRvcEVuZFggPSBub2RlWCArICh3aWR0aCAvIDIgKyBwYWRkaW5nKTtcbiAgICAgIHZhciB0b3BJbnRlcnNlY3Rpb25zID0gZmluaXRlTGluZXNJbnRlcnNlY3QoeCwgeSwgbm9kZVgsIG5vZGVZLCB0b3BTdGFydFgsIHRvcFN0YXJ0WSwgdG9wRW5kWCwgdG9wRW5kWSwgZmFsc2UpO1xuXG4gICAgICBpZiAodG9wSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB0b3BJbnRlcnNlY3Rpb25zO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcm91bmRSZWN0YW5nbGVJbnRlcnNlY3RMaW5lKHgsIHksIG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZyk7XG4gICAgfSxcbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbiBjaGVja1BvaW50KHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgIHZhciBjb3JuZXJSYWRpdXMgPSBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHZhciBkaWFtID0gMiAqIGNvcm5lclJhZGl1czsgLy8gQ2hlY2sgaEJveFxuXG4gICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0IC0gZGlhbSwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIENoZWNrIHZCb3hcblxuXG4gICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCAtIGRpYW0sIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIGNoZWNrIG5vbi1yb3VuZGVkIHRvcCBzaWRlXG5cblxuICAgICAgdmFyIG91dGVyV2lkdGggPSB3aWR0aCAvIDIgKyAyICogcGFkZGluZztcbiAgICAgIHZhciBvdXRlckhlaWdodCA9IGhlaWdodCAvIDIgKyAyICogcGFkZGluZztcbiAgICAgIHZhciBwb2ludHMgPSBbY2VudGVyWCAtIG91dGVyV2lkdGgsIGNlbnRlclkgLSBvdXRlckhlaWdodCwgY2VudGVyWCAtIG91dGVyV2lkdGgsIGNlbnRlclksIGNlbnRlclggKyBvdXRlcldpZHRoLCBjZW50ZXJZLCBjZW50ZXJYICsgb3V0ZXJXaWR0aCwgY2VudGVyWSAtIG91dGVySGVpZ2h0XTtcblxuICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBwb2ludHMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBDaGVjayBib3R0b20gcmlnaHQgcXVhcnRlciBjaXJjbGVcblxuXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSwgZGlhbSwgZGlhbSwgY2VudGVyWCArIHdpZHRoIC8gMiAtIGNvcm5lclJhZGl1cywgY2VudGVyWSArIGhlaWdodCAvIDIgLSBjb3JuZXJSYWRpdXMsIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBDaGVjayBib3R0b20gbGVmdCBxdWFydGVyIGNpcmNsZVxuXG5cbiAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LCBkaWFtLCBkaWFtLCBjZW50ZXJYIC0gd2lkdGggLyAyICsgY29ybmVyUmFkaXVzLCBjZW50ZXJZICsgaGVpZ2h0IC8gMiAtIGNvcm5lclJhZGl1cywgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG59O1xuXG5CUnAkMi5yZWdpc3Rlck5vZGVTaGFwZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlU2hhcGVzID0gdGhpcy5ub2RlU2hhcGVzID0ge307XG4gIHZhciByZW5kZXJlciA9IHRoaXM7XG4gIHRoaXMuZ2VuZXJhdGVFbGxpcHNlKCk7XG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCd0cmlhbmdsZScsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSgzLCAwKSk7XG4gIHRoaXMuZ2VuZXJhdGVSb3VuZFBvbHlnb24oJ3JvdW5kLXRyaWFuZ2xlJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDMsIDApKTtcbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3JlY3RhbmdsZScsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg0LCAwKSk7XG4gIG5vZGVTaGFwZXNbJ3NxdWFyZSddID0gbm9kZVNoYXBlc1sncmVjdGFuZ2xlJ107XG4gIHRoaXMuZ2VuZXJhdGVSb3VuZFJlY3RhbmdsZSgpO1xuICB0aGlzLmdlbmVyYXRlQ3V0UmVjdGFuZ2xlKCk7XG4gIHRoaXMuZ2VuZXJhdGVCYXJyZWwoKTtcbiAgdGhpcy5nZW5lcmF0ZUJvdHRvbVJvdW5kcmVjdGFuZ2xlKCk7XG4gIHtcbiAgICB2YXIgZGlhbW9uZFBvaW50cyA9IFswLCAxLCAxLCAwLCAwLCAtMSwgLTEsIDBdO1xuICAgIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdkaWFtb25kJywgZGlhbW9uZFBvaW50cyk7XG4gICAgdGhpcy5nZW5lcmF0ZVJvdW5kUG9seWdvbigncm91bmQtZGlhbW9uZCcsIGRpYW1vbmRQb2ludHMpO1xuICB9XG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdwZW50YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg1LCAwKSk7XG4gIHRoaXMuZ2VuZXJhdGVSb3VuZFBvbHlnb24oJ3JvdW5kLXBlbnRhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDUsIDApKTtcbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ2hleGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNiwgMCkpO1xuICB0aGlzLmdlbmVyYXRlUm91bmRQb2x5Z29uKCdyb3VuZC1oZXhhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDYsIDApKTtcbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ2hlcHRhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDcsIDApKTtcbiAgdGhpcy5nZW5lcmF0ZVJvdW5kUG9seWdvbigncm91bmQtaGVwdGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNywgMCkpO1xuICB0aGlzLmdlbmVyYXRlUG9seWdvbignb2N0YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg4LCAwKSk7XG4gIHRoaXMuZ2VuZXJhdGVSb3VuZFBvbHlnb24oJ3JvdW5kLW9jdGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoOCwgMCkpO1xuICB2YXIgc3RhcjVQb2ludHMgPSBuZXcgQXJyYXkoMjApO1xuICB7XG4gICAgdmFyIG91dGVyUG9pbnRzID0gZ2VuZXJhdGVVbml0TmdvblBvaW50cyg1LCAwKTtcbiAgICB2YXIgaW5uZXJQb2ludHMgPSBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzKDUsIE1hdGguUEkgLyA1KTsgLy8gT3V0ZXIgcmFkaXVzIGlzIDE7IGlubmVyIHJhZGl1cyBvZiBzdGFyIGlzIHNtYWxsZXJcblxuICAgIHZhciBpbm5lclJhZGl1cyA9IDAuNSAqICgzIC0gTWF0aC5zcXJ0KDUpKTtcbiAgICBpbm5lclJhZGl1cyAqPSAxLjU3O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbm5lclBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIGlubmVyUG9pbnRzW2kgKiAyXSAqPSBpbm5lclJhZGl1cztcbiAgICAgIGlubmVyUG9pbnRzW2kgKiAyICsgMV0gKj0gaW5uZXJSYWRpdXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyMCAvIDQ7IGkrKykge1xuICAgICAgc3RhcjVQb2ludHNbaSAqIDRdID0gb3V0ZXJQb2ludHNbaSAqIDJdO1xuICAgICAgc3RhcjVQb2ludHNbaSAqIDQgKyAxXSA9IG91dGVyUG9pbnRzW2kgKiAyICsgMV07XG4gICAgICBzdGFyNVBvaW50c1tpICogNCArIDJdID0gaW5uZXJQb2ludHNbaSAqIDJdO1xuICAgICAgc3RhcjVQb2ludHNbaSAqIDQgKyAzXSA9IGlubmVyUG9pbnRzW2kgKiAyICsgMV07XG4gICAgfVxuICB9XG4gIHN0YXI1UG9pbnRzID0gZml0UG9seWdvblRvU3F1YXJlKHN0YXI1UG9pbnRzKTtcbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3N0YXInLCBzdGFyNVBvaW50cyk7XG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCd2ZWUnLCBbLTEsIC0xLCAwLCAtMC4zMzMsIDEsIC0xLCAwLCAxXSk7XG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdyaG9tYm9pZCcsIFstMSwgLTEsIDAuMzMzLCAtMSwgMSwgMSwgLTAuMzMzLCAxXSk7XG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdyaWdodC1yaG9tYm9pZCcsIFstMC4zMzMsIC0xLCAxLCAtMSwgMC4zMzMsIDEsIC0xLCAxXSk7XG4gIHRoaXMubm9kZVNoYXBlc1snY29uY2F2ZWhleGFnb24nXSA9IHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdjb25jYXZlLWhleGFnb24nLCBbLTEsIC0wLjk1LCAtMC43NSwgMCwgLTEsIDAuOTUsIDEsIDAuOTUsIDAuNzUsIDAsIDEsIC0wLjk1XSk7XG4gIHtcbiAgICB2YXIgdGFnUG9pbnRzID0gWy0xLCAtMSwgMC4yNSwgLTEsIDEsIDAsIDAuMjUsIDEsIC0xLCAxXTtcbiAgICB0aGlzLmdlbmVyYXRlUG9seWdvbigndGFnJywgdGFnUG9pbnRzKTtcbiAgICB0aGlzLmdlbmVyYXRlUm91bmRQb2x5Z29uKCdyb3VuZC10YWcnLCB0YWdQb2ludHMpO1xuICB9XG5cbiAgbm9kZVNoYXBlcy5tYWtlUG9seWdvbiA9IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICAvLyB1c2UgY2FjaGluZyBvbiB1c2VyLXNwZWNpZmllZCBwb2x5Z29ucyBzbyB0aGV5IGFyZSBhcyBmYXN0IGFzIG5hdGl2ZSBzaGFwZXNcbiAgICB2YXIga2V5ID0gcG9pbnRzLmpvaW4oJyQnKTtcbiAgICB2YXIgbmFtZSA9ICdwb2x5Z29uLScgKyBrZXk7XG4gICAgdmFyIHNoYXBlO1xuXG4gICAgaWYgKHNoYXBlID0gdGhpc1tuYW1lXSkge1xuICAgICAgLy8gZ290IGNhY2hlZCBzaGFwZVxuICAgICAgcmV0dXJuIHNoYXBlO1xuICAgIH0gLy8gY3JlYXRlIGFuZCBjYWNoZSBuZXcgc2hhcGVcblxuXG4gICAgcmV0dXJuIHJlbmRlcmVyLmdlbmVyYXRlUG9seWdvbihuYW1lLCBwb2ludHMpO1xuICB9O1xufTtcblxudmFyIEJScCQxID0ge307XG5cbkJScCQxLnRpbWVUb1JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVkcmF3VG90YWxUaW1lIC8gdGhpcy5yZWRyYXdDb3VudDtcbn07XG5cbkJScCQxLnJlZHJhdyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHN0YXRpY0VtcHR5T2JqZWN0KCk7XG4gIHZhciByID0gdGhpcztcblxuICBpZiAoci5hdmVyYWdlUmVkcmF3VGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgci5hdmVyYWdlUmVkcmF3VGltZSA9IDA7XG4gIH1cblxuICBpZiAoci5sYXN0UmVkcmF3VGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgci5sYXN0UmVkcmF3VGltZSA9IDA7XG4gIH1cblxuICBpZiAoci5sYXN0RHJhd1RpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHIubGFzdERyYXdUaW1lID0gMDtcbiAgfVxuXG4gIHIucmVxdWVzdGVkRnJhbWUgPSB0cnVlO1xuICByLnJlbmRlck9wdGlvbnMgPSBvcHRpb25zO1xufTtcblxuQlJwJDEuYmVmb3JlUmVuZGVyID0gZnVuY3Rpb24gKGZuLCBwcmlvcml0eSkge1xuICAvLyB0aGUgcmVuZGVyZXIgY2FuJ3QgYWRkIHRpY2sgY2FsbGJhY2tzIHdoZW4gZGVzdHJveWVkXG4gIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChwcmlvcml0eSA9PSBudWxsKSB7XG4gICAgZXJyb3IoJ1ByaW9yaXR5IGlzIG5vdCBvcHRpb25hbCBmb3IgYmVmb3JlUmVuZGVyJyk7XG4gIH1cblxuICB2YXIgY2JzID0gdGhpcy5iZWZvcmVSZW5kZXJDYWxsYmFja3M7XG4gIGNicy5wdXNoKHtcbiAgICBmbjogZm4sXG4gICAgcHJpb3JpdHk6IHByaW9yaXR5XG4gIH0pOyAvLyBoaWdoZXIgcHJpb3JpdHkgY2FsbGJhY2tzIGV4ZWN1dGVkIGZpcnN0XG5cbiAgY2JzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5wcmlvcml0eSAtIGEucHJpb3JpdHk7XG4gIH0pO1xufTtcblxudmFyIGJlZm9yZVJlbmRlckNhbGxiYWNrcyA9IGZ1bmN0aW9uIGJlZm9yZVJlbmRlckNhbGxiYWNrcyhyLCB3aWxsRHJhdywgc3RhcnRUaW1lKSB7XG4gIHZhciBjYnMgPSByLmJlZm9yZVJlbmRlckNhbGxiYWNrcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5sZW5ndGg7IGkrKykge1xuICAgIGNic1tpXS5mbih3aWxsRHJhdywgc3RhcnRUaW1lKTtcbiAgfVxufTtcblxuQlJwJDEuc3RhcnRSZW5kZXJMb29wID0gZnVuY3Rpb24gKCkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBjeSA9IHIuY3k7XG5cbiAgaWYgKHIucmVuZGVyTG9vcFN0YXJ0ZWQpIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgci5yZW5kZXJMb29wU3RhcnRlZCA9IHRydWU7XG4gIH1cblxuICB2YXIgcmVuZGVyRm4gPSBmdW5jdGlvbiByZW5kZXJGbihyZXF1ZXN0VGltZSkge1xuICAgIGlmIChyLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjeS5iYXRjaGluZygpKSA7IGVsc2UgaWYgKHIucmVxdWVzdGVkRnJhbWUgJiYgIXIuc2tpcEZyYW1lKSB7XG4gICAgICBiZWZvcmVSZW5kZXJDYWxsYmFja3MociwgdHJ1ZSwgcmVxdWVzdFRpbWUpO1xuICAgICAgdmFyIHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG4gICAgICByLnJlbmRlcihyLnJlbmRlck9wdGlvbnMpO1xuICAgICAgdmFyIGVuZFRpbWUgPSByLmxhc3REcmF3VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG5cbiAgICAgIGlmIChyLmF2ZXJhZ2VSZWRyYXdUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgci5hdmVyYWdlUmVkcmF3VGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChyLnJlZHJhd0NvdW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgci5yZWRyYXdDb3VudCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHIucmVkcmF3Q291bnQrKztcblxuICAgICAgaWYgKHIucmVkcmF3VG90YWxUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgci5yZWRyYXdUb3RhbFRpbWUgPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHVyYXRpb24gPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgci5yZWRyYXdUb3RhbFRpbWUgKz0gZHVyYXRpb247XG4gICAgICByLmxhc3RSZWRyYXdUaW1lID0gZHVyYXRpb247IC8vIHVzZSBhIHdlaWdodGVkIGF2ZXJhZ2Ugd2l0aCBhIGJpYXMgZnJvbSB0aGUgcHJldmlvdXMgYXZlcmFnZSBzbyB3ZSBkb24ndCBzcGlrZSBzbyBlYXNpbHlcblxuICAgICAgci5hdmVyYWdlUmVkcmF3VGltZSA9IHIuYXZlcmFnZVJlZHJhd1RpbWUgLyAyICsgZHVyYXRpb24gLyAyO1xuICAgICAgci5yZXF1ZXN0ZWRGcmFtZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBiZWZvcmVSZW5kZXJDYWxsYmFja3MociwgZmFsc2UsIHJlcXVlc3RUaW1lKTtcbiAgICB9XG5cbiAgICByLnNraXBGcmFtZSA9IGZhbHNlO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXJGbik7XG4gIH07XG5cbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlckZuKTtcbn07XG5cbnZhciBCYXNlUmVuZGVyZXIgPSBmdW5jdGlvbiBCYXNlUmVuZGVyZXIob3B0aW9ucykge1xuICB0aGlzLmluaXQob3B0aW9ucyk7XG59O1xuXG52YXIgQlIgPSBCYXNlUmVuZGVyZXI7XG52YXIgQlJwID0gQlIucHJvdG90eXBlO1xuQlJwLmNsaWVudEZ1bmN0aW9ucyA9IFsncmVkcmF3SGludCcsICdyZW5kZXInLCAncmVuZGVyVG8nLCAnbWF0Y2hDYW52YXNTaXplJywgJ25vZGVTaGFwZUltcGwnLCAnYXJyb3dTaGFwZUltcGwnXTtcblxuQlJwLmluaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgciA9IHRoaXM7XG4gIHIub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHIuY3kgPSBvcHRpb25zLmN5O1xuICB2YXIgY3RyID0gci5jb250YWluZXIgPSBvcHRpb25zLmN5LmNvbnRhaW5lcigpO1xuICB2YXIgY29udGFpbmVyV2luZG93ID0gci5jeS53aW5kb3coKTsgLy8gcHJlcGVuZCBhIHN0eWxlc2hlZXQgaW4gdGhlIGhlYWQgc3VjaCB0aGF0XG5cbiAgaWYgKGNvbnRhaW5lcldpbmRvdykge1xuICAgIHZhciBkb2N1bWVudCA9IGNvbnRhaW5lcldpbmRvdy5kb2N1bWVudDtcbiAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQ7XG4gICAgdmFyIHN0eWxlc2hlZXRJZCA9ICdfX19fX19fX19fY3l0b3NjYXBlX3N0eWxlc2hlZXQnO1xuICAgIHZhciBjbGFzc05hbWUgPSAnX19fX19fX19fX2N5dG9zY2FwZV9jb250YWluZXInO1xuICAgIHZhciBzdHlsZXNoZWV0QWxyZWFkeUV4aXN0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHN0eWxlc2hlZXRJZCkgIT0gbnVsbDtcblxuICAgIGlmIChjdHIuY2xhc3NOYW1lLmluZGV4T2YoY2xhc3NOYW1lKSA8IDApIHtcbiAgICAgIGN0ci5jbGFzc05hbWUgPSAoY3RyLmNsYXNzTmFtZSB8fCAnJykgKyAnICcgKyBjbGFzc05hbWU7XG4gICAgfVxuXG4gICAgaWYgKCFzdHlsZXNoZWV0QWxyZWFkeUV4aXN0cykge1xuICAgICAgdmFyIHN0eWxlc2hlZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgc3R5bGVzaGVldC5pZCA9IHN0eWxlc2hlZXRJZDtcbiAgICAgIHN0eWxlc2hlZXQudGV4dENvbnRlbnQgPSAnLicgKyBjbGFzc05hbWUgKyAnIHsgcG9zaXRpb246IHJlbGF0aXZlOyB9JztcbiAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlc2hlZXQsIGhlYWQuY2hpbGRyZW5bMF0pOyAvLyBmaXJzdCBzbyBsb3dlc3QgcHJpb3JpdHlcbiAgICB9XG5cbiAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IGNvbnRhaW5lcldpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGN0cik7XG4gICAgdmFyIHBvc2l0aW9uID0gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdwb3NpdGlvbicpO1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgICAgd2FybignQSBDeXRvc2NhcGUgY29udGFpbmVyIGhhcyBzdHlsZSBwb3NpdGlvbjpzdGF0aWMgYW5kIHNvIGNhbiBub3QgdXNlIFVJIGV4dGVuc2lvbnMgcHJvcGVybHknKTtcbiAgICB9XG4gIH1cblxuICByLnNlbGVjdGlvbiA9IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIDBdOyAvLyBDb29yZGluYXRlcyBmb3Igc2VsZWN0aW9uIGJveCwgcGx1cyBlbmFibGVkIGZsYWdcblxuICByLmJlemllclByb2pQY3RzID0gWzAuMDUsIDAuMjI1LCAwLjQsIDAuNSwgMC42LCAwLjc3NSwgMC45NV07IC8vLS1Qb2ludGVyLXJlbGF0ZWQgZGF0YVxuXG4gIHIuaG92ZXJEYXRhID0ge1xuICAgIGRvd246IG51bGwsXG4gICAgbGFzdDogbnVsbCxcbiAgICBkb3duVGltZTogbnVsbCxcbiAgICB0cmlnZ2VyTW9kZTogbnVsbCxcbiAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgaW5pdGlhbFBhbjogW251bGwsIG51bGxdLFxuICAgIGNhcHR1cmU6IGZhbHNlXG4gIH07XG4gIHIuZHJhZ0RhdGEgPSB7XG4gICAgcG9zc2libGVEcmFnRWxlbWVudHM6IFtdXG4gIH07XG4gIHIudG91Y2hEYXRhID0ge1xuICAgIHN0YXJ0OiBudWxsLFxuICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgIC8vIFRoZXNlIDMgZmllbGRzIHJlbGF0ZWQgdG8gdGFwLCB0YXBob2xkIGV2ZW50c1xuICAgIHN0YXJ0UG9zaXRpb246IFtudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsXSxcbiAgICBzaW5nbGVUb3VjaFN0YXJ0VGltZTogbnVsbCxcbiAgICBzaW5nbGVUb3VjaE1vdmVkOiB0cnVlLFxuICAgIG5vdzogW251bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGxdLFxuICAgIGVhcmxpZXI6IFtudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsXVxuICB9O1xuICByLnJlZHJhd3MgPSAwO1xuICByLnNob3dGcHMgPSBvcHRpb25zLnNob3dGcHM7XG4gIHIuZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuICByLmhpZGVFZGdlc09uVmlld3BvcnQgPSBvcHRpb25zLmhpZGVFZGdlc09uVmlld3BvcnQ7XG4gIHIudGV4dHVyZU9uVmlld3BvcnQgPSBvcHRpb25zLnRleHR1cmVPblZpZXdwb3J0O1xuICByLndoZWVsU2Vuc2l0aXZpdHkgPSBvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHk7XG4gIHIubW90aW9uQmx1ckVuYWJsZWQgPSBvcHRpb25zLm1vdGlvbkJsdXI7IC8vIG9uIGJ5IGRlZmF1bHRcblxuICByLmZvcmNlZFBpeGVsUmF0aW8gPSBudW1iZXIkMShvcHRpb25zLnBpeGVsUmF0aW8pID8gb3B0aW9ucy5waXhlbFJhdGlvIDogbnVsbDtcbiAgci5tb3Rpb25CbHVyID0gb3B0aW9ucy5tb3Rpb25CbHVyOyAvLyBmb3IgaW5pdGlhbCBraWNrIG9mZlxuXG4gIHIubW90aW9uQmx1ck9wYWNpdHkgPSBvcHRpb25zLm1vdGlvbkJsdXJPcGFjaXR5O1xuICByLm1vdGlvbkJsdXJUcmFuc3BhcmVuY3kgPSAxIC0gci5tb3Rpb25CbHVyT3BhY2l0eTtcbiAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IDE7XG4gIHIubWJQeFJCbHVycnkgPSAxOyAvLzAuODtcblxuICByLm1pbk1iTG93UXVhbEZyYW1lcyA9IDQ7XG4gIHIuZnVsbFF1YWxpdHlNYiA9IGZhbHNlO1xuICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyID0gW107XG4gIHIuZGVza3RvcFRhcFRocmVzaG9sZCA9IG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZDtcbiAgci5kZXNrdG9wVGFwVGhyZXNob2xkMiA9IG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZCAqIG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZDtcbiAgci50b3VjaFRhcFRocmVzaG9sZCA9IG9wdGlvbnMudG91Y2hUYXBUaHJlc2hvbGQ7XG4gIHIudG91Y2hUYXBUaHJlc2hvbGQyID0gb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZCAqIG9wdGlvbnMudG91Y2hUYXBUaHJlc2hvbGQ7XG4gIHIudGFwaG9sZER1cmF0aW9uID0gNTAwO1xuICByLmJpbmRpbmdzID0gW107XG4gIHIuYmVmb3JlUmVuZGVyQ2FsbGJhY2tzID0gW107XG4gIHIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcyA9IHtcbiAgICAvLyBoaWdoZXIgcHJpb3JpdHkgZXhlY3MgYmVmb3JlIGxvd2VyIG9uZVxuICAgIGFuaW1hdGlvbnM6IDQwMCxcbiAgICBlbGVDYWxjczogMzAwLFxuICAgIGVsZVR4ckRlcTogMjAwLFxuICAgIGx5clR4ckRlcTogMTUwLFxuICAgIGx5clR4clNraXA6IDEwMFxuICB9O1xuICByLnJlZ2lzdGVyTm9kZVNoYXBlcygpO1xuICByLnJlZ2lzdGVyQXJyb3dTaGFwZXMoKTtcbiAgci5yZWdpc3RlckNhbGN1bGF0aW9uTGlzdGVuZXJzKCk7XG59O1xuXG5CUnAubm90aWZ5ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZWxlcykge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBjeSA9IHIuY3k7IC8vIHRoZSByZW5kZXJlciBjYW4ndCBiZSBub3RpZmllZCBhZnRlciBpdCdzIGRlc3Ryb3llZFxuXG4gIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChldmVudE5hbWUgPT09ICdpbml0Jykge1xuICAgIHIubG9hZCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChldmVudE5hbWUgPT09ICdkZXN0cm95Jykge1xuICAgIHIuZGVzdHJveSgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChldmVudE5hbWUgPT09ICdhZGQnIHx8IGV2ZW50TmFtZSA9PT0gJ3JlbW92ZScgfHwgZXZlbnROYW1lID09PSAnbW92ZScgJiYgY3kuaGFzQ29tcG91bmROb2RlcygpIHx8IGV2ZW50TmFtZSA9PT0gJ2xvYWQnIHx8IGV2ZW50TmFtZSA9PT0gJ3pvcmRlcicgfHwgZXZlbnROYW1lID09PSAnbW91bnQnKSB7XG4gICAgci5pbnZhbGlkYXRlQ2FjaGVkWlNvcnRlZEVsZXMoKTtcbiAgfVxuXG4gIGlmIChldmVudE5hbWUgPT09ICd2aWV3cG9ydCcpIHtcbiAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICB9XG5cbiAgaWYgKGV2ZW50TmFtZSA9PT0gJ2xvYWQnIHx8IGV2ZW50TmFtZSA9PT0gJ3Jlc2l6ZScgfHwgZXZlbnROYW1lID09PSAnbW91bnQnKSB7XG4gICAgci5pbnZhbGlkYXRlQ29udGFpbmVyQ2xpZW50Q29vcmRzQ2FjaGUoKTtcbiAgICByLm1hdGNoQ2FudmFzU2l6ZShyLmNvbnRhaW5lcik7XG4gIH1cblxuICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gIHRoaXMuc3RhcnRSZW5kZXJMb29wKCk7XG4gIHRoaXMucmVkcmF3KCk7XG59O1xuXG5CUnAuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICByLmRlc3Ryb3llZCA9IHRydWU7XG4gIHIuY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHIuYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYmluZGluZyA9IHIuYmluZGluZ3NbaV07XG4gICAgdmFyIGIgPSBiaW5kaW5nO1xuICAgIHZhciB0Z3QgPSBiLnRhcmdldDtcbiAgICAodGd0Lm9mZiB8fCB0Z3QucmVtb3ZlRXZlbnRMaXN0ZW5lcikuYXBwbHkodGd0LCBiLmFyZ3MpO1xuICB9XG5cbiAgci5iaW5kaW5ncyA9IFtdO1xuICByLmJlZm9yZVJlbmRlckNhbGxiYWNrcyA9IFtdO1xuICByLm9uVXBkYXRlRWxlQ2FsY3NGbnMgPSBbXTtcblxuICBpZiAoci5yZW1vdmVPYnNlcnZlcikge1xuICAgIHIucmVtb3ZlT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9XG5cbiAgaWYgKHIuc3R5bGVPYnNlcnZlcikge1xuICAgIHIuc3R5bGVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH1cblxuICBpZiAoci5yZXNpemVPYnNlcnZlcikge1xuICAgIHIucmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9XG5cbiAgaWYgKHIubGFiZWxDYWxjRGl2KSB7XG4gICAgdHJ5IHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoci5sYWJlbENhbGNEaXYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgfSBjYXRjaCAoZSkgey8vIGllMTAgaXNzdWUgIzEwMTRcbiAgICB9XG4gIH1cbn07XG5cbkJScC5pc0hlYWRsZXNzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG5bQlJwJGYsIEJScCQ1LCBCUnAkNCwgQlJwJDMsIEJScCQyLCBCUnAkMV0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgZXh0ZW5kKEJScCwgcHJvcHMpO1xufSk7XG5cbnZhciBmdWxsRnBzVGltZSA9IDEwMDAgLyA2MDsgLy8gYXNzdW1lIDYwIGZyYW1lcyBwZXIgc2Vjb25kXG5cbnZhciBkZWZzID0ge1xuICBzZXR1cERlcXVldWVpbmc6IGZ1bmN0aW9uIHNldHVwRGVxdWV1ZWluZyhvcHRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNldHVwRGVxdWV1ZWluZ0ltcGwoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgciA9IHRoaXMucmVuZGVyZXI7XG5cbiAgICAgIGlmIChzZWxmLmRlcXVldWVpbmdTZXR1cCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmRlcXVldWVpbmdTZXR1cCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBxdWV1ZVJlZHJhdyA9IGRlYm91bmNlX19kZWZhdWx0W1wiZGVmYXVsdFwiXShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH0sIG9wdHMuZGVxUmVkcmF3VGhyZXNob2xkKTtcblxuICAgICAgdmFyIGRlcXVldWUgPSBmdW5jdGlvbiBkZXF1ZXVlKHdpbGxEcmF3LCBmcmFtZVN0YXJ0VGltZSkge1xuICAgICAgICB2YXIgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgdmFyIGF2Z1JlbmRlclRpbWUgPSByLmF2ZXJhZ2VSZWRyYXdUaW1lO1xuICAgICAgICB2YXIgcmVuZGVyVGltZSA9IHIubGFzdFJlZHJhd1RpbWU7XG4gICAgICAgIHZhciBkZXFkID0gW107XG4gICAgICAgIHZhciBleHRlbnQgPSByLmN5LmV4dGVudCgpO1xuICAgICAgICB2YXIgcGl4ZWxSYXRpbyA9IHIuZ2V0UGl4ZWxSYXRpbygpOyAvLyBpZiB3ZSBhcmVuJ3QgaW4gYSB0aWNrIHRoYXQgY2F1c2VzIGEgZHJhdywgdGhlbiB0aGUgcmVuZGVyZWQgc3R5bGVcbiAgICAgICAgLy8gcXVldWUgd29uJ3QgYXV0b21hdGljYWxseSBiZSBmbHVzaGVkIGJlZm9yZSBkZXF1ZXVlaW5nIHN0YXJ0c1xuXG4gICAgICAgIGlmICghd2lsbERyYXcpIHtcbiAgICAgICAgICByLmZsdXNoUmVuZGVyZWRTdHlsZVF1ZXVlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgICAgdmFyIG5vdyA9IHBlcmZvcm1hbmNlTm93KCk7XG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gbm93IC0gc3RhcnRUaW1lO1xuICAgICAgICAgIHZhciBmcmFtZUR1cmF0aW9uID0gbm93IC0gZnJhbWVTdGFydFRpbWU7XG5cbiAgICAgICAgICBpZiAocmVuZGVyVGltZSA8IGZ1bGxGcHNUaW1lKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSdyZSByZW5kZXJpbmcgZmFzdGVyIHRoYW4gdGhlIGlkZWFsIGZwcywgdGhlbiBkbyBkZXF1ZXVlaW5nXG4gICAgICAgICAgICAvLyBkdXJpbmcgYWxsIG9mIHRoZSByZW1haW5pbmcgZnJhbWUgdGltZVxuICAgICAgICAgICAgdmFyIHRpbWVBdmFpbGFibGUgPSBmdWxsRnBzVGltZSAtICh3aWxsRHJhdyA/IGF2Z1JlbmRlclRpbWUgOiAwKTtcblxuICAgICAgICAgICAgaWYgKGZyYW1lRHVyYXRpb24gPj0gb3B0cy5kZXFGYXN0Q29zdCAqIHRpbWVBdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh3aWxsRHJhdykge1xuICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gPj0gb3B0cy5kZXFDb3N0ICogcmVuZGVyVGltZSB8fCBkdXJhdGlvbiA+PSBvcHRzLmRlcUF2Z0Nvc3QgKiBhdmdSZW5kZXJUaW1lKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZnJhbWVEdXJhdGlvbiA+PSBvcHRzLmRlcU5vRHJhd0Nvc3QgKiBmdWxsRnBzVGltZSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdGhpc0RlcWQgPSBvcHRzLmRlcShzZWxmLCBwaXhlbFJhdGlvLCBleHRlbnQpO1xuXG4gICAgICAgICAgaWYgKHRoaXNEZXFkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpc0RlcWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgZGVxZC5wdXNoKHRoaXNEZXFkW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGNhbGxiYWNrcyBvbiBkZXF1ZXVlXG5cblxuICAgICAgICBpZiAoZGVxZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgb3B0cy5vbkRlcWQoc2VsZiwgZGVxZCk7XG5cbiAgICAgICAgICBpZiAoIXdpbGxEcmF3ICYmIG9wdHMuc2hvdWxkUmVkcmF3KHNlbGYsIGRlcWQsIHBpeGVsUmF0aW8sIGV4dGVudCkpIHtcbiAgICAgICAgICAgIHF1ZXVlUmVkcmF3KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgcHJpb3JpdHkgPSBvcHRzLnByaW9yaXR5IHx8IG5vb3AkMTtcbiAgICAgIHIuYmVmb3JlUmVuZGVyKGRlcXVldWUsIHByaW9yaXR5KHNlbGYpKTtcbiAgICB9O1xuICB9XG59O1xuXG4vLyBVc2VzIGtleXMgc28gZWxlbWVudHMgbWF5IHNoYXJlIHRoZSBzYW1lIGNhY2hlLlxuXG52YXIgRWxlbWVudFRleHR1cmVDYWNoZUxvb2t1cCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVsZW1lbnRUZXh0dXJlQ2FjaGVMb29rdXAoZ2V0S2V5KSB7XG4gICAgdmFyIGRvZXNFbGVJbnZhbGlkYXRlS2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzaWZ5O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVsZW1lbnRUZXh0dXJlQ2FjaGVMb29rdXApO1xuXG4gICAgdGhpcy5pZHNCeUtleSA9IG5ldyBNYXAkMSgpO1xuICAgIHRoaXMua2V5Rm9ySWQgPSBuZXcgTWFwJDEoKTtcbiAgICB0aGlzLmNhY2hlc0J5THZsID0gbmV3IE1hcCQxKCk7XG4gICAgdGhpcy5sdmxzID0gW107XG4gICAgdGhpcy5nZXRLZXkgPSBnZXRLZXk7XG4gICAgdGhpcy5kb2VzRWxlSW52YWxpZGF0ZUtleSA9IGRvZXNFbGVJbnZhbGlkYXRlS2V5O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEVsZW1lbnRUZXh0dXJlQ2FjaGVMb29rdXAsIFt7XG4gICAga2V5OiBcImdldElkc0ZvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJZHNGb3Ioa2V5KSB7XG4gICAgICBpZiAoa2V5ID09IG51bGwpIHtcbiAgICAgICAgZXJyb3IoXCJDYW4gbm90IGdldCBpZCBsaXN0IGZvciBudWxsIGtleVwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlkc0J5S2V5ID0gdGhpcy5pZHNCeUtleTtcbiAgICAgIHZhciBpZHMgPSB0aGlzLmlkc0J5S2V5LmdldChrZXkpO1xuXG4gICAgICBpZiAoIWlkcykge1xuICAgICAgICBpZHMgPSBuZXcgU2V0JDEoKTtcbiAgICAgICAgaWRzQnlLZXkuc2V0KGtleSwgaWRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlkcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkSWRGb3JLZXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSWRGb3JLZXkoa2V5LCBpZCkge1xuICAgICAgaWYgKGtleSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZ2V0SWRzRm9yKGtleSkuYWRkKGlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlSWRGb3JLZXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlSWRGb3JLZXkoa2V5LCBpZCkge1xuICAgICAgaWYgKGtleSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZ2V0SWRzRm9yKGtleSlbXCJkZWxldGVcIl0oaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXROdW1iZXJPZklkc0ZvcktleVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROdW1iZXJPZklkc0ZvcktleShrZXkpIHtcbiAgICAgIGlmIChrZXkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldElkc0ZvcihrZXkpLnNpemU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUtleU1hcHBpbmdGb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlS2V5TWFwcGluZ0ZvcihlbGUpIHtcbiAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgICAgdmFyIHByZXZLZXkgPSB0aGlzLmtleUZvcklkLmdldChpZCk7XG4gICAgICB2YXIgY3VycktleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gICAgICB0aGlzLmRlbGV0ZUlkRm9yS2V5KHByZXZLZXksIGlkKTtcbiAgICAgIHRoaXMuYWRkSWRGb3JLZXkoY3VycktleSwgaWQpO1xuICAgICAgdGhpcy5rZXlGb3JJZC5zZXQoaWQsIGN1cnJLZXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVLZXlNYXBwaW5nRm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZUtleU1hcHBpbmdGb3IoZWxlKSB7XG4gICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICAgIHZhciBwcmV2S2V5ID0gdGhpcy5rZXlGb3JJZC5nZXQoaWQpO1xuICAgICAgdGhpcy5kZWxldGVJZEZvcktleShwcmV2S2V5LCBpZCk7XG4gICAgICB0aGlzLmtleUZvcklkW1wiZGVsZXRlXCJdKGlkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwia2V5SGFzQ2hhbmdlZEZvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBrZXlIYXNDaGFuZ2VkRm9yKGVsZSkge1xuICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgICB2YXIgcHJldktleSA9IHRoaXMua2V5Rm9ySWQuZ2V0KGlkKTtcbiAgICAgIHZhciBuZXdLZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICAgICAgcmV0dXJuIHByZXZLZXkgIT09IG5ld0tleTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNJbnZhbGlkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzSW52YWxpZChlbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmtleUhhc0NoYW5nZWRGb3IoZWxlKSB8fCB0aGlzLmRvZXNFbGVJbnZhbGlkYXRlS2V5KGVsZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENhY2hlc0F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENhY2hlc0F0KGx2bCkge1xuICAgICAgdmFyIGNhY2hlc0J5THZsID0gdGhpcy5jYWNoZXNCeUx2bCxcbiAgICAgICAgICBsdmxzID0gdGhpcy5sdmxzO1xuICAgICAgdmFyIGNhY2hlcyA9IGNhY2hlc0J5THZsLmdldChsdmwpO1xuXG4gICAgICBpZiAoIWNhY2hlcykge1xuICAgICAgICBjYWNoZXMgPSBuZXcgTWFwJDEoKTtcbiAgICAgICAgY2FjaGVzQnlMdmwuc2V0KGx2bCwgY2FjaGVzKTtcbiAgICAgICAgbHZscy5wdXNoKGx2bCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWNoZXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENhY2hlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENhY2hlKGtleSwgbHZsKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRDYWNoZXNBdChsdmwpLmdldChrZXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGVsZSwgbHZsKSB7XG4gICAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgICAgIHZhciBjYWNoZSA9IHRoaXMuZ2V0Q2FjaGUoa2V5LCBsdmwpOyAvLyBnZXR0aW5nIGZvciBhbiBlbGVtZW50IG1heSBuZWVkIHRvIGFkZCB0byB0aGUgaWQgbGlzdCBiL2MgZWxlcyBjYW4gc2hhcmUga2V5c1xuXG4gICAgICBpZiAoY2FjaGUgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUtleU1hcHBpbmdGb3IoZWxlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRGb3JDYWNoZWRLZXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9yQ2FjaGVkS2V5KGVsZSwgbHZsKSB7XG4gICAgICB2YXIga2V5ID0gdGhpcy5rZXlGb3JJZC5nZXQoZWxlLmlkKCkpOyAvLyBuLmIuIHVzZSBjYWNoZWQga2V5LCBub3QgbmV3bHkgY29tcHV0ZWQga2V5XG5cbiAgICAgIHZhciBjYWNoZSA9IHRoaXMuZ2V0Q2FjaGUoa2V5LCBsdmwpO1xuICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNDYWNoZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNDYWNoZShrZXksIGx2bCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FjaGVzQXQobHZsKS5oYXMoa2V5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhcyhlbGUsIGx2bCkge1xuICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gICAgICByZXR1cm4gdGhpcy5oYXNDYWNoZShrZXksIGx2bCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldENhY2hlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENhY2hlKGtleSwgbHZsLCBjYWNoZSkge1xuICAgICAgY2FjaGUua2V5ID0ga2V5O1xuICAgICAgdGhpcy5nZXRDYWNoZXNBdChsdmwpLnNldChrZXksIGNhY2hlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChlbGUsIGx2bCwgY2FjaGUpIHtcbiAgICAgIHZhciBrZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICAgICAgdGhpcy5zZXRDYWNoZShrZXksIGx2bCwgY2FjaGUpO1xuICAgICAgdGhpcy51cGRhdGVLZXlNYXBwaW5nRm9yKGVsZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZUNhY2hlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZUNhY2hlKGtleSwgbHZsKSB7XG4gICAgICB0aGlzLmdldENhY2hlc0F0KGx2bClbXCJkZWxldGVcIl0oa2V5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUoZWxlLCBsdmwpIHtcbiAgICAgIHZhciBrZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICAgICAgdGhpcy5kZWxldGVDYWNoZShrZXksIGx2bCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludmFsaWRhdGVLZXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW52YWxpZGF0ZUtleShrZXkpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMubHZscy5mb3JFYWNoKGZ1bmN0aW9uIChsdmwpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmRlbGV0ZUNhY2hlKGtleSwgbHZsKTtcbiAgICAgIH0pO1xuICAgIH0gLy8gcmV0dXJucyB0cnVlIGlmIG5vIG90aGVyIGVsZXMgcmVmZXJlbmNlIHRoZSBpbnZhbGlkYXRlZCBjYWNoZSAobi5iLiBvdGhlciBlbGVzIG1heSBuZWVkIHRoZSBjYWNoZSB3aXRoIHRoZSBzYW1lIGtleSlcblxuICB9LCB7XG4gICAga2V5OiBcImludmFsaWRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW52YWxpZGF0ZShlbGUpIHtcbiAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgICAgdmFyIGtleSA9IHRoaXMua2V5Rm9ySWQuZ2V0KGlkKTsgLy8gbi5iLiB1c2Ugc3RvcmVkIGtleSByYXRoZXIgdGhhbiBjdXJyZW50IChwb3RlbnRpYWwga2V5KVxuXG4gICAgICB0aGlzLmRlbGV0ZUtleU1hcHBpbmdGb3IoZWxlKTtcbiAgICAgIHZhciBlbnRpcmVLZXlJbnZhbGlkYXRlZCA9IHRoaXMuZG9lc0VsZUludmFsaWRhdGVLZXkoZWxlKTtcblxuICAgICAgaWYgKGVudGlyZUtleUludmFsaWRhdGVkKSB7XG4gICAgICAgIC8vIGNsZWFyIG1hcHBpbmcgZm9yIGN1cnJlbnQga2V5XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZUtleShrZXkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZW50aXJlS2V5SW52YWxpZGF0ZWQgfHwgdGhpcy5nZXROdW1iZXJPZklkc0ZvcktleShrZXkpID09PSAwO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFbGVtZW50VGV4dHVyZUNhY2hlTG9va3VwO1xufSgpO1xuXG52YXIgbWluVHhySCA9IDI1OyAvLyB0aGUgc2l6ZSBvZiB0aGUgdGV4dHVyZSBjYWNoZSBmb3Igc21hbGwgaGVpZ2h0IGVsZXMgKHNwZWNpYWwgY2FzZSlcblxudmFyIHR4clN0ZXBIID0gNTA7IC8vIHRoZSBtaW4gc2l6ZSBvZiB0aGUgcmVndWxhciBjYWNoZSwgYW5kIHRoZSBzaXplIGl0IGluY3JlYXNlcyB3aXRoIGVhY2ggc3RlcCB1cFxuXG52YXIgbWluTHZsJDEgPSAtNDsgLy8gd2hlbiBzY2FsaW5nIHNtYWxsZXIgdGhhbiB0aGF0IHdlIGRvbid0IG5lZWQgdG8gcmUtcmVuZGVyXG5cbnZhciBtYXhMdmwkMSA9IDM7IC8vIHdoZW4gbGFyZ2VyIHRoYW4gdGhpcyBzY2FsZSBqdXN0IHJlbmRlciBkaXJlY3RseSAoY2FjaGluZyBpcyBub3QgaGVscGZ1bClcblxudmFyIG1heFpvb20kMSA9IDcuOTk7IC8vIGJleW9uZCB0aGlzIHpvb20gbGV2ZWwsIGxheWVyZWQgdGV4dHVyZXMgYXJlIG5vdCB1c2VkXG5cbnZhciBlbGVUeHJTcGFjaW5nID0gODsgLy8gc3BhY2luZyBiZXR3ZWVuIGVsZW1lbnRzIG9uIHRleHR1cmVzIHRvIGF2b2lkIGJsaXR0aW5nIG92ZXJsYXBzXG5cbnZhciBkZWZUeHJXaWR0aCA9IDEwMjQ7IC8vIGRlZmF1bHQvbWluaW11bSB0ZXh0dXJlIHdpZHRoXG5cbnZhciBtYXhUeHJXID0gMTAyNDsgLy8gdGhlIG1heGltdW0gd2lkdGggb2YgYSB0ZXh0dXJlXG5cbnZhciBtYXhUeHJIID0gMTAyNDsgLy8gdGhlIG1heGltdW0gaGVpZ2h0IG9mIGEgdGV4dHVyZVxuXG52YXIgbWluVXRpbGl0eSA9IDAuMjsgLy8gaWYgdXNhZ2Ugb2YgdGV4dHVyZSBpcyBsZXNzIHRoYW4gdGhpcywgaXQgaXMgcmV0aXJlZFxuXG52YXIgbWF4RnVsbG5lc3MgPSAwLjg7IC8vIGZ1bGxuZXNzIG9mIHRleHR1cmUgYWZ0ZXIgd2hpY2ggcXVldWUgcmVtb3ZhbCBpcyBjaGVja2VkXG5cbnZhciBtYXhGdWxsbmVzc0NoZWNrcyA9IDEwOyAvLyBkZXF1ZXVlZCBhZnRlciB0aGlzIG1hbnkgY2hlY2tzXG5cbnZhciBkZXFDb3N0JDEgPSAwLjE1OyAvLyAlIG9mIGFkZCdsIHJlbmRlcmluZyBjb3N0IGFsbG93ZWQgZm9yIGRlcXVldWluZyBlbGUgY2FjaGVzIGVhY2ggZnJhbWVcblxudmFyIGRlcUF2Z0Nvc3QkMSA9IDAuMTsgLy8gJSBvZiBhZGQnbCByZW5kZXJpbmcgY29zdCBjb21wYXJlZCB0byBhdmVyYWdlIG92ZXJhbGwgcmVkcmF3IHRpbWVcblxudmFyIGRlcU5vRHJhd0Nvc3QkMSA9IDAuOTsgLy8gJSBvZiBhdmcgZnJhbWUgdGltZSB0aGF0IGNhbiBiZSB1c2VkIGZvciBkZXF1ZXVlaW5nIHdoZW4gbm90IGRyYXdpbmdcblxudmFyIGRlcUZhc3RDb3N0JDEgPSAwLjk7IC8vICUgb2YgZnJhbWUgdGltZSB0byBiZSB1c2VkIHdoZW4gPjYwZnBzXG5cbnZhciBkZXFSZWRyYXdUaHJlc2hvbGQkMSA9IDEwMDsgLy8gdGltZSB0byBiYXRjaCByZWRyYXdzIHRvZ2V0aGVyIGZyb20gZGVxdWV1ZWluZyB0byBhbGxvdyBtb3JlIGRlcXVldWVpbmcgY2FsY3MgdG8gaGFwcGVuIGluIHRoZSBtZWFud2hpbGVcblxudmFyIG1heERlcVNpemUkMSA9IDE7IC8vIG51bWJlciBvZiBlbGVzIHRvIGRlcXVldWUgYW5kIHJlbmRlciBhdCBoaWdoZXIgdGV4dHVyZSBpbiBlYWNoIGJhdGNoXG5cbnZhciBnZXRUeHJSZWFzb25zID0ge1xuICBkZXF1ZXVlOiAnZGVxdWV1ZScsXG4gIGRvd25zY2FsZTogJ2Rvd25zY2FsZScsXG4gIGhpZ2hRdWFsaXR5OiAnaGlnaFF1YWxpdHknXG59O1xudmFyIGluaXREZWZhdWx0cyA9IGRlZmF1bHRzJGcoe1xuICBnZXRLZXk6IG51bGwsXG4gIGRvZXNFbGVJbnZhbGlkYXRlS2V5OiBmYWxzaWZ5LFxuICBkcmF3RWxlbWVudDogbnVsbCxcbiAgZ2V0Qm91bmRpbmdCb3g6IG51bGwsXG4gIGdldFJvdGF0aW9uUG9pbnQ6IG51bGwsXG4gIGdldFJvdGF0aW9uT2Zmc2V0OiBudWxsLFxuICBpc1Zpc2libGU6IHRydWVpZnksXG4gIGFsbG93RWRnZVR4ckNhY2hpbmc6IHRydWUsXG4gIGFsbG93UGFyZW50VHhyQ2FjaGluZzogdHJ1ZVxufSk7XG5cbnZhciBFbGVtZW50VGV4dHVyZUNhY2hlID0gZnVuY3Rpb24gRWxlbWVudFRleHR1cmVDYWNoZShyZW5kZXJlciwgaW5pdE9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gIHNlbGYub25EZXF1ZXVlcyA9IFtdO1xuICB2YXIgb3B0cyA9IGluaXREZWZhdWx0cyhpbml0T3B0aW9ucyk7XG4gIGV4dGVuZChzZWxmLCBvcHRzKTtcbiAgc2VsZi5sb29rdXAgPSBuZXcgRWxlbWVudFRleHR1cmVDYWNoZUxvb2t1cChvcHRzLmdldEtleSwgb3B0cy5kb2VzRWxlSW52YWxpZGF0ZUtleSk7XG4gIHNlbGYuc2V0dXBEZXF1ZXVlaW5nKCk7XG59O1xuXG52YXIgRVRDcCA9IEVsZW1lbnRUZXh0dXJlQ2FjaGUucHJvdG90eXBlO1xuRVRDcC5yZWFzb25zID0gZ2V0VHhyUmVhc29uczsgLy8gdGhlIGxpc3Qgb2YgdGV4dHVyZXMgaW4gd2hpY2ggbmV3IHN1YnRleHR1cmVzIGZvciBlbGVtZW50cyBjYW4gYmUgcGxhY2VkXG5cbkVUQ3AuZ2V0VGV4dHVyZVF1ZXVlID0gZnVuY3Rpb24gKHR4ckgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLmVsZUltZ0NhY2hlcyA9IHNlbGYuZWxlSW1nQ2FjaGVzIHx8IHt9O1xuICByZXR1cm4gc2VsZi5lbGVJbWdDYWNoZXNbdHhySF0gPSBzZWxmLmVsZUltZ0NhY2hlc1t0eHJIXSB8fCBbXTtcbn07IC8vIHRoZSBsaXN0IG9mIHVzdXNlZCB0ZXh0dXJlcyB3aGljaCBjYW4gYmUgcmVjeWNsZWQgKGluIHVzZSBpbiB0ZXh0dXJlIHF1ZXVlKVxuXG5cbkVUQ3AuZ2V0UmV0aXJlZFRleHR1cmVRdWV1ZSA9IGZ1bmN0aW9uICh0eHJIKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHJ0eHRyUXMgPSBzZWxmLmVsZUltZ0NhY2hlcy5yZXRpcmVkID0gc2VsZi5lbGVJbWdDYWNoZXMucmV0aXJlZCB8fCB7fTtcbiAgdmFyIHJ0eHRyUSA9IHJ0eHRyUXNbdHhySF0gPSBydHh0clFzW3R4ckhdIHx8IFtdO1xuICByZXR1cm4gcnR4dHJRO1xufTsgLy8gcXVldWUgb2YgZWxlbWVudCBkcmF3IHJlcXVlc3RzIGF0IGRpZmZlcmVudCBzY2FsZSBsZXZlbHNcblxuXG5FVENwLmdldEVsZW1lbnRRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcSA9IHNlbGYuZWxlQ2FjaGVRdWV1ZSA9IHNlbGYuZWxlQ2FjaGVRdWV1ZSB8fCBuZXcgSGVhcF9fZGVmYXVsdFtcImRlZmF1bHRcIl0oZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5yZXFzIC0gYS5yZXFzO1xuICB9KTtcbiAgcmV0dXJuIHE7XG59OyAvLyBxdWV1ZSBvZiBlbGVtZW50IGRyYXcgcmVxdWVzdHMgYXQgZGlmZmVyZW50IHNjYWxlIGxldmVscyAoZWxlbWVudCBpZCBsb29rdXApXG5cblxuRVRDcC5nZXRFbGVtZW50S2V5VG9RdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgazJxID0gc2VsZi5lbGVLZXlUb0NhY2hlUXVldWUgPSBzZWxmLmVsZUtleVRvQ2FjaGVRdWV1ZSB8fCB7fTtcbiAgcmV0dXJuIGsycTtcbn07XG5cbkVUQ3AuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGUsIGJiLCBweFJhdGlvLCBsdmwsIHJlYXNvbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByID0gdGhpcy5yZW5kZXJlcjtcbiAgdmFyIHpvb20gPSByLmN5Lnpvb20oKTtcbiAgdmFyIGxvb2t1cCA9IHRoaXMubG9va3VwO1xuXG4gIGlmICghYmIgfHwgYmIudyA9PT0gMCB8fCBiYi5oID09PSAwIHx8IGlzTmFOKGJiLncpIHx8IGlzTmFOKGJiLmgpIHx8ICFlbGUudmlzaWJsZSgpIHx8IGVsZS5yZW1vdmVkKCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICghc2VsZi5hbGxvd0VkZ2VUeHJDYWNoaW5nICYmIGVsZS5pc0VkZ2UoKSB8fCAhc2VsZi5hbGxvd1BhcmVudFR4ckNhY2hpbmcgJiYgZWxlLmlzUGFyZW50KCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChsdmwgPT0gbnVsbCkge1xuICAgIGx2bCA9IE1hdGguY2VpbChsb2cyKHpvb20gKiBweFJhdGlvKSk7XG4gIH1cblxuICBpZiAobHZsIDwgbWluTHZsJDEpIHtcbiAgICBsdmwgPSBtaW5MdmwkMTtcbiAgfSBlbHNlIGlmICh6b29tID49IG1heFpvb20kMSB8fCBsdmwgPiBtYXhMdmwkMSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHNjYWxlID0gTWF0aC5wb3coMiwgbHZsKTtcbiAgdmFyIGVsZVNjYWxlZEggPSBiYi5oICogc2NhbGU7XG4gIHZhciBlbGVTY2FsZWRXID0gYmIudyAqIHNjYWxlO1xuICB2YXIgc2NhbGVkTGFiZWxTaG93biA9IHIuZWxlVGV4dEJpZ2dlclRoYW5NaW4oZWxlLCBzY2FsZSk7XG5cbiAgaWYgKCF0aGlzLmlzVmlzaWJsZShlbGUsIHNjYWxlZExhYmVsU2hvd24pKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZWxlQ2FjaGUgPSBsb29rdXAuZ2V0KGVsZSwgbHZsKTsgLy8gaWYgdGhpcyBnZXQgd2FzIG9uIGFuIHVudXNlZC9pbnZhbGlkYXRlZCBjYWNoZSwgdGhlbiByZXN0b3JlIHRoZSB0ZXh0dXJlIHVzYWdlIG1ldHJpY1xuXG4gIGlmIChlbGVDYWNoZSAmJiBlbGVDYWNoZS5pbnZhbGlkYXRlZCkge1xuICAgIGVsZUNhY2hlLmludmFsaWRhdGVkID0gZmFsc2U7XG4gICAgZWxlQ2FjaGUudGV4dHVyZS5pbnZhbGlkYXRlZFdpZHRoIC09IGVsZUNhY2hlLndpZHRoO1xuICB9XG5cbiAgaWYgKGVsZUNhY2hlKSB7XG4gICAgcmV0dXJuIGVsZUNhY2hlO1xuICB9XG5cbiAgdmFyIHR4ckg7IC8vIHdoaWNoIHRleHR1cmUgaGVpZ2h0IHRoaXMgZWxlIGJlbG9uZ3MgdG9cblxuICBpZiAoZWxlU2NhbGVkSCA8PSBtaW5UeHJIKSB7XG4gICAgdHhySCA9IG1pblR4ckg7XG4gIH0gZWxzZSBpZiAoZWxlU2NhbGVkSCA8PSB0eHJTdGVwSCkge1xuICAgIHR4ckggPSB0eHJTdGVwSDtcbiAgfSBlbHNlIHtcbiAgICB0eHJIID0gTWF0aC5jZWlsKGVsZVNjYWxlZEggLyB0eHJTdGVwSCkgKiB0eHJTdGVwSDtcbiAgfVxuXG4gIGlmIChlbGVTY2FsZWRIID4gbWF4VHhySCB8fCBlbGVTY2FsZWRXID4gbWF4VHhyVykge1xuICAgIHJldHVybiBudWxsOyAvLyBjYWNoaW5nIGxhcmdlIGVsZW1lbnRzIGlzIG5vdCBlZmZpY2llbnRcbiAgfVxuXG4gIHZhciB0eHJRID0gc2VsZi5nZXRUZXh0dXJlUXVldWUodHhySCk7IC8vIGZpcnN0IHRyeSB0aGUgc2Vjb25kIGxhc3Qgb25lIGluIGNhc2UgaXQgaGFzIHNwYWNlIGF0IHRoZSBlbmRcblxuICB2YXIgdHhyID0gdHhyUVt0eHJRLmxlbmd0aCAtIDJdO1xuXG4gIHZhciBhZGROZXdUeHIgPSBmdW5jdGlvbiBhZGROZXdUeHIoKSB7XG4gICAgcmV0dXJuIHNlbGYucmVjeWNsZVRleHR1cmUodHhySCwgZWxlU2NhbGVkVykgfHwgc2VsZi5hZGRUZXh0dXJlKHR4ckgsIGVsZVNjYWxlZFcpO1xuICB9OyAvLyB0cnkgdGhlIGxhc3Qgb25lIGlmIHRoZXJlIGlzIG5vIHNlY29uZCBsYXN0IG9uZVxuXG5cbiAgaWYgKCF0eHIpIHtcbiAgICB0eHIgPSB0eHJRW3R4clEubGVuZ3RoIC0gMV07XG4gIH0gLy8gaWYgdGhlIGxhc3Qgb25lIGRvZXNuJ3QgZXhpc3QsIHdlIG5lZWQgYSBmaXJzdCBvbmVcblxuXG4gIGlmICghdHhyKSB7XG4gICAgdHhyID0gYWRkTmV3VHhyKCk7XG4gIH0gLy8gaWYgdGhlcmUncyBubyByb29tIGluIHRoZSBjdXJyZW50IHRleHR1cmUsIHdlIG5lZWQgYSBuZXcgb25lXG5cblxuICBpZiAodHhyLndpZHRoIC0gdHhyLnVzZWRXaWR0aCA8IGVsZVNjYWxlZFcpIHtcbiAgICB0eHIgPSBhZGROZXdUeHIoKTtcbiAgfVxuXG4gIHZhciBzY2FsYWJsZUZyb20gPSBmdW5jdGlvbiBzY2FsYWJsZUZyb20ob3RoZXJDYWNoZSkge1xuICAgIHJldHVybiBvdGhlckNhY2hlICYmIG90aGVyQ2FjaGUuc2NhbGVkTGFiZWxTaG93biA9PT0gc2NhbGVkTGFiZWxTaG93bjtcbiAgfTtcblxuICB2YXIgZGVxaW5nID0gcmVhc29uICYmIHJlYXNvbiA9PT0gZ2V0VHhyUmVhc29ucy5kZXF1ZXVlO1xuICB2YXIgaGlnaFF1YWxpdHlSZXEgPSByZWFzb24gJiYgcmVhc29uID09PSBnZXRUeHJSZWFzb25zLmhpZ2hRdWFsaXR5O1xuICB2YXIgZG93bnNjYWxlUmVxID0gcmVhc29uICYmIHJlYXNvbiA9PT0gZ2V0VHhyUmVhc29ucy5kb3duc2NhbGU7XG4gIHZhciBoaWdoZXJDYWNoZTsgLy8gdGhlIG5lYXJlc3QgY2FjaGUgd2l0aCBhIGhpZ2hlciBsZXZlbFxuXG4gIGZvciAodmFyIGwgPSBsdmwgKyAxOyBsIDw9IG1heEx2bCQxOyBsKyspIHtcbiAgICB2YXIgYyA9IGxvb2t1cC5nZXQoZWxlLCBsKTtcblxuICAgIGlmIChjKSB7XG4gICAgICBoaWdoZXJDYWNoZSA9IGM7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb25lVXBDYWNoZSA9IGhpZ2hlckNhY2hlICYmIGhpZ2hlckNhY2hlLmxldmVsID09PSBsdmwgKyAxID8gaGlnaGVyQ2FjaGUgOiBudWxsO1xuXG4gIHZhciBkb3duc2NhbGUgPSBmdW5jdGlvbiBkb3duc2NhbGUoKSB7XG4gICAgdHhyLmNvbnRleHQuZHJhd0ltYWdlKG9uZVVwQ2FjaGUudGV4dHVyZS5jYW52YXMsIG9uZVVwQ2FjaGUueCwgMCwgb25lVXBDYWNoZS53aWR0aCwgb25lVXBDYWNoZS5oZWlnaHQsIHR4ci51c2VkV2lkdGgsIDAsIGVsZVNjYWxlZFcsIGVsZVNjYWxlZEgpO1xuICB9OyAvLyByZXNldCBlbGUgYXJlYSBpbiB0ZXh0dXJlXG5cblxuICB0eHIuY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gIHR4ci5jb250ZXh0LmNsZWFyUmVjdCh0eHIudXNlZFdpZHRoLCAwLCBlbGVTY2FsZWRXLCB0eHJIKTtcblxuICBpZiAoc2NhbGFibGVGcm9tKG9uZVVwQ2FjaGUpKSB7XG4gICAgLy8gdGhlbiB3ZSBjYW4gcmVsYXRpdmVseSBjaGVhcGx5IHJlc2NhbGUgdGhlIGV4aXN0aW5nIGltYWdlIHcvbyByZXJlbmRlcmluZ1xuICAgIGRvd25zY2FsZSgpO1xuICB9IGVsc2UgaWYgKHNjYWxhYmxlRnJvbShoaWdoZXJDYWNoZSkpIHtcbiAgICAvLyB0aGVuIHVzZSB0aGUgaGlnaGVyIGNhY2hlIGZvciBub3cgYW5kIHF1ZXVlIHRoZSBuZXh0IGxldmVsIGRvd25cbiAgICAvLyB0byBjaGVhcGx5IHNjYWxlIHRvd2FyZHMgdGhlIHNtYWxsZXIgbGV2ZWxcbiAgICBpZiAoaGlnaFF1YWxpdHlSZXEpIHtcbiAgICAgIGZvciAodmFyIF9sID0gaGlnaGVyQ2FjaGUubGV2ZWw7IF9sID4gbHZsOyBfbC0tKSB7XG4gICAgICAgIG9uZVVwQ2FjaGUgPSBzZWxmLmdldEVsZW1lbnQoZWxlLCBiYiwgcHhSYXRpbywgX2wsIGdldFR4clJlYXNvbnMuZG93bnNjYWxlKTtcbiAgICAgIH1cblxuICAgICAgZG93bnNjYWxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYucXVldWVFbGVtZW50KGVsZSwgaGlnaGVyQ2FjaGUubGV2ZWwgLSAxKTtcbiAgICAgIHJldHVybiBoaWdoZXJDYWNoZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxvd2VyQ2FjaGU7IC8vIHRoZSBuZWFyZXN0IGNhY2hlIHdpdGggYSBsb3dlciBsZXZlbFxuXG4gICAgaWYgKCFkZXFpbmcgJiYgIWhpZ2hRdWFsaXR5UmVxICYmICFkb3duc2NhbGVSZXEpIHtcbiAgICAgIGZvciAodmFyIF9sMiA9IGx2bCAtIDE7IF9sMiA+PSBtaW5MdmwkMTsgX2wyLS0pIHtcbiAgICAgICAgdmFyIF9jID0gbG9va3VwLmdldChlbGUsIF9sMik7XG5cbiAgICAgICAgaWYgKF9jKSB7XG4gICAgICAgICAgbG93ZXJDYWNoZSA9IF9jO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNjYWxhYmxlRnJvbShsb3dlckNhY2hlKSkge1xuICAgICAgLy8gdGhlbiB1c2UgdGhlIGxvd2VyIHF1YWxpdHkgY2FjaGUgZm9yIG5vdyBhbmQgcXVldWUgdGhlIGJldHRlciBvbmUgZm9yIGxhdGVyXG4gICAgICBzZWxmLnF1ZXVlRWxlbWVudChlbGUsIGx2bCk7XG4gICAgICByZXR1cm4gbG93ZXJDYWNoZTtcbiAgICB9XG5cbiAgICB0eHIuY29udGV4dC50cmFuc2xhdGUodHhyLnVzZWRXaWR0aCwgMCk7XG4gICAgdHhyLmNvbnRleHQuc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgICB0aGlzLmRyYXdFbGVtZW50KHR4ci5jb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duLCBmYWxzZSk7XG4gICAgdHhyLmNvbnRleHQuc2NhbGUoMSAvIHNjYWxlLCAxIC8gc2NhbGUpO1xuICAgIHR4ci5jb250ZXh0LnRyYW5zbGF0ZSgtdHhyLnVzZWRXaWR0aCwgMCk7XG4gIH1cblxuICBlbGVDYWNoZSA9IHtcbiAgICB4OiB0eHIudXNlZFdpZHRoLFxuICAgIHRleHR1cmU6IHR4cixcbiAgICBsZXZlbDogbHZsLFxuICAgIHNjYWxlOiBzY2FsZSxcbiAgICB3aWR0aDogZWxlU2NhbGVkVyxcbiAgICBoZWlnaHQ6IGVsZVNjYWxlZEgsXG4gICAgc2NhbGVkTGFiZWxTaG93bjogc2NhbGVkTGFiZWxTaG93blxuICB9O1xuICB0eHIudXNlZFdpZHRoICs9IE1hdGguY2VpbChlbGVTY2FsZWRXICsgZWxlVHhyU3BhY2luZyk7XG4gIHR4ci5lbGVDYWNoZXMucHVzaChlbGVDYWNoZSk7XG4gIGxvb2t1cC5zZXQoZWxlLCBsdmwsIGVsZUNhY2hlKTtcbiAgc2VsZi5jaGVja1RleHR1cmVGdWxsbmVzcyh0eHIpO1xuICByZXR1cm4gZWxlQ2FjaGU7XG59O1xuXG5FVENwLmludmFsaWRhdGVFbGVtZW50cyA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuaW52YWxpZGF0ZUVsZW1lbnQoZWxlc1tpXSk7XG4gIH1cbn07XG5cbkVUQ3AuaW52YWxpZGF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGxvb2t1cCA9IHNlbGYubG9va3VwO1xuICB2YXIgY2FjaGVzID0gW107XG4gIHZhciBpbnZhbGlkID0gbG9va3VwLmlzSW52YWxpZChlbGUpO1xuXG4gIGlmICghaW52YWxpZCkge1xuICAgIHJldHVybjsgLy8gb3ZlcnJpZGUgdGhlIGludmFsaWRhdGlvbiByZXF1ZXN0IGlmIHRoZSBlbGVtZW50IGtleSBoYXMgbm90IGNoYW5nZWRcbiAgfVxuXG4gIGZvciAodmFyIGx2bCA9IG1pbkx2bCQxOyBsdmwgPD0gbWF4THZsJDE7IGx2bCsrKSB7XG4gICAgdmFyIGNhY2hlID0gbG9va3VwLmdldEZvckNhY2hlZEtleShlbGUsIGx2bCk7XG5cbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgIGNhY2hlcy5wdXNoKGNhY2hlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbm9PdGhlckVsZXNVc2VDYWNoZSA9IGxvb2t1cC5pbnZhbGlkYXRlKGVsZSk7XG5cbiAgaWYgKG5vT3RoZXJFbGVzVXNlQ2FjaGUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhY2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9jYWNoZSA9IGNhY2hlc1tpXTtcbiAgICAgIHZhciB0eHIgPSBfY2FjaGUudGV4dHVyZTsgLy8gcmVtb3ZlIHNwYWNlIGZyb20gdGhlIHRleHR1cmUgaXQgYmVsb25ncyB0b1xuXG4gICAgICB0eHIuaW52YWxpZGF0ZWRXaWR0aCArPSBfY2FjaGUud2lkdGg7IC8vIG1hcmsgdGhlIGNhY2hlIGFzIGludmFsaWRhdGVkXG5cbiAgICAgIF9jYWNoZS5pbnZhbGlkYXRlZCA9IHRydWU7IC8vIHJldGlyZSB0aGUgdGV4dHVyZSBpZiBpdHMgdXRpbGl0eSBpcyBsb3dcblxuICAgICAgc2VsZi5jaGVja1RleHR1cmVVdGlsaXR5KHR4cik7XG4gICAgfVxuICB9IC8vIHJlbW92ZSBmcm9tIHF1ZXVlIHNpbmNlIHRoZSBvbGQgcmVxIHdhcyBmb3IgdGhlIG9sZCBzdGF0ZVxuXG5cbiAgc2VsZi5yZW1vdmVGcm9tUXVldWUoZWxlKTtcbn07XG5cbkVUQ3AuY2hlY2tUZXh0dXJlVXRpbGl0eSA9IGZ1bmN0aW9uICh0eHIpIHtcbiAgLy8gaW52YWxpZGF0ZSBhbGwgZW50cmllcyBpbiB0aGUgY2FjaGUgaWYgdGhlIGNhY2hlIHNpemUgaXMgc21hbGxcbiAgaWYgKHR4ci5pbnZhbGlkYXRlZFdpZHRoID49IG1pblV0aWxpdHkgKiB0eHIud2lkdGgpIHtcbiAgICB0aGlzLnJldGlyZVRleHR1cmUodHhyKTtcbiAgfVxufTtcblxuRVRDcC5jaGVja1RleHR1cmVGdWxsbmVzcyA9IGZ1bmN0aW9uICh0eHIpIHtcbiAgLy8gaWYgdGV4dHVyZSBoYXMgYmVlbiBtb3N0bHkgZmlsbGVkIGFuZCBwYXNzZWQgb3ZlciBzZXZlcmFsIHRpbWVzLCByZW1vdmVcbiAgLy8gaXQgZnJvbSB0aGUgcXVldWUgc28gd2UgZG9uJ3QgbmVlZCB0byB3YXN0ZSB0aW1lIGxvb2tpbmcgYXQgaXQgdG8gcHV0IG5ldyB0aGluZ3NcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdHhyUSA9IHNlbGYuZ2V0VGV4dHVyZVF1ZXVlKHR4ci5oZWlnaHQpO1xuXG4gIGlmICh0eHIudXNlZFdpZHRoIC8gdHhyLndpZHRoID4gbWF4RnVsbG5lc3MgJiYgdHhyLmZ1bGxuZXNzQ2hlY2tzID49IG1heEZ1bGxuZXNzQ2hlY2tzKSB7XG4gICAgcmVtb3ZlRnJvbUFycmF5KHR4clEsIHR4cik7XG4gIH0gZWxzZSB7XG4gICAgdHhyLmZ1bGxuZXNzQ2hlY2tzKys7XG4gIH1cbn07XG5cbkVUQ3AucmV0aXJlVGV4dHVyZSA9IGZ1bmN0aW9uICh0eHIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdHhySCA9IHR4ci5oZWlnaHQ7XG4gIHZhciB0eHJRID0gc2VsZi5nZXRUZXh0dXJlUXVldWUodHhySCk7XG4gIHZhciBsb29rdXAgPSB0aGlzLmxvb2t1cDsgLy8gcmV0aXJlIHRoZSB0ZXh0dXJlIGZyb20gdGhlIGFjdGl2ZSAvIHNlYXJjaGFibGUgcXVldWU6XG5cbiAgcmVtb3ZlRnJvbUFycmF5KHR4clEsIHR4cik7XG4gIHR4ci5yZXRpcmVkID0gdHJ1ZTsgLy8gcmVtb3ZlIHRoZSByZWZzIGZyb20gdGhlIGVsZXMgdG8gdGhlIGNhY2hlczpcblxuICB2YXIgZWxlQ2FjaGVzID0gdHhyLmVsZUNhY2hlcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZUNhY2hlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGVDYWNoZSA9IGVsZUNhY2hlc1tpXTtcbiAgICBsb29rdXAuZGVsZXRlQ2FjaGUoZWxlQ2FjaGUua2V5LCBlbGVDYWNoZS5sZXZlbCk7XG4gIH1cblxuICBjbGVhckFycmF5KGVsZUNhY2hlcyk7IC8vIGFkZCB0aGUgdGV4dHVyZSB0byBhIHJldGlyZWQgcXVldWUgc28gaXQgY2FuIGJlIHJlY3ljbGVkIGluIGZ1dHVyZTpcblxuICB2YXIgcnR4dHJRID0gc2VsZi5nZXRSZXRpcmVkVGV4dHVyZVF1ZXVlKHR4ckgpO1xuICBydHh0clEucHVzaCh0eHIpO1xufTtcblxuRVRDcC5hZGRUZXh0dXJlID0gZnVuY3Rpb24gKHR4ckgsIG1pblcpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdHhyUSA9IHNlbGYuZ2V0VGV4dHVyZVF1ZXVlKHR4ckgpO1xuICB2YXIgdHhyID0ge307XG4gIHR4clEucHVzaCh0eHIpO1xuICB0eHIuZWxlQ2FjaGVzID0gW107XG4gIHR4ci5oZWlnaHQgPSB0eHJIO1xuICB0eHIud2lkdGggPSBNYXRoLm1heChkZWZUeHJXaWR0aCwgbWluVyk7XG4gIHR4ci51c2VkV2lkdGggPSAwO1xuICB0eHIuaW52YWxpZGF0ZWRXaWR0aCA9IDA7XG4gIHR4ci5mdWxsbmVzc0NoZWNrcyA9IDA7XG4gIHR4ci5jYW52YXMgPSBzZWxmLnJlbmRlcmVyLm1ha2VPZmZzY3JlZW5DYW52YXModHhyLndpZHRoLCB0eHIuaGVpZ2h0KTtcbiAgdHhyLmNvbnRleHQgPSB0eHIuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIHJldHVybiB0eHI7XG59O1xuXG5FVENwLnJlY3ljbGVUZXh0dXJlID0gZnVuY3Rpb24gKHR4ckgsIG1pblcpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdHhyUSA9IHNlbGYuZ2V0VGV4dHVyZVF1ZXVlKHR4ckgpO1xuICB2YXIgcnR4dHJRID0gc2VsZi5nZXRSZXRpcmVkVGV4dHVyZVF1ZXVlKHR4ckgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcnR4dHJRLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHR4ciA9IHJ0eHRyUVtpXTtcblxuICAgIGlmICh0eHIud2lkdGggPj0gbWluVykge1xuICAgICAgdHhyLnJldGlyZWQgPSBmYWxzZTtcbiAgICAgIHR4ci51c2VkV2lkdGggPSAwO1xuICAgICAgdHhyLmludmFsaWRhdGVkV2lkdGggPSAwO1xuICAgICAgdHhyLmZ1bGxuZXNzQ2hlY2tzID0gMDtcbiAgICAgIGNsZWFyQXJyYXkodHhyLmVsZUNhY2hlcyk7XG4gICAgICB0eHIuY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICB0eHIuY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdHhyLndpZHRoLCB0eHIuaGVpZ2h0KTtcbiAgICAgIHJlbW92ZUZyb21BcnJheShydHh0clEsIHR4cik7XG4gICAgICB0eHJRLnB1c2godHhyKTtcbiAgICAgIHJldHVybiB0eHI7XG4gICAgfVxuICB9XG59O1xuXG5FVENwLnF1ZXVlRWxlbWVudCA9IGZ1bmN0aW9uIChlbGUsIGx2bCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBxID0gc2VsZi5nZXRFbGVtZW50UXVldWUoKTtcbiAgdmFyIGsycSA9IHNlbGYuZ2V0RWxlbWVudEtleVRvUXVldWUoKTtcbiAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gIHZhciBleGlzdGluZ1JlcSA9IGsycVtrZXldO1xuXG4gIGlmIChleGlzdGluZ1JlcSkge1xuICAgIC8vIHVzZSB0aGUgbWF4IGx2bCBiL2MgaW4gYmV0d2VlbiBsdmxzIGFyZSBjaGVhcCB0byBtYWtlXG4gICAgZXhpc3RpbmdSZXEubGV2ZWwgPSBNYXRoLm1heChleGlzdGluZ1JlcS5sZXZlbCwgbHZsKTtcbiAgICBleGlzdGluZ1JlcS5lbGVzLm1lcmdlKGVsZSk7XG4gICAgZXhpc3RpbmdSZXEucmVxcysrO1xuICAgIHEudXBkYXRlSXRlbShleGlzdGluZ1JlcSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlcSA9IHtcbiAgICAgIGVsZXM6IGVsZS5zcGF3bigpLm1lcmdlKGVsZSksXG4gICAgICBsZXZlbDogbHZsLFxuICAgICAgcmVxczogMSxcbiAgICAgIGtleToga2V5XG4gICAgfTtcbiAgICBxLnB1c2gocmVxKTtcbiAgICBrMnFba2V5XSA9IHJlcTtcbiAgfVxufTtcblxuRVRDcC5kZXF1ZXVlID0gZnVuY3Rpb24gKHB4UmF0aW9cbi8qLCBleHRlbnQqL1xuKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHEgPSBzZWxmLmdldEVsZW1lbnRRdWV1ZSgpO1xuICB2YXIgazJxID0gc2VsZi5nZXRFbGVtZW50S2V5VG9RdWV1ZSgpO1xuICB2YXIgZGVxdWV1ZWQgPSBbXTtcbiAgdmFyIGxvb2t1cCA9IHNlbGYubG9va3VwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4RGVxU2l6ZSQxOyBpKyspIHtcbiAgICBpZiAocS5zaXplKCkgPiAwKSB7XG4gICAgICB2YXIgcmVxID0gcS5wb3AoKTtcbiAgICAgIHZhciBrZXkgPSByZXEua2V5O1xuICAgICAgdmFyIGVsZSA9IHJlcS5lbGVzWzBdOyAvLyBhbGwgZWxlcyBoYXZlIHRoZSBzYW1lIGtleVxuXG4gICAgICB2YXIgY2FjaGVFeGlzdHMgPSBsb29rdXAuaGFzQ2FjaGUoZWxlLCByZXEubGV2ZWwpOyAvLyBjbGVhciBvdXQgdGhlIGtleSB0byByZXEgbG9va3VwXG5cbiAgICAgIGsycVtrZXldID0gbnVsbDsgLy8gZGVxdWV1ZWluZyBpc24ndCBuZWNlc3Nhcnkgd2l0aCBhbiBleGlzdGluZyBjYWNoZVxuXG4gICAgICBpZiAoY2FjaGVFeGlzdHMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGRlcXVldWVkLnB1c2gocmVxKTtcbiAgICAgIHZhciBiYiA9IHNlbGYuZ2V0Qm91bmRpbmdCb3goZWxlKTtcbiAgICAgIHNlbGYuZ2V0RWxlbWVudChlbGUsIGJiLCBweFJhdGlvLCByZXEubGV2ZWwsIGdldFR4clJlYXNvbnMuZGVxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZXF1ZXVlZDtcbn07XG5cbkVUQ3AucmVtb3ZlRnJvbVF1ZXVlID0gZnVuY3Rpb24gKGVsZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBxID0gc2VsZi5nZXRFbGVtZW50UXVldWUoKTtcbiAgdmFyIGsycSA9IHNlbGYuZ2V0RWxlbWVudEtleVRvUXVldWUoKTtcbiAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gIHZhciByZXEgPSBrMnFba2V5XTtcblxuICBpZiAocmVxICE9IG51bGwpIHtcbiAgICBpZiAocmVxLmVsZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyByZW1vdmUgaWYgbGFzdCBlbGUgaW4gdGhlIHJlcVxuICAgICAgLy8gYnJpbmcgdG8gZnJvbnQgb2YgcXVldWVcbiAgICAgIHJlcS5yZXFzID0gTUFYX0lOVCQxO1xuICAgICAgcS51cGRhdGVJdGVtKHJlcSk7XG4gICAgICBxLnBvcCgpOyAvLyByZW1vdmUgZnJvbSBxdWV1ZVxuXG4gICAgICBrMnFba2V5XSA9IG51bGw7IC8vIHJlbW92ZSBmcm9tIGxvb2t1cCBtYXBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3RoZXJ3aXNlIGp1c3QgcmVtb3ZlIGVsZSBmcm9tIHJlcVxuICAgICAgcmVxLmVsZXMudW5tZXJnZShlbGUpO1xuICAgIH1cbiAgfVxufTtcblxuRVRDcC5vbkRlcXVldWUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdGhpcy5vbkRlcXVldWVzLnB1c2goZm4pO1xufTtcblxuRVRDcC5vZmZEZXF1ZXVlID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJlbW92ZUZyb21BcnJheSh0aGlzLm9uRGVxdWV1ZXMsIGZuKTtcbn07XG5cbkVUQ3Auc2V0dXBEZXF1ZXVlaW5nID0gZGVmcy5zZXR1cERlcXVldWVpbmcoe1xuICBkZXFSZWRyYXdUaHJlc2hvbGQ6IGRlcVJlZHJhd1RocmVzaG9sZCQxLFxuICBkZXFDb3N0OiBkZXFDb3N0JDEsXG4gIGRlcUF2Z0Nvc3Q6IGRlcUF2Z0Nvc3QkMSxcbiAgZGVxTm9EcmF3Q29zdDogZGVxTm9EcmF3Q29zdCQxLFxuICBkZXFGYXN0Q29zdDogZGVxRmFzdENvc3QkMSxcbiAgZGVxOiBmdW5jdGlvbiBkZXEoc2VsZiwgcHhSYXRpbywgZXh0ZW50KSB7XG4gICAgcmV0dXJuIHNlbGYuZGVxdWV1ZShweFJhdGlvLCBleHRlbnQpO1xuICB9LFxuICBvbkRlcWQ6IGZ1bmN0aW9uIG9uRGVxZChzZWxmLCBkZXFkKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLm9uRGVxdWV1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBmbiA9IHNlbGYub25EZXF1ZXVlc1tpXTtcbiAgICAgIGZuKGRlcWQpO1xuICAgIH1cbiAgfSxcbiAgc2hvdWxkUmVkcmF3OiBmdW5jdGlvbiBzaG91bGRSZWRyYXcoc2VsZiwgZGVxZCwgcHhSYXRpbywgZXh0ZW50KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXFkLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlcyA9IGRlcWRbaV0uZWxlcztcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBiYiA9IGVsZXNbal0uYm91bmRpbmdCb3goKTtcblxuICAgICAgICBpZiAoYm91bmRpbmdCb3hlc0ludGVyc2VjdChiYiwgZXh0ZW50KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBwcmlvcml0eTogZnVuY3Rpb24gcHJpb3JpdHkoc2VsZikge1xuICAgIHJldHVybiBzZWxmLnJlbmRlcmVyLmJlZm9yZVJlbmRlclByaW9yaXRpZXMuZWxlVHhyRGVxO1xuICB9XG59KTtcblxudmFyIGRlZk51bUxheWVycyA9IDE7IC8vIGRlZmF1bHQgbnVtYmVyIG9mIGxheWVycyB0byB1c2VcblxudmFyIG1pbkx2bCA9IC00OyAvLyB3aGVuIHNjYWxpbmcgc21hbGxlciB0aGFuIHRoYXQgd2UgZG9uJ3QgbmVlZCB0byByZS1yZW5kZXJcblxudmFyIG1heEx2bCA9IDI7IC8vIHdoZW4gbGFyZ2VyIHRoYW4gdGhpcyBzY2FsZSBqdXN0IHJlbmRlciBkaXJlY3RseSAoY2FjaGluZyBpcyBub3QgaGVscGZ1bClcblxudmFyIG1heFpvb20gPSAzLjk5OyAvLyBiZXlvbmQgdGhpcyB6b29tIGxldmVsLCBsYXllcmVkIHRleHR1cmVzIGFyZSBub3QgdXNlZFxuXG52YXIgZGVxUmVkcmF3VGhyZXNob2xkID0gNTA7IC8vIHRpbWUgdG8gYmF0Y2ggcmVkcmF3cyB0b2dldGhlciBmcm9tIGRlcXVldWVpbmcgdG8gYWxsb3cgbW9yZSBkZXF1ZXVlaW5nIGNhbGNzIHRvIGhhcHBlbiBpbiB0aGUgbWVhbndoaWxlXG5cbnZhciByZWZpbmVFbGVEZWJvdW5jZVRpbWUgPSA1MDsgLy8gdGltZSB0byBkZWJvdW5jZSBzaGFycGVyIGVsZSB0ZXh0dXJlIHVwZGF0ZXNcblxudmFyIGRlcUNvc3QgPSAwLjE1OyAvLyAlIG9mIGFkZCdsIHJlbmRlcmluZyBjb3N0IGFsbG93ZWQgZm9yIGRlcXVldWluZyBlbGUgY2FjaGVzIGVhY2ggZnJhbWVcblxudmFyIGRlcUF2Z0Nvc3QgPSAwLjE7IC8vICUgb2YgYWRkJ2wgcmVuZGVyaW5nIGNvc3QgY29tcGFyZWQgdG8gYXZlcmFnZSBvdmVyYWxsIHJlZHJhdyB0aW1lXG5cbnZhciBkZXFOb0RyYXdDb3N0ID0gMC45OyAvLyAlIG9mIGF2ZyBmcmFtZSB0aW1lIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGRlcXVldWVpbmcgd2hlbiBub3QgZHJhd2luZ1xuXG52YXIgZGVxRmFzdENvc3QgPSAwLjk7IC8vICUgb2YgZnJhbWUgdGltZSB0byBiZSB1c2VkIHdoZW4gPjYwZnBzXG5cbnZhciBtYXhEZXFTaXplID0gMTsgLy8gbnVtYmVyIG9mIGVsZXMgdG8gZGVxdWV1ZSBhbmQgcmVuZGVyIGF0IGhpZ2hlciB0ZXh0dXJlIGluIGVhY2ggYmF0Y2hcblxudmFyIGludmFsaWRUaHJlc2hvbGQgPSAyNTA7IC8vIHRpbWUgdGhyZXNob2xkIGZvciBkaXNhYmxpbmcgYi9jIG9mIGludmFsaWRhdGlvbnNcblxudmFyIG1heExheWVyQXJlYSA9IDQwMDAgKiA0MDAwOyAvLyBsYXllcnMgY2FuJ3QgYmUgYmlnZ2VyIHRoYW4gdGhpc1xuXG52YXIgdXNlSGlnaFF1YWxpdHlFbGVUeHJSZXFzID0gdHJ1ZTsgLy8gd2hldGhlciB0byB1c2UgaGlnaCBxdWFsaXR5IGVsZSB0eHIgcmVxdWVzdHMgKGdlbmVyYWxseSBmYXN0ZXIgYW5kIGNoZWFwZXIgaW4gdGhlIGxvbmd0ZXJtKVxuLy8gdmFyIGxvZyA9IGZ1bmN0aW9uKCl7IGNvbnNvbGUubG9nLmFwcGx5KCBjb25zb2xlLCBhcmd1bWVudHMgKTsgfTtcblxudmFyIExheWVyZWRUZXh0dXJlQ2FjaGUgPSBmdW5jdGlvbiBMYXllcmVkVGV4dHVyZUNhY2hlKHJlbmRlcmVyKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHIgPSBzZWxmLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gIHZhciBjeSA9IHIuY3k7XG4gIHNlbGYubGF5ZXJzQnlMZXZlbCA9IHt9OyAvLyBlLmcuIDIgPT4gWyBsYXllcjEsIGxheWVyMiwgLi4uLCBsYXllck4gXVxuXG4gIHNlbGYuZmlyc3RHZXQgPSB0cnVlO1xuICBzZWxmLmxhc3RJbnZhbGlkYXRpb25UaW1lID0gcGVyZm9ybWFuY2VOb3coKSAtIDIgKiBpbnZhbGlkVGhyZXNob2xkO1xuICBzZWxmLnNraXBwaW5nID0gZmFsc2U7XG4gIHNlbGYuZWxlVHhyRGVxcyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgc2VsZi5zY2hlZHVsZUVsZW1lbnRSZWZpbmVtZW50ID0gZGVib3VuY2VfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLnJlZmluZUVsZW1lbnRUZXh0dXJlcyhzZWxmLmVsZVR4ckRlcXMpO1xuICAgIHNlbGYuZWxlVHhyRGVxcy51bm1lcmdlKHNlbGYuZWxlVHhyRGVxcyk7XG4gIH0sIHJlZmluZUVsZURlYm91bmNlVGltZSk7XG4gIHIuYmVmb3JlUmVuZGVyKGZ1bmN0aW9uICh3aWxsRHJhdywgbm93KSB7XG4gICAgaWYgKG5vdyAtIHNlbGYubGFzdEludmFsaWRhdGlvblRpbWUgPD0gaW52YWxpZFRocmVzaG9sZCkge1xuICAgICAgc2VsZi5za2lwcGluZyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuc2tpcHBpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH0sIHIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcy5seXJUeHJTa2lwKTtcblxuICB2YXIgcVNvcnQgPSBmdW5jdGlvbiBxU29ydChhLCBiKSB7XG4gICAgcmV0dXJuIGIucmVxcyAtIGEucmVxcztcbiAgfTtcblxuICBzZWxmLmxheWVyc1F1ZXVlID0gbmV3IEhlYXBfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHFTb3J0KTtcbiAgc2VsZi5zZXR1cERlcXVldWVpbmcoKTtcbn07XG5cbnZhciBMVENwID0gTGF5ZXJlZFRleHR1cmVDYWNoZS5wcm90b3R5cGU7XG52YXIgbGF5ZXJJZFBvb2wgPSAwO1xudmFyIE1BWF9JTlQgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuXG5MVENwLm1ha2VMYXllciA9IGZ1bmN0aW9uIChiYiwgbHZsKSB7XG4gIHZhciBzY2FsZSA9IE1hdGgucG93KDIsIGx2bCk7XG4gIHZhciB3ID0gTWF0aC5jZWlsKGJiLncgKiBzY2FsZSk7XG4gIHZhciBoID0gTWF0aC5jZWlsKGJiLmggKiBzY2FsZSk7XG4gIHZhciBjYW52YXMgPSB0aGlzLnJlbmRlcmVyLm1ha2VPZmZzY3JlZW5DYW52YXModywgaCk7XG4gIHZhciBsYXllciA9IHtcbiAgICBpZDogbGF5ZXJJZFBvb2wgPSArK2xheWVySWRQb29sICUgTUFYX0lOVCxcbiAgICBiYjogYmIsXG4gICAgbGV2ZWw6IGx2bCxcbiAgICB3aWR0aDogdyxcbiAgICBoZWlnaHQ6IGgsXG4gICAgY2FudmFzOiBjYW52YXMsXG4gICAgY29udGV4dDogY2FudmFzLmdldENvbnRleHQoJzJkJyksXG4gICAgZWxlczogW10sXG4gICAgZWxlc1F1ZXVlOiBbXSxcbiAgICByZXFzOiAwXG4gIH07IC8vIGxvZygnbWFrZSBsYXllciAlcyB3aXRoIHcgJXMgYW5kIGggJXMgYW5kIGx2bCAlcycsIGxheWVyLmlkLCBsYXllci53aWR0aCwgbGF5ZXIuaGVpZ2h0LCBsYXllci5sZXZlbCk7XG5cbiAgdmFyIGN4dCA9IGxheWVyLmNvbnRleHQ7XG4gIHZhciBkeCA9IC1sYXllci5iYi54MTtcbiAgdmFyIGR5ID0gLWxheWVyLmJiLnkxOyAvLyBkbyB0aGUgdHJhbnNmb3JtIG9uIGNyZWF0aW9uIHRvIHNhdmUgY3ljbGVzIChpdCdzIHRoZSBzYW1lIGZvciBhbGwgZWxlcylcblxuICBjeHQuc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgY3h0LnRyYW5zbGF0ZShkeCwgZHkpO1xuICByZXR1cm4gbGF5ZXI7XG59O1xuXG5MVENwLmdldExheWVycyA9IGZ1bmN0aW9uIChlbGVzLCBweFJhdGlvLCBsdmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgciA9IHNlbGYucmVuZGVyZXI7XG4gIHZhciBjeSA9IHIuY3k7XG4gIHZhciB6b29tID0gY3kuem9vbSgpO1xuICB2YXIgZmlyc3RHZXQgPSBzZWxmLmZpcnN0R2V0O1xuICBzZWxmLmZpcnN0R2V0ID0gZmFsc2U7IC8vIGxvZygnLS1cXG5nZXQgbGF5ZXJzIHdpdGggJXMgZWxlcycsIGVsZXMubGVuZ3RoKTtcbiAgLy9sb2cgZWxlcy5tYXAoZnVuY3Rpb24oZWxlKXsgcmV0dXJuIGVsZS5pZCgpIH0pICk7XG5cbiAgaWYgKGx2bCA9PSBudWxsKSB7XG4gICAgbHZsID0gTWF0aC5jZWlsKGxvZzIoem9vbSAqIHB4UmF0aW8pKTtcblxuICAgIGlmIChsdmwgPCBtaW5MdmwpIHtcbiAgICAgIGx2bCA9IG1pbkx2bDtcbiAgICB9IGVsc2UgaWYgKHpvb20gPj0gbWF4Wm9vbSB8fCBsdmwgPiBtYXhMdmwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHNlbGYudmFsaWRhdGVMYXllcnNFbGVzT3JkZXJpbmcobHZsLCBlbGVzKTtcbiAgdmFyIGxheWVyc0J5THZsID0gc2VsZi5sYXllcnNCeUxldmVsO1xuICB2YXIgc2NhbGUgPSBNYXRoLnBvdygyLCBsdmwpO1xuICB2YXIgbGF5ZXJzID0gbGF5ZXJzQnlMdmxbbHZsXSA9IGxheWVyc0J5THZsW2x2bF0gfHwgW107XG4gIHZhciBiYjtcbiAgdmFyIGx2bENvbXBsZXRlID0gc2VsZi5sZXZlbElzQ29tcGxldGUobHZsLCBlbGVzKTtcbiAgdmFyIHRtcExheWVycztcblxuICB2YXIgY2hlY2tUZW1wTGV2ZWxzID0gZnVuY3Rpb24gY2hlY2tUZW1wTGV2ZWxzKCkge1xuICAgIHZhciBjYW5Vc2VBc1RtcEx2bCA9IGZ1bmN0aW9uIGNhblVzZUFzVG1wTHZsKGwpIHtcbiAgICAgIHNlbGYudmFsaWRhdGVMYXllcnNFbGVzT3JkZXJpbmcobCwgZWxlcyk7XG5cbiAgICAgIGlmIChzZWxmLmxldmVsSXNDb21wbGV0ZShsLCBlbGVzKSkge1xuICAgICAgICB0bXBMYXllcnMgPSBsYXllcnNCeUx2bFtsXTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjaGVja0x2bHMgPSBmdW5jdGlvbiBjaGVja0x2bHMoZGlyKSB7XG4gICAgICBpZiAodG1wTGF5ZXJzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgbCA9IGx2bCArIGRpcjsgbWluTHZsIDw9IGwgJiYgbCA8PSBtYXhMdmw7IGwgKz0gZGlyKSB7XG4gICAgICAgIGlmIChjYW5Vc2VBc1RtcEx2bChsKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNoZWNrTHZscygrMSk7XG4gICAgY2hlY2tMdmxzKC0xKTsgLy8gcmVtb3ZlIHRoZSBpbnZhbGlkIGxheWVyczsgdGhleSB3aWxsIGJlIHJlcGxhY2VkIGFzIG5lZWRlZCBsYXRlciBpbiB0aGlzIGZ1bmN0aW9uXG5cbiAgICBmb3IgKHZhciBpID0gbGF5ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbaV07XG5cbiAgICAgIGlmIChsYXllci5pbnZhbGlkKSB7XG4gICAgICAgIHJlbW92ZUZyb21BcnJheShsYXllcnMsIGxheWVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaWYgKCFsdmxDb21wbGV0ZSkge1xuICAgIC8vIGlmIHRoZSBjdXJyZW50IGxldmVsIGlzIGluY29tcGxldGUsIHRoZW4gdXNlIHRoZSBjbG9zZXN0LCBiZXN0IHF1YWxpdHkgbGF5ZXJzZXQgdGVtcG9yYXJpbHlcbiAgICAvLyBhbmQgbGF0ZXIgcXVldWUgdGhlIGN1cnJlbnQgbGF5ZXJzZXQgc28gd2UgY2FuIGdldCB0aGUgcHJvcGVyIHF1YWxpdHkgbGV2ZWwgc29vblxuICAgIGNoZWNrVGVtcExldmVscygpO1xuICB9IGVsc2Uge1xuICAgIC8vIGxvZygnbGV2ZWwgY29tcGxldGUsIHVzaW5nIGV4aXN0aW5nIGxheWVyc1xcbi0tJyk7XG4gICAgcmV0dXJuIGxheWVycztcbiAgfVxuXG4gIHZhciBnZXRCYiA9IGZ1bmN0aW9uIGdldEJiKCkge1xuICAgIGlmICghYmIpIHtcbiAgICAgIGJiID0gbWFrZUJvdW5kaW5nQm94KCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB1cGRhdGVCb3VuZGluZ0JveChiYiwgZWxlc1tpXS5ib3VuZGluZ0JveCgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYmI7XG4gIH07XG5cbiAgdmFyIG1ha2VMYXllciA9IGZ1bmN0aW9uIG1ha2VMYXllcihvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgdmFyIGFmdGVyID0gb3B0cy5hZnRlcjtcbiAgICBnZXRCYigpO1xuICAgIHZhciBhcmVhID0gYmIudyAqIHNjYWxlICogKGJiLmggKiBzY2FsZSk7XG5cbiAgICBpZiAoYXJlYSA+IG1heExheWVyQXJlYSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxheWVyID0gc2VsZi5tYWtlTGF5ZXIoYmIsIGx2bCk7XG5cbiAgICBpZiAoYWZ0ZXIgIT0gbnVsbCkge1xuICAgICAgdmFyIGluZGV4ID0gbGF5ZXJzLmluZGV4T2YoYWZ0ZXIpICsgMTtcbiAgICAgIGxheWVycy5zcGxpY2UoaW5kZXgsIDAsIGxheWVyKTtcbiAgICB9IGVsc2UgaWYgKG9wdHMuaW5zZXJ0ID09PSB1bmRlZmluZWQgfHwgb3B0cy5pbnNlcnQpIHtcbiAgICAgIC8vIG5vIGFmdGVyIHNwZWNpZmllZCA9PiBmaXJzdCBsYXllciBtYWRlIHNvIHB1dCBhdCBzdGFydFxuICAgICAgbGF5ZXJzLnVuc2hpZnQobGF5ZXIpO1xuICAgIH0gLy8gaWYoIHRtcExheWVycyApe1xuICAgIC8vc2VsZi5xdWV1ZUxheWVyKCBsYXllciApO1xuICAgIC8vIH1cblxuXG4gICAgcmV0dXJuIGxheWVyO1xuICB9O1xuXG4gIGlmIChzZWxmLnNraXBwaW5nICYmICFmaXJzdEdldCkge1xuICAgIC8vIGxvZygnc2tpcCBsYXllcnMnKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBsb2coJ2RvIGxheWVycycpO1xuXG5cbiAgdmFyIGxheWVyID0gbnVsbDtcbiAgdmFyIG1heEVsZXNQZXJMYXllciA9IGVsZXMubGVuZ3RoIC8gZGVmTnVtTGF5ZXJzO1xuICB2YXIgYWxsb3dMYXp5UXVldWVpbmcgPSAhZmlyc3RHZXQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgdmFyIHJzID0gZWxlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciBjYWNoZXMgPSBycy5pbWdMYXllckNhY2hlcyA9IHJzLmltZ0xheWVyQ2FjaGVzIHx8IHt9OyAvLyBsb2coJ2xvb2sgYXQgZWxlJywgZWxlLmlkKCkpO1xuXG4gICAgdmFyIGV4aXN0aW5nTGF5ZXIgPSBjYWNoZXNbbHZsXTtcblxuICAgIGlmIChleGlzdGluZ0xheWVyKSB7XG4gICAgICAvLyByZXVzZSBsYXllciBmb3IgbGF0ZXIgZWxlc1xuICAgICAgLy8gbG9nKCdyZXVzZSBsYXllciBmb3InLCBlbGUuaWQoKSk7XG4gICAgICBsYXllciA9IGV4aXN0aW5nTGF5ZXI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoIWxheWVyIHx8IGxheWVyLmVsZXMubGVuZ3RoID49IG1heEVsZXNQZXJMYXllciB8fCAhYm91bmRpbmdCb3hJbkJvdW5kaW5nQm94KGxheWVyLmJiLCBlbGUuYm91bmRpbmdCb3goKSkpIHtcbiAgICAgIC8vIGxvZygnbWFrZSBuZXcgbGF5ZXIgZm9yIGVsZSAlcycsIGVsZS5pZCgpKTtcbiAgICAgIGxheWVyID0gbWFrZUxheWVyKHtcbiAgICAgICAgaW5zZXJ0OiB0cnVlLFxuICAgICAgICBhZnRlcjogbGF5ZXJcbiAgICAgIH0pOyAvLyBpZiBub3cgbGF5ZXIgY2FuIGJlIGJ1aWx0IHRoZW4gd2UgY2FuJ3QgdXNlIGxheWVycyBhdCB0aGlzIGxldmVsXG5cbiAgICAgIGlmICghbGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IC8vIGxvZygnbmV3IGxheWVyIHdpdGggaWQgJXMnLCBsYXllci5pZCk7XG5cbiAgICB9XG5cbiAgICBpZiAodG1wTGF5ZXJzIHx8IGFsbG93TGF6eVF1ZXVlaW5nKSB7XG4gICAgICAvLyBsb2coJ3F1ZXVlIGVsZSAlcyBpbiBsYXllciAlcycsIGVsZS5pZCgpLCBsYXllci5pZCk7XG4gICAgICBzZWxmLnF1ZXVlTGF5ZXIobGF5ZXIsIGVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxvZygnZHJhdyBlbGUgJXMgaW4gbGF5ZXIgJXMnLCBlbGUuaWQoKSwgbGF5ZXIuaWQpO1xuICAgICAgc2VsZi5kcmF3RWxlSW5MYXllcihsYXllciwgZWxlLCBsdmwsIHB4UmF0aW8pO1xuICAgIH1cblxuICAgIGxheWVyLmVsZXMucHVzaChlbGUpO1xuICAgIGNhY2hlc1tsdmxdID0gbGF5ZXI7XG4gIH0gLy8gbG9nKCctLScpO1xuXG5cbiAgaWYgKHRtcExheWVycykge1xuICAgIC8vIHRoZW4gd2Ugb25seSBxdWV1ZWQgdGhlIGN1cnJlbnQgbGF5ZXJzZXQgYW5kIGNhbid0IGRyYXcgaXQgeWV0XG4gICAgcmV0dXJuIHRtcExheWVycztcbiAgfVxuXG4gIGlmIChhbGxvd0xhenlRdWV1ZWluZykge1xuICAgIC8vIGxvZygnbGF6eSBxdWV1ZSBsZXZlbCcsIGx2bCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gbGF5ZXJzO1xufTsgLy8gYSBsYXllciBtYXkgd2FudCB0byB1c2UgYW4gZWxlIGNhY2hlIG9mIGEgaGlnaGVyIGxldmVsIHRvIGF2b2lkIGJsdXJyaW5lc3Ncbi8vIHNvIHRoZSBsYXllciBsZXZlbCBtaWdodCBub3QgZXF1YWwgdGhlIGVsZSBsZXZlbFxuXG5cbkxUQ3AuZ2V0RWxlTGV2ZWxGb3JMYXllckxldmVsID0gZnVuY3Rpb24gKGx2bCwgcHhSYXRpbykge1xuICByZXR1cm4gbHZsO1xufTtcblxuTFRDcC5kcmF3RWxlSW5MYXllciA9IGZ1bmN0aW9uIChsYXllciwgZWxlLCBsdmwsIHB4UmF0aW8pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgciA9IHRoaXMucmVuZGVyZXI7XG4gIHZhciBjb250ZXh0ID0gbGF5ZXIuY29udGV4dDtcbiAgdmFyIGJiID0gZWxlLmJvdW5kaW5nQm94KCk7XG5cbiAgaWYgKGJiLncgPT09IDAgfHwgYmIuaCA9PT0gMCB8fCAhZWxlLnZpc2libGUoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGx2bCA9IHNlbGYuZ2V0RWxlTGV2ZWxGb3JMYXllckxldmVsKGx2bCwgcHhSYXRpbyk7XG5cbiAge1xuICAgIHIuc2V0SW1nU21vb3RoaW5nKGNvbnRleHQsIGZhbHNlKTtcbiAgfVxuXG4gIHtcbiAgICByLmRyYXdDYWNoZWRFbGVtZW50KGNvbnRleHQsIGVsZSwgbnVsbCwgbnVsbCwgbHZsLCB1c2VIaWdoUXVhbGl0eUVsZVR4clJlcXMpO1xuICB9XG5cbiAge1xuICAgIHIuc2V0SW1nU21vb3RoaW5nKGNvbnRleHQsIHRydWUpO1xuICB9XG59O1xuXG5MVENwLmxldmVsSXNDb21wbGV0ZSA9IGZ1bmN0aW9uIChsdmwsIGVsZXMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbGF5ZXJzID0gc2VsZi5sYXllcnNCeUxldmVsW2x2bF07XG5cbiAgaWYgKCFsYXllcnMgfHwgbGF5ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBudW1FbGVzSW5MYXllcnMgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxheWVyID0gbGF5ZXJzW2ldOyAvLyBpZiB0aGVyZSBhcmUgYW55IGVsZXMgbmVlZGVkIHRvIGJlIGRyYXduIHlldCwgdGhlIGxldmVsIGlzIG5vdCBjb21wbGV0ZVxuXG4gICAgaWYgKGxheWVyLnJlcXMgPiAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBpZiB0aGUgbGF5ZXIgaXMgaW52YWxpZCwgdGhlIGxldmVsIGlzIG5vdCBjb21wbGV0ZVxuXG5cbiAgICBpZiAobGF5ZXIuaW52YWxpZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG51bUVsZXNJbkxheWVycyArPSBsYXllci5lbGVzLmxlbmd0aDtcbiAgfSAvLyB3ZSBzaG91bGQgaGF2ZSBleGFjdGx5IHRoZSBudW1iZXIgb2YgZWxlcyBwYXNzZWQgaW4gdG8gYmUgY29tcGxldGVcblxuXG4gIGlmIChudW1FbGVzSW5MYXllcnMgIT09IGVsZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5MVENwLnZhbGlkYXRlTGF5ZXJzRWxlc09yZGVyaW5nID0gZnVuY3Rpb24gKGx2bCwgZWxlcykge1xuICB2YXIgbGF5ZXJzID0gdGhpcy5sYXllcnNCeUxldmVsW2x2bF07XG5cbiAgaWYgKCFsYXllcnMpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gaWYgaW4gYSBsYXllciB0aGUgZWxlcyBhcmUgbm90IGluIHRoZSBzYW1lIG9yZGVyLCB0aGVuIHRoZSBsYXllciBpcyBpbnZhbGlkXG4gIC8vIChpLmUuIHRoZXJlIGlzIGFuIGVsZSBpbiBiZXR3ZWVuIHRoZSBlbGVzIGluIHRoZSBsYXllcilcblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxheWVyID0gbGF5ZXJzW2ldO1xuICAgIHZhciBvZmZzZXQgPSAtMTsgLy8gZmluZCB0aGUgb2Zmc2V0XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChsYXllci5lbGVzWzBdID09PSBlbGVzW2pdKSB7XG4gICAgICAgIG9mZnNldCA9IGo7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAvLyB0aGVuIHRoZSBsYXllciBoYXMgbm9uZXhpc3RlbnQgZWxlbWVudHMgYW5kIGlzIGludmFsaWRcbiAgICAgIHRoaXMuaW52YWxpZGF0ZUxheWVyKGxheWVyKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gdGhlIGVsZXMgaW4gdGhlIGxheWVyIG11c3QgYmUgaW4gdGhlIHNhbWUgY29udGludW91cyBvcmRlciwgZWxzZSB0aGUgbGF5ZXIgaXMgaW52YWxpZFxuXG5cbiAgICB2YXIgbyA9IG9mZnNldDtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGF5ZXIuZWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGxheWVyLmVsZXNbal0gIT09IGVsZXNbbyArIGpdKSB7XG4gICAgICAgIC8vIGxvZygnaW52YWxpZGF0ZSBiYXNlZCBvbiBvcmRlcmluZycsIGxheWVyLmlkKTtcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlTGF5ZXIobGF5ZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbkxUQ3AudXBkYXRlRWxlbWVudHNJbkxheWVycyA9IGZ1bmN0aW9uIChlbGVzLCB1cGRhdGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgaXNFbGVzID0gZWxlbWVudChlbGVzWzBdKTsgLy8gY29sbGVjdCB1ZHBhdGVkIGVsZW1lbnRzIChjYXNjYWRlZCBmcm9tIHRoZSBsYXllcnMpIGFuZCB1cGRhdGUgZWFjaFxuICAvLyBsYXllciBpdHNlbGYgYWxvbmcgdGhlIHdheVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciByZXEgPSBpc0VsZXMgPyBudWxsIDogZWxlc1tpXTtcbiAgICB2YXIgZWxlID0gaXNFbGVzID8gZWxlc1tpXSA6IGVsZXNbaV0uZWxlO1xuICAgIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgY2FjaGVzID0gcnMuaW1nTGF5ZXJDYWNoZXMgPSBycy5pbWdMYXllckNhY2hlcyB8fCB7fTtcblxuICAgIGZvciAodmFyIGwgPSBtaW5Mdmw7IGwgPD0gbWF4THZsOyBsKyspIHtcbiAgICAgIHZhciBsYXllciA9IGNhY2hlc1tsXTtcblxuICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gaWYgdXBkYXRlIGlzIGEgcmVxdWVzdCBmcm9tIHRoZSBlbGUgY2FjaGUsIHRoZW4gaXQgYWZmZWN0cyBvbmx5XG4gICAgICAvLyB0aGUgbWF0Y2hpbmcgbGV2ZWxcblxuXG4gICAgICBpZiAocmVxICYmIHNlbGYuZ2V0RWxlTGV2ZWxGb3JMYXllckxldmVsKGxheWVyLmxldmVsKSAhPT0gcmVxLmxldmVsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUobGF5ZXIsIGVsZSwgcmVxKTtcbiAgICB9XG4gIH1cbn07XG5cbkxUQ3AuaGF2ZUxheWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgaGF2ZUxheWVycyA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGwgPSBtaW5Mdmw7IGwgPD0gbWF4THZsOyBsKyspIHtcbiAgICB2YXIgbGF5ZXJzID0gc2VsZi5sYXllcnNCeUxldmVsW2xdO1xuXG4gICAgaWYgKGxheWVycyAmJiBsYXllcnMubGVuZ3RoID4gMCkge1xuICAgICAgaGF2ZUxheWVycyA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaGF2ZUxheWVycztcbn07XG5cbkxUQ3AuaW52YWxpZGF0ZUVsZW1lbnRzID0gZnVuY3Rpb24gKGVsZXMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmIChlbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHNlbGYubGFzdEludmFsaWRhdGlvblRpbWUgPSBwZXJmb3JtYW5jZU5vdygpOyAvLyBsb2coJ3VwZGF0ZSBpbnZhbGlkYXRlIGxheWVyIHRpbWUgZnJvbSBlbGVzJyk7XG5cbiAgaWYgKGVsZXMubGVuZ3RoID09PSAwIHx8ICFzZWxmLmhhdmVMYXllcnMoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHNlbGYudXBkYXRlRWxlbWVudHNJbkxheWVycyhlbGVzLCBmdW5jdGlvbiBpbnZhbEFzc29jTGF5ZXJzKGxheWVyLCBlbGUsIHJlcSkge1xuICAgIHNlbGYuaW52YWxpZGF0ZUxheWVyKGxheWVyKTtcbiAgfSk7XG59O1xuXG5MVENwLmludmFsaWRhdGVMYXllciA9IGZ1bmN0aW9uIChsYXllcikge1xuICAvLyBsb2coJ3VwZGF0ZSBpbnZhbGlkYXRlIGxheWVyIHRpbWUnKTtcbiAgdGhpcy5sYXN0SW52YWxpZGF0aW9uVGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG5cbiAgaWYgKGxheWVyLmludmFsaWQpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gc2F2ZSBjeWNsZXNcblxuXG4gIHZhciBsdmwgPSBsYXllci5sZXZlbDtcbiAgdmFyIGVsZXMgPSBsYXllci5lbGVzO1xuICB2YXIgbGF5ZXJzID0gdGhpcy5sYXllcnNCeUxldmVsW2x2bF07IC8vIGxvZygnaW52YWxpZGF0ZSBsYXllcicsIGxheWVyLmlkICk7XG5cbiAgcmVtb3ZlRnJvbUFycmF5KGxheWVycywgbGF5ZXIpOyAvLyBsYXllci5lbGVzID0gW107XG5cbiAgbGF5ZXIuZWxlc1F1ZXVlID0gW107XG4gIGxheWVyLmludmFsaWQgPSB0cnVlO1xuXG4gIGlmIChsYXllci5yZXBsYWNlbWVudCkge1xuICAgIGxheWVyLnJlcGxhY2VtZW50LmludmFsaWQgPSB0cnVlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNhY2hlcyA9IGVsZXNbaV0uX3ByaXZhdGUucnNjcmF0Y2guaW1nTGF5ZXJDYWNoZXM7XG5cbiAgICBpZiAoY2FjaGVzKSB7XG4gICAgICBjYWNoZXNbbHZsXSA9IG51bGw7XG4gICAgfVxuICB9XG59O1xuXG5MVENwLnJlZmluZUVsZW1lbnRUZXh0dXJlcyA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gIHZhciBzZWxmID0gdGhpczsgLy8gbG9nKCdyZWZpbmUnLCBlbGVzLmxlbmd0aCk7XG5cbiAgc2VsZi51cGRhdGVFbGVtZW50c0luTGF5ZXJzKGVsZXMsIGZ1bmN0aW9uIHJlZmluZUVhY2hFbGUobGF5ZXIsIGVsZSwgcmVxKSB7XG4gICAgdmFyIHJMeXIgPSBsYXllci5yZXBsYWNlbWVudDtcblxuICAgIGlmICghckx5cikge1xuICAgICAgckx5ciA9IGxheWVyLnJlcGxhY2VtZW50ID0gc2VsZi5tYWtlTGF5ZXIobGF5ZXIuYmIsIGxheWVyLmxldmVsKTtcbiAgICAgIHJMeXIucmVwbGFjZXMgPSBsYXllcjtcbiAgICAgIHJMeXIuZWxlcyA9IGxheWVyLmVsZXM7IC8vIGxvZygnbWFrZSByZXBsYWNlbWVudCBsYXllciAlcyBmb3IgJXMgd2l0aCBsZXZlbCAlcycsIHJMeXIuaWQsIGxheWVyLmlkLCByTHlyLmxldmVsKTtcbiAgICB9XG5cbiAgICBpZiAoIXJMeXIucmVxcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByTHlyLmVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5xdWV1ZUxheWVyKHJMeXIsIHJMeXIuZWxlc1tpXSk7XG4gICAgICB9IC8vIGxvZygncXVldWUgcmVwbGFjZW1lbnQgbGF5ZXIgcmVmaW5lbWVudCcsIHJMeXIuaWQpO1xuXG4gICAgfVxuICB9KTtcbn07XG5cbkxUQ3AuZW5xdWV1ZUVsZW1lbnRSZWZpbmVtZW50ID0gZnVuY3Rpb24gKGVsZSkge1xuXG4gIHRoaXMuZWxlVHhyRGVxcy5tZXJnZShlbGUpO1xuICB0aGlzLnNjaGVkdWxlRWxlbWVudFJlZmluZW1lbnQoKTtcbn07XG5cbkxUQ3AucXVldWVMYXllciA9IGZ1bmN0aW9uIChsYXllciwgZWxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHEgPSBzZWxmLmxheWVyc1F1ZXVlO1xuICB2YXIgZWxlc1EgPSBsYXllci5lbGVzUXVldWU7XG4gIHZhciBoYXNJZCA9IGVsZXNRLmhhc0lkID0gZWxlc1EuaGFzSWQgfHwge307IC8vIGlmIGEgbGF5ZXIgaXMgZ29pbmcgdG8gYmUgcmVwbGFjZWQsIHF1ZXVpbmcgaXMgYSB3YXN0ZSBvZiB0aW1lXG5cbiAgaWYgKGxheWVyLnJlcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGVsZSkge1xuICAgIGlmIChoYXNJZFtlbGUuaWQoKV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVzUS5wdXNoKGVsZSk7XG4gICAgaGFzSWRbZWxlLmlkKCldID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChsYXllci5yZXFzKSB7XG4gICAgbGF5ZXIucmVxcysrO1xuICAgIHEudXBkYXRlSXRlbShsYXllcik7XG4gIH0gZWxzZSB7XG4gICAgbGF5ZXIucmVxcyA9IDE7XG4gICAgcS5wdXNoKGxheWVyKTtcbiAgfVxufTtcblxuTFRDcC5kZXF1ZXVlID0gZnVuY3Rpb24gKHB4UmF0aW8pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcSA9IHNlbGYubGF5ZXJzUXVldWU7XG4gIHZhciBkZXFkID0gW107XG4gIHZhciBlbGVEZXFzID0gMDtcblxuICB3aGlsZSAoZWxlRGVxcyA8IG1heERlcVNpemUpIHtcbiAgICBpZiAocS5zaXplKCkgPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBsYXllciA9IHEucGVlaygpOyAvLyBpZiBhIGxheWVyIGhhcyBiZWVuIG9yIHdpbGwgYmUgcmVwbGFjZWQsIHRoZW4gZG9uJ3Qgd2FzdGUgdGltZSB3aXRoIGl0XG5cbiAgICBpZiAobGF5ZXIucmVwbGFjZW1lbnQpIHtcbiAgICAgIC8vIGxvZygnbGF5ZXIgJXMgaW4gcXVldWUgc2tpcHBlZCBiL2MgaXQgYWxyZWFkeSBoYXMgYSByZXBsYWNlbWVudCcsIGxheWVyLmlkKTtcbiAgICAgIHEucG9wKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIGlmIHRoaXMgaXMgYSByZXBsYWNlbWVudCBsYXllciB0aGF0IGhhcyBiZWVuIHN1cGVyY2VkZWQsIHRoZW4gZm9yZ2V0IGl0XG5cblxuICAgIGlmIChsYXllci5yZXBsYWNlcyAmJiBsYXllciAhPT0gbGF5ZXIucmVwbGFjZXMucmVwbGFjZW1lbnQpIHtcbiAgICAgIC8vIGxvZygnbGF5ZXIgaXMgbm8gbG9uZ2VyIHRoZSBtb3N0IHVwdG9kYXRlIHJlcGxhY2VtZW50OyBkZXF1ZXVlZCcsIGxheWVyLmlkKVxuICAgICAgcS5wb3AoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChsYXllci5pbnZhbGlkKSB7XG4gICAgICAvLyBsb2coJ3JlcGxhY2VtZW50IGxheWVyICVzIGlzIGludmFsaWQ7IGRlcXVldWVkJywgbGF5ZXIuaWQpO1xuICAgICAgcS5wb3AoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBlbGUgPSBsYXllci5lbGVzUXVldWUuc2hpZnQoKTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIC8vIGxvZygnZGVxdWV1ZSBsYXllciAlcycsIGxheWVyLmlkKTtcbiAgICAgIHNlbGYuZHJhd0VsZUluTGF5ZXIobGF5ZXIsIGVsZSwgbGF5ZXIubGV2ZWwsIHB4UmF0aW8pO1xuICAgICAgZWxlRGVxcysrO1xuICAgIH1cblxuICAgIGlmIChkZXFkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gd2UgbmVlZCBvbmx5IG9uZSBlbnRyeSBpbiBkZXFkIHRvIHF1ZXVlIHJlZHJhd2luZyBldGNcbiAgICAgIGRlcWQucHVzaCh0cnVlKTtcbiAgICB9IC8vIGlmIHRoZSBsYXllciBoYXMgYWxsIGl0cyBlbGVzIGRvbmUsIHRoZW4gcmVtb3ZlIGZyb20gdGhlIHF1ZXVlXG5cblxuICAgIGlmIChsYXllci5lbGVzUXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICBxLnBvcCgpO1xuICAgICAgbGF5ZXIucmVxcyA9IDA7IC8vIGxvZygnZGVxdWV1ZSBvZiBsYXllciAlcyBjb21wbGV0ZScsIGxheWVyLmlkKTtcbiAgICAgIC8vIHdoZW4gYSByZXBsYWNlbWVudCBsYXllciBpcyBkZXF1ZXVlZCwgaXQgcmVwbGFjZXMgdGhlIG9sZCBsYXllciBpbiB0aGUgbGV2ZWxcblxuICAgICAgaWYgKGxheWVyLnJlcGxhY2VzKSB7XG4gICAgICAgIHNlbGYuYXBwbHlMYXllclJlcGxhY2VtZW50KGxheWVyKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5yZXF1ZXN0UmVkcmF3KCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlcWQ7XG59O1xuXG5MVENwLmFwcGx5TGF5ZXJSZXBsYWNlbWVudCA9IGZ1bmN0aW9uIChsYXllcikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBsYXllcnNJbkxldmVsID0gc2VsZi5sYXllcnNCeUxldmVsW2xheWVyLmxldmVsXTtcbiAgdmFyIHJlcGxhY2VkID0gbGF5ZXIucmVwbGFjZXM7XG4gIHZhciBpbmRleCA9IGxheWVyc0luTGV2ZWwuaW5kZXhPZihyZXBsYWNlZCk7IC8vIGlmIHRoZSByZXBsYWNlZCBsYXllciBpcyBub3QgaW4gdGhlIGFjdGl2ZSBsaXN0IGZvciB0aGUgbGV2ZWwsIHRoZW4gcmVwbGFjaW5nXG4gIC8vIHJlZnMgd291bGQgYmUgYSBtaXN0YWtlIChpLmUuIG92ZXJ3cml0aW5nIHRoZSB0cnVlIGFjdGl2ZSBsYXllcilcblxuICBpZiAoaW5kZXggPCAwIHx8IHJlcGxhY2VkLmludmFsaWQpIHtcbiAgICAvLyBsb2coJ3JlcGxhY2VtZW50IGxheWVyIHdvdWxkIGhhdmUgbm8gZWZmZWN0JywgbGF5ZXIuaWQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxheWVyc0luTGV2ZWxbaW5kZXhdID0gbGF5ZXI7IC8vIHJlcGxhY2UgbGV2ZWwgcmVmXG4gIC8vIHJlcGxhY2UgcmVmcyBpbiBlbGVzXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllci5lbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9wID0gbGF5ZXIuZWxlc1tpXS5fcHJpdmF0ZTtcbiAgICB2YXIgY2FjaGUgPSBfcC5pbWdMYXllckNhY2hlcyA9IF9wLmltZ0xheWVyQ2FjaGVzIHx8IHt9O1xuXG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICBjYWNoZVtsYXllci5sZXZlbF0gPSBsYXllcjtcbiAgICB9XG4gIH0gLy8gbG9nKCdhcHBseSByZXBsYWNlbWVudCBsYXllciAlcyBvdmVyICVzJywgbGF5ZXIuaWQsIHJlcGxhY2VkLmlkKTtcblxuXG4gIHNlbGYucmVxdWVzdFJlZHJhdygpO1xufTtcblxuTFRDcC5yZXF1ZXN0UmVkcmF3ID0gZGVib3VuY2VfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHIgPSB0aGlzLnJlbmRlcmVyO1xuICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gIHIucmVkcmF3KCk7XG59LCAxMDApO1xuTFRDcC5zZXR1cERlcXVldWVpbmcgPSBkZWZzLnNldHVwRGVxdWV1ZWluZyh7XG4gIGRlcVJlZHJhd1RocmVzaG9sZDogZGVxUmVkcmF3VGhyZXNob2xkLFxuICBkZXFDb3N0OiBkZXFDb3N0LFxuICBkZXFBdmdDb3N0OiBkZXFBdmdDb3N0LFxuICBkZXFOb0RyYXdDb3N0OiBkZXFOb0RyYXdDb3N0LFxuICBkZXFGYXN0Q29zdDogZGVxRmFzdENvc3QsXG4gIGRlcTogZnVuY3Rpb24gZGVxKHNlbGYsIHB4UmF0aW8pIHtcbiAgICByZXR1cm4gc2VsZi5kZXF1ZXVlKHB4UmF0aW8pO1xuICB9LFxuICBvbkRlcWQ6IG5vb3AkMSxcbiAgc2hvdWxkUmVkcmF3OiB0cnVlaWZ5LFxuICBwcmlvcml0eTogZnVuY3Rpb24gcHJpb3JpdHkoc2VsZikge1xuICAgIHJldHVybiBzZWxmLnJlbmRlcmVyLmJlZm9yZVJlbmRlclByaW9yaXRpZXMubHlyVHhyRGVxO1xuICB9XG59KTtcblxudmFyIENScCRhID0ge307XG52YXIgaW1wbDtcblxuZnVuY3Rpb24gcG9seWdvbihjb250ZXh0LCBwb2ludHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHQgPSBwb2ludHNbaV07XG4gICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJpYW5nbGVCYWNrY3VydmUoY29udGV4dCwgcG9pbnRzLCBjb250cm9sUG9pbnQpIHtcbiAgdmFyIGZpcnN0UHQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHQgPSBwb2ludHNbaV07XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgZmlyc3RQdCA9IHB0O1xuICAgIH1cblxuICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICB9XG5cbiAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgZmlyc3RQdC54LCBmaXJzdFB0LnkpO1xufVxuXG5mdW5jdGlvbiB0cmlhbmdsZVRlZShjb250ZXh0LCB0cmlhbmdsZVBvaW50cywgdGVlUG9pbnRzKSB7XG4gIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIH1cblxuICB2YXIgdHJpUHRzID0gdHJpYW5nbGVQb2ludHM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmlQdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHQgPSB0cmlQdHNbaV07XG4gICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gIH1cblxuICB2YXIgdGVlUHRzID0gdGVlUG9pbnRzO1xuICB2YXIgZmlyc3RUZWVQdCA9IHRlZVBvaW50c1swXTtcbiAgY29udGV4dC5tb3ZlVG8oZmlyc3RUZWVQdC54LCBmaXJzdFRlZVB0LnkpO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgdGVlUHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHB0ID0gdGVlUHRzW2ldO1xuICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICB9XG5cbiAgaWYgKGNvbnRleHQuY2xvc2VQYXRoKSB7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaXJjbGVUcmlhbmdsZShjb250ZXh0LCB0cmlhbmdsZVBvaW50cywgcngsIHJ5LCByKSB7XG4gIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIH1cblxuICBjb250ZXh0LmFyYyhyeCwgcnksIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gIHZhciB0cmlQdHMgPSB0cmlhbmdsZVBvaW50cztcbiAgdmFyIGZpcnN0VHJQdCA9IHRyaVB0c1swXTtcbiAgY29udGV4dC5tb3ZlVG8oZmlyc3RUclB0LngsIGZpcnN0VHJQdC55KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyaVB0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwdCA9IHRyaVB0c1tpXTtcbiAgICBjb250ZXh0LmxpbmVUbyhwdC54LCBwdC55KTtcbiAgfVxuXG4gIGlmIChjb250ZXh0LmNsb3NlUGF0aCkge1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2lyY2xlKGNvbnRleHQsIHJ4LCByeSwgcikge1xuICBjb250ZXh0LmFyYyhyeCwgcnksIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG59XG5cbkNScCRhLmFycm93U2hhcGVJbXBsID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIChpbXBsIHx8IChpbXBsID0ge1xuICAgICdwb2x5Z29uJzogcG9seWdvbixcbiAgICAndHJpYW5nbGUtYmFja2N1cnZlJzogdHJpYW5nbGVCYWNrY3VydmUsXG4gICAgJ3RyaWFuZ2xlLXRlZSc6IHRyaWFuZ2xlVGVlLFxuICAgICdjaXJjbGUtdHJpYW5nbGUnOiBjaXJjbGVUcmlhbmdsZSxcbiAgICAndHJpYW5nbGUtY3Jvc3MnOiB0cmlhbmdsZVRlZSxcbiAgICAnY2lyY2xlJzogY2lyY2xlXG4gIH0pKVtuYW1lXTtcbn07XG5cbnZhciBDUnAkOSA9IHt9O1xuXG5DUnAkOS5kcmF3RWxlbWVudCA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIHNoaWZ0VG9PcmlnaW5XaXRoQmIsIHNob3dMYWJlbCwgc2hvd092ZXJsYXksIHNob3dPcGFjaXR5KSB7XG4gIHZhciByID0gdGhpcztcblxuICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgci5kcmF3Tm9kZShjb250ZXh0LCBlbGUsIHNoaWZ0VG9PcmlnaW5XaXRoQmIsIHNob3dMYWJlbCwgc2hvd092ZXJsYXksIHNob3dPcGFjaXR5KTtcbiAgfSBlbHNlIHtcbiAgICByLmRyYXdFZGdlKGNvbnRleHQsIGVsZSwgc2hpZnRUb09yaWdpbldpdGhCYiwgc2hvd0xhYmVsLCBzaG93T3ZlcmxheSwgc2hvd09wYWNpdHkpO1xuICB9XG59O1xuXG5DUnAkOS5kcmF3RWxlbWVudE92ZXJsYXkgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlKSB7XG4gIHZhciByID0gdGhpcztcblxuICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgci5kcmF3Tm9kZU92ZXJsYXkoY29udGV4dCwgZWxlKTtcbiAgfSBlbHNlIHtcbiAgICByLmRyYXdFZGdlT3ZlcmxheShjb250ZXh0LCBlbGUpO1xuICB9XG59O1xuXG5DUnAkOS5kcmF3RWxlbWVudFVuZGVybGF5ID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSkge1xuICB2YXIgciA9IHRoaXM7XG5cbiAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgIHIuZHJhd05vZGVVbmRlcmxheShjb250ZXh0LCBlbGUpO1xuICB9IGVsc2Uge1xuICAgIHIuZHJhd0VkZ2VVbmRlcmxheShjb250ZXh0LCBlbGUpO1xuICB9XG59O1xuXG5DUnAkOS5kcmF3Q2FjaGVkRWxlbWVudFBvcnRpb24gPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBlbGVUeHJDYWNoZSwgcHhSYXRpbywgbHZsLCByZWFzb24sIGdldFJvdGF0aW9uLCBnZXRPcGFjaXR5KSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGJiID0gZWxlVHhyQ2FjaGUuZ2V0Qm91bmRpbmdCb3goZWxlKTtcblxuICBpZiAoYmIudyA9PT0gMCB8fCBiYi5oID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIGlnbm9yZSB6ZXJvIHNpemUgY2FzZVxuXG5cbiAgdmFyIGVsZUNhY2hlID0gZWxlVHhyQ2FjaGUuZ2V0RWxlbWVudChlbGUsIGJiLCBweFJhdGlvLCBsdmwsIHJlYXNvbik7XG5cbiAgaWYgKGVsZUNhY2hlICE9IG51bGwpIHtcbiAgICB2YXIgb3BhY2l0eSA9IGdldE9wYWNpdHkociwgZWxlKTtcblxuICAgIGlmIChvcGFjaXR5ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRoZXRhID0gZ2V0Um90YXRpb24ociwgZWxlKTtcbiAgICB2YXIgeDEgPSBiYi54MSxcbiAgICAgICAgeTEgPSBiYi55MSxcbiAgICAgICAgdyA9IGJiLncsXG4gICAgICAgIGggPSBiYi5oO1xuICAgIHZhciB4LCB5LCBzeCwgc3ksIHNtb290aDtcblxuICAgIGlmICh0aGV0YSAhPT0gMCkge1xuICAgICAgdmFyIHJvdFB0ID0gZWxlVHhyQ2FjaGUuZ2V0Um90YXRpb25Qb2ludChlbGUpO1xuICAgICAgc3ggPSByb3RQdC54O1xuICAgICAgc3kgPSByb3RQdC55O1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoc3gsIHN5KTtcbiAgICAgIGNvbnRleHQucm90YXRlKHRoZXRhKTtcbiAgICAgIHNtb290aCA9IHIuZ2V0SW1nU21vb3RoaW5nKGNvbnRleHQpO1xuXG4gICAgICBpZiAoIXNtb290aCkge1xuICAgICAgICByLnNldEltZ1Ntb290aGluZyhjb250ZXh0LCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9mZiA9IGVsZVR4ckNhY2hlLmdldFJvdGF0aW9uT2Zmc2V0KGVsZSk7XG4gICAgICB4ID0gb2ZmLng7XG4gICAgICB5ID0gb2ZmLnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSB4MTtcbiAgICAgIHkgPSB5MTtcbiAgICB9XG5cbiAgICB2YXIgb2xkR2xvYmFsQWxwaGE7XG5cbiAgICBpZiAob3BhY2l0eSAhPT0gMSkge1xuICAgICAgb2xkR2xvYmFsQWxwaGEgPSBjb250ZXh0Lmdsb2JhbEFscGhhO1xuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IG9sZEdsb2JhbEFscGhhICogb3BhY2l0eTtcbiAgICB9XG5cbiAgICBjb250ZXh0LmRyYXdJbWFnZShlbGVDYWNoZS50ZXh0dXJlLmNhbnZhcywgZWxlQ2FjaGUueCwgMCwgZWxlQ2FjaGUud2lkdGgsIGVsZUNhY2hlLmhlaWdodCwgeCwgeSwgdywgaCk7XG5cbiAgICBpZiAob3BhY2l0eSAhPT0gMSkge1xuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IG9sZEdsb2JhbEFscGhhO1xuICAgIH1cblxuICAgIGlmICh0aGV0YSAhPT0gMCkge1xuICAgICAgY29udGV4dC5yb3RhdGUoLXRoZXRhKTtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKC1zeCwgLXN5KTtcblxuICAgICAgaWYgKCFzbW9vdGgpIHtcbiAgICAgICAgci5zZXRJbWdTbW9vdGhpbmcoY29udGV4dCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBlbGVUeHJDYWNoZS5kcmF3RWxlbWVudChjb250ZXh0LCBlbGUpOyAvLyBkaXJlY3QgZHJhdyBmYWxsYmFja1xuICB9XG59O1xuXG52YXIgZ2V0WmVyb1JvdGF0aW9uID0gZnVuY3Rpb24gZ2V0WmVyb1JvdGF0aW9uKCkge1xuICByZXR1cm4gMDtcbn07XG5cbnZhciBnZXRMYWJlbFJvdGF0aW9uID0gZnVuY3Rpb24gZ2V0TGFiZWxSb3RhdGlvbihyLCBlbGUpIHtcbiAgcmV0dXJuIHIuZ2V0VGV4dEFuZ2xlKGVsZSwgbnVsbCk7XG59O1xuXG52YXIgZ2V0U291cmNlTGFiZWxSb3RhdGlvbiA9IGZ1bmN0aW9uIGdldFNvdXJjZUxhYmVsUm90YXRpb24ociwgZWxlKSB7XG4gIHJldHVybiByLmdldFRleHRBbmdsZShlbGUsICdzb3VyY2UnKTtcbn07XG5cbnZhciBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uID0gZnVuY3Rpb24gZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvbihyLCBlbGUpIHtcbiAgcmV0dXJuIHIuZ2V0VGV4dEFuZ2xlKGVsZSwgJ3RhcmdldCcpO1xufTtcblxudmFyIGdldE9wYWNpdHkgPSBmdW5jdGlvbiBnZXRPcGFjaXR5KHIsIGVsZSkge1xuICByZXR1cm4gZWxlLmVmZmVjdGl2ZU9wYWNpdHkoKTtcbn07XG5cbnZhciBnZXRUZXh0T3BhY2l0eSA9IGZ1bmN0aW9uIGdldFRleHRPcGFjaXR5KGUsIGVsZSkge1xuICByZXR1cm4gZWxlLnBzdHlsZSgndGV4dC1vcGFjaXR5JykucGZWYWx1ZSAqIGVsZS5lZmZlY3RpdmVPcGFjaXR5KCk7XG59O1xuXG5DUnAkOS5kcmF3Q2FjaGVkRWxlbWVudCA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIHB4UmF0aW8sIGV4dGVudCwgbHZsLCByZXF1ZXN0SGlnaFF1YWxpdHkpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgX3IkZGF0YSA9IHIuZGF0YSxcbiAgICAgIGVsZVR4ckNhY2hlID0gX3IkZGF0YS5lbGVUeHJDYWNoZSxcbiAgICAgIGxibFR4ckNhY2hlID0gX3IkZGF0YS5sYmxUeHJDYWNoZSxcbiAgICAgIHNsYlR4ckNhY2hlID0gX3IkZGF0YS5zbGJUeHJDYWNoZSxcbiAgICAgIHRsYlR4ckNhY2hlID0gX3IkZGF0YS50bGJUeHJDYWNoZTtcbiAgdmFyIGJiID0gZWxlLmJvdW5kaW5nQm94KCk7XG4gIHZhciByZWFzb24gPSByZXF1ZXN0SGlnaFF1YWxpdHkgPT09IHRydWUgPyBlbGVUeHJDYWNoZS5yZWFzb25zLmhpZ2hRdWFsaXR5IDogbnVsbDtcblxuICBpZiAoYmIudyA9PT0gMCB8fCBiYi5oID09PSAwIHx8ICFlbGUudmlzaWJsZSgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFleHRlbnQgfHwgYm91bmRpbmdCb3hlc0ludGVyc2VjdChiYiwgZXh0ZW50KSkge1xuICAgIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG5cbiAgICB2YXIgYmFkTGluZSA9IGVsZS5lbGVtZW50KCkuX3ByaXZhdGUucnNjcmF0Y2guYmFkTGluZTtcblxuICAgIHIuZHJhd0VsZW1lbnRVbmRlcmxheShjb250ZXh0LCBlbGUpO1xuICAgIHIuZHJhd0NhY2hlZEVsZW1lbnRQb3J0aW9uKGNvbnRleHQsIGVsZSwgZWxlVHhyQ2FjaGUsIHB4UmF0aW8sIGx2bCwgcmVhc29uLCBnZXRaZXJvUm90YXRpb24sIGdldE9wYWNpdHkpO1xuXG4gICAgaWYgKCFpc0VkZ2UgfHwgIWJhZExpbmUpIHtcbiAgICAgIHIuZHJhd0NhY2hlZEVsZW1lbnRQb3J0aW9uKGNvbnRleHQsIGVsZSwgbGJsVHhyQ2FjaGUsIHB4UmF0aW8sIGx2bCwgcmVhc29uLCBnZXRMYWJlbFJvdGF0aW9uLCBnZXRUZXh0T3BhY2l0eSk7XG4gICAgfVxuXG4gICAgaWYgKGlzRWRnZSAmJiAhYmFkTGluZSkge1xuICAgICAgci5kcmF3Q2FjaGVkRWxlbWVudFBvcnRpb24oY29udGV4dCwgZWxlLCBzbGJUeHJDYWNoZSwgcHhSYXRpbywgbHZsLCByZWFzb24sIGdldFNvdXJjZUxhYmVsUm90YXRpb24sIGdldFRleHRPcGFjaXR5KTtcbiAgICAgIHIuZHJhd0NhY2hlZEVsZW1lbnRQb3J0aW9uKGNvbnRleHQsIGVsZSwgdGxiVHhyQ2FjaGUsIHB4UmF0aW8sIGx2bCwgcmVhc29uLCBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uLCBnZXRUZXh0T3BhY2l0eSk7XG4gICAgfVxuXG4gICAgci5kcmF3RWxlbWVudE92ZXJsYXkoY29udGV4dCwgZWxlKTtcbiAgfVxufTtcblxuQ1JwJDkuZHJhd0VsZW1lbnRzID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZXMpIHtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIHIuZHJhd0VsZW1lbnQoY29udGV4dCwgZWxlKTtcbiAgfVxufTtcblxuQ1JwJDkuZHJhd0NhY2hlZEVsZW1lbnRzID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZXMsIHB4UmF0aW8sIGV4dGVudCkge1xuICB2YXIgciA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgci5kcmF3Q2FjaGVkRWxlbWVudChjb250ZXh0LCBlbGUsIHB4UmF0aW8sIGV4dGVudCk7XG4gIH1cbn07XG5cbkNScCQ5LmRyYXdDYWNoZWROb2RlcyA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGVzLCBweFJhdGlvLCBleHRlbnQpIHtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgaWYgKCFlbGUuaXNOb2RlKCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHIuZHJhd0NhY2hlZEVsZW1lbnQoY29udGV4dCwgZWxlLCBweFJhdGlvLCBleHRlbnQpO1xuICB9XG59O1xuXG5DUnAkOS5kcmF3TGF5ZXJlZEVsZW1lbnRzID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZXMsIHB4UmF0aW8sIGV4dGVudCkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBsYXllcnMgPSByLmRhdGEubHlyVHhyQ2FjaGUuZ2V0TGF5ZXJzKGVsZXMsIHB4UmF0aW8pO1xuXG4gIGlmIChsYXllcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW2ldO1xuICAgICAgdmFyIGJiID0gbGF5ZXIuYmI7XG5cbiAgICAgIGlmIChiYi53ID09PSAwIHx8IGJiLmggPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGxheWVyLmNhbnZhcywgYmIueDEsIGJiLnkxLCBiYi53LCBiYi5oKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZmFsbCBiYWNrIG9uIHBsYWluIGNhY2hpbmcgaWYgbm8gbGF5ZXJzXG4gICAgci5kcmF3Q2FjaGVkRWxlbWVudHMoY29udGV4dCwgZWxlcywgcHhSYXRpbywgZXh0ZW50KTtcbiAgfVxufTtcblxuLyogZ2xvYmFsIFBhdGgyRCAqL1xudmFyIENScCQ4ID0ge307XG5cbkNScCQ4LmRyYXdFZGdlID0gZnVuY3Rpb24gKGNvbnRleHQsIGVkZ2UsIHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgdmFyIGRyYXdMYWJlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcbiAgdmFyIHNob3VsZERyYXdPdmVybGF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0cnVlO1xuICB2YXIgc2hvdWxkRHJhd09wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHRydWU7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcblxuICBpZiAoc2hvdWxkRHJhd09wYWNpdHkgJiYgIWVkZ2UudmlzaWJsZSgpKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIGlmIGJlemllciBjdHJsIHB0cyBjYW4gbm90IGJlIGNhbGN1bGF0ZWQsIHRoZW4gZGllXG5cblxuICBpZiAocnMuYmFkTGluZSB8fCBycy5hbGxwdHMgPT0gbnVsbCB8fCBpc05hTihycy5hbGxwdHNbMF0pKSB7XG4gICAgLy8gaXNOYU4gaW4gY2FzZSBlZGdlIGlzIGltcG9zc2libGUgYW5kIGJyb3dzZXIgYnVncyAoZS5nLiBzYWZhcmkpXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGJiO1xuXG4gIGlmIChzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gICAgYmIgPSBzaGlmdFRvT3JpZ2luV2l0aEJiO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC1iYi54MSwgLWJiLnkxKTtcbiAgfVxuXG4gIHZhciBvcGFjaXR5ID0gc2hvdWxkRHJhd09wYWNpdHkgPyBlZGdlLnBzdHlsZSgnb3BhY2l0eScpLnZhbHVlIDogMTtcbiAgdmFyIGxpbmVPcGFjaXR5ID0gc2hvdWxkRHJhd09wYWNpdHkgPyBlZGdlLnBzdHlsZSgnbGluZS1vcGFjaXR5JykudmFsdWUgOiAxO1xuICB2YXIgY3VydmVTdHlsZSA9IGVkZ2UucHN0eWxlKCdjdXJ2ZS1zdHlsZScpLnZhbHVlO1xuICB2YXIgbGluZVN0eWxlID0gZWRnZS5wc3R5bGUoJ2xpbmUtc3R5bGUnKS52YWx1ZTtcbiAgdmFyIGVkZ2VXaWR0aCA9IGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG4gIHZhciBsaW5lQ2FwID0gZWRnZS5wc3R5bGUoJ2xpbmUtY2FwJykudmFsdWU7XG4gIHZhciBlZmZlY3RpdmVMaW5lT3BhY2l0eSA9IG9wYWNpdHkgKiBsaW5lT3BhY2l0eTsgLy8gc2VwYXJhdGUgYXJyb3cgb3BhY2l0eSB3b3VsZCByZXF1aXJlIGFycm93LW9wYWNpdHkgcHJvcGVydHlcblxuICB2YXIgZWZmZWN0aXZlQXJyb3dPcGFjaXR5ID0gb3BhY2l0eSAqIGxpbmVPcGFjaXR5O1xuXG4gIHZhciBkcmF3TGluZSA9IGZ1bmN0aW9uIGRyYXdMaW5lKCkge1xuICAgIHZhciBzdHJva2VPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBlZmZlY3RpdmVMaW5lT3BhY2l0eTtcblxuICAgIGlmIChjdXJ2ZVN0eWxlID09PSAnc3RyYWlnaHQtdHJpYW5nbGUnKSB7XG4gICAgICByLmVsZVN0cm9rZVN0eWxlKGNvbnRleHQsIGVkZ2UsIHN0cm9rZU9wYWNpdHkpO1xuICAgICAgci5kcmF3RWRnZVRyaWFuZ2xlUGF0aChlZGdlLCBjb250ZXh0LCBycy5hbGxwdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGVkZ2VXaWR0aDtcbiAgICAgIGNvbnRleHQubGluZUNhcCA9IGxpbmVDYXA7XG4gICAgICByLmVsZVN0cm9rZVN0eWxlKGNvbnRleHQsIGVkZ2UsIHN0cm9rZU9wYWNpdHkpO1xuICAgICAgci5kcmF3RWRnZVBhdGgoZWRnZSwgY29udGV4dCwgcnMuYWxscHRzLCBsaW5lU3R5bGUpO1xuICAgICAgY29udGV4dC5saW5lQ2FwID0gJ2J1dHQnOyAvLyByZXNldCBmb3Igb3RoZXIgZHJhd2luZyBmdW5jdGlvbnNcbiAgICB9XG4gIH07XG5cbiAgdmFyIGRyYXdPdmVybGF5ID0gZnVuY3Rpb24gZHJhd092ZXJsYXkoKSB7XG4gICAgaWYgKCFzaG91bGREcmF3T3ZlcmxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHIuZHJhd0VkZ2VPdmVybGF5KGNvbnRleHQsIGVkZ2UpO1xuICB9O1xuXG4gIHZhciBkcmF3VW5kZXJsYXkgPSBmdW5jdGlvbiBkcmF3VW5kZXJsYXkoKSB7XG4gICAgaWYgKCFzaG91bGREcmF3T3ZlcmxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHIuZHJhd0VkZ2VVbmRlcmxheShjb250ZXh0LCBlZGdlKTtcbiAgfTtcblxuICB2YXIgZHJhd0Fycm93cyA9IGZ1bmN0aW9uIGRyYXdBcnJvd3MoKSB7XG4gICAgdmFyIGFycm93T3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZWZmZWN0aXZlQXJyb3dPcGFjaXR5O1xuICAgIHIuZHJhd0Fycm93aGVhZHMoY29udGV4dCwgZWRnZSwgYXJyb3dPcGFjaXR5KTtcbiAgfTtcblxuICB2YXIgZHJhd1RleHQgPSBmdW5jdGlvbiBkcmF3VGV4dCgpIHtcbiAgICByLmRyYXdFbGVtZW50VGV4dChjb250ZXh0LCBlZGdlLCBudWxsLCBkcmF3TGFiZWwpO1xuICB9O1xuXG4gIGNvbnRleHQubGluZUpvaW4gPSAncm91bmQnO1xuICB2YXIgZ2hvc3QgPSBlZGdlLnBzdHlsZSgnZ2hvc3QnKS52YWx1ZSA9PT0gJ3llcyc7XG5cbiAgaWYgKGdob3N0KSB7XG4gICAgdmFyIGd4ID0gZWRnZS5wc3R5bGUoJ2dob3N0LW9mZnNldC14JykucGZWYWx1ZTtcbiAgICB2YXIgZ3kgPSBlZGdlLnBzdHlsZSgnZ2hvc3Qtb2Zmc2V0LXknKS5wZlZhbHVlO1xuICAgIHZhciBnaG9zdE9wYWNpdHkgPSBlZGdlLnBzdHlsZSgnZ2hvc3Qtb3BhY2l0eScpLnZhbHVlO1xuICAgIHZhciBlZmZlY3RpdmVHaG9zdE9wYWNpdHkgPSBlZmZlY3RpdmVMaW5lT3BhY2l0eSAqIGdob3N0T3BhY2l0eTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShneCwgZ3kpO1xuICAgIGRyYXdMaW5lKGVmZmVjdGl2ZUdob3N0T3BhY2l0eSk7XG4gICAgZHJhd0Fycm93cyhlZmZlY3RpdmVHaG9zdE9wYWNpdHkpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC1neCwgLWd5KTtcbiAgfVxuXG4gIGRyYXdVbmRlcmxheSgpO1xuICBkcmF3TGluZSgpO1xuICBkcmF3QXJyb3dzKCk7XG4gIGRyYXdPdmVybGF5KCk7XG4gIGRyYXdUZXh0KCk7XG5cbiAgaWYgKHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShiYi54MSwgYmIueTEpO1xuICB9XG59O1xuXG52YXIgZHJhd0VkZ2VPdmVybGF5VW5kZXJsYXkgPSBmdW5jdGlvbiBkcmF3RWRnZU92ZXJsYXlVbmRlcmxheShvdmVybGF5T3JVbmRlcmxheSkge1xuICBpZiAoIVsnb3ZlcmxheScsICd1bmRlcmxheSddLmluY2x1ZGVzKG92ZXJsYXlPclVuZGVybGF5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZScpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0LCBlZGdlKSB7XG4gICAgaWYgKCFlZGdlLnZpc2libGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvcGFjaXR5ID0gZWRnZS5wc3R5bGUoXCJcIi5jb25jYXQob3ZlcmxheU9yVW5kZXJsYXksIFwiLW9wYWNpdHlcIikpLnZhbHVlO1xuXG4gICAgaWYgKG9wYWNpdHkgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIHVzZVBhdGhzID0gci51c2VQYXRocygpO1xuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIHBhZGRpbmcgPSBlZGdlLnBzdHlsZShcIlwiLmNvbmNhdChvdmVybGF5T3JVbmRlcmxheSwgXCItcGFkZGluZ1wiKSkucGZWYWx1ZTtcbiAgICB2YXIgd2lkdGggPSAyICogcGFkZGluZztcbiAgICB2YXIgY29sb3IgPSBlZGdlLnBzdHlsZShcIlwiLmNvbmNhdChvdmVybGF5T3JVbmRlcmxheSwgXCItY29sb3JcIikpLnZhbHVlO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gd2lkdGg7XG5cbiAgICBpZiAocnMuZWRnZVR5cGUgPT09ICdzZWxmJyAmJiAhdXNlUGF0aHMpIHtcbiAgICAgIGNvbnRleHQubGluZUNhcCA9ICdidXR0JztcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5saW5lQ2FwID0gJ3JvdW5kJztcbiAgICB9XG5cbiAgICByLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eSk7XG4gICAgci5kcmF3RWRnZVBhdGgoZWRnZSwgY29udGV4dCwgcnMuYWxscHRzLCAnc29saWQnKTtcbiAgfTtcbn07XG5cbkNScCQ4LmRyYXdFZGdlT3ZlcmxheSA9IGRyYXdFZGdlT3ZlcmxheVVuZGVybGF5KCdvdmVybGF5Jyk7XG5DUnAkOC5kcmF3RWRnZVVuZGVybGF5ID0gZHJhd0VkZ2VPdmVybGF5VW5kZXJsYXkoJ3VuZGVybGF5Jyk7XG5cbkNScCQ4LmRyYXdFZGdlUGF0aCA9IGZ1bmN0aW9uIChlZGdlLCBjb250ZXh0LCBwdHMsIHR5cGUpIHtcbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIGNhbnZhc0N4dCA9IGNvbnRleHQ7XG4gIHZhciBwYXRoO1xuICB2YXIgcGF0aENhY2hlSGl0ID0gZmFsc2U7XG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKTtcbiAgdmFyIGxpbmVEYXNoUGF0dGVybiA9IGVkZ2UucHN0eWxlKCdsaW5lLWRhc2gtcGF0dGVybicpLnBmVmFsdWU7XG4gIHZhciBsaW5lRGFzaE9mZnNldCA9IGVkZ2UucHN0eWxlKCdsaW5lLWRhc2gtb2Zmc2V0JykucGZWYWx1ZTtcblxuICBpZiAodXNlUGF0aHMpIHtcbiAgICB2YXIgcGF0aENhY2hlS2V5ID0gcHRzLmpvaW4oJyQnKTtcbiAgICB2YXIga2V5TWF0Y2hlcyA9IHJzLnBhdGhDYWNoZUtleSAmJiBycy5wYXRoQ2FjaGVLZXkgPT09IHBhdGhDYWNoZUtleTtcblxuICAgIGlmIChrZXlNYXRjaGVzKSB7XG4gICAgICBwYXRoID0gY29udGV4dCA9IHJzLnBhdGhDYWNoZTtcbiAgICAgIHBhdGhDYWNoZUhpdCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSBjb250ZXh0ID0gbmV3IFBhdGgyRCgpO1xuICAgICAgcnMucGF0aENhY2hlS2V5ID0gcGF0aENhY2hlS2V5O1xuICAgICAgcnMucGF0aENhY2hlID0gcGF0aDtcbiAgICB9XG4gIH1cblxuICBpZiAoY2FudmFzQ3h0LnNldExpbmVEYXNoKSB7XG4gICAgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdkb3R0ZWQnOlxuICAgICAgICBjYW52YXNDeHQuc2V0TGluZURhc2goWzEsIDFdKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2Rhc2hlZCc6XG4gICAgICAgIGNhbnZhc0N4dC5zZXRMaW5lRGFzaChsaW5lRGFzaFBhdHRlcm4pO1xuICAgICAgICBjYW52YXNDeHQubGluZURhc2hPZmZzZXQgPSBsaW5lRGFzaE9mZnNldDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3NvbGlkJzpcbiAgICAgICAgY2FudmFzQ3h0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFwYXRoQ2FjaGVIaXQgJiYgIXJzLmJhZExpbmUpIHtcbiAgICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgfVxuXG4gICAgY29udGV4dC5tb3ZlVG8ocHRzWzBdLCBwdHNbMV0pO1xuXG4gICAgc3dpdGNoIChycy5lZGdlVHlwZSkge1xuICAgICAgY2FzZSAnYmV6aWVyJzpcbiAgICAgIGNhc2UgJ3NlbGYnOlxuICAgICAgY2FzZSAnY29tcG91bmQnOlxuICAgICAgY2FzZSAnbXVsdGliZXppZXInOlxuICAgICAgICBmb3IgKHZhciBpID0gMjsgaSArIDMgPCBwdHMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8ocHRzW2ldLCBwdHNbaSArIDFdLCBwdHNbaSArIDJdLCBwdHNbaSArIDNdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzdHJhaWdodCc6XG4gICAgICBjYXNlICdzZWdtZW50cyc6XG4gICAgICBjYXNlICdoYXlzdGFjayc6XG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgKyAxIDwgcHRzLmxlbmd0aDsgX2kgKz0gMikge1xuICAgICAgICAgIGNvbnRleHQubGluZVRvKHB0c1tfaV0sIHB0c1tfaSArIDFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGNvbnRleHQgPSBjYW52YXNDeHQ7XG5cbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgY29udGV4dC5zdHJva2UocGF0aCk7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5zdHJva2UoKTtcbiAgfSAvLyByZXNldCBhbnkgbGluZSBkYXNoZXNcblxuXG4gIGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gIH1cbn07XG5cbkNScCQ4LmRyYXdFZGdlVHJpYW5nbGVQYXRoID0gZnVuY3Rpb24gKGVkZ2UsIGNvbnRleHQsIHB0cykge1xuICAvLyB1c2UgbGluZSBzdHJva2Ugc3R5bGUgZm9yIHRyaWFuZ2xlIGZpbGwgc3R5bGVcbiAgY29udGV4dC5maWxsU3R5bGUgPSBjb250ZXh0LnN0cm9rZVN0eWxlO1xuICB2YXIgZWRnZVdpZHRoID0gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSArIDEgPCBwdHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgdmVjdG9yID0gW3B0c1tpICsgMl0gLSBwdHNbaV0sIHB0c1tpICsgM10gLSBwdHNbaSArIDFdXTtcbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5zcXJ0KHZlY3RvclswXSAqIHZlY3RvclswXSArIHZlY3RvclsxXSAqIHZlY3RvclsxXSk7XG4gICAgdmFyIG5vcm1hbCA9IFt2ZWN0b3JbMV0gLyBsZW5ndGgsIC12ZWN0b3JbMF0gLyBsZW5ndGhdO1xuICAgIHZhciB0cmlhbmdsZUhlYWQgPSBbbm9ybWFsWzBdICogZWRnZVdpZHRoIC8gMiwgbm9ybWFsWzFdICogZWRnZVdpZHRoIC8gMl07XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhwdHNbaV0gLSB0cmlhbmdsZUhlYWRbMF0sIHB0c1tpICsgMV0gLSB0cmlhbmdsZUhlYWRbMV0pO1xuICAgIGNvbnRleHQubGluZVRvKHB0c1tpXSArIHRyaWFuZ2xlSGVhZFswXSwgcHRzW2kgKyAxXSArIHRyaWFuZ2xlSGVhZFsxXSk7XG4gICAgY29udGV4dC5saW5lVG8ocHRzW2kgKyAyXSwgcHRzW2kgKyAzXSk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfVxufTtcblxuQ1JwJDguZHJhd0Fycm93aGVhZHMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWRnZSwgb3BhY2l0eSkge1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgaXNIYXlzdGFjayA9IHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snO1xuXG4gIGlmICghaXNIYXlzdGFjaykge1xuICAgIHRoaXMuZHJhd0Fycm93aGVhZChjb250ZXh0LCBlZGdlLCAnc291cmNlJywgcnMuYXJyb3dTdGFydFgsIHJzLmFycm93U3RhcnRZLCBycy5zcmNBcnJvd0FuZ2xlLCBvcGFjaXR5KTtcbiAgfVxuXG4gIHRoaXMuZHJhd0Fycm93aGVhZChjb250ZXh0LCBlZGdlLCAnbWlkLXRhcmdldCcsIHJzLm1pZFgsIHJzLm1pZFksIHJzLm1pZHRndEFycm93QW5nbGUsIG9wYWNpdHkpO1xuICB0aGlzLmRyYXdBcnJvd2hlYWQoY29udGV4dCwgZWRnZSwgJ21pZC1zb3VyY2UnLCBycy5taWRYLCBycy5taWRZLCBycy5taWRzcmNBcnJvd0FuZ2xlLCBvcGFjaXR5KTtcblxuICBpZiAoIWlzSGF5c3RhY2spIHtcbiAgICB0aGlzLmRyYXdBcnJvd2hlYWQoY29udGV4dCwgZWRnZSwgJ3RhcmdldCcsIHJzLmFycm93RW5kWCwgcnMuYXJyb3dFbmRZLCBycy50Z3RBcnJvd0FuZ2xlLCBvcGFjaXR5KTtcbiAgfVxufTtcblxuQ1JwJDguZHJhd0Fycm93aGVhZCA9IGZ1bmN0aW9uIChjb250ZXh0LCBlZGdlLCBwcmVmaXgsIHgsIHksIGFuZ2xlLCBvcGFjaXR5KSB7XG4gIGlmIChpc05hTih4KSB8fCB4ID09IG51bGwgfHwgaXNOYU4oeSkgfHwgeSA9PSBudWxsIHx8IGlzTmFOKGFuZ2xlKSB8fCBhbmdsZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYXJyb3dTaGFwZSA9IGVkZ2UucHN0eWxlKHByZWZpeCArICctYXJyb3ctc2hhcGUnKS52YWx1ZTtcblxuICBpZiAoYXJyb3dTaGFwZSA9PT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGFycm93Q2xlYXJGaWxsID0gZWRnZS5wc3R5bGUocHJlZml4ICsgJy1hcnJvdy1maWxsJykudmFsdWUgPT09ICdob2xsb3cnID8gJ2JvdGgnIDogJ2ZpbGxlZCc7XG4gIHZhciBhcnJvd0ZpbGwgPSBlZGdlLnBzdHlsZShwcmVmaXggKyAnLWFycm93LWZpbGwnKS52YWx1ZTtcbiAgdmFyIGVkZ2VXaWR0aCA9IGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG4gIHZhciBlZGdlT3BhY2l0eSA9IGVkZ2UucHN0eWxlKCdvcGFjaXR5JykudmFsdWU7XG5cbiAgaWYgKG9wYWNpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wYWNpdHkgPSBlZGdlT3BhY2l0eTtcbiAgfVxuXG4gIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcblxuICBpZiAob3BhY2l0eSAhPT0gMSB8fCBhcnJvd0ZpbGwgPT09ICdob2xsb3cnKSB7XG4gICAgLy8gdGhlbiBleHRyYSBjbGVhciBpcyBuZWVkZWRcbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuICAgIHNlbGYuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgMjU1LCAyNTUsIDI1NSwgMSk7XG4gICAgc2VsZi5jb2xvclN0cm9rZVN0eWxlKGNvbnRleHQsIDI1NSwgMjU1LCAyNTUsIDEpO1xuICAgIHNlbGYuZHJhd0Fycm93U2hhcGUoZWRnZSwgY29udGV4dCwgYXJyb3dDbGVhckZpbGwsIGVkZ2VXaWR0aCwgYXJyb3dTaGFwZSwgeCwgeSwgYW5nbGUpO1xuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZ2NvO1xuICB9IC8vIG90aGVyd2lzZSwgdGhlIG9wYXF1ZSBhcnJvdyBjbGVhcnMgaXQgZm9yIGZyZWUgOilcblxuXG4gIHZhciBjb2xvciA9IGVkZ2UucHN0eWxlKHByZWZpeCArICctYXJyb3ctY29sb3InKS52YWx1ZTtcbiAgc2VsZi5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgc2VsZi5jb2xvclN0cm9rZVN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkpO1xuICBzZWxmLmRyYXdBcnJvd1NoYXBlKGVkZ2UsIGNvbnRleHQsIGFycm93RmlsbCwgZWRnZVdpZHRoLCBhcnJvd1NoYXBlLCB4LCB5LCBhbmdsZSk7XG59O1xuXG5DUnAkOC5kcmF3QXJyb3dTaGFwZSA9IGZ1bmN0aW9uIChlZGdlLCBjb250ZXh0LCBmaWxsLCBlZGdlV2lkdGgsIHNoYXBlLCB4LCB5LCBhbmdsZSkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKSAmJiBzaGFwZSAhPT0gJ3RyaWFuZ2xlLWNyb3NzJztcbiAgdmFyIHBhdGhDYWNoZUhpdCA9IGZhbHNlO1xuICB2YXIgcGF0aDtcbiAgdmFyIGNhbnZhc0NvbnRleHQgPSBjb250ZXh0O1xuICB2YXIgdHJhbnNsYXRpb24gPSB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG4gIHZhciBzY2FsZSA9IGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlO1xuICB2YXIgc2l6ZSA9IHRoaXMuZ2V0QXJyb3dXaWR0aChlZGdlV2lkdGgsIHNjYWxlKTtcbiAgdmFyIHNoYXBlSW1wbCA9IHIuYXJyb3dTaGFwZXNbc2hhcGVdO1xuXG4gIGlmICh1c2VQYXRocykge1xuICAgIHZhciBjYWNoZSA9IHIuYXJyb3dQYXRoQ2FjaGUgPSByLmFycm93UGF0aENhY2hlIHx8IFtdO1xuICAgIHZhciBrZXkgPSBoYXNoU3RyaW5nKHNoYXBlKTtcbiAgICB2YXIgY2FjaGVkUGF0aCA9IGNhY2hlW2tleV07XG5cbiAgICBpZiAoY2FjaGVkUGF0aCAhPSBudWxsKSB7XG4gICAgICBwYXRoID0gY29udGV4dCA9IGNhY2hlZFBhdGg7XG4gICAgICBwYXRoQ2FjaGVIaXQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gY29udGV4dCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgIGNhY2hlW2tleV0gPSBwYXRoO1xuICAgIH1cbiAgfVxuXG4gIGlmICghcGF0aENhY2hlSGl0KSB7XG4gICAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIH1cblxuICAgIGlmICh1c2VQYXRocykge1xuICAgICAgLy8gc3RvcmUgaW4gdGhlIHBhdGggY2FjaGUgd2l0aCB2YWx1ZXMgZWFzaWx5IG1hbmlwdWxhdGVkIGxhdGVyXG4gICAgICBzaGFwZUltcGwuZHJhdyhjb250ZXh0LCAxLCAwLCB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaGFwZUltcGwuZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQuY2xvc2VQYXRoKSB7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnRleHQgPSBjYW52YXNDb250ZXh0O1xuXG4gIGlmICh1c2VQYXRocykge1xuICAgIC8vIHNldCB0cmFuc2Zvcm0gdG8gYXJyb3cgcG9zaXRpb24vb3JpZW50YXRpb25cbiAgICBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICBjb250ZXh0LnJvdGF0ZShhbmdsZSk7XG4gICAgY29udGV4dC5zY2FsZShzaXplLCBzaXplKTtcbiAgfVxuXG4gIGlmIChmaWxsID09PSAnZmlsbGVkJyB8fCBmaWxsID09PSAnYm90aCcpIHtcbiAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgIGNvbnRleHQuZmlsbChwYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZpbGwgPT09ICdob2xsb3cnIHx8IGZpbGwgPT09ICdib3RoJykge1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gKHNoYXBlSW1wbC5tYXRjaEVkZ2VXaWR0aCA/IGVkZ2VXaWR0aCA6IDEpIC8gKHVzZVBhdGhzID8gc2l6ZSA6IDEpO1xuICAgIGNvbnRleHQubGluZUpvaW4gPSAnbWl0ZXInO1xuXG4gICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICBjb250ZXh0LnN0cm9rZShwYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9XG4gIH1cblxuICBpZiAodXNlUGF0aHMpIHtcbiAgICAvLyByZXNldCB0cmFuc2Zvcm0gYnkgYXBwbHlpbmcgaW52ZXJzZVxuICAgIGNvbnRleHQuc2NhbGUoMSAvIHNpemUsIDEgLyBzaXplKTtcbiAgICBjb250ZXh0LnJvdGF0ZSgtYW5nbGUpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC14LCAteSk7XG4gIH1cbn07XG5cbnZhciBDUnAkNyA9IHt9O1xuXG5DUnAkNy5zYWZlRHJhd0ltYWdlID0gZnVuY3Rpb24gKGNvbnRleHQsIGltZywgaXgsIGl5LCBpdywgaWgsIHgsIHksIHcsIGgpIHtcbiAgLy8gZGV0ZWN0IHByb2JsZW1hdGljIGNhc2VzIGZvciBvbGQgYnJvd3NlcnMgd2l0aCBiYWQgaW1hZ2VzIChjaGVhcGVyIHRoYW4gdHJ5LWNhdGNoKVxuICBpZiAoaXcgPD0gMCB8fCBpaCA8PSAwIHx8IHcgPD0gMCB8fCBoIDw9IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKGltZywgaXgsIGl5LCBpdywgaWgsIHgsIHksIHcsIGgpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgd2FybihlKTtcbiAgfVxufTtcblxuQ1JwJDcuZHJhd0luc2NyaWJlZEltYWdlID0gZnVuY3Rpb24gKGNvbnRleHQsIGltZywgbm9kZSwgaW5kZXgsIG5vZGVPcGFjaXR5KSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIHBvcyA9IG5vZGUucG9zaXRpb24oKTtcbiAgdmFyIG5vZGVYID0gcG9zLng7XG4gIHZhciBub2RlWSA9IHBvcy55O1xuICB2YXIgc3R5bGVPYmogPSBub2RlLmN5KCkuc3R5bGUoKTtcbiAgdmFyIGdldEluZGV4ZWRTdHlsZSA9IHN0eWxlT2JqLmdldEluZGV4ZWRTdHlsZS5iaW5kKHN0eWxlT2JqKTtcbiAgdmFyIGZpdCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1maXQnLCAndmFsdWUnLCBpbmRleCk7XG4gIHZhciByZXBlYXQgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtcmVwZWF0JywgJ3ZhbHVlJywgaW5kZXgpO1xuICB2YXIgbm9kZVcgPSBub2RlLndpZHRoKCk7XG4gIHZhciBub2RlSCA9IG5vZGUuaGVpZ2h0KCk7XG4gIHZhciBwYWRkaW5nWDIgPSBub2RlLnBhZGRpbmcoKSAqIDI7XG4gIHZhciBub2RlVFcgPSBub2RlVyArIChnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtd2lkdGgtcmVsYXRpdmUtdG8nLCAndmFsdWUnLCBpbmRleCkgPT09ICdpbm5lcicgPyAwIDogcGFkZGluZ1gyKTtcbiAgdmFyIG5vZGVUSCA9IG5vZGVIICsgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1oZWlnaHQtcmVsYXRpdmUtdG8nLCAndmFsdWUnLCBpbmRleCkgPT09ICdpbm5lcicgPyAwIDogcGFkZGluZ1gyKTtcbiAgdmFyIHJzID0gbm9kZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIGNsaXAgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtY2xpcCcsICd2YWx1ZScsIGluZGV4KTtcbiAgdmFyIHNob3VsZENsaXAgPSBjbGlwID09PSAnbm9kZSc7XG4gIHZhciBpbWdPcGFjaXR5ID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknLCAndmFsdWUnLCBpbmRleCkgKiBub2RlT3BhY2l0eTtcbiAgdmFyIHNtb290aCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1pbWFnZS1zbW9vdGhpbmcnLCAndmFsdWUnLCBpbmRleCk7XG4gIHZhciBpbWdXID0gaW1nLndpZHRoIHx8IGltZy5jYWNoZWRXO1xuICB2YXIgaW1nSCA9IGltZy5oZWlnaHQgfHwgaW1nLmNhY2hlZEg7IC8vIHdvcmthcm91bmQgZm9yIGJyb2tlbiBicm93c2VycyBsaWtlIGllXG5cbiAgaWYgKG51bGwgPT0gaW1nVyB8fCBudWxsID09IGltZ0gpIHtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGltZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgIGltZ1cgPSBpbWcuY2FjaGVkVyA9IGltZy53aWR0aCB8fCBpbWcub2Zmc2V0V2lkdGg7XG4gICAgaW1nSCA9IGltZy5jYWNoZWRIID0gaW1nLmhlaWdodCB8fCBpbWcub2Zmc2V0SGVpZ2h0O1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaW1nKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICB9XG5cbiAgdmFyIHcgPSBpbWdXO1xuICB2YXIgaCA9IGltZ0g7XG5cbiAgaWYgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC13aWR0aCcsICd2YWx1ZScsIGluZGV4KSAhPT0gJ2F1dG8nKSB7XG4gICAgaWYgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC13aWR0aCcsICd1bml0cycsIGluZGV4KSA9PT0gJyUnKSB7XG4gICAgICB3ID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXdpZHRoJywgJ3BmVmFsdWUnLCBpbmRleCkgKiBub2RlVFc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHcgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtd2lkdGgnLCAncGZWYWx1ZScsIGluZGV4KTtcbiAgICB9XG4gIH1cblxuICBpZiAoZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWhlaWdodCcsICd2YWx1ZScsIGluZGV4KSAhPT0gJ2F1dG8nKSB7XG4gICAgaWYgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1oZWlnaHQnLCAndW5pdHMnLCBpbmRleCkgPT09ICclJykge1xuICAgICAgaCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1oZWlnaHQnLCAncGZWYWx1ZScsIGluZGV4KSAqIG5vZGVUSDtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1oZWlnaHQnLCAncGZWYWx1ZScsIGluZGV4KTtcbiAgICB9XG4gIH1cblxuICBpZiAodyA9PT0gMCB8fCBoID09PSAwKSB7XG4gICAgcmV0dXJuOyAvLyBubyBwb2ludCBpbiBkcmF3aW5nIGVtcHR5IGltYWdlIChhbmQgY2hyb21lIGlzIGJyb2tlbiBpbiB0aGlzIGNhc2UpXG4gIH1cblxuICBpZiAoZml0ID09PSAnY29udGFpbicpIHtcbiAgICB2YXIgc2NhbGUgPSBNYXRoLm1pbihub2RlVFcgLyB3LCBub2RlVEggLyBoKTtcbiAgICB3ICo9IHNjYWxlO1xuICAgIGggKj0gc2NhbGU7XG4gIH0gZWxzZSBpZiAoZml0ID09PSAnY292ZXInKSB7XG4gICAgdmFyIHNjYWxlID0gTWF0aC5tYXgobm9kZVRXIC8gdywgbm9kZVRIIC8gaCk7XG4gICAgdyAqPSBzY2FsZTtcbiAgICBoICo9IHNjYWxlO1xuICB9XG5cbiAgdmFyIHggPSBub2RlWCAtIG5vZGVUVyAvIDI7IC8vIGxlZnRcblxuICB2YXIgcG9zWFVuaXRzID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnLCAndW5pdHMnLCBpbmRleCk7XG4gIHZhciBwb3NYUGZWYWwgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtcG9zaXRpb24teCcsICdwZlZhbHVlJywgaW5kZXgpO1xuXG4gIGlmIChwb3NYVW5pdHMgPT09ICclJykge1xuICAgIHggKz0gKG5vZGVUVyAtIHcpICogcG9zWFBmVmFsO1xuICB9IGVsc2Uge1xuICAgIHggKz0gcG9zWFBmVmFsO1xuICB9XG5cbiAgdmFyIG9mZlhVbml0cyA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1vZmZzZXQteCcsICd1bml0cycsIGluZGV4KTtcbiAgdmFyIG9mZlhQZlZhbCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1vZmZzZXQteCcsICdwZlZhbHVlJywgaW5kZXgpO1xuXG4gIGlmIChvZmZYVW5pdHMgPT09ICclJykge1xuICAgIHggKz0gKG5vZGVUVyAtIHcpICogb2ZmWFBmVmFsO1xuICB9IGVsc2Uge1xuICAgIHggKz0gb2ZmWFBmVmFsO1xuICB9XG5cbiAgdmFyIHkgPSBub2RlWSAtIG5vZGVUSCAvIDI7IC8vIHRvcFxuXG4gIHZhciBwb3NZVW5pdHMgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtcG9zaXRpb24teScsICd1bml0cycsIGluZGV4KTtcbiAgdmFyIHBvc1lQZlZhbCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1wb3NpdGlvbi15JywgJ3BmVmFsdWUnLCBpbmRleCk7XG5cbiAgaWYgKHBvc1lVbml0cyA9PT0gJyUnKSB7XG4gICAgeSArPSAobm9kZVRIIC0gaCkgKiBwb3NZUGZWYWw7XG4gIH0gZWxzZSB7XG4gICAgeSArPSBwb3NZUGZWYWw7XG4gIH1cblxuICB2YXIgb2ZmWVVuaXRzID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLW9mZnNldC15JywgJ3VuaXRzJywgaW5kZXgpO1xuICB2YXIgb2ZmWVBmVmFsID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLW9mZnNldC15JywgJ3BmVmFsdWUnLCBpbmRleCk7XG5cbiAgaWYgKG9mZllVbml0cyA9PT0gJyUnKSB7XG4gICAgeSArPSAobm9kZVRIIC0gaCkgKiBvZmZZUGZWYWw7XG4gIH0gZWxzZSB7XG4gICAgeSArPSBvZmZZUGZWYWw7XG4gIH1cblxuICBpZiAocnMucGF0aENhY2hlKSB7XG4gICAgeCAtPSBub2RlWDtcbiAgICB5IC09IG5vZGVZO1xuICAgIG5vZGVYID0gMDtcbiAgICBub2RlWSA9IDA7XG4gIH1cblxuICB2YXIgZ0FscGhhID0gY29udGV4dC5nbG9iYWxBbHBoYTtcbiAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGltZ09wYWNpdHk7XG4gIHZhciBzbW9vdGhpbmdFbmFibGVkID0gci5nZXRJbWdTbW9vdGhpbmcoY29udGV4dCk7XG4gIHZhciBpc1Ntb290aGluZ1N3aXRjaGVkID0gZmFsc2U7XG5cbiAgaWYgKHNtb290aCA9PT0gJ25vJyAmJiBzbW9vdGhpbmdFbmFibGVkKSB7XG4gICAgci5zZXRJbWdTbW9vdGhpbmcoY29udGV4dCwgZmFsc2UpO1xuICAgIGlzU21vb3RoaW5nU3dpdGNoZWQgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHNtb290aCA9PT0gJ3llcycgJiYgIXNtb290aGluZ0VuYWJsZWQpIHtcbiAgICByLnNldEltZ1Ntb290aGluZyhjb250ZXh0LCB0cnVlKTtcbiAgICBpc1Ntb290aGluZ1N3aXRjaGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChyZXBlYXQgPT09ICduby1yZXBlYXQnKSB7XG4gICAgaWYgKHNob3VsZENsaXApIHtcbiAgICAgIGNvbnRleHQuc2F2ZSgpO1xuXG4gICAgICBpZiAocnMucGF0aENhY2hlKSB7XG4gICAgICAgIGNvbnRleHQuY2xpcChycy5wYXRoQ2FjaGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgci5ub2RlU2hhcGVzW3IuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5kcmF3KGNvbnRleHQsIG5vZGVYLCBub2RlWSwgbm9kZVRXLCBub2RlVEgpO1xuICAgICAgICBjb250ZXh0LmNsaXAoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByLnNhZmVEcmF3SW1hZ2UoY29udGV4dCwgaW1nLCAwLCAwLCBpbWdXLCBpbWdILCB4LCB5LCB3LCBoKTtcblxuICAgIGlmIChzaG91bGRDbGlwKSB7XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhdHRlcm4gPSBjb250ZXh0LmNyZWF0ZVBhdHRlcm4oaW1nLCByZXBlYXQpO1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gcGF0dGVybjtcbiAgICByLm5vZGVTaGFwZXNbci5nZXROb2RlU2hhcGUobm9kZSldLmRyYXcoY29udGV4dCwgbm9kZVgsIG5vZGVZLCBub2RlVFcsIG5vZGVUSCk7XG4gICAgY29udGV4dC50cmFuc2xhdGUoeCwgeSk7XG4gICAgY29udGV4dC5maWxsKCk7XG4gICAgY29udGV4dC50cmFuc2xhdGUoLXgsIC15KTtcbiAgfVxuXG4gIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBnQWxwaGE7XG5cbiAgaWYgKGlzU21vb3RoaW5nU3dpdGNoZWQpIHtcbiAgICByLnNldEltZ1Ntb290aGluZyhjb250ZXh0LCBzbW9vdGhpbmdFbmFibGVkKTtcbiAgfVxufTtcblxudmFyIENScCQ2ID0ge307XG5cbkNScCQ2LmVsZVRleHRCaWdnZXJUaGFuTWluID0gZnVuY3Rpb24gKGVsZSwgc2NhbGUpIHtcbiAgaWYgKCFzY2FsZSkge1xuICAgIHZhciB6b29tID0gZWxlLmN5KCkuem9vbSgpO1xuICAgIHZhciBweFJhdGlvID0gdGhpcy5nZXRQaXhlbFJhdGlvKCk7XG4gICAgdmFyIGx2bCA9IE1hdGguY2VpbChsb2cyKHpvb20gKiBweFJhdGlvKSk7IC8vIHRoZSBlZmZlY3RpdmUgdGV4dHVyZSBsZXZlbFxuXG4gICAgc2NhbGUgPSBNYXRoLnBvdygyLCBsdmwpO1xuICB9XG5cbiAgdmFyIGNvbXB1dGVkU2l6ZSA9IGVsZS5wc3R5bGUoJ2ZvbnQtc2l6ZScpLnBmVmFsdWUgKiBzY2FsZTtcbiAgdmFyIG1pblNpemUgPSBlbGUucHN0eWxlKCdtaW4tem9vbWVkLWZvbnQtc2l6ZScpLnBmVmFsdWU7XG5cbiAgaWYgKGNvbXB1dGVkU2l6ZSA8IG1pblNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkNScCQ2LmRyYXdFbGVtZW50VGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIHNoaWZ0VG9PcmlnaW5XaXRoQmIsIGZvcmNlLCBwcmVmaXgpIHtcbiAgdmFyIHVzZUVsZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHRydWU7XG4gIHZhciByID0gdGhpcztcblxuICBpZiAoZm9yY2UgPT0gbnVsbCkge1xuICAgIGlmICh1c2VFbGVPcGFjaXR5ICYmICFyLmVsZVRleHRCaWdnZXJUaGFuTWluKGVsZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZm9yY2UgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgIHZhciBsYWJlbCA9IGVsZS5wc3R5bGUoJ2xhYmVsJyk7XG5cbiAgICBpZiAoIWxhYmVsIHx8ICFsYWJlbC52YWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBqdXN0aWZpY2F0aW9uID0gci5nZXRMYWJlbEp1c3RpZmljYXRpb24oZWxlKTtcbiAgICBjb250ZXh0LnRleHRBbGlnbiA9IGp1c3RpZmljYXRpb247XG4gICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgfSBlbHNlIHtcbiAgICB2YXIgYmFkTGluZSA9IGVsZS5lbGVtZW50KCkuX3ByaXZhdGUucnNjcmF0Y2guYmFkTGluZTtcblxuICAgIHZhciBfbGFiZWwgPSBlbGUucHN0eWxlKCdsYWJlbCcpO1xuXG4gICAgdmFyIHNyY0xhYmVsID0gZWxlLnBzdHlsZSgnc291cmNlLWxhYmVsJyk7XG4gICAgdmFyIHRndExhYmVsID0gZWxlLnBzdHlsZSgndGFyZ2V0LWxhYmVsJyk7XG5cbiAgICBpZiAoYmFkTGluZSB8fCAoIV9sYWJlbCB8fCAhX2xhYmVsLnZhbHVlKSAmJiAoIXNyY0xhYmVsIHx8ICFzcmNMYWJlbC52YWx1ZSkgJiYgKCF0Z3RMYWJlbCB8fCAhdGd0TGFiZWwudmFsdWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGV4dC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICB9XG5cbiAgdmFyIGFwcGx5Um90YXRpb24gPSAhc2hpZnRUb09yaWdpbldpdGhCYjtcbiAgdmFyIGJiO1xuXG4gIGlmIChzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gICAgYmIgPSBzaGlmdFRvT3JpZ2luV2l0aEJiO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC1iYi54MSwgLWJiLnkxKTtcbiAgfVxuXG4gIGlmIChwcmVmaXggPT0gbnVsbCkge1xuICAgIHIuZHJhd1RleHQoY29udGV4dCwgZWxlLCBudWxsLCBhcHBseVJvdGF0aW9uLCB1c2VFbGVPcGFjaXR5KTtcblxuICAgIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICAgIHIuZHJhd1RleHQoY29udGV4dCwgZWxlLCAnc291cmNlJywgYXBwbHlSb3RhdGlvbiwgdXNlRWxlT3BhY2l0eSk7XG4gICAgICByLmRyYXdUZXh0KGNvbnRleHQsIGVsZSwgJ3RhcmdldCcsIGFwcGx5Um90YXRpb24sIHVzZUVsZU9wYWNpdHkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByLmRyYXdUZXh0KGNvbnRleHQsIGVsZSwgcHJlZml4LCBhcHBseVJvdGF0aW9uLCB1c2VFbGVPcGFjaXR5KTtcbiAgfVxuXG4gIGlmIChzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gICAgY29udGV4dC50cmFuc2xhdGUoYmIueDEsIGJiLnkxKTtcbiAgfVxufTtcblxuQ1JwJDYuZ2V0Rm9udENhY2hlID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgdmFyIGNhY2hlO1xuICB0aGlzLmZvbnRDYWNoZXMgPSB0aGlzLmZvbnRDYWNoZXMgfHwgW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZvbnRDYWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjYWNoZSA9IHRoaXMuZm9udENhY2hlc1tpXTtcblxuICAgIGlmIChjYWNoZS5jb250ZXh0ID09PSBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gY2FjaGU7XG4gICAgfVxuICB9XG5cbiAgY2FjaGUgPSB7XG4gICAgY29udGV4dDogY29udGV4dFxuICB9O1xuICB0aGlzLmZvbnRDYWNoZXMucHVzaChjYWNoZSk7XG4gIHJldHVybiBjYWNoZTtcbn07IC8vIHNldCB1cCBjYW52YXMgY29udGV4dCB3aXRoIGZvbnRcbi8vIHJldHVybnMgdHJhbnNmb3JtZWQgdGV4dCBzdHJpbmdcblxuXG5DUnAkNi5zZXR1cFRleHRTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUpIHtcbiAgdmFyIHVzZUVsZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gIC8vIEZvbnQgc3R5bGVcbiAgdmFyIGxhYmVsU3R5bGUgPSBlbGUucHN0eWxlKCdmb250LXN0eWxlJykuc3RyVmFsdWU7XG4gIHZhciBsYWJlbFNpemUgPSBlbGUucHN0eWxlKCdmb250LXNpemUnKS5wZlZhbHVlICsgJ3B4JztcbiAgdmFyIGxhYmVsRmFtaWx5ID0gZWxlLnBzdHlsZSgnZm9udC1mYW1pbHknKS5zdHJWYWx1ZTtcbiAgdmFyIGxhYmVsV2VpZ2h0ID0gZWxlLnBzdHlsZSgnZm9udC13ZWlnaHQnKS5zdHJWYWx1ZTtcbiAgdmFyIG9wYWNpdHkgPSB1c2VFbGVPcGFjaXR5ID8gZWxlLmVmZmVjdGl2ZU9wYWNpdHkoKSAqIGVsZS5wc3R5bGUoJ3RleHQtb3BhY2l0eScpLnZhbHVlIDogMTtcbiAgdmFyIG91dGxpbmVPcGFjaXR5ID0gZWxlLnBzdHlsZSgndGV4dC1vdXRsaW5lLW9wYWNpdHknKS52YWx1ZSAqIG9wYWNpdHk7XG4gIHZhciBjb2xvciA9IGVsZS5wc3R5bGUoJ2NvbG9yJykudmFsdWU7XG4gIHZhciBvdXRsaW5lQ29sb3IgPSBlbGUucHN0eWxlKCd0ZXh0LW91dGxpbmUtY29sb3InKS52YWx1ZTtcbiAgY29udGV4dC5mb250ID0gbGFiZWxTdHlsZSArICcgJyArIGxhYmVsV2VpZ2h0ICsgJyAnICsgbGFiZWxTaXplICsgJyAnICsgbGFiZWxGYW1pbHk7XG4gIGNvbnRleHQubGluZUpvaW4gPSAncm91bmQnOyAvLyBzbyB0ZXh0IG91dGxpbmVzIGFyZW4ndCBqYWdnZWRcblxuICB0aGlzLmNvbG9yRmlsbFN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkpO1xuICB0aGlzLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgb3V0bGluZUNvbG9yWzBdLCBvdXRsaW5lQ29sb3JbMV0sIG91dGxpbmVDb2xvclsyXSwgb3V0bGluZU9wYWNpdHkpO1xufTsgLy8gVE9ETyBlbnN1cmUgcmUtdXNlZFxuXG5cbmZ1bmN0aW9uIHJvdW5kUmVjdChjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIHJhZGl1cyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogNTtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgubW92ZVRvKHggKyByYWRpdXMsIHkpO1xuICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHJhZGl1cywgeSk7XG4gIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzKTtcbiAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJhZGl1cywgeSArIGhlaWdodCk7XG4gIGN0eC5saW5lVG8oeCArIHJhZGl1cywgeSArIGhlaWdodCk7XG4gIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICBjdHgubGluZVRvKHgsIHkgKyByYWRpdXMpO1xuICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcmFkaXVzLCB5KTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguZmlsbCgpO1xufVxuXG5DUnAkNi5nZXRUZXh0QW5nbGUgPSBmdW5jdGlvbiAoZWxlLCBwcmVmaXgpIHtcbiAgdmFyIHRoZXRhO1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciByc2NyYXRjaCA9IF9wLnJzY3JhdGNoO1xuICB2YXIgcGRhc2ggPSBwcmVmaXggPyBwcmVmaXggKyAnLScgOiAnJztcbiAgdmFyIHJvdGF0aW9uID0gZWxlLnBzdHlsZShwZGFzaCArICd0ZXh0LXJvdGF0aW9uJyk7XG4gIHZhciB0ZXh0QW5nbGUgPSBnZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxBbmdsZScsIHByZWZpeCk7XG5cbiAgaWYgKHJvdGF0aW9uLnN0clZhbHVlID09PSAnYXV0b3JvdGF0ZScpIHtcbiAgICB0aGV0YSA9IGVsZS5pc0VkZ2UoKSA/IHRleHRBbmdsZSA6IDA7XG4gIH0gZWxzZSBpZiAocm90YXRpb24uc3RyVmFsdWUgPT09ICdub25lJykge1xuICAgIHRoZXRhID0gMDtcbiAgfSBlbHNlIHtcbiAgICB0aGV0YSA9IHJvdGF0aW9uLnBmVmFsdWU7XG4gIH1cblxuICByZXR1cm4gdGhldGE7XG59O1xuXG5DUnAkNi5kcmF3VGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIHByZWZpeCkge1xuICB2YXIgYXBwbHlSb3RhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcbiAgdmFyIHVzZUVsZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRydWU7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHJzY3JhdGNoID0gX3AucnNjcmF0Y2g7XG4gIHZhciBwYXJlbnRPcGFjaXR5ID0gdXNlRWxlT3BhY2l0eSA/IGVsZS5lZmZlY3RpdmVPcGFjaXR5KCkgOiAxO1xuXG4gIGlmICh1c2VFbGVPcGFjaXR5ICYmIChwYXJlbnRPcGFjaXR5ID09PSAwIHx8IGVsZS5wc3R5bGUoJ3RleHQtb3BhY2l0eScpLnZhbHVlID09PSAwKSkge1xuICAgIHJldHVybjtcbiAgfSAvLyB1c2UgJ21haW4nIGFzIGFuIGFsaWFzIGZvciB0aGUgbWFpbiBsYWJlbCAoaS5lLiBudWxsIHByZWZpeClcblxuXG4gIGlmIChwcmVmaXggPT09ICdtYWluJykge1xuICAgIHByZWZpeCA9IG51bGw7XG4gIH1cblxuICB2YXIgdGV4dFggPSBnZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxYJywgcHJlZml4KTtcbiAgdmFyIHRleHRZID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShyc2NyYXRjaCwgJ2xhYmVsWScsIHByZWZpeCk7XG4gIHZhciBvcmdUZXh0WCwgb3JnVGV4dFk7IC8vIHVzZWQgZm9yIHJvdGF0aW9uXG5cbiAgdmFyIHRleHQgPSB0aGlzLmdldExhYmVsVGV4dChlbGUsIHByZWZpeCk7XG5cbiAgaWYgKHRleHQgIT0gbnVsbCAmJiB0ZXh0ICE9PSAnJyAmJiAhaXNOYU4odGV4dFgpICYmICFpc05hTih0ZXh0WSkpIHtcbiAgICB0aGlzLnNldHVwVGV4dFN0eWxlKGNvbnRleHQsIGVsZSwgdXNlRWxlT3BhY2l0eSk7XG4gICAgdmFyIHBkYXNoID0gcHJlZml4ID8gcHJlZml4ICsgJy0nIDogJyc7XG4gICAgdmFyIHRleHRXID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShyc2NyYXRjaCwgJ2xhYmVsV2lkdGgnLCBwcmVmaXgpO1xuICAgIHZhciB0ZXh0SCA9IGdldFByZWZpeGVkUHJvcGVydHkocnNjcmF0Y2gsICdsYWJlbEhlaWdodCcsIHByZWZpeCk7XG4gICAgdmFyIG1hcmdpblggPSBlbGUucHN0eWxlKHBkYXNoICsgJ3RleHQtbWFyZ2luLXgnKS5wZlZhbHVlO1xuICAgIHZhciBtYXJnaW5ZID0gZWxlLnBzdHlsZShwZGFzaCArICd0ZXh0LW1hcmdpbi15JykucGZWYWx1ZTtcbiAgICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICAgIHZhciBoYWxpZ24gPSBlbGUucHN0eWxlKCd0ZXh0LWhhbGlnbicpLnZhbHVlO1xuICAgIHZhciB2YWxpZ24gPSBlbGUucHN0eWxlKCd0ZXh0LXZhbGlnbicpLnZhbHVlO1xuXG4gICAgaWYgKGlzRWRnZSkge1xuICAgICAgaGFsaWduID0gJ2NlbnRlcic7XG4gICAgICB2YWxpZ24gPSAnY2VudGVyJztcbiAgICB9XG5cbiAgICB0ZXh0WCArPSBtYXJnaW5YO1xuICAgIHRleHRZICs9IG1hcmdpblk7XG4gICAgdmFyIHRoZXRhO1xuXG4gICAgaWYgKCFhcHBseVJvdGF0aW9uKSB7XG4gICAgICB0aGV0YSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoZXRhID0gdGhpcy5nZXRUZXh0QW5nbGUoZWxlLCBwcmVmaXgpO1xuICAgIH1cblxuICAgIGlmICh0aGV0YSAhPT0gMCkge1xuICAgICAgb3JnVGV4dFggPSB0ZXh0WDtcbiAgICAgIG9yZ1RleHRZID0gdGV4dFk7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZShvcmdUZXh0WCwgb3JnVGV4dFkpO1xuICAgICAgY29udGV4dC5yb3RhdGUodGhldGEpO1xuICAgICAgdGV4dFggPSAwO1xuICAgICAgdGV4dFkgPSAwO1xuICAgIH1cblxuICAgIHN3aXRjaCAodmFsaWduKSB7XG4gICAgICBjYXNlICd0b3AnOlxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgdGV4dFkgKz0gdGV4dEggLyAyO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgdGV4dFkgKz0gdGV4dEg7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBiYWNrZ3JvdW5kT3BhY2l0eSA9IGVsZS5wc3R5bGUoJ3RleHQtYmFja2dyb3VuZC1vcGFjaXR5JykudmFsdWU7XG4gICAgdmFyIGJvcmRlck9wYWNpdHkgPSBlbGUucHN0eWxlKCd0ZXh0LWJvcmRlci1vcGFjaXR5JykudmFsdWU7XG4gICAgdmFyIHRleHRCb3JkZXJXaWR0aCA9IGVsZS5wc3R5bGUoJ3RleHQtYm9yZGVyLXdpZHRoJykucGZWYWx1ZTtcbiAgICB2YXIgYmFja2dyb3VuZFBhZGRpbmcgPSBlbGUucHN0eWxlKCd0ZXh0LWJhY2tncm91bmQtcGFkZGluZycpLnBmVmFsdWU7XG5cbiAgICBpZiAoYmFja2dyb3VuZE9wYWNpdHkgPiAwIHx8IHRleHRCb3JkZXJXaWR0aCA+IDAgJiYgYm9yZGVyT3BhY2l0eSA+IDApIHtcbiAgICAgIHZhciBiZ1ggPSB0ZXh0WCAtIGJhY2tncm91bmRQYWRkaW5nO1xuXG4gICAgICBzd2l0Y2ggKGhhbGlnbikge1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICBiZ1ggLT0gdGV4dFc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICBiZ1ggLT0gdGV4dFcgLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmdZID0gdGV4dFkgLSB0ZXh0SCAtIGJhY2tncm91bmRQYWRkaW5nO1xuICAgICAgdmFyIGJnVyA9IHRleHRXICsgMiAqIGJhY2tncm91bmRQYWRkaW5nO1xuICAgICAgdmFyIGJnSCA9IHRleHRIICsgMiAqIGJhY2tncm91bmRQYWRkaW5nO1xuXG4gICAgICBpZiAoYmFja2dyb3VuZE9wYWNpdHkgPiAwKSB7XG4gICAgICAgIHZhciB0ZXh0RmlsbCA9IGNvbnRleHQuZmlsbFN0eWxlO1xuICAgICAgICB2YXIgdGV4dEJhY2tncm91bmRDb2xvciA9IGVsZS5wc3R5bGUoJ3RleHQtYmFja2dyb3VuZC1jb2xvcicpLnZhbHVlO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyB0ZXh0QmFja2dyb3VuZENvbG9yWzBdICsgJywnICsgdGV4dEJhY2tncm91bmRDb2xvclsxXSArICcsJyArIHRleHRCYWNrZ3JvdW5kQ29sb3JbMl0gKyAnLCcgKyBiYWNrZ3JvdW5kT3BhY2l0eSAqIHBhcmVudE9wYWNpdHkgKyAnKSc7XG4gICAgICAgIHZhciBzdHlsZVNoYXBlID0gZWxlLnBzdHlsZSgndGV4dC1iYWNrZ3JvdW5kLXNoYXBlJykuc3RyVmFsdWU7XG5cbiAgICAgICAgaWYgKHN0eWxlU2hhcGUuaW5kZXhPZigncm91bmQnKSA9PT0gMCkge1xuICAgICAgICAgIHJvdW5kUmVjdChjb250ZXh0LCBiZ1gsIGJnWSwgYmdXLCBiZ0gsIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QoYmdYLCBiZ1ksIGJnVywgYmdIKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGV4dEZpbGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0Qm9yZGVyV2lkdGggPiAwICYmIGJvcmRlck9wYWNpdHkgPiAwKSB7XG4gICAgICAgIHZhciB0ZXh0U3Ryb2tlID0gY29udGV4dC5zdHJva2VTdHlsZTtcbiAgICAgICAgdmFyIHRleHRMaW5lV2lkdGggPSBjb250ZXh0LmxpbmVXaWR0aDtcbiAgICAgICAgdmFyIHRleHRCb3JkZXJDb2xvciA9IGVsZS5wc3R5bGUoJ3RleHQtYm9yZGVyLWNvbG9yJykudmFsdWU7XG4gICAgICAgIHZhciB0ZXh0Qm9yZGVyU3R5bGUgPSBlbGUucHN0eWxlKCd0ZXh0LWJvcmRlci1zdHlsZScpLnZhbHVlO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYmEoJyArIHRleHRCb3JkZXJDb2xvclswXSArICcsJyArIHRleHRCb3JkZXJDb2xvclsxXSArICcsJyArIHRleHRCb3JkZXJDb2xvclsyXSArICcsJyArIGJvcmRlck9wYWNpdHkgKiBwYXJlbnRPcGFjaXR5ICsgJyknO1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHRleHRCb3JkZXJXaWR0aDtcblxuICAgICAgICBpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuICAgICAgICAgIC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgICAgIHN3aXRjaCAodGV4dEJvcmRlclN0eWxlKSB7XG4gICAgICAgICAgICBjYXNlICdkb3R0ZWQnOlxuICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsxLCAxXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdkYXNoZWQnOlxuICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFs0LCAyXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHRleHRCb3JkZXJXaWR0aCAvIDQ7IC8vIDUwJSByZXNlcnZlZCBmb3Igd2hpdGUgYmV0d2VlbiB0aGUgdHdvIGJvcmRlcnNcblxuICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3NvbGlkJzpcbiAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdChiZ1gsIGJnWSwgYmdXLCBiZ0gpO1xuXG4gICAgICAgIGlmICh0ZXh0Qm9yZGVyU3R5bGUgPT09ICdkb3VibGUnKSB7XG4gICAgICAgICAgdmFyIHdoaXRlV2lkdGggPSB0ZXh0Qm9yZGVyV2lkdGggLyAyO1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdChiZ1ggKyB3aGl0ZVdpZHRoLCBiZ1kgKyB3aGl0ZVdpZHRoLCBiZ1cgLSB3aGl0ZVdpZHRoICogMiwgYmdIIC0gd2hpdGVXaWR0aCAqIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQuc2V0TGluZURhc2gpIHtcbiAgICAgICAgICAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gdGV4dExpbmVXaWR0aDtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHRleHRTdHJva2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxpbmVXaWR0aCA9IDIgKiBlbGUucHN0eWxlKCd0ZXh0LW91dGxpbmUtd2lkdGgnKS5wZlZhbHVlOyAvLyAqMiBiL2MgdGhlIHN0cm9rZSBpcyBkcmF3biBjZW50cmVkIG9uIHRoZSBtaWRkbGVcblxuICAgIGlmIChsaW5lV2lkdGggPiAwKSB7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICB9XG5cbiAgICBpZiAoZWxlLnBzdHlsZSgndGV4dC13cmFwJykudmFsdWUgPT09ICd3cmFwJykge1xuICAgICAgdmFyIGxpbmVzID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShyc2NyYXRjaCwgJ2xhYmVsV3JhcENhY2hlZExpbmVzJywgcHJlZml4KTtcbiAgICAgIHZhciBsaW5lSGVpZ2h0ID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShyc2NyYXRjaCwgJ2xhYmVsTGluZUhlaWdodCcsIHByZWZpeCk7XG4gICAgICB2YXIgaGFsZlRleHRXID0gdGV4dFcgLyAyO1xuICAgICAgdmFyIGp1c3RpZmljYXRpb24gPSB0aGlzLmdldExhYmVsSnVzdGlmaWNhdGlvbihlbGUpO1xuXG4gICAgICBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ2F1dG8nKSA7IGVsc2UgaWYgKGhhbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIC8vIGF1dG8ganVzdGlmaWNhdGlvbiA6IHJpZ2h0XG4gICAgICAgIGlmIChqdXN0aWZpY2F0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICB0ZXh0WCArPSAtdGV4dFc7XG4gICAgICAgIH0gZWxzZSBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0WCArPSAtaGFsZlRleHRXO1xuICAgICAgICB9IC8vIGVsc2Ugc2FtZSBhcyBhdXRvXG5cbiAgICAgIH0gZWxzZSBpZiAoaGFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAvLyBhdXRvIGp1c3RmaWNhdGlvbiA6IGNlbnRlclxuICAgICAgICBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgdGV4dFggKz0gLWhhbGZUZXh0VztcbiAgICAgICAgfSBlbHNlIGlmIChqdXN0aWZpY2F0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgdGV4dFggKz0gaGFsZlRleHRXO1xuICAgICAgICB9IC8vIGVsc2Ugc2FtZSBhcyBhdXRvXG5cbiAgICAgIH0gZWxzZSBpZiAoaGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIC8vIGF1dG8ganVzdGlmaWNhdGlvbiA6IGxlZnRcbiAgICAgICAgaWYgKGp1c3RpZmljYXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dFggKz0gaGFsZlRleHRXO1xuICAgICAgICB9IGVsc2UgaWYgKGp1c3RpZmljYXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICB0ZXh0WCArPSB0ZXh0VztcbiAgICAgICAgfSAvLyBlbHNlIHNhbWUgYXMgYXV0b1xuXG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAodmFsaWduKSB7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgdGV4dFkgLT0gKGxpbmVzLmxlbmd0aCAtIDEpICogbGluZUhlaWdodDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIHRleHRZIC09IChsaW5lcy5sZW5ndGggLSAxKSAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbGluZXMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgaWYgKGxpbmVXaWR0aCA+IDApIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQobGluZXNbbF0sIHRleHRYLCB0ZXh0WSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KGxpbmVzW2xdLCB0ZXh0WCwgdGV4dFkpO1xuICAgICAgICB0ZXh0WSArPSBsaW5lSGVpZ2h0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobGluZVdpZHRoID4gMCkge1xuICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQodGV4dCwgdGV4dFgsIHRleHRZKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5maWxsVGV4dCh0ZXh0LCB0ZXh0WCwgdGV4dFkpO1xuICAgIH1cblxuICAgIGlmICh0aGV0YSAhPT0gMCkge1xuICAgICAgY29udGV4dC5yb3RhdGUoLXRoZXRhKTtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKC1vcmdUZXh0WCwgLW9yZ1RleHRZKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qIGdsb2JhbCBQYXRoMkQgKi9cbnZhciBDUnAkNSA9IHt9O1xuXG5DUnAkNS5kcmF3Tm9kZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBub2RlLCBzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gIHZhciBkcmF3TGFiZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHRydWU7XG4gIHZhciBzaG91bGREcmF3T3ZlcmxheSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogdHJ1ZTtcbiAgdmFyIHNob3VsZERyYXdPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB0cnVlO1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBub2RlV2lkdGgsIG5vZGVIZWlnaHQ7XG4gIHZhciBfcCA9IG5vZGUuX3ByaXZhdGU7XG4gIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICB2YXIgcG9zID0gbm9kZS5wb3NpdGlvbigpO1xuXG4gIGlmICghbnVtYmVyJDEocG9zLngpIHx8ICFudW1iZXIkMShwb3MueSkpIHtcbiAgICByZXR1cm47IC8vIGNhbid0IGRyYXcgbm9kZSB3aXRoIHVuZGVmaW5lZCBwb3NpdGlvblxuICB9XG5cbiAgaWYgKHNob3VsZERyYXdPcGFjaXR5ICYmICFub2RlLnZpc2libGUoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBlbGVPcGFjaXR5ID0gc2hvdWxkRHJhd09wYWNpdHkgPyBub2RlLmVmZmVjdGl2ZU9wYWNpdHkoKSA6IDE7XG4gIHZhciB1c2VQYXRocyA9IHIudXNlUGF0aHMoKTtcbiAgdmFyIHBhdGg7XG4gIHZhciBwYXRoQ2FjaGVIaXQgPSBmYWxzZTtcbiAgdmFyIHBhZGRpbmcgPSBub2RlLnBhZGRpbmcoKTtcbiAgbm9kZVdpZHRoID0gbm9kZS53aWR0aCgpICsgMiAqIHBhZGRpbmc7XG4gIG5vZGVIZWlnaHQgPSBub2RlLmhlaWdodCgpICsgMiAqIHBhZGRpbmc7IC8vXG4gIC8vIHNldHVwIHNoaWZ0XG5cbiAgdmFyIGJiO1xuXG4gIGlmIChzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gICAgYmIgPSBzaGlmdFRvT3JpZ2luV2l0aEJiO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC1iYi54MSwgLWJiLnkxKTtcbiAgfSAvL1xuICAvLyBsb2FkIGJnIGltYWdlXG5cblxuICB2YXIgYmdJbWdQcm9wID0gbm9kZS5wc3R5bGUoJ2JhY2tncm91bmQtaW1hZ2UnKTtcbiAgdmFyIHVybHMgPSBiZ0ltZ1Byb3AudmFsdWU7XG4gIHZhciB1cmxEZWZpbmVkID0gbmV3IEFycmF5KHVybHMubGVuZ3RoKTtcbiAgdmFyIGltYWdlID0gbmV3IEFycmF5KHVybHMubGVuZ3RoKTtcbiAgdmFyIG51bUltYWdlcyA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cmxzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHVybCA9IHVybHNbaV07XG4gICAgdmFyIGRlZmQgPSB1cmxEZWZpbmVkW2ldID0gdXJsICE9IG51bGwgJiYgdXJsICE9PSAnbm9uZSc7XG5cbiAgICBpZiAoZGVmZCkge1xuICAgICAgdmFyIGJnSW1nQ3Jvc3NPcmlnaW4gPSBub2RlLmN5KCkuc3R5bGUoKS5nZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaW1hZ2UtY3Jvc3NvcmlnaW4nLCAndmFsdWUnLCBpKTtcbiAgICAgIG51bUltYWdlcysrOyAvLyBnZXQgaW1hZ2UsIGFuZCBpZiBub3QgbG9hZGVkIHRoZW4gYXNrIHRvIHJlZHJhdyB3aGVuIGxhdGVyIGxvYWRlZFxuXG4gICAgICBpbWFnZVtpXSA9IHIuZ2V0Q2FjaGVkSW1hZ2UodXJsLCBiZ0ltZ0Nyb3NzT3JpZ2luLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9wLmJhY2tncm91bmRUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICBub2RlLmVtaXRBbmROb3RpZnkoJ2JhY2tncm91bmQnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSAvL1xuICAvLyBzZXR1cCBzdHlsZXNcblxuXG4gIHZhciBkYXJrbmVzcyA9IG5vZGUucHN0eWxlKCdiYWNrZ3JvdW5kLWJsYWNrZW4nKS52YWx1ZTtcbiAgdmFyIGJvcmRlcldpZHRoID0gbm9kZS5wc3R5bGUoJ2JvcmRlci13aWR0aCcpLnBmVmFsdWU7XG4gIHZhciBiZ09wYWNpdHkgPSBub2RlLnBzdHlsZSgnYmFja2dyb3VuZC1vcGFjaXR5JykudmFsdWUgKiBlbGVPcGFjaXR5O1xuICB2YXIgYm9yZGVyQ29sb3IgPSBub2RlLnBzdHlsZSgnYm9yZGVyLWNvbG9yJykudmFsdWU7XG4gIHZhciBib3JkZXJTdHlsZSA9IG5vZGUucHN0eWxlKCdib3JkZXItc3R5bGUnKS52YWx1ZTtcbiAgdmFyIGJvcmRlck9wYWNpdHkgPSBub2RlLnBzdHlsZSgnYm9yZGVyLW9wYWNpdHknKS52YWx1ZSAqIGVsZU9wYWNpdHk7XG4gIGNvbnRleHQubGluZUpvaW4gPSAnbWl0ZXInOyAvLyBzbyBib3JkZXJzIGFyZSBzcXVhcmUgd2l0aCB0aGUgbm9kZSBzaGFwZVxuXG4gIHZhciBzZXR1cFNoYXBlQ29sb3IgPSBmdW5jdGlvbiBzZXR1cFNoYXBlQ29sb3IoKSB7XG4gICAgdmFyIGJnT3B5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBiZ09wYWNpdHk7XG4gICAgci5lbGVGaWxsU3R5bGUoY29udGV4dCwgbm9kZSwgYmdPcHkpO1xuICB9O1xuXG4gIHZhciBzZXR1cEJvcmRlckNvbG9yID0gZnVuY3Rpb24gc2V0dXBCb3JkZXJDb2xvcigpIHtcbiAgICB2YXIgYmRyT3B5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBib3JkZXJPcGFjaXR5O1xuICAgIHIuY29sb3JTdHJva2VTdHlsZShjb250ZXh0LCBib3JkZXJDb2xvclswXSwgYm9yZGVyQ29sb3JbMV0sIGJvcmRlckNvbG9yWzJdLCBiZHJPcHkpO1xuICB9OyAvL1xuICAvLyBzZXR1cCBzaGFwZVxuXG5cbiAgdmFyIHN0eWxlU2hhcGUgPSBub2RlLnBzdHlsZSgnc2hhcGUnKS5zdHJWYWx1ZTtcbiAgdmFyIHNoYXBlUHRzID0gbm9kZS5wc3R5bGUoJ3NoYXBlLXBvbHlnb24tcG9pbnRzJykucGZWYWx1ZTtcblxuICBpZiAodXNlUGF0aHMpIHtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShwb3MueCwgcG9zLnkpO1xuICAgIHZhciBwYXRoQ2FjaGUgPSByLm5vZGVQYXRoQ2FjaGUgPSByLm5vZGVQYXRoQ2FjaGUgfHwgW107XG4gICAgdmFyIGtleSA9IGhhc2hTdHJpbmdzKHN0eWxlU2hhcGUgPT09ICdwb2x5Z29uJyA/IHN0eWxlU2hhcGUgKyAnLCcgKyBzaGFwZVB0cy5qb2luKCcsJykgOiBzdHlsZVNoYXBlLCAnJyArIG5vZGVIZWlnaHQsICcnICsgbm9kZVdpZHRoKTtcbiAgICB2YXIgY2FjaGVkUGF0aCA9IHBhdGhDYWNoZVtrZXldO1xuXG4gICAgaWYgKGNhY2hlZFBhdGggIT0gbnVsbCkge1xuICAgICAgcGF0aCA9IGNhY2hlZFBhdGg7XG4gICAgICBwYXRoQ2FjaGVIaXQgPSB0cnVlO1xuICAgICAgcnMucGF0aENhY2hlID0gcGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgIHBhdGhDYWNoZVtrZXldID0gcnMucGF0aENhY2hlID0gcGF0aDtcbiAgICB9XG4gIH1cblxuICB2YXIgZHJhd1NoYXBlID0gZnVuY3Rpb24gZHJhd1NoYXBlKCkge1xuICAgIGlmICghcGF0aENhY2hlSGl0KSB7XG4gICAgICB2YXIgbnBvcyA9IHBvcztcblxuICAgICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAgIG5wb3MgPSB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHIubm9kZVNoYXBlc1tyLmdldE5vZGVTaGFwZShub2RlKV0uZHJhdyhwYXRoIHx8IGNvbnRleHQsIG5wb3MueCwgbnBvcy55LCBub2RlV2lkdGgsIG5vZGVIZWlnaHQpO1xuICAgIH1cblxuICAgIGlmICh1c2VQYXRocykge1xuICAgICAgY29udGV4dC5maWxsKHBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGRyYXdJbWFnZXMgPSBmdW5jdGlvbiBkcmF3SW1hZ2VzKCkge1xuICAgIHZhciBub2RlT3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZWxlT3BhY2l0eTtcbiAgICB2YXIgaW5zaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgIHZhciBwcmV2QmdpbmcgPSBfcC5iYWNrZ3JvdW5kaW5nO1xuICAgIHZhciB0b3RhbENvbXBsZXRlZCA9IDA7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgaW1hZ2UubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgYmdDb250YWlubWVudCA9IG5vZGUuY3koKS5zdHlsZSgpLmdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1pbWFnZS1jb250YWlubWVudCcsICd2YWx1ZScsIF9pKTtcblxuICAgICAgaWYgKGluc2lkZSAmJiBiZ0NvbnRhaW5tZW50ID09PSAnb3ZlcicgfHwgIWluc2lkZSAmJiBiZ0NvbnRhaW5tZW50ID09PSAnaW5zaWRlJykge1xuICAgICAgICB0b3RhbENvbXBsZXRlZCsrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHVybERlZmluZWRbX2ldICYmIGltYWdlW19pXS5jb21wbGV0ZSAmJiAhaW1hZ2VbX2ldLmVycm9yKSB7XG4gICAgICAgIHRvdGFsQ29tcGxldGVkKys7XG4gICAgICAgIHIuZHJhd0luc2NyaWJlZEltYWdlKGNvbnRleHQsIGltYWdlW19pXSwgbm9kZSwgX2ksIG5vZGVPcGFjaXR5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfcC5iYWNrZ3JvdW5kaW5nID0gISh0b3RhbENvbXBsZXRlZCA9PT0gbnVtSW1hZ2VzKTtcblxuICAgIGlmIChwcmV2QmdpbmcgIT09IF9wLmJhY2tncm91bmRpbmcpIHtcbiAgICAgIC8vIHVwZGF0ZSBzdHlsZSBiL2MgOmJhY2tncm91bmRpbmcgc3RhdGUgY2hhbmdlZFxuICAgICAgbm9kZS51cGRhdGVTdHlsZShmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBkcmF3UGllID0gZnVuY3Rpb24gZHJhd1BpZSgpIHtcbiAgICB2YXIgcmVkcmF3U2hhcGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIHZhciBwaWVPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBlbGVPcGFjaXR5O1xuXG4gICAgaWYgKHIuaGFzUGllKG5vZGUpKSB7XG4gICAgICByLmRyYXdQaWUoY29udGV4dCwgbm9kZSwgcGllT3BhY2l0eSk7IC8vIHJlZHJhdy9yZXN0b3JlIHBhdGggaWYgc3RlcHMgYWZ0ZXIgcGllIG5lZWQgaXRcblxuICAgICAgaWYgKHJlZHJhd1NoYXBlKSB7XG4gICAgICAgIGlmICghdXNlUGF0aHMpIHtcbiAgICAgICAgICByLm5vZGVTaGFwZXNbci5nZXROb2RlU2hhcGUobm9kZSldLmRyYXcoY29udGV4dCwgcG9zLngsIHBvcy55LCBub2RlV2lkdGgsIG5vZGVIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBkYXJrZW4gPSBmdW5jdGlvbiBkYXJrZW4oKSB7XG4gICAgdmFyIGRhcmtlbk9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGVsZU9wYWNpdHk7XG4gICAgdmFyIG9wYWNpdHkgPSAoZGFya25lc3MgPiAwID8gZGFya25lc3MgOiAtZGFya25lc3MpICogZGFya2VuT3BhY2l0eTtcbiAgICB2YXIgYyA9IGRhcmtuZXNzID4gMCA/IDAgOiAyNTU7XG5cbiAgICBpZiAoZGFya25lc3MgIT09IDApIHtcbiAgICAgIHIuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgYywgYywgYywgb3BhY2l0eSk7XG5cbiAgICAgIGlmICh1c2VQYXRocykge1xuICAgICAgICBjb250ZXh0LmZpbGwocGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGRyYXdCb3JkZXIgPSBmdW5jdGlvbiBkcmF3Qm9yZGVyKCkge1xuICAgIGlmIChib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSAnYnV0dCc7XG5cbiAgICAgIGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgICAgIC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgICBzd2l0Y2ggKGJvcmRlclN0eWxlKSB7XG4gICAgICAgICAgY2FzZSAnZG90dGVkJzpcbiAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWzEsIDFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZGFzaGVkJzpcbiAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWzQsIDJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnc29saWQnOlxuICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh1c2VQYXRocykge1xuICAgICAgICBjb250ZXh0LnN0cm9rZShwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChib3JkZXJTdHlsZSA9PT0gJ2RvdWJsZScpIHtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBib3JkZXJXaWR0aCAvIDM7XG4gICAgICAgIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcblxuICAgICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZShwYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBnY287XG4gICAgICB9IC8vIHJlc2V0IGluIGNhc2Ugd2UgY2hhbmdlZCB0aGUgYm9yZGVyIHN0eWxlXG5cblxuICAgICAgaWYgKGNvbnRleHQuc2V0TGluZURhc2gpIHtcbiAgICAgICAgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgZHJhd092ZXJsYXkgPSBmdW5jdGlvbiBkcmF3T3ZlcmxheSgpIHtcbiAgICBpZiAoc2hvdWxkRHJhd092ZXJsYXkpIHtcbiAgICAgIHIuZHJhd05vZGVPdmVybGF5KGNvbnRleHQsIG5vZGUsIHBvcywgbm9kZVdpZHRoLCBub2RlSGVpZ2h0KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGRyYXdVbmRlcmxheSA9IGZ1bmN0aW9uIGRyYXdVbmRlcmxheSgpIHtcbiAgICBpZiAoc2hvdWxkRHJhd092ZXJsYXkpIHtcbiAgICAgIHIuZHJhd05vZGVVbmRlcmxheShjb250ZXh0LCBub2RlLCBwb3MsIG5vZGVXaWR0aCwgbm9kZUhlaWdodCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBkcmF3VGV4dCA9IGZ1bmN0aW9uIGRyYXdUZXh0KCkge1xuICAgIHIuZHJhd0VsZW1lbnRUZXh0KGNvbnRleHQsIG5vZGUsIG51bGwsIGRyYXdMYWJlbCk7XG4gIH07XG5cbiAgdmFyIGdob3N0ID0gbm9kZS5wc3R5bGUoJ2dob3N0JykudmFsdWUgPT09ICd5ZXMnO1xuXG4gIGlmIChnaG9zdCkge1xuICAgIHZhciBneCA9IG5vZGUucHN0eWxlKCdnaG9zdC1vZmZzZXQteCcpLnBmVmFsdWU7XG4gICAgdmFyIGd5ID0gbm9kZS5wc3R5bGUoJ2dob3N0LW9mZnNldC15JykucGZWYWx1ZTtcbiAgICB2YXIgZ2hvc3RPcGFjaXR5ID0gbm9kZS5wc3R5bGUoJ2dob3N0LW9wYWNpdHknKS52YWx1ZTtcbiAgICB2YXIgZWZmR2hvc3RPcGFjaXR5ID0gZ2hvc3RPcGFjaXR5ICogZWxlT3BhY2l0eTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShneCwgZ3kpO1xuICAgIHNldHVwU2hhcGVDb2xvcihnaG9zdE9wYWNpdHkgKiBiZ09wYWNpdHkpO1xuICAgIGRyYXdTaGFwZSgpO1xuICAgIGRyYXdJbWFnZXMoZWZmR2hvc3RPcGFjaXR5LCB0cnVlKTtcbiAgICBzZXR1cEJvcmRlckNvbG9yKGdob3N0T3BhY2l0eSAqIGJvcmRlck9wYWNpdHkpO1xuICAgIGRyYXdCb3JkZXIoKTtcbiAgICBkcmF3UGllKGRhcmtuZXNzICE9PSAwIHx8IGJvcmRlcldpZHRoICE9PSAwKTtcbiAgICBkcmF3SW1hZ2VzKGVmZkdob3N0T3BhY2l0eSwgZmFsc2UpO1xuICAgIGRhcmtlbihlZmZHaG9zdE9wYWNpdHkpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC1neCwgLWd5KTtcbiAgfVxuXG4gIGlmICh1c2VQYXRocykge1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC1wb3MueCwgLXBvcy55KTtcbiAgfVxuXG4gIGRyYXdVbmRlcmxheSgpO1xuXG4gIGlmICh1c2VQYXRocykge1xuICAgIGNvbnRleHQudHJhbnNsYXRlKHBvcy54LCBwb3MueSk7XG4gIH1cblxuICBzZXR1cFNoYXBlQ29sb3IoKTtcbiAgZHJhd1NoYXBlKCk7XG4gIGRyYXdJbWFnZXMoZWxlT3BhY2l0eSwgdHJ1ZSk7XG4gIHNldHVwQm9yZGVyQ29sb3IoKTtcbiAgZHJhd0JvcmRlcigpO1xuICBkcmF3UGllKGRhcmtuZXNzICE9PSAwIHx8IGJvcmRlcldpZHRoICE9PSAwKTtcbiAgZHJhd0ltYWdlcyhlbGVPcGFjaXR5LCBmYWxzZSk7XG4gIGRhcmtlbigpO1xuXG4gIGlmICh1c2VQYXRocykge1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC1wb3MueCwgLXBvcy55KTtcbiAgfVxuXG4gIGRyYXdUZXh0KCk7XG4gIGRyYXdPdmVybGF5KCk7IC8vXG4gIC8vIGNsZWFuIHVwIHNoaWZ0XG5cbiAgaWYgKHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShiYi54MSwgYmIueTEpO1xuICB9XG59O1xuXG52YXIgZHJhd05vZGVPdmVybGF5VW5kZXJsYXkgPSBmdW5jdGlvbiBkcmF3Tm9kZU92ZXJsYXlVbmRlcmxheShvdmVybGF5T3JVbmRlcmxheSkge1xuICBpZiAoIVsnb3ZlcmxheScsICd1bmRlcmxheSddLmluY2x1ZGVzKG92ZXJsYXlPclVuZGVybGF5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZScpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0LCBub2RlLCBwb3MsIG5vZGVXaWR0aCwgbm9kZUhlaWdodCkge1xuICAgIHZhciByID0gdGhpcztcblxuICAgIGlmICghbm9kZS52aXNpYmxlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGFkZGluZyA9IG5vZGUucHN0eWxlKFwiXCIuY29uY2F0KG92ZXJsYXlPclVuZGVybGF5LCBcIi1wYWRkaW5nXCIpKS5wZlZhbHVlO1xuICAgIHZhciBvcGFjaXR5ID0gbm9kZS5wc3R5bGUoXCJcIi5jb25jYXQob3ZlcmxheU9yVW5kZXJsYXksIFwiLW9wYWNpdHlcIikpLnZhbHVlO1xuICAgIHZhciBjb2xvciA9IG5vZGUucHN0eWxlKFwiXCIuY29uY2F0KG92ZXJsYXlPclVuZGVybGF5LCBcIi1jb2xvclwiKSkudmFsdWU7XG4gICAgdmFyIHNoYXBlID0gbm9kZS5wc3R5bGUoXCJcIi5jb25jYXQob3ZlcmxheU9yVW5kZXJsYXksIFwiLXNoYXBlXCIpKS52YWx1ZTtcblxuICAgIGlmIChvcGFjaXR5ID4gMCkge1xuICAgICAgcG9zID0gcG9zIHx8IG5vZGUucG9zaXRpb24oKTtcblxuICAgICAgaWYgKG5vZGVXaWR0aCA9PSBudWxsIHx8IG5vZGVIZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICB2YXIgX3BhZGRpbmcgPSBub2RlLnBhZGRpbmcoKTtcblxuICAgICAgICBub2RlV2lkdGggPSBub2RlLndpZHRoKCkgKyAyICogX3BhZGRpbmc7XG4gICAgICAgIG5vZGVIZWlnaHQgPSBub2RlLmhlaWdodCgpICsgMiAqIF9wYWRkaW5nO1xuICAgICAgfVxuXG4gICAgICByLmNvbG9yRmlsbFN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkpO1xuICAgICAgci5ub2RlU2hhcGVzW3NoYXBlXS5kcmF3KGNvbnRleHQsIHBvcy54LCBwb3MueSwgbm9kZVdpZHRoICsgcGFkZGluZyAqIDIsIG5vZGVIZWlnaHQgKyBwYWRkaW5nICogMik7XG4gICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICB9XG4gIH07XG59O1xuXG5DUnAkNS5kcmF3Tm9kZU92ZXJsYXkgPSBkcmF3Tm9kZU92ZXJsYXlVbmRlcmxheSgnb3ZlcmxheScpO1xuQ1JwJDUuZHJhd05vZGVVbmRlcmxheSA9IGRyYXdOb2RlT3ZlcmxheVVuZGVybGF5KCd1bmRlcmxheScpOyAvLyBkb2VzIHRoZSBub2RlIGhhdmUgYXQgbGVhc3Qgb25lIHBpZSBwaWVjZT9cblxuQ1JwJDUuaGFzUGllID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgbm9kZSA9IG5vZGVbMF07IC8vIGVuc3VyZSBlbGUgcmVmXG5cbiAgcmV0dXJuIG5vZGUuX3ByaXZhdGUuaGFzUGllO1xufTtcblxuQ1JwJDUuZHJhd1BpZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBub2RlLCBub2RlT3BhY2l0eSwgcG9zKSB7XG4gIG5vZGUgPSBub2RlWzBdOyAvLyBlbnN1cmUgZWxlIHJlZlxuXG4gIHBvcyA9IHBvcyB8fCBub2RlLnBvc2l0aW9uKCk7XG4gIHZhciBjeVN0eWxlID0gbm9kZS5jeSgpLnN0eWxlKCk7XG4gIHZhciBwaWVTaXplID0gbm9kZS5wc3R5bGUoJ3BpZS1zaXplJyk7XG4gIHZhciB4ID0gcG9zLng7XG4gIHZhciB5ID0gcG9zLnk7XG4gIHZhciBub2RlVyA9IG5vZGUud2lkdGgoKTtcbiAgdmFyIG5vZGVIID0gbm9kZS5oZWlnaHQoKTtcbiAgdmFyIHJhZGl1cyA9IE1hdGgubWluKG5vZGVXLCBub2RlSCkgLyAyOyAvLyBtdXN0IGZpdCBpbiBub2RlXG5cbiAgdmFyIGxhc3RQZXJjZW50ID0gMDsgLy8gd2hhdCAlIHRvIGNvbnRpbnVlIGRyYXdpbmcgcGllIHNsaWNlcyBmcm9tIG9uIFswLCAxXVxuXG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKTtcblxuICBpZiAodXNlUGF0aHMpIHtcbiAgICB4ID0gMDtcbiAgICB5ID0gMDtcbiAgfVxuXG4gIGlmIChwaWVTaXplLnVuaXRzID09PSAnJScpIHtcbiAgICByYWRpdXMgPSByYWRpdXMgKiBwaWVTaXplLnBmVmFsdWU7XG4gIH0gZWxzZSBpZiAocGllU2l6ZS5wZlZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICByYWRpdXMgPSBwaWVTaXplLnBmVmFsdWUgLyAyO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gY3lTdHlsZS5waWVCYWNrZ3JvdW5kTjsgaSsrKSB7XG4gICAgLy8gMS4uTlxuICAgIHZhciBzaXplID0gbm9kZS5wc3R5bGUoJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1zaXplJykudmFsdWU7XG4gICAgdmFyIGNvbG9yID0gbm9kZS5wc3R5bGUoJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1jb2xvcicpLnZhbHVlO1xuICAgIHZhciBvcGFjaXR5ID0gbm9kZS5wc3R5bGUoJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1vcGFjaXR5JykudmFsdWUgKiBub2RlT3BhY2l0eTtcbiAgICB2YXIgcGVyY2VudCA9IHNpemUgLyAxMDA7IC8vIG1hcCBpbnRlZ2VyIHJhbmdlIFswLCAxMDBdIHRvIFswLCAxXVxuICAgIC8vIHBlcmNlbnQgY2FuJ3QgcHVzaCBiZXlvbmQgMVxuXG4gICAgaWYgKHBlcmNlbnQgKyBsYXN0UGVyY2VudCA+IDEpIHtcbiAgICAgIHBlcmNlbnQgPSAxIC0gbGFzdFBlcmNlbnQ7XG4gICAgfVxuXG4gICAgdmFyIGFuZ2xlU3RhcnQgPSAxLjUgKiBNYXRoLlBJICsgMiAqIE1hdGguUEkgKiBsYXN0UGVyY2VudDsgLy8gc3RhcnQgYXQgMTIgbydjbG9jayBhbmQgZ28gY2xvY2t3aXNlXG5cbiAgICB2YXIgYW5nbGVEZWx0YSA9IDIgKiBNYXRoLlBJICogcGVyY2VudDtcbiAgICB2YXIgYW5nbGVFbmQgPSBhbmdsZVN0YXJ0ICsgYW5nbGVEZWx0YTsgLy8gaWdub3JlIGlmXG4gICAgLy8gLSB6ZXJvIHNpemVcbiAgICAvLyAtIHdlJ3JlIGFscmVhZHkgYmV5b25kIHRoZSBmdWxsIGNpcmNsZVxuICAgIC8vIC0gYWRkaW5nIHRoZSBjdXJyZW50IHNsaWNlIHdvdWxkIGdvIGJleW9uZCB0aGUgZnVsbCBjaXJjbGVcblxuICAgIGlmIChzaXplID09PSAwIHx8IGxhc3RQZXJjZW50ID49IDEgfHwgbGFzdFBlcmNlbnQgKyBwZXJjZW50ID4gMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgICBjb250ZXh0LmFyYyh4LCB5LCByYWRpdXMsIGFuZ2xlU3RhcnQsIGFuZ2xlRW5kKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eSk7XG4gICAgY29udGV4dC5maWxsKCk7XG4gICAgbGFzdFBlcmNlbnQgKz0gcGVyY2VudDtcbiAgfVxufTtcblxudmFyIENScCQ0ID0ge307XG52YXIgbW90aW9uQmx1ckRlbGF5ID0gMTAwOyAvLyB2YXIgaXNGaXJlZm94ID0gdHlwZW9mIEluc3RhbGxUcmlnZ2VyICE9PSAndW5kZWZpbmVkJztcblxuQ1JwJDQuZ2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNvbnRleHQgPSB0aGlzLmRhdGEuY29udGV4dHNbMF07XG5cbiAgaWYgKHRoaXMuZm9yY2VkUGl4ZWxSYXRpbyAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yY2VkUGl4ZWxSYXRpbztcbiAgfVxuXG4gIHZhciBiYWNraW5nU3RvcmUgPSBjb250ZXh0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQuYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC8gYmFja2luZ1N0b3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG59O1xuXG5DUnAkNC5wYWludENhY2hlID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgdmFyIGNhY2hlcyA9IHRoaXMucGFpbnRDYWNoZXMgPSB0aGlzLnBhaW50Q2FjaGVzIHx8IFtdO1xuICB2YXIgbmVlZFRvQ3JlYXRlQ2FjaGUgPSB0cnVlO1xuICB2YXIgY2FjaGU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjYWNoZSA9IGNhY2hlc1tpXTtcblxuICAgIGlmIChjYWNoZS5jb250ZXh0ID09PSBjb250ZXh0KSB7XG4gICAgICBuZWVkVG9DcmVhdGVDYWNoZSA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKG5lZWRUb0NyZWF0ZUNhY2hlKSB7XG4gICAgY2FjaGUgPSB7XG4gICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgfTtcbiAgICBjYWNoZXMucHVzaChjYWNoZSk7XG4gIH1cblxuICByZXR1cm4gY2FjaGU7XG59O1xuXG5DUnAkNC5jcmVhdGVHcmFkaWVudFN0eWxlRm9yID0gZnVuY3Rpb24gKGNvbnRleHQsIHNoYXBlU3R5bGVOYW1lLCBlbGUsIGZpbGwsIG9wYWNpdHkpIHtcbiAgdmFyIGdyYWRpZW50U3R5bGU7XG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKTtcbiAgdmFyIGNvbG9ycyA9IGVsZS5wc3R5bGUoc2hhcGVTdHlsZU5hbWUgKyAnLWdyYWRpZW50LXN0b3AtY29sb3JzJykudmFsdWUsXG4gICAgICBwb3NpdGlvbnMgPSBlbGUucHN0eWxlKHNoYXBlU3R5bGVOYW1lICsgJy1ncmFkaWVudC1zdG9wLXBvc2l0aW9ucycpLnBmVmFsdWU7XG5cbiAgaWYgKGZpbGwgPT09ICdyYWRpYWwtZ3JhZGllbnQnKSB7XG4gICAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgICAgdmFyIHN0YXJ0ID0gZWxlLnNvdXJjZUVuZHBvaW50KCksXG4gICAgICAgICAgZW5kID0gZWxlLnRhcmdldEVuZHBvaW50KCksXG4gICAgICAgICAgbWlkID0gZWxlLm1pZHBvaW50KCk7XG4gICAgICB2YXIgZDEgPSBkaXN0KHN0YXJ0LCBtaWQpO1xuICAgICAgdmFyIGQyID0gZGlzdChlbmQsIG1pZCk7XG4gICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVSYWRpYWxHcmFkaWVudChtaWQueCwgbWlkLnksIDAsIG1pZC54LCBtaWQueSwgTWF0aC5tYXgoZDEsIGQyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwb3MgPSB1c2VQYXRocyA/IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSA6IGVsZS5wb3NpdGlvbigpLFxuICAgICAgICAgIHdpZHRoID0gZWxlLnBhZGRlZFdpZHRoKCksXG4gICAgICAgICAgaGVpZ2h0ID0gZWxlLnBhZGRlZEhlaWdodCgpO1xuICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlUmFkaWFsR3JhZGllbnQocG9zLngsIHBvcy55LCAwLCBwb3MueCwgcG9zLnksIE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgICAgdmFyIF9zdGFydCA9IGVsZS5zb3VyY2VFbmRwb2ludCgpLFxuICAgICAgICAgIF9lbmQgPSBlbGUudGFyZ2V0RW5kcG9pbnQoKTtcblxuICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3N0YXJ0LngsIF9zdGFydC55LCBfZW5kLngsIF9lbmQueSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfcG9zID0gdXNlUGF0aHMgPyB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0gOiBlbGUucG9zaXRpb24oKSxcbiAgICAgICAgICBfd2lkdGggPSBlbGUucGFkZGVkV2lkdGgoKSxcbiAgICAgICAgICBfaGVpZ2h0ID0gZWxlLnBhZGRlZEhlaWdodCgpLFxuICAgICAgICAgIGhhbGZXaWR0aCA9IF93aWR0aCAvIDIsXG4gICAgICAgICAgaGFsZkhlaWdodCA9IF9oZWlnaHQgLyAyO1xuXG4gICAgICB2YXIgZGlyZWN0aW9uID0gZWxlLnBzdHlsZSgnYmFja2dyb3VuZC1ncmFkaWVudC1kaXJlY3Rpb24nKS52YWx1ZTtcblxuICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgY2FzZSAndG8tYm90dG9tJzpcbiAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLngsIF9wb3MueSAtIGhhbGZIZWlnaHQsIF9wb3MueCwgX3Bvcy55ICsgaGFsZkhlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndG8tdG9wJzpcbiAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLngsIF9wb3MueSArIGhhbGZIZWlnaHQsIF9wb3MueCwgX3Bvcy55IC0gaGFsZkhlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndG8tbGVmdCc6XG4gICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54ICsgaGFsZldpZHRoLCBfcG9zLnksIF9wb3MueCAtIGhhbGZXaWR0aCwgX3Bvcy55KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0by1yaWdodCc6XG4gICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54IC0gaGFsZldpZHRoLCBfcG9zLnksIF9wb3MueCArIGhhbGZXaWR0aCwgX3Bvcy55KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0by1ib3R0b20tcmlnaHQnOlxuICAgICAgICBjYXNlICd0by1yaWdodC1ib3R0b20nOlxuICAgICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9wb3MueCAtIGhhbGZXaWR0aCwgX3Bvcy55IC0gaGFsZkhlaWdodCwgX3Bvcy54ICsgaGFsZldpZHRoLCBfcG9zLnkgKyBoYWxmSGVpZ2h0KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0by10b3AtcmlnaHQnOlxuICAgICAgICBjYXNlICd0by1yaWdodC10b3AnOlxuICAgICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9wb3MueCAtIGhhbGZXaWR0aCwgX3Bvcy55ICsgaGFsZkhlaWdodCwgX3Bvcy54ICsgaGFsZldpZHRoLCBfcG9zLnkgLSBoYWxmSGVpZ2h0KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0by1ib3R0b20tbGVmdCc6XG4gICAgICAgIGNhc2UgJ3RvLWxlZnQtYm90dG9tJzpcbiAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLnggKyBoYWxmV2lkdGgsIF9wb3MueSAtIGhhbGZIZWlnaHQsIF9wb3MueCAtIGhhbGZXaWR0aCwgX3Bvcy55ICsgaGFsZkhlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndG8tdG9wLWxlZnQnOlxuICAgICAgICBjYXNlICd0by1sZWZ0LXRvcCc6XG4gICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54ICsgaGFsZldpZHRoLCBfcG9zLnkgKyBoYWxmSGVpZ2h0LCBfcG9zLnggLSBoYWxmV2lkdGgsIF9wb3MueSAtIGhhbGZIZWlnaHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghZ3JhZGllbnRTdHlsZSkgcmV0dXJuIG51bGw7IC8vIGludmFsaWQgZ3JhZGllbnQgc3R5bGVcblxuICB2YXIgaGFzUG9zaXRpb25zID0gcG9zaXRpb25zLmxlbmd0aCA9PT0gY29sb3JzLmxlbmd0aDtcbiAgdmFyIGxlbmd0aCA9IGNvbG9ycy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGdyYWRpZW50U3R5bGUuYWRkQ29sb3JTdG9wKGhhc1Bvc2l0aW9ucyA/IHBvc2l0aW9uc1tpXSA6IGkgLyAobGVuZ3RoIC0gMSksICdyZ2JhKCcgKyBjb2xvcnNbaV1bMF0gKyAnLCcgKyBjb2xvcnNbaV1bMV0gKyAnLCcgKyBjb2xvcnNbaV1bMl0gKyAnLCcgKyBvcGFjaXR5ICsgJyknKTtcbiAgfVxuXG4gIHJldHVybiBncmFkaWVudFN0eWxlO1xufTtcblxuQ1JwJDQuZ3JhZGllbnRGaWxsU3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBmaWxsLCBvcGFjaXR5KSB7XG4gIHZhciBncmFkaWVudFN0eWxlID0gdGhpcy5jcmVhdGVHcmFkaWVudFN0eWxlRm9yKGNvbnRleHQsICdiYWNrZ3JvdW5kJywgZWxlLCBmaWxsLCBvcGFjaXR5KTtcbiAgaWYgKCFncmFkaWVudFN0eWxlKSByZXR1cm4gbnVsbDsgLy8gZXJyb3JcblxuICBjb250ZXh0LmZpbGxTdHlsZSA9IGdyYWRpZW50U3R5bGU7XG59O1xuXG5DUnAkNC5jb2xvckZpbGxTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCByLCBnLCBiLCBhKSB7XG4gIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7IC8vIHR1cm4gb2ZmIGZvciBub3csIHNlZW1zIGNvbnRleHQgZG9lcyBpdHMgb3duIGNhY2hpbmdcbiAgLy8gdmFyIGNhY2hlID0gdGhpcy5wYWludENhY2hlKGNvbnRleHQpO1xuICAvLyB2YXIgZmlsbFN0eWxlID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG4gIC8vIGlmKCBjYWNoZS5maWxsU3R5bGUgIT09IGZpbGxTdHlsZSApe1xuICAvLyAgIGNvbnRleHQuZmlsbFN0eWxlID0gY2FjaGUuZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAvLyB9XG59O1xuXG5DUnAkNC5lbGVGaWxsU3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBvcGFjaXR5KSB7XG4gIHZhciBiYWNrZ3JvdW5kRmlsbCA9IGVsZS5wc3R5bGUoJ2JhY2tncm91bmQtZmlsbCcpLnZhbHVlO1xuXG4gIGlmIChiYWNrZ3JvdW5kRmlsbCA9PT0gJ2xpbmVhci1ncmFkaWVudCcgfHwgYmFja2dyb3VuZEZpbGwgPT09ICdyYWRpYWwtZ3JhZGllbnQnKSB7XG4gICAgdGhpcy5ncmFkaWVudEZpbGxTdHlsZShjb250ZXh0LCBlbGUsIGJhY2tncm91bmRGaWxsLCBvcGFjaXR5KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYmFja2dyb3VuZENvbG9yID0gZWxlLnBzdHlsZSgnYmFja2dyb3VuZC1jb2xvcicpLnZhbHVlO1xuICAgIHRoaXMuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgYmFja2dyb3VuZENvbG9yWzBdLCBiYWNrZ3JvdW5kQ29sb3JbMV0sIGJhY2tncm91bmRDb2xvclsyXSwgb3BhY2l0eSk7XG4gIH1cbn07XG5cbkNScCQ0LmdyYWRpZW50U3Ryb2tlU3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBmaWxsLCBvcGFjaXR5KSB7XG4gIHZhciBncmFkaWVudFN0eWxlID0gdGhpcy5jcmVhdGVHcmFkaWVudFN0eWxlRm9yKGNvbnRleHQsICdsaW5lJywgZWxlLCBmaWxsLCBvcGFjaXR5KTtcbiAgaWYgKCFncmFkaWVudFN0eWxlKSByZXR1cm4gbnVsbDsgLy8gZXJyb3JcblxuICBjb250ZXh0LnN0cm9rZVN0eWxlID0gZ3JhZGllbnRTdHlsZTtcbn07XG5cbkNScCQ0LmNvbG9yU3Ryb2tlU3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgciwgZywgYiwgYSkge1xuICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7IC8vIHR1cm4gb2ZmIGZvciBub3csIHNlZW1zIGNvbnRleHQgZG9lcyBpdHMgb3duIGNhY2hpbmdcbiAgLy8gdmFyIGNhY2hlID0gdGhpcy5wYWludENhY2hlKGNvbnRleHQpO1xuICAvLyB2YXIgc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcbiAgLy8gaWYoIGNhY2hlLnN0cm9rZVN0eWxlICE9PSBzdHJva2VTdHlsZSApe1xuICAvLyAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjYWNoZS5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAvLyB9XG59O1xuXG5DUnAkNC5lbGVTdHJva2VTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIG9wYWNpdHkpIHtcbiAgdmFyIGxpbmVGaWxsID0gZWxlLnBzdHlsZSgnbGluZS1maWxsJykudmFsdWU7XG5cbiAgaWYgKGxpbmVGaWxsID09PSAnbGluZWFyLWdyYWRpZW50JyB8fCBsaW5lRmlsbCA9PT0gJ3JhZGlhbC1ncmFkaWVudCcpIHtcbiAgICB0aGlzLmdyYWRpZW50U3Ryb2tlU3R5bGUoY29udGV4dCwgZWxlLCBsaW5lRmlsbCwgb3BhY2l0eSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxpbmVDb2xvciA9IGVsZS5wc3R5bGUoJ2xpbmUtY29sb3InKS52YWx1ZTtcbiAgICB0aGlzLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgbGluZUNvbG9yWzBdLCBsaW5lQ29sb3JbMV0sIGxpbmVDb2xvclsyXSwgb3BhY2l0eSk7XG4gIH1cbn07IC8vIFJlc2l6ZSBjYW52YXNcblxuXG5DUnAkNC5tYXRjaENhbnZhc1NpemUgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGRhdGEgPSByLmRhdGE7XG4gIHZhciBiYiA9IHIuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICB2YXIgd2lkdGggPSBiYlsyXTtcbiAgdmFyIGhlaWdodCA9IGJiWzNdO1xuICB2YXIgcGl4ZWxSYXRpbyA9IHIuZ2V0UGl4ZWxSYXRpbygpO1xuICB2YXIgbWJQeFJhdGlvID0gci5tb3Rpb25CbHVyUHhSYXRpbztcblxuICBpZiAoY29udGFpbmVyID09PSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFXSB8fCBjb250YWluZXIgPT09IHIuZGF0YS5idWZmZXJDYW52YXNlc1tyLk1PVElPTkJMVVJfQlVGRkVSX0RSQUddKSB7XG4gICAgcGl4ZWxSYXRpbyA9IG1iUHhSYXRpbztcbiAgfVxuXG4gIHZhciBjYW52YXNXaWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcbiAgdmFyIGNhbnZhc0hlaWdodCA9IGhlaWdodCAqIHBpeGVsUmF0aW87XG4gIHZhciBjYW52YXM7XG5cbiAgaWYgKGNhbnZhc1dpZHRoID09PSByLmNhbnZhc1dpZHRoICYmIGNhbnZhc0hlaWdodCA9PT0gci5jYW52YXNIZWlnaHQpIHtcbiAgICByZXR1cm47IC8vIHNhdmUgY3ljbGVzIGlmIHNhbWVcbiAgfVxuXG4gIHIuZm9udENhY2hlcyA9IG51bGw7IC8vIHJlc2l6aW5nIHJlc2V0cyB0aGUgc3R5bGVcblxuICB2YXIgY2FudmFzQ29udGFpbmVyID0gZGF0YS5jYW52YXNDb250YWluZXI7XG4gIGNhbnZhc0NvbnRhaW5lci5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgY2FudmFzQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByLkNBTlZBU19MQVlFUlM7IGkrKykge1xuICAgIGNhbnZhcyA9IGRhdGEuY2FudmFzZXNbaV07XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHIuQlVGRkVSX0NPVU5UOyBpKyspIHtcbiAgICBjYW52YXMgPSBkYXRhLmJ1ZmZlckNhbnZhc2VzW2ldO1xuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICB9XG5cbiAgci50ZXh0dXJlTXVsdCA9IDE7XG5cbiAgaWYgKHBpeGVsUmF0aW8gPD0gMSkge1xuICAgIGNhbnZhcyA9IGRhdGEuYnVmZmVyQ2FudmFzZXNbci5URVhUVVJFX0JVRkZFUl07XG4gICAgci50ZXh0dXJlTXVsdCA9IDI7XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGggKiByLnRleHR1cmVNdWx0O1xuICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQgKiByLnRleHR1cmVNdWx0O1xuICB9XG5cbiAgci5jYW52YXNXaWR0aCA9IGNhbnZhc1dpZHRoO1xuICByLmNhbnZhc0hlaWdodCA9IGNhbnZhc0hlaWdodDtcbn07XG5cbkNScCQ0LnJlbmRlclRvID0gZnVuY3Rpb24gKGN4dCwgem9vbSwgcGFuLCBweFJhdGlvKSB7XG4gIHRoaXMucmVuZGVyKHtcbiAgICBmb3JjZWRDb250ZXh0OiBjeHQsXG4gICAgZm9yY2VkWm9vbTogem9vbSxcbiAgICBmb3JjZWRQYW46IHBhbixcbiAgICBkcmF3QWxsTGF5ZXJzOiB0cnVlLFxuICAgIGZvcmNlZFB4UmF0aW86IHB4UmF0aW9cbiAgfSk7XG59O1xuXG5DUnAkNC5yZW5kZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCBzdGF0aWNFbXB0eU9iamVjdCgpO1xuICB2YXIgZm9yY2VkQ29udGV4dCA9IG9wdGlvbnMuZm9yY2VkQ29udGV4dDtcbiAgdmFyIGRyYXdBbGxMYXllcnMgPSBvcHRpb25zLmRyYXdBbGxMYXllcnM7XG4gIHZhciBkcmF3T25seU5vZGVMYXllciA9IG9wdGlvbnMuZHJhd09ubHlOb2RlTGF5ZXI7XG4gIHZhciBmb3JjZWRab29tID0gb3B0aW9ucy5mb3JjZWRab29tO1xuICB2YXIgZm9yY2VkUGFuID0gb3B0aW9ucy5mb3JjZWRQYW47XG4gIHZhciByID0gdGhpcztcbiAgdmFyIHBpeGVsUmF0aW8gPSBvcHRpb25zLmZvcmNlZFB4UmF0aW8gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0UGl4ZWxSYXRpbygpIDogb3B0aW9ucy5mb3JjZWRQeFJhdGlvO1xuICB2YXIgY3kgPSByLmN5O1xuICB2YXIgZGF0YSA9IHIuZGF0YTtcbiAgdmFyIG5lZWREcmF3ID0gZGF0YS5jYW52YXNOZWVkc1JlZHJhdztcbiAgdmFyIHRleHR1cmVEcmF3ID0gci50ZXh0dXJlT25WaWV3cG9ydCAmJiAhZm9yY2VkQ29udGV4dCAmJiAoci5waW5jaGluZyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZyB8fCByLnN3aXBlUGFubmluZyB8fCByLmRhdGEud2hlZWxab29taW5nKTtcbiAgdmFyIG1vdGlvbkJsdXIgPSBvcHRpb25zLm1vdGlvbkJsdXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubW90aW9uQmx1ciA6IHIubW90aW9uQmx1cjtcbiAgdmFyIG1iUHhSYXRpbyA9IHIubW90aW9uQmx1clB4UmF0aW87XG4gIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICB2YXIgaW5Ob2RlRHJhZ0dlc3R1cmUgPSByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXM7XG4gIHZhciBpbkJveFNlbGVjdGlvbiA9IHIuaG92ZXJEYXRhLnNlbGVjdGluZyB8fCByLnRvdWNoRGF0YS5zZWxlY3RpbmcgPyB0cnVlIDogZmFsc2U7XG4gIG1vdGlvbkJsdXIgPSBtb3Rpb25CbHVyICYmICFmb3JjZWRDb250ZXh0ICYmIHIubW90aW9uQmx1ckVuYWJsZWQgJiYgIWluQm94U2VsZWN0aW9uO1xuICB2YXIgbW90aW9uQmx1ckZhZGVFZmZlY3QgPSBtb3Rpb25CbHVyO1xuXG4gIGlmICghZm9yY2VkQ29udGV4dCkge1xuICAgIGlmIChyLnByZXZQeFJhdGlvICE9PSBwaXhlbFJhdGlvKSB7XG4gICAgICByLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSgpO1xuICAgICAgci5tYXRjaENhbnZhc1NpemUoci5jb250YWluZXIpO1xuICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICB9XG5cbiAgICByLnByZXZQeFJhdGlvID0gcGl4ZWxSYXRpbztcbiAgfVxuXG4gIGlmICghZm9yY2VkQ29udGV4dCAmJiByLm1vdGlvbkJsdXJUaW1lb3V0KSB7XG4gICAgY2xlYXJUaW1lb3V0KHIubW90aW9uQmx1clRpbWVvdXQpO1xuICB9XG5cbiAgaWYgKG1vdGlvbkJsdXIpIHtcbiAgICBpZiAoci5tYkZyYW1lcyA9PSBudWxsKSB7XG4gICAgICByLm1iRnJhbWVzID0gMDtcbiAgICB9XG5cbiAgICByLm1iRnJhbWVzKys7XG5cbiAgICBpZiAoci5tYkZyYW1lcyA8IDMpIHtcbiAgICAgIC8vIG5lZWQgc2V2ZXJhbCBmcmFtZXMgYmVmb3JlIGV2ZW4gaGlnaCBxdWFsaXR5IG1vdGlvbmJsdXJcbiAgICAgIG1vdGlvbkJsdXJGYWRlRWZmZWN0ID0gZmFsc2U7XG4gICAgfSAvLyBnbyB0byBsb3dlciBxdWFsaXR5IGJsdXJyeSBmcmFtZXMgd2hlbiBzZXZlcmFsIG0vYiBmcmFtZXMgaGF2ZSBiZWVuIHJlbmRlcmVkIChhdm9pZHMgZmxhc2hpbmcpXG5cblxuICAgIGlmIChyLm1iRnJhbWVzID4gci5taW5NYkxvd1F1YWxGcmFtZXMpIHtcbiAgICAgIC8vci5mdWxsUXVhbGl0eU1iID0gZmFsc2U7XG4gICAgICByLm1vdGlvbkJsdXJQeFJhdGlvID0gci5tYlB4UkJsdXJyeTtcbiAgICB9XG4gIH1cblxuICBpZiAoci5jbGVhcmluZ01vdGlvbkJsdXIpIHtcbiAgICByLm1vdGlvbkJsdXJQeFJhdGlvID0gMTtcbiAgfSAvLyBiL2MgZHJhd1RvQ29udGV4dCgpIG1heSBiZSBhc3luYyB3LnIudC4gcmVkcmF3KCksIGtlZXAgdHJhY2sgb2YgbGFzdCB0ZXh0dXJlIGZyYW1lXG4gIC8vIGJlY2F1c2UgYSByb2d1ZSBhc3luYyB0ZXh0dXJlIGZyYW1lIHdvdWxkIGNsZWFyIG5lZWREcmF3XG5cblxuICBpZiAoci50ZXh0dXJlRHJhd0xhc3RGcmFtZSAmJiAhdGV4dHVyZURyYXcpIHtcbiAgICBuZWVkRHJhd1tyLk5PREVdID0gdHJ1ZTtcbiAgICBuZWVkRHJhd1tyLlNFTEVDVF9CT1hdID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gIHZhciB6b29tID0gY3kuem9vbSgpO1xuICB2YXIgZWZmZWN0aXZlWm9vbSA9IGZvcmNlZFpvb20gIT09IHVuZGVmaW5lZCA/IGZvcmNlZFpvb20gOiB6b29tO1xuICB2YXIgcGFuID0gY3kucGFuKCk7XG4gIHZhciBlZmZlY3RpdmVQYW4gPSB7XG4gICAgeDogcGFuLngsXG4gICAgeTogcGFuLnlcbiAgfTtcbiAgdmFyIHZwID0ge1xuICAgIHpvb206IHpvb20sXG4gICAgcGFuOiB7XG4gICAgICB4OiBwYW4ueCxcbiAgICAgIHk6IHBhbi55XG4gICAgfVxuICB9O1xuICB2YXIgcHJldlZwID0gci5wcmV2Vmlld3BvcnQ7XG4gIHZhciB2aWV3cG9ydElzRGlmZiA9IHByZXZWcCA9PT0gdW5kZWZpbmVkIHx8IHZwLnpvb20gIT09IHByZXZWcC56b29tIHx8IHZwLnBhbi54ICE9PSBwcmV2VnAucGFuLnggfHwgdnAucGFuLnkgIT09IHByZXZWcC5wYW4ueTsgLy8gd2Ugd2FudCB0aGUgbG93IHF1YWxpdHkgbW90aW9uYmx1ciBvbmx5IHdoZW4gdGhlIHZpZXdwb3J0IGlzIGJlaW5nIG1hbmlwdWxhdGVkIGV0YyAod2hlcmUgaXQncyBub3Qgbm90aWNlZClcblxuICBpZiAoIXZpZXdwb3J0SXNEaWZmICYmICEoaW5Ob2RlRHJhZ0dlc3R1cmUgJiYgIWhhc0NvbXBvdW5kTm9kZXMpKSB7XG4gICAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IDE7XG4gIH1cblxuICBpZiAoZm9yY2VkUGFuKSB7XG4gICAgZWZmZWN0aXZlUGFuID0gZm9yY2VkUGFuO1xuICB9IC8vIGFwcGx5IHBpeGVsIHJhdGlvXG5cblxuICBlZmZlY3RpdmVab29tICo9IHBpeGVsUmF0aW87XG4gIGVmZmVjdGl2ZVBhbi54ICo9IHBpeGVsUmF0aW87XG4gIGVmZmVjdGl2ZVBhbi55ICo9IHBpeGVsUmF0aW87XG4gIHZhciBlbGVzID0gci5nZXRDYWNoZWRaU29ydGVkRWxlcygpO1xuXG4gIGZ1bmN0aW9uIG1iY2xlYXIoY29udGV4dCwgeCwgeSwgdywgaCkge1xuICAgIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuICAgIHIuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgMjU1LCAyNTUsIDI1NSwgci5tb3Rpb25CbHVyVHJhbnNwYXJlbmN5KTtcbiAgICBjb250ZXh0LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZ2NvO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q29udGV4dFRyYW5zZm9ybShjb250ZXh0LCBjbGVhcikge1xuICAgIHZhciBlUGFuLCBlWm9vbSwgdywgaDtcblxuICAgIGlmICghci5jbGVhcmluZ01vdGlvbkJsdXIgJiYgKGNvbnRleHQgPT09IGRhdGEuYnVmZmVyQ29udGV4dHNbci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFXSB8fCBjb250ZXh0ID09PSBkYXRhLmJ1ZmZlckNvbnRleHRzW3IuTU9USU9OQkxVUl9CVUZGRVJfRFJBR10pKSB7XG4gICAgICBlUGFuID0ge1xuICAgICAgICB4OiBwYW4ueCAqIG1iUHhSYXRpbyxcbiAgICAgICAgeTogcGFuLnkgKiBtYlB4UmF0aW9cbiAgICAgIH07XG4gICAgICBlWm9vbSA9IHpvb20gKiBtYlB4UmF0aW87XG4gICAgICB3ID0gci5jYW52YXNXaWR0aCAqIG1iUHhSYXRpbztcbiAgICAgIGggPSByLmNhbnZhc0hlaWdodCAqIG1iUHhSYXRpbztcbiAgICB9IGVsc2Uge1xuICAgICAgZVBhbiA9IGVmZmVjdGl2ZVBhbjtcbiAgICAgIGVab29tID0gZWZmZWN0aXZlWm9vbTtcbiAgICAgIHcgPSByLmNhbnZhc1dpZHRoO1xuICAgICAgaCA9IHIuY2FudmFzSGVpZ2h0O1xuICAgIH1cblxuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXG4gICAgaWYgKGNsZWFyID09PSAnbW90aW9uQmx1cicpIHtcbiAgICAgIG1iY2xlYXIoY29udGV4dCwgMCwgMCwgdywgaCk7XG4gICAgfSBlbHNlIGlmICghZm9yY2VkQ29udGV4dCAmJiAoY2xlYXIgPT09IHVuZGVmaW5lZCB8fCBjbGVhcikpIHtcbiAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuICAgIH1cblxuICAgIGlmICghZHJhd0FsbExheWVycykge1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoZVBhbi54LCBlUGFuLnkpO1xuICAgICAgY29udGV4dC5zY2FsZShlWm9vbSwgZVpvb20pO1xuICAgIH1cblxuICAgIGlmIChmb3JjZWRQYW4pIHtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKGZvcmNlZFBhbi54LCBmb3JjZWRQYW4ueSk7XG4gICAgfVxuXG4gICAgaWYgKGZvcmNlZFpvb20pIHtcbiAgICAgIGNvbnRleHQuc2NhbGUoZm9yY2VkWm9vbSwgZm9yY2VkWm9vbSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0ZXh0dXJlRHJhdykge1xuICAgIHIudGV4dHVyZURyYXdMYXN0RnJhbWUgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0ZXh0dXJlRHJhdykge1xuICAgIHIudGV4dHVyZURyYXdMYXN0RnJhbWUgPSB0cnVlO1xuXG4gICAgaWYgKCFyLnRleHR1cmVDYWNoZSkge1xuICAgICAgci50ZXh0dXJlQ2FjaGUgPSB7fTtcbiAgICAgIHIudGV4dHVyZUNhY2hlLmJiID0gY3kubXV0YWJsZUVsZW1lbnRzKCkuYm91bmRpbmdCb3goKTtcbiAgICAgIHIudGV4dHVyZUNhY2hlLnRleHR1cmUgPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbci5URVhUVVJFX0JVRkZFUl07XG4gICAgICB2YXIgY3h0ID0gci5kYXRhLmJ1ZmZlckNvbnRleHRzW3IuVEVYVFVSRV9CVUZGRVJdO1xuICAgICAgY3h0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIGN4dC5jbGVhclJlY3QoMCwgMCwgci5jYW52YXNXaWR0aCAqIHIudGV4dHVyZU11bHQsIHIuY2FudmFzSGVpZ2h0ICogci50ZXh0dXJlTXVsdCk7XG4gICAgICByLnJlbmRlcih7XG4gICAgICAgIGZvcmNlZENvbnRleHQ6IGN4dCxcbiAgICAgICAgZHJhd09ubHlOb2RlTGF5ZXI6IHRydWUsXG4gICAgICAgIGZvcmNlZFB4UmF0aW86IHBpeGVsUmF0aW8gKiByLnRleHR1cmVNdWx0XG4gICAgICB9KTtcbiAgICAgIHZhciB2cCA9IHIudGV4dHVyZUNhY2hlLnZpZXdwb3J0ID0ge1xuICAgICAgICB6b29tOiBjeS56b29tKCksXG4gICAgICAgIHBhbjogY3kucGFuKCksXG4gICAgICAgIHdpZHRoOiByLmNhbnZhc1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IHIuY2FudmFzSGVpZ2h0XG4gICAgICB9O1xuICAgICAgdnAubXBhbiA9IHtcbiAgICAgICAgeDogKDAgLSB2cC5wYW4ueCkgLyB2cC56b29tLFxuICAgICAgICB5OiAoMCAtIHZwLnBhbi55KSAvIHZwLnpvb21cbiAgICAgIH07XG4gICAgfVxuXG4gICAgbmVlZERyYXdbci5EUkFHXSA9IGZhbHNlO1xuICAgIG5lZWREcmF3W3IuTk9ERV0gPSBmYWxzZTtcbiAgICB2YXIgY29udGV4dCA9IGRhdGEuY29udGV4dHNbci5OT0RFXTtcbiAgICB2YXIgdGV4dHVyZSA9IHIudGV4dHVyZUNhY2hlLnRleHR1cmU7XG4gICAgdmFyIHZwID0gci50ZXh0dXJlQ2FjaGUudmlld3BvcnQ7XG4gICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cbiAgICBpZiAobW90aW9uQmx1cikge1xuICAgICAgbWJjbGVhcihjb250ZXh0LCAwLCAwLCB2cC53aWR0aCwgdnAuaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdnAud2lkdGgsIHZwLmhlaWdodCk7XG4gICAgfVxuXG4gICAgdmFyIG91dHNpZGVCZ0NvbG9yID0gc3R5bGUuY29yZSgnb3V0c2lkZS10ZXh0dXJlLWJnLWNvbG9yJykudmFsdWU7XG4gICAgdmFyIG91dHNpZGVCZ09wYWNpdHkgPSBzdHlsZS5jb3JlKCdvdXRzaWRlLXRleHR1cmUtYmctb3BhY2l0eScpLnZhbHVlO1xuICAgIHIuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgb3V0c2lkZUJnQ29sb3JbMF0sIG91dHNpZGVCZ0NvbG9yWzFdLCBvdXRzaWRlQmdDb2xvclsyXSwgb3V0c2lkZUJnT3BhY2l0eSk7XG4gICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCB2cC53aWR0aCwgdnAuaGVpZ2h0KTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICBzZXRDb250ZXh0VHJhbnNmb3JtKGNvbnRleHQsIGZhbHNlKTtcbiAgICBjb250ZXh0LmNsZWFyUmVjdCh2cC5tcGFuLngsIHZwLm1wYW4ueSwgdnAud2lkdGggLyB2cC56b29tIC8gcGl4ZWxSYXRpbywgdnAuaGVpZ2h0IC8gdnAuem9vbSAvIHBpeGVsUmF0aW8pO1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKHRleHR1cmUsIHZwLm1wYW4ueCwgdnAubXBhbi55LCB2cC53aWR0aCAvIHZwLnpvb20gLyBwaXhlbFJhdGlvLCB2cC5oZWlnaHQgLyB2cC56b29tIC8gcGl4ZWxSYXRpbyk7XG4gIH0gZWxzZSBpZiAoci50ZXh0dXJlT25WaWV3cG9ydCAmJiAhZm9yY2VkQ29udGV4dCkge1xuICAgIC8vIGNsZWFyIHRoZSBjYWNoZSBzaW5jZSB3ZSBkb24ndCBuZWVkIGl0XG4gICAgci50ZXh0dXJlQ2FjaGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGV4dGVudCA9IGN5LmV4dGVudCgpO1xuICB2YXIgdnBNYW5pcCA9IHIucGluY2hpbmcgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmcgfHwgci5zd2lwZVBhbm5pbmcgfHwgci5kYXRhLndoZWVsWm9vbWluZyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgfHwgci5jeS5hbmltYXRlZCgpO1xuICB2YXIgaGlkZUVkZ2VzID0gci5oaWRlRWRnZXNPblZpZXdwb3J0ICYmIHZwTWFuaXA7XG4gIHZhciBuZWVkTWJDbGVhciA9IFtdO1xuICBuZWVkTWJDbGVhcltyLk5PREVdID0gIW5lZWREcmF3W3IuTk9ERV0gJiYgbW90aW9uQmx1ciAmJiAhci5jbGVhcmVkRm9yTW90aW9uQmx1cltyLk5PREVdIHx8IHIuY2xlYXJpbmdNb3Rpb25CbHVyO1xuXG4gIGlmIChuZWVkTWJDbGVhcltyLk5PREVdKSB7XG4gICAgci5jbGVhcmVkRm9yTW90aW9uQmx1cltyLk5PREVdID0gdHJ1ZTtcbiAgfVxuXG4gIG5lZWRNYkNsZWFyW3IuRFJBR10gPSAhbmVlZERyYXdbci5EUkFHXSAmJiBtb3Rpb25CbHVyICYmICFyLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuRFJBR10gfHwgci5jbGVhcmluZ01vdGlvbkJsdXI7XG5cbiAgaWYgKG5lZWRNYkNsZWFyW3IuRFJBR10pIHtcbiAgICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuRFJBR10gPSB0cnVlO1xuICB9XG5cbiAgaWYgKG5lZWREcmF3W3IuTk9ERV0gfHwgZHJhd0FsbExheWVycyB8fCBkcmF3T25seU5vZGVMYXllciB8fCBuZWVkTWJDbGVhcltyLk5PREVdKSB7XG4gICAgdmFyIHVzZUJ1ZmZlciA9IG1vdGlvbkJsdXIgJiYgIW5lZWRNYkNsZWFyW3IuTk9ERV0gJiYgbWJQeFJhdGlvICE9PSAxO1xuICAgIHZhciBjb250ZXh0ID0gZm9yY2VkQ29udGV4dCB8fCAodXNlQnVmZmVyID8gci5kYXRhLmJ1ZmZlckNvbnRleHRzW3IuTU9USU9OQkxVUl9CVUZGRVJfTk9ERV0gOiBkYXRhLmNvbnRleHRzW3IuTk9ERV0pO1xuICAgIHZhciBjbGVhciA9IG1vdGlvbkJsdXIgJiYgIXVzZUJ1ZmZlciA/ICdtb3Rpb25CbHVyJyA6IHVuZGVmaW5lZDtcbiAgICBzZXRDb250ZXh0VHJhbnNmb3JtKGNvbnRleHQsIGNsZWFyKTtcblxuICAgIGlmIChoaWRlRWRnZXMpIHtcbiAgICAgIHIuZHJhd0NhY2hlZE5vZGVzKGNvbnRleHQsIGVsZXMubm9uZHJhZywgcGl4ZWxSYXRpbywgZXh0ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgci5kcmF3TGF5ZXJlZEVsZW1lbnRzKGNvbnRleHQsIGVsZXMubm9uZHJhZywgcGl4ZWxSYXRpbywgZXh0ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoci5kZWJ1Zykge1xuICAgICAgci5kcmF3RGVidWdQb2ludHMoY29udGV4dCwgZWxlcy5ub25kcmFnKTtcbiAgICB9XG5cbiAgICBpZiAoIWRyYXdBbGxMYXllcnMgJiYgIW1vdGlvbkJsdXIpIHtcbiAgICAgIG5lZWREcmF3W3IuTk9ERV0gPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWRyYXdPbmx5Tm9kZUxheWVyICYmIChuZWVkRHJhd1tyLkRSQUddIHx8IGRyYXdBbGxMYXllcnMgfHwgbmVlZE1iQ2xlYXJbci5EUkFHXSkpIHtcbiAgICB2YXIgdXNlQnVmZmVyID0gbW90aW9uQmx1ciAmJiAhbmVlZE1iQ2xlYXJbci5EUkFHXSAmJiBtYlB4UmF0aW8gIT09IDE7XG4gICAgdmFyIGNvbnRleHQgPSBmb3JjZWRDb250ZXh0IHx8ICh1c2VCdWZmZXIgPyByLmRhdGEuYnVmZmVyQ29udGV4dHNbci5NT1RJT05CTFVSX0JVRkZFUl9EUkFHXSA6IGRhdGEuY29udGV4dHNbci5EUkFHXSk7XG4gICAgc2V0Q29udGV4dFRyYW5zZm9ybShjb250ZXh0LCBtb3Rpb25CbHVyICYmICF1c2VCdWZmZXIgPyAnbW90aW9uQmx1cicgOiB1bmRlZmluZWQpO1xuXG4gICAgaWYgKGhpZGVFZGdlcykge1xuICAgICAgci5kcmF3Q2FjaGVkTm9kZXMoY29udGV4dCwgZWxlcy5kcmFnLCBwaXhlbFJhdGlvLCBleHRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByLmRyYXdDYWNoZWRFbGVtZW50cyhjb250ZXh0LCBlbGVzLmRyYWcsIHBpeGVsUmF0aW8sIGV4dGVudCk7XG4gICAgfVxuXG4gICAgaWYgKHIuZGVidWcpIHtcbiAgICAgIHIuZHJhd0RlYnVnUG9pbnRzKGNvbnRleHQsIGVsZXMuZHJhZyk7XG4gICAgfVxuXG4gICAgaWYgKCFkcmF3QWxsTGF5ZXJzICYmICFtb3Rpb25CbHVyKSB7XG4gICAgICBuZWVkRHJhd1tyLkRSQUddID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKHIuc2hvd0ZwcyB8fCAhZHJhd09ubHlOb2RlTGF5ZXIgJiYgbmVlZERyYXdbci5TRUxFQ1RfQk9YXSAmJiAhZHJhd0FsbExheWVycykge1xuICAgIHZhciBjb250ZXh0ID0gZm9yY2VkQ29udGV4dCB8fCBkYXRhLmNvbnRleHRzW3IuU0VMRUNUX0JPWF07XG4gICAgc2V0Q29udGV4dFRyYW5zZm9ybShjb250ZXh0KTtcblxuICAgIGlmIChyLnNlbGVjdGlvbls0XSA9PSAxICYmIChyLmhvdmVyRGF0YS5zZWxlY3RpbmcgfHwgci50b3VjaERhdGEuc2VsZWN0aW5nKSkge1xuICAgICAgdmFyIHpvb20gPSByLmN5Lnpvb20oKTtcbiAgICAgIHZhciBib3JkZXJXaWR0aCA9IHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLXdpZHRoJykudmFsdWUgLyB6b29tO1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSBib3JkZXJXaWR0aDtcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtY29sb3InKS52YWx1ZVswXSArICcsJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtY29sb3InKS52YWx1ZVsxXSArICcsJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtY29sb3InKS52YWx1ZVsyXSArICcsJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eScpLnZhbHVlICsgJyknO1xuICAgICAgY29udGV4dC5maWxsUmVjdChyLnNlbGVjdGlvblswXSwgci5zZWxlY3Rpb25bMV0sIHIuc2VsZWN0aW9uWzJdIC0gci5zZWxlY3Rpb25bMF0sIHIuc2VsZWN0aW9uWzNdIC0gci5zZWxlY3Rpb25bMV0pO1xuXG4gICAgICBpZiAoYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InKS52YWx1ZVswXSArICcsJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJykudmFsdWVbMV0gKyAnLCcgKyBzdHlsZS5jb3JlKCdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcicpLnZhbHVlWzJdICsgJywnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1vcGFjaXR5JykudmFsdWUgKyAnKSc7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdChyLnNlbGVjdGlvblswXSwgci5zZWxlY3Rpb25bMV0sIHIuc2VsZWN0aW9uWzJdIC0gci5zZWxlY3Rpb25bMF0sIHIuc2VsZWN0aW9uWzNdIC0gci5zZWxlY3Rpb25bMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkYXRhLmJnQWN0aXZlUG9zaXN0aW9uICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gICAgICB2YXIgcG9zID0gZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbjtcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIHN0eWxlLmNvcmUoJ2FjdGl2ZS1iZy1jb2xvcicpLnZhbHVlWzBdICsgJywnICsgc3R5bGUuY29yZSgnYWN0aXZlLWJnLWNvbG9yJykudmFsdWVbMV0gKyAnLCcgKyBzdHlsZS5jb3JlKCdhY3RpdmUtYmctY29sb3InKS52YWx1ZVsyXSArICcsJyArIHN0eWxlLmNvcmUoJ2FjdGl2ZS1iZy1vcGFjaXR5JykudmFsdWUgKyAnKSc7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5hcmMocG9zLngsIHBvcy55LCBzdHlsZS5jb3JlKCdhY3RpdmUtYmctc2l6ZScpLnBmVmFsdWUgLyB6b29tLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICB9XG5cbiAgICB2YXIgdGltZVRvUmVuZGVyID0gci5sYXN0UmVkcmF3VGltZTtcblxuICAgIGlmIChyLnNob3dGcHMgJiYgdGltZVRvUmVuZGVyKSB7XG4gICAgICB0aW1lVG9SZW5kZXIgPSBNYXRoLnJvdW5kKHRpbWVUb1JlbmRlcik7XG4gICAgICB2YXIgZnBzID0gTWF0aC5yb3VuZCgxMDAwIC8gdGltZVRvUmVuZGVyKTtcbiAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNzUpJztcbiAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNzUpJztcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gMTtcbiAgICAgIGNvbnRleHQuZmlsbFRleHQoJzEgZnJhbWUgPSAnICsgdGltZVRvUmVuZGVyICsgJyBtcyA9ICcgKyBmcHMgKyAnIGZwcycsIDAsIDIwKTtcbiAgICAgIHZhciBtYXhGcHMgPSA2MDtcbiAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdCgwLCAzMCwgMjUwLCAyMCk7XG4gICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDMwLCAyNTAgKiBNYXRoLm1pbihmcHMgLyBtYXhGcHMsIDEpLCAyMCk7XG4gICAgfVxuXG4gICAgaWYgKCFkcmF3QWxsTGF5ZXJzKSB7XG4gICAgICBuZWVkRHJhd1tyLlNFTEVDVF9CT1hdID0gZmFsc2U7XG4gICAgfVxuICB9IC8vIG1vdGlvbmJsdXI6IGJsaXQgcmVuZGVyZWQgYmx1cnJ5IGZyYW1lc1xuXG5cbiAgaWYgKG1vdGlvbkJsdXIgJiYgbWJQeFJhdGlvICE9PSAxKSB7XG4gICAgdmFyIGN4dE5vZGUgPSBkYXRhLmNvbnRleHRzW3IuTk9ERV07XG4gICAgdmFyIHR4dE5vZGUgPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFXTtcbiAgICB2YXIgY3h0RHJhZyA9IGRhdGEuY29udGV4dHNbci5EUkFHXTtcbiAgICB2YXIgdHh0RHJhZyA9IHIuZGF0YS5idWZmZXJDYW52YXNlc1tyLk1PVElPTkJMVVJfQlVGRkVSX0RSQUddO1xuXG4gICAgdmFyIGRyYXdNb3Rpb25CbHVyID0gZnVuY3Rpb24gZHJhd01vdGlvbkJsdXIoY3h0LCB0eHQsIG5lZWRDbGVhcikge1xuICAgICAgY3h0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblxuICAgICAgaWYgKG5lZWRDbGVhciB8fCAhbW90aW9uQmx1ckZhZGVFZmZlY3QpIHtcbiAgICAgICAgY3h0LmNsZWFyUmVjdCgwLCAwLCByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYmNsZWFyKGN4dCwgMCwgMCwgci5jYW52YXNXaWR0aCwgci5jYW52YXNIZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHhyID0gbWJQeFJhdGlvO1xuICAgICAgY3h0LmRyYXdJbWFnZSh0eHQsIC8vIGltZ1xuICAgICAgMCwgMCwgLy8gc3gsIHN5XG4gICAgICByLmNhbnZhc1dpZHRoICogcHhyLCByLmNhbnZhc0hlaWdodCAqIHB4ciwgLy8gc3csIHNoXG4gICAgICAwLCAwLCAvLyB4LCB5XG4gICAgICByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCAvLyB3LCBoXG4gICAgICApO1xuICAgIH07XG5cbiAgICBpZiAobmVlZERyYXdbci5OT0RFXSB8fCBuZWVkTWJDbGVhcltyLk5PREVdKSB7XG4gICAgICBkcmF3TW90aW9uQmx1cihjeHROb2RlLCB0eHROb2RlLCBuZWVkTWJDbGVhcltyLk5PREVdKTtcbiAgICAgIG5lZWREcmF3W3IuTk9ERV0gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobmVlZERyYXdbci5EUkFHXSB8fCBuZWVkTWJDbGVhcltyLkRSQUddKSB7XG4gICAgICBkcmF3TW90aW9uQmx1cihjeHREcmFnLCB0eHREcmFnLCBuZWVkTWJDbGVhcltyLkRSQUddKTtcbiAgICAgIG5lZWREcmF3W3IuRFJBR10gPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByLnByZXZWaWV3cG9ydCA9IHZwO1xuXG4gIGlmIChyLmNsZWFyaW5nTW90aW9uQmx1cikge1xuICAgIHIuY2xlYXJpbmdNb3Rpb25CbHVyID0gZmFsc2U7XG4gICAgci5tb3Rpb25CbHVyQ2xlYXJlZCA9IHRydWU7XG4gICAgci5tb3Rpb25CbHVyID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChtb3Rpb25CbHVyKSB7XG4gICAgci5tb3Rpb25CbHVyVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgci5tb3Rpb25CbHVyVGltZW91dCA9IG51bGw7XG4gICAgICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuTk9ERV0gPSBmYWxzZTtcbiAgICAgIHIuY2xlYXJlZEZvck1vdGlvbkJsdXJbci5EUkFHXSA9IGZhbHNlO1xuICAgICAgci5tb3Rpb25CbHVyID0gZmFsc2U7XG4gICAgICByLmNsZWFyaW5nTW90aW9uQmx1ciA9ICF0ZXh0dXJlRHJhdztcbiAgICAgIHIubWJGcmFtZXMgPSAwO1xuICAgICAgbmVlZERyYXdbci5OT0RFXSA9IHRydWU7XG4gICAgICBuZWVkRHJhd1tyLkRSQUddID0gdHJ1ZTtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfSwgbW90aW9uQmx1ckRlbGF5KTtcbiAgfVxuXG4gIGlmICghZm9yY2VkQ29udGV4dCkge1xuICAgIGN5LmVtaXQoJ3JlbmRlcicpO1xuICB9XG59O1xuXG52YXIgQ1JwJDMgPSB7fTsgLy8gQE8gUG9seWdvbiBkcmF3aW5nXG5cbkNScCQzLmRyYXdQb2x5Z29uUGF0aCA9IGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMpIHtcbiAgdmFyIGhhbGZXID0gd2lkdGggLyAyO1xuICB2YXIgaGFsZkggPSBoZWlnaHQgLyAyO1xuXG4gIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIH1cblxuICBjb250ZXh0Lm1vdmVUbyh4ICsgaGFsZlcgKiBwb2ludHNbMF0sIHkgKyBoYWxmSCAqIHBvaW50c1sxXSk7XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgY29udGV4dC5saW5lVG8oeCArIGhhbGZXICogcG9pbnRzW2kgKiAyXSwgeSArIGhhbGZIICogcG9pbnRzW2kgKiAyICsgMV0pO1xuICB9XG5cbiAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG5cbkNScCQzLmRyYXdSb3VuZFBvbHlnb25QYXRoID0gZnVuY3Rpb24gKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHBvaW50cykge1xuICB2YXIgaGFsZlcgPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSCA9IGhlaWdodCAvIDI7XG4gIHZhciBjb3JuZXJSYWRpdXMgPSBnZXRSb3VuZFBvbHlnb25SYWRpdXMod2lkdGgsIGhlaWdodCk7XG5cbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgfVxuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBwb2ludHMubGVuZ3RoIC8gNDsgX2krKykge1xuICAgIHZhciBzb3VyY2VVdiA9IHZvaWQgMCxcbiAgICAgICAgZGVzdFV2ID0gdm9pZCAwO1xuXG4gICAgaWYgKF9pID09PSAwKSB7XG4gICAgICBzb3VyY2VVdiA9IHBvaW50cy5sZW5ndGggLSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3VyY2VVdiA9IF9pICogNCAtIDI7XG4gICAgfVxuXG4gICAgZGVzdFV2ID0gX2kgKiA0ICsgMjtcbiAgICB2YXIgcHggPSB4ICsgaGFsZlcgKiBwb2ludHNbX2kgKiA0XTtcbiAgICB2YXIgcHkgPSB5ICsgaGFsZkggKiBwb2ludHNbX2kgKiA0ICsgMV07XG4gICAgdmFyIGNvc1RoZXRhID0gLXBvaW50c1tzb3VyY2VVdl0gKiBwb2ludHNbZGVzdFV2XSAtIHBvaW50c1tzb3VyY2VVdiArIDFdICogcG9pbnRzW2Rlc3RVdiArIDFdO1xuICAgIHZhciBvZmZzZXQgPSBjb3JuZXJSYWRpdXMgLyBNYXRoLnRhbihNYXRoLmFjb3MoY29zVGhldGEpIC8gMik7XG4gICAgdmFyIGNwMHggPSBweCAtIG9mZnNldCAqIHBvaW50c1tzb3VyY2VVdl07XG4gICAgdmFyIGNwMHkgPSBweSAtIG9mZnNldCAqIHBvaW50c1tzb3VyY2VVdiArIDFdO1xuICAgIHZhciBjcDF4ID0gcHggKyBvZmZzZXQgKiBwb2ludHNbZGVzdFV2XTtcbiAgICB2YXIgY3AxeSA9IHB5ICsgb2Zmc2V0ICogcG9pbnRzW2Rlc3RVdiArIDFdO1xuXG4gICAgaWYgKF9pID09PSAwKSB7XG4gICAgICBjb250ZXh0Lm1vdmVUbyhjcDB4LCBjcDB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5saW5lVG8oY3AweCwgY3AweSk7XG4gICAgfVxuXG4gICAgY29udGV4dC5hcmNUbyhweCwgcHksIGNwMXgsIGNwMXksIGNvcm5lclJhZGl1cyk7XG4gIH1cblxuICBjb250ZXh0LmNsb3NlUGF0aCgpO1xufTsgLy8gUm91bmQgcmVjdGFuZ2xlIGRyYXdpbmdcblxuXG5DUnAkMy5kcmF3Um91bmRSZWN0YW5nbGVQYXRoID0gZnVuY3Rpb24gKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcbiAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuICB2YXIgY29ybmVyUmFkaXVzID0gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCk7XG5cbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgfSAvLyBTdGFydCBhdCB0b3AgbWlkZGxlXG5cblxuICBjb250ZXh0Lm1vdmVUbyh4LCB5IC0gaGFsZkhlaWdodCk7IC8vIEFyYyBmcm9tIG1pZGRsZSB0b3AgdG8gcmlnaHQgc2lkZVxuXG4gIGNvbnRleHQuYXJjVG8oeCArIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQsIHggKyBoYWxmV2lkdGgsIHksIGNvcm5lclJhZGl1cyk7IC8vIEFyYyBmcm9tIHJpZ2h0IHNpZGUgdG8gYm90dG9tXG5cbiAgY29udGV4dC5hcmNUbyh4ICsgaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCwgeCwgeSArIGhhbGZIZWlnaHQsIGNvcm5lclJhZGl1cyk7IC8vIEFyYyBmcm9tIGJvdHRvbSB0byBsZWZ0IHNpZGVcblxuICBjb250ZXh0LmFyY1RvKHggLSBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0LCB4IC0gaGFsZldpZHRoLCB5LCBjb3JuZXJSYWRpdXMpOyAvLyBBcmMgZnJvbSBsZWZ0IHNpZGUgdG8gdG9wQm9yZGVyXG5cbiAgY29udGV4dC5hcmNUbyh4IC0gaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCwgeCwgeSAtIGhhbGZIZWlnaHQsIGNvcm5lclJhZGl1cyk7IC8vIEpvaW4gbGluZVxuXG4gIGNvbnRleHQubGluZVRvKHgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG5cbkNScCQzLmRyYXdCb3R0b21Sb3VuZFJlY3RhbmdsZVBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gIHZhciBjb3JuZXJSYWRpdXMgPSBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcblxuICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICB9IC8vIFN0YXJ0IGF0IHRvcCBtaWRkbGVcblxuXG4gIGNvbnRleHQubW92ZVRvKHgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgY29udGV4dC5saW5lVG8oeCArIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQpO1xuICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoLCB5KTtcbiAgY29udGV4dC5hcmNUbyh4ICsgaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCwgeCwgeSArIGhhbGZIZWlnaHQsIGNvcm5lclJhZGl1cyk7XG4gIGNvbnRleHQuYXJjVG8oeCAtIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQsIHggLSBoYWxmV2lkdGgsIHksIGNvcm5lclJhZGl1cyk7XG4gIGNvbnRleHQubGluZVRvKHggLSBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgY29udGV4dC5saW5lVG8oeCwgeSAtIGhhbGZIZWlnaHQpO1xuICBjb250ZXh0LmNsb3NlUGF0aCgpO1xufTtcblxuQ1JwJDMuZHJhd0N1dFJlY3RhbmdsZVBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gIHZhciBjb3JuZXJMZW5ndGggPSBnZXRDdXRSZWN0YW5nbGVDb3JuZXJMZW5ndGgoKTtcblxuICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICB9XG5cbiAgY29udGV4dC5tb3ZlVG8oeCAtIGhhbGZXaWR0aCArIGNvcm5lckxlbmd0aCwgeSAtIGhhbGZIZWlnaHQpO1xuICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoIC0gY29ybmVyTGVuZ3RoLCB5IC0gaGFsZkhlaWdodCk7XG4gIGNvbnRleHQubGluZVRvKHggKyBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyTGVuZ3RoKTtcbiAgY29udGV4dC5saW5lVG8oeCArIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQgLSBjb3JuZXJMZW5ndGgpO1xuICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoIC0gY29ybmVyTGVuZ3RoLCB5ICsgaGFsZkhlaWdodCk7XG4gIGNvbnRleHQubGluZVRvKHggLSBoYWxmV2lkdGggKyBjb3JuZXJMZW5ndGgsIHkgKyBoYWxmSGVpZ2h0KTtcbiAgY29udGV4dC5saW5lVG8oeCAtIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQgLSBjb3JuZXJMZW5ndGgpO1xuICBjb250ZXh0LmxpbmVUbyh4IC0gaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCArIGNvcm5lckxlbmd0aCk7XG4gIGNvbnRleHQuY2xvc2VQYXRoKCk7XG59O1xuXG5DUnAkMy5kcmF3QmFycmVsUGF0aCA9IGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgdmFyIHhCZWdpbiA9IHggLSBoYWxmV2lkdGg7XG4gIHZhciB4RW5kID0geCArIGhhbGZXaWR0aDtcbiAgdmFyIHlCZWdpbiA9IHkgLSBoYWxmSGVpZ2h0O1xuICB2YXIgeUVuZCA9IHkgKyBoYWxmSGVpZ2h0O1xuICB2YXIgYmFycmVsQ3VydmVDb25zdGFudHMgPSBnZXRCYXJyZWxDdXJ2ZUNvbnN0YW50cyh3aWR0aCwgaGVpZ2h0KTtcbiAgdmFyIHdPZmZzZXQgPSBiYXJyZWxDdXJ2ZUNvbnN0YW50cy53aWR0aE9mZnNldDtcbiAgdmFyIGhPZmZzZXQgPSBiYXJyZWxDdXJ2ZUNvbnN0YW50cy5oZWlnaHRPZmZzZXQ7XG4gIHZhciBjdHJsUHRYT2Zmc2V0ID0gYmFycmVsQ3VydmVDb25zdGFudHMuY3RybFB0T2Zmc2V0UGN0ICogd09mZnNldDtcblxuICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICB9XG5cbiAgY29udGV4dC5tb3ZlVG8oeEJlZ2luLCB5QmVnaW4gKyBoT2Zmc2V0KTtcbiAgY29udGV4dC5saW5lVG8oeEJlZ2luLCB5RW5kIC0gaE9mZnNldCk7XG4gIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh4QmVnaW4gKyBjdHJsUHRYT2Zmc2V0LCB5RW5kLCB4QmVnaW4gKyB3T2Zmc2V0LCB5RW5kKTtcbiAgY29udGV4dC5saW5lVG8oeEVuZCAtIHdPZmZzZXQsIHlFbmQpO1xuICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oeEVuZCAtIGN0cmxQdFhPZmZzZXQsIHlFbmQsIHhFbmQsIHlFbmQgLSBoT2Zmc2V0KTtcbiAgY29udGV4dC5saW5lVG8oeEVuZCwgeUJlZ2luICsgaE9mZnNldCk7XG4gIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh4RW5kIC0gY3RybFB0WE9mZnNldCwgeUJlZ2luLCB4RW5kIC0gd09mZnNldCwgeUJlZ2luKTtcbiAgY29udGV4dC5saW5lVG8oeEJlZ2luICsgd09mZnNldCwgeUJlZ2luKTtcbiAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHhCZWdpbiArIGN0cmxQdFhPZmZzZXQsIHlCZWdpbiwgeEJlZ2luLCB5QmVnaW4gKyBoT2Zmc2V0KTtcbiAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG5cbnZhciBzaW4wID0gTWF0aC5zaW4oMCk7XG52YXIgY29zMCA9IE1hdGguY29zKDApO1xudmFyIHNpbiA9IHt9O1xudmFyIGNvcyA9IHt9O1xudmFyIGVsbGlwc2VTdGVwU2l6ZSA9IE1hdGguUEkgLyA0MDtcblxuZm9yICh2YXIgaSA9IDAgKiBNYXRoLlBJOyBpIDwgMiAqIE1hdGguUEk7IGkgKz0gZWxsaXBzZVN0ZXBTaXplKSB7XG4gIHNpbltpXSA9IE1hdGguc2luKGkpO1xuICBjb3NbaV0gPSBNYXRoLmNvcyhpKTtcbn1cblxuQ1JwJDMuZHJhd0VsbGlwc2VQYXRoID0gZnVuY3Rpb24gKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgfVxuXG4gIGlmIChjb250ZXh0LmVsbGlwc2UpIHtcbiAgICBjb250ZXh0LmVsbGlwc2UoY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLyAyLCBoZWlnaHQgLyAyLCAwLCAwLCAyICogTWF0aC5QSSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHhQb3MsIHlQb3M7XG4gICAgdmFyIHJ3ID0gd2lkdGggLyAyO1xuICAgIHZhciByaCA9IGhlaWdodCAvIDI7XG5cbiAgICBmb3IgKHZhciBpID0gMCAqIE1hdGguUEk7IGkgPCAyICogTWF0aC5QSTsgaSArPSBlbGxpcHNlU3RlcFNpemUpIHtcbiAgICAgIHhQb3MgPSBjZW50ZXJYIC0gcncgKiBzaW5baV0gKiBzaW4wICsgcncgKiBjb3NbaV0gKiBjb3MwO1xuICAgICAgeVBvcyA9IGNlbnRlclkgKyByaCAqIGNvc1tpXSAqIHNpbjAgKyByaCAqIHNpbltpXSAqIGNvczA7XG5cbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHhQb3MsIHlQb3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeFBvcywgeVBvcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG5cbi8qIGdsb2JhbCBhdG9iLCBBcnJheUJ1ZmZlciwgVWludDhBcnJheSwgQmxvYiAqL1xudmFyIENScCQyID0ge307XG5cbkNScCQyLmNyZWF0ZUJ1ZmZlciA9IGZ1bmN0aW9uICh3LCBoKSB7XG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIGJ1ZmZlci53aWR0aCA9IHc7XG4gIGJ1ZmZlci5oZWlnaHQgPSBoO1xuICByZXR1cm4gW2J1ZmZlciwgYnVmZmVyLmdldENvbnRleHQoJzJkJyldO1xufTtcblxuQ1JwJDIuYnVmZmVyQ2FudmFzSW1hZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgY3kgPSB0aGlzLmN5O1xuICB2YXIgZWxlcyA9IGN5Lm11dGFibGVFbGVtZW50cygpO1xuICB2YXIgYmIgPSBlbGVzLmJvdW5kaW5nQm94KCk7XG4gIHZhciBjdHJSZWN0ID0gdGhpcy5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gIHZhciB3aWR0aCA9IG9wdGlvbnMuZnVsbCA/IE1hdGguY2VpbChiYi53KSA6IGN0clJlY3RbMl07XG4gIHZhciBoZWlnaHQgPSBvcHRpb25zLmZ1bGwgPyBNYXRoLmNlaWwoYmIuaCkgOiBjdHJSZWN0WzNdO1xuICB2YXIgc3BlY2RNYXhEaW1zID0gbnVtYmVyJDEob3B0aW9ucy5tYXhXaWR0aCkgfHwgbnVtYmVyJDEob3B0aW9ucy5tYXhIZWlnaHQpO1xuICB2YXIgcHhSYXRpbyA9IHRoaXMuZ2V0UGl4ZWxSYXRpbygpO1xuICB2YXIgc2NhbGUgPSAxO1xuXG4gIGlmIChvcHRpb25zLnNjYWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICB3aWR0aCAqPSBvcHRpb25zLnNjYWxlO1xuICAgIGhlaWdodCAqPSBvcHRpb25zLnNjYWxlO1xuICAgIHNjYWxlID0gb3B0aW9ucy5zY2FsZTtcbiAgfSBlbHNlIGlmIChzcGVjZE1heERpbXMpIHtcbiAgICB2YXIgbWF4U2NhbGVXID0gSW5maW5pdHk7XG4gICAgdmFyIG1heFNjYWxlSCA9IEluZmluaXR5O1xuXG4gICAgaWYgKG51bWJlciQxKG9wdGlvbnMubWF4V2lkdGgpKSB7XG4gICAgICBtYXhTY2FsZVcgPSBzY2FsZSAqIG9wdGlvbnMubWF4V2lkdGggLyB3aWR0aDtcbiAgICB9XG5cbiAgICBpZiAobnVtYmVyJDEob3B0aW9ucy5tYXhIZWlnaHQpKSB7XG4gICAgICBtYXhTY2FsZUggPSBzY2FsZSAqIG9wdGlvbnMubWF4SGVpZ2h0IC8gaGVpZ2h0O1xuICAgIH1cblxuICAgIHNjYWxlID0gTWF0aC5taW4obWF4U2NhbGVXLCBtYXhTY2FsZUgpO1xuICAgIHdpZHRoICo9IHNjYWxlO1xuICAgIGhlaWdodCAqPSBzY2FsZTtcbiAgfVxuXG4gIGlmICghc3BlY2RNYXhEaW1zKSB7XG4gICAgd2lkdGggKj0gcHhSYXRpbztcbiAgICBoZWlnaHQgKj0gcHhSYXRpbztcbiAgICBzY2FsZSAqPSBweFJhdGlvO1xuICB9XG5cbiAgdmFyIGJ1ZmZDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIGJ1ZmZDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgYnVmZkNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIGJ1ZmZDYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gIGJ1ZmZDYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgdmFyIGJ1ZmZDeHQgPSBidWZmQ2FudmFzLmdldENvbnRleHQoJzJkJyk7IC8vIFJhc3Rlcml6ZSB0aGUgbGF5ZXJzLCBidXQgb25seSBpZiBjb250YWluZXIgaGFzIG5vbnplcm8gc2l6ZVxuXG4gIGlmICh3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCkge1xuICAgIGJ1ZmZDeHQuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGJ1ZmZDeHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcbiAgICB2YXIgenNvcnRlZEVsZXMgPSB0aGlzLmdldENhY2hlZFpTb3J0ZWRFbGVzKCk7XG5cbiAgICBpZiAob3B0aW9ucy5mdWxsKSB7XG4gICAgICAvLyBkcmF3IHRoZSBmdWxsIGJvdW5kcyBvZiB0aGUgZ3JhcGhcbiAgICAgIGJ1ZmZDeHQudHJhbnNsYXRlKC1iYi54MSAqIHNjYWxlLCAtYmIueTEgKiBzY2FsZSk7XG4gICAgICBidWZmQ3h0LnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gICAgICB0aGlzLmRyYXdFbGVtZW50cyhidWZmQ3h0LCB6c29ydGVkRWxlcyk7XG4gICAgICBidWZmQ3h0LnNjYWxlKDEgLyBzY2FsZSwgMSAvIHNjYWxlKTtcbiAgICAgIGJ1ZmZDeHQudHJhbnNsYXRlKGJiLngxICogc2NhbGUsIGJiLnkxICogc2NhbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkcmF3IHRoZSBjdXJyZW50IHZpZXdcbiAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICAgIHZhciB0cmFuc2xhdGlvbiA9IHtcbiAgICAgICAgeDogcGFuLnggKiBzY2FsZSxcbiAgICAgICAgeTogcGFuLnkgKiBzY2FsZVxuICAgICAgfTtcbiAgICAgIHNjYWxlICo9IGN5Lnpvb20oKTtcbiAgICAgIGJ1ZmZDeHQudHJhbnNsYXRlKHRyYW5zbGF0aW9uLngsIHRyYW5zbGF0aW9uLnkpO1xuICAgICAgYnVmZkN4dC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICAgICAgdGhpcy5kcmF3RWxlbWVudHMoYnVmZkN4dCwgenNvcnRlZEVsZXMpO1xuICAgICAgYnVmZkN4dC5zY2FsZSgxIC8gc2NhbGUsIDEgLyBzY2FsZSk7XG4gICAgICBidWZmQ3h0LnRyYW5zbGF0ZSgtdHJhbnNsYXRpb24ueCwgLXRyYW5zbGF0aW9uLnkpO1xuICAgIH0gLy8gbmVlZCB0byBmaWxsIGJnIGF0IGVuZCBsaWtlIHRoaXMgaW4gb3JkZXIgdG8gZmlsbCBjbGVhcmVkIHRyYW5zcGFyZW50IHBpeGVscyBpbiBqcGdzXG5cblxuICAgIGlmIChvcHRpb25zLmJnKSB7XG4gICAgICBidWZmQ3h0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdmVyJztcbiAgICAgIGJ1ZmZDeHQuZmlsbFN0eWxlID0gb3B0aW9ucy5iZztcbiAgICAgIGJ1ZmZDeHQucmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGJ1ZmZDeHQuZmlsbCgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWZmQ2FudmFzO1xufTtcblxuZnVuY3Rpb24gYjY0VG9CbG9iKGI2NCwgbWltZVR5cGUpIHtcbiAgdmFyIGJ5dGVzID0gYXRvYihiNjQpO1xuICB2YXIgYnVmZiA9IG5ldyBBcnJheUJ1ZmZlcihieXRlcy5sZW5ndGgpO1xuICB2YXIgYnVmZlVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGJ1ZmZVaW50OFtpXSA9IGJ5dGVzLmNoYXJDb2RlQXQoaSk7XG4gIH1cblxuICByZXR1cm4gbmV3IEJsb2IoW2J1ZmZdLCB7XG4gICAgdHlwZTogbWltZVR5cGVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGI2NFVyaVRvQjY0KGI2NHVyaSkge1xuICB2YXIgaSA9IGI2NHVyaS5pbmRleE9mKCcsJyk7XG4gIHJldHVybiBiNjR1cmkuc3Vic3RyKGkgKyAxKTtcbn1cblxuZnVuY3Rpb24gb3V0cHV0KG9wdGlvbnMsIGNhbnZhcywgbWltZVR5cGUpIHtcbiAgdmFyIGdldEI2NFVyaSA9IGZ1bmN0aW9uIGdldEI2NFVyaSgpIHtcbiAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTChtaW1lVHlwZSwgb3B0aW9ucy5xdWFsaXR5KTtcbiAgfTtcblxuICBzd2l0Y2ggKG9wdGlvbnMub3V0cHV0KSB7XG4gICAgY2FzZSAnYmxvYi1wcm9taXNlJzpcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYW52YXMudG9CbG9iKGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICAgICAgICBpZiAoYmxvYiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoYmxvYik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdgY2FudmFzLnRvQmxvYigpYCBzZW50IGEgbnVsbCB2YWx1ZSBpbiBpdHMgY2FsbGJhY2snKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgbWltZVR5cGUsIG9wdGlvbnMucXVhbGl0eSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIGNhc2UgJ2Jsb2InOlxuICAgICAgcmV0dXJuIGI2NFRvQmxvYihiNjRVcmlUb0I2NChnZXRCNjRVcmkoKSksIG1pbWVUeXBlKTtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gYjY0VXJpVG9CNjQoZ2V0QjY0VXJpKCkpO1xuXG4gICAgY2FzZSAnYmFzZTY0dXJpJzpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGdldEI2NFVyaSgpO1xuICB9XG59XG5cbkNScCQyLnBuZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHJldHVybiBvdXRwdXQob3B0aW9ucywgdGhpcy5idWZmZXJDYW52YXNJbWFnZShvcHRpb25zKSwgJ2ltYWdlL3BuZycpO1xufTtcblxuQ1JwJDIuanBnID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG91dHB1dChvcHRpb25zLCB0aGlzLmJ1ZmZlckNhbnZhc0ltYWdlKG9wdGlvbnMpLCAnaW1hZ2UvanBlZycpO1xufTtcblxudmFyIENScCQxID0ge307XG5cbkNScCQxLm5vZGVTaGFwZUltcGwgPSBmdW5jdGlvbiAobmFtZSwgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ2VsbGlwc2UnOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd0VsbGlwc2VQYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgY2FzZSAncG9seWdvbic6XG4gICAgICByZXR1cm4gdGhpcy5kcmF3UG9seWdvblBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzKTtcblxuICAgIGNhc2UgJ3JvdW5kLXBvbHlnb24nOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd1JvdW5kUG9seWdvblBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzKTtcblxuICAgIGNhc2UgJ3JvdW5kcmVjdGFuZ2xlJzpcbiAgICBjYXNlICdyb3VuZC1yZWN0YW5nbGUnOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd1JvdW5kUmVjdGFuZ2xlUGF0aChjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGNhc2UgJ2N1dHJlY3RhbmdsZSc6XG4gICAgY2FzZSAnY3V0LXJlY3RhbmdsZSc6XG4gICAgICByZXR1cm4gdGhpcy5kcmF3Q3V0UmVjdGFuZ2xlUGF0aChjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGNhc2UgJ2JvdHRvbXJvdW5kcmVjdGFuZ2xlJzpcbiAgICBjYXNlICdib3R0b20tcm91bmQtcmVjdGFuZ2xlJzpcbiAgICAgIHJldHVybiB0aGlzLmRyYXdCb3R0b21Sb3VuZFJlY3RhbmdsZVBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICBjYXNlICdiYXJyZWwnOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd0JhcnJlbFBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gIH1cbn07XG5cbnZhciBDUiA9IENhbnZhc1JlbmRlcmVyO1xudmFyIENScCA9IENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZTtcbkNScC5DQU5WQVNfTEFZRVJTID0gMzsgLy9cblxuQ1JwLlNFTEVDVF9CT1ggPSAwO1xuQ1JwLkRSQUcgPSAxO1xuQ1JwLk5PREUgPSAyO1xuQ1JwLkJVRkZFUl9DT1VOVCA9IDM7IC8vXG5cbkNScC5URVhUVVJFX0JVRkZFUiA9IDA7XG5DUnAuTU9USU9OQkxVUl9CVUZGRVJfTk9ERSA9IDE7XG5DUnAuTU9USU9OQkxVUl9CVUZGRVJfRFJBRyA9IDI7XG5cbmZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKG9wdGlvbnMpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICByLmRhdGEgPSB7XG4gICAgY2FudmFzZXM6IG5ldyBBcnJheShDUnAuQ0FOVkFTX0xBWUVSUyksXG4gICAgY29udGV4dHM6IG5ldyBBcnJheShDUnAuQ0FOVkFTX0xBWUVSUyksXG4gICAgY2FudmFzTmVlZHNSZWRyYXc6IG5ldyBBcnJheShDUnAuQ0FOVkFTX0xBWUVSUyksXG4gICAgYnVmZmVyQ2FudmFzZXM6IG5ldyBBcnJheShDUnAuQlVGRkVSX0NPVU5UKSxcbiAgICBidWZmZXJDb250ZXh0czogbmV3IEFycmF5KENScC5DQU5WQVNfTEFZRVJTKVxuICB9O1xuICB2YXIgdGFwSGxPZmZBdHRyID0gJy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcic7XG4gIHZhciB0YXBIbE9mZlN0eWxlID0gJ3JnYmEoMCwwLDAsMCknO1xuICByLmRhdGEuY2FudmFzQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICB2YXIgY29udGFpbmVyU3R5bGUgPSByLmRhdGEuY2FudmFzQ29udGFpbmVyLnN0eWxlO1xuICByLmRhdGEuY2FudmFzQ29udGFpbmVyLnN0eWxlW3RhcEhsT2ZmQXR0cl0gPSB0YXBIbE9mZlN0eWxlO1xuICBjb250YWluZXJTdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gIGNvbnRhaW5lclN0eWxlLnpJbmRleCA9ICcwJztcbiAgY29udGFpbmVyU3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgdmFyIGNvbnRhaW5lciA9IG9wdGlvbnMuY3kuY29udGFpbmVyKCk7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChyLmRhdGEuY2FudmFzQ29udGFpbmVyKTtcbiAgY29udGFpbmVyLnN0eWxlW3RhcEhsT2ZmQXR0cl0gPSB0YXBIbE9mZlN0eWxlO1xuICB2YXIgc3R5bGVNYXAgPSB7XG4gICAgJy13ZWJraXQtdXNlci1zZWxlY3QnOiAnbm9uZScsXG4gICAgJy1tb3otdXNlci1zZWxlY3QnOiAnLW1vei1ub25lJyxcbiAgICAndXNlci1zZWxlY3QnOiAnbm9uZScsXG4gICAgJy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcic6ICdyZ2JhKDAsMCwwLDApJyxcbiAgICAnb3V0bGluZS1zdHlsZSc6ICdub25lJ1xuICB9O1xuXG4gIGlmIChtcygpKSB7XG4gICAgc3R5bGVNYXBbJy1tcy10b3VjaC1hY3Rpb24nXSA9ICdub25lJztcbiAgICBzdHlsZU1hcFsndG91Y2gtYWN0aW9uJ10gPSAnbm9uZSc7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IENScC5DQU5WQVNfTEFZRVJTOyBpKyspIHtcbiAgICB2YXIgY2FudmFzID0gci5kYXRhLmNhbnZhc2VzW2ldID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgIHIuZGF0YS5jb250ZXh0c1tpXSA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIE9iamVjdC5rZXlzKHN0eWxlTWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBjYW52YXMuc3R5bGVba10gPSBzdHlsZU1hcFtrXTtcbiAgICB9KTtcbiAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgaSk7XG4gICAgY2FudmFzLnN0eWxlLnpJbmRleCA9IFN0cmluZyhDUnAuQ0FOVkFTX0xBWUVSUyAtIGkpO1xuICAgIHIuZGF0YS5jYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbaV0gPSBmYWxzZTtcbiAgfVxuXG4gIHIuZGF0YS50b3BDYW52YXMgPSByLmRhdGEuY2FudmFzZXNbMF07XG4gIHIuZGF0YS5jYW52YXNlc1tDUnAuTk9ERV0uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2xheWVyJyArIENScC5OT0RFICsgJy1ub2RlJyk7XG4gIHIuZGF0YS5jYW52YXNlc1tDUnAuU0VMRUNUX0JPWF0uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2xheWVyJyArIENScC5TRUxFQ1RfQk9YICsgJy1zZWxlY3Rib3gnKTtcbiAgci5kYXRhLmNhbnZhc2VzW0NScC5EUkFHXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgQ1JwLkRSQUcgKyAnLWRyYWcnKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IENScC5CVUZGRVJfQ09VTlQ7IGkrKykge1xuICAgIHIuZGF0YS5idWZmZXJDYW52YXNlc1tpXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICByLmRhdGEuYnVmZmVyQ29udGV4dHNbaV0gPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0uZ2V0Q29udGV4dCgnMmQnKTtcbiAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIHIuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnYnVmZmVyJyArIGkpO1xuICAgIHIuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5zdHlsZS56SW5kZXggPSBTdHJpbmcoLWkgLSAxKTtcbiAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0uc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nOyAvL3IuZGF0YS5jYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQoci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldKTtcbiAgfVxuXG4gIHIucGF0aHNFbmFibGVkID0gdHJ1ZTtcbiAgdmFyIGVtcHR5QmIgPSBtYWtlQm91bmRpbmdCb3goKTtcblxuICB2YXIgZ2V0Qm94Q2VudGVyID0gZnVuY3Rpb24gZ2V0Qm94Q2VudGVyKGJiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IChiYi54MSArIGJiLngyKSAvIDIsXG4gICAgICB5OiAoYmIueTEgKyBiYi55MikgLyAyXG4gICAgfTtcbiAgfTtcblxuICB2YXIgZ2V0Q2VudGVyT2Zmc2V0ID0gZnVuY3Rpb24gZ2V0Q2VudGVyT2Zmc2V0KGJiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IC1iYi53IC8gMixcbiAgICAgIHk6IC1iYi5oIC8gMlxuICAgIH07XG4gIH07XG5cbiAgdmFyIGJhY2tncm91bmRUaW1lc3RhbXBIYXNDaGFuZ2VkID0gZnVuY3Rpb24gYmFja2dyb3VuZFRpbWVzdGFtcEhhc0NoYW5nZWQoZWxlKSB7XG4gICAgdmFyIF9wID0gZWxlWzBdLl9wcml2YXRlO1xuICAgIHZhciBzYW1lID0gX3Aub2xkQmFja2dyb3VuZFRpbWVzdGFtcCA9PT0gX3AuYmFja2dyb3VuZFRpbWVzdGFtcDtcbiAgICByZXR1cm4gIXNhbWU7XG4gIH07XG5cbiAgdmFyIGdldFN0eWxlS2V5ID0gZnVuY3Rpb24gZ2V0U3R5bGVLZXkoZWxlKSB7XG4gICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5ub2RlS2V5O1xuICB9O1xuXG4gIHZhciBnZXRMYWJlbEtleSA9IGZ1bmN0aW9uIGdldExhYmVsS2V5KGVsZSkge1xuICAgIHJldHVybiBlbGVbMF0uX3ByaXZhdGUubGFiZWxTdHlsZUtleTtcbiAgfTtcblxuICB2YXIgZ2V0U291cmNlTGFiZWxLZXkgPSBmdW5jdGlvbiBnZXRTb3VyY2VMYWJlbEtleShlbGUpIHtcbiAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLnNvdXJjZUxhYmVsU3R5bGVLZXk7XG4gIH07XG5cbiAgdmFyIGdldFRhcmdldExhYmVsS2V5ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0TGFiZWxLZXkoZWxlKSB7XG4gICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS50YXJnZXRMYWJlbFN0eWxlS2V5O1xuICB9O1xuXG4gIHZhciBkcmF3RWxlbWVudCA9IGZ1bmN0aW9uIGRyYXdFbGVtZW50KGNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sIHVzZUVsZU9wYWNpdHkpIHtcbiAgICByZXR1cm4gci5kcmF3RWxlbWVudChjb250ZXh0LCBlbGUsIGJiLCBmYWxzZSwgZmFsc2UsIHVzZUVsZU9wYWNpdHkpO1xuICB9O1xuXG4gIHZhciBkcmF3TGFiZWwgPSBmdW5jdGlvbiBkcmF3TGFiZWwoY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgdXNlRWxlT3BhY2l0eSkge1xuICAgIHJldHVybiByLmRyYXdFbGVtZW50VGV4dChjb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duLCAnbWFpbicsIHVzZUVsZU9wYWNpdHkpO1xuICB9O1xuXG4gIHZhciBkcmF3U291cmNlTGFiZWwgPSBmdW5jdGlvbiBkcmF3U291cmNlTGFiZWwoY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgdXNlRWxlT3BhY2l0eSkge1xuICAgIHJldHVybiByLmRyYXdFbGVtZW50VGV4dChjb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duLCAnc291cmNlJywgdXNlRWxlT3BhY2l0eSk7XG4gIH07XG5cbiAgdmFyIGRyYXdUYXJnZXRMYWJlbCA9IGZ1bmN0aW9uIGRyYXdUYXJnZXRMYWJlbChjb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duLCB1c2VFbGVPcGFjaXR5KSB7XG4gICAgcmV0dXJuIHIuZHJhd0VsZW1lbnRUZXh0KGNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sICd0YXJnZXQnLCB1c2VFbGVPcGFjaXR5KTtcbiAgfTtcblxuICB2YXIgZ2V0RWxlbWVudEJveCA9IGZ1bmN0aW9uIGdldEVsZW1lbnRCb3goZWxlKSB7XG4gICAgZWxlLmJvdW5kaW5nQm94KCk7XG4gICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5ib2R5Qm91bmRzO1xuICB9O1xuXG4gIHZhciBnZXRMYWJlbEJveCA9IGZ1bmN0aW9uIGdldExhYmVsQm94KGVsZSkge1xuICAgIGVsZS5ib3VuZGluZ0JveCgpO1xuICAgIHJldHVybiBlbGVbMF0uX3ByaXZhdGUubGFiZWxCb3VuZHMubWFpbiB8fCBlbXB0eUJiO1xuICB9O1xuXG4gIHZhciBnZXRTb3VyY2VMYWJlbEJveCA9IGZ1bmN0aW9uIGdldFNvdXJjZUxhYmVsQm94KGVsZSkge1xuICAgIGVsZS5ib3VuZGluZ0JveCgpO1xuICAgIHJldHVybiBlbGVbMF0uX3ByaXZhdGUubGFiZWxCb3VuZHMuc291cmNlIHx8IGVtcHR5QmI7XG4gIH07XG5cbiAgdmFyIGdldFRhcmdldExhYmVsQm94ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0TGFiZWxCb3goZWxlKSB7XG4gICAgZWxlLmJvdW5kaW5nQm94KCk7XG4gICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5sYWJlbEJvdW5kcy50YXJnZXQgfHwgZW1wdHlCYjtcbiAgfTtcblxuICB2YXIgaXNMYWJlbFZpc2libGVBdFNjYWxlID0gZnVuY3Rpb24gaXNMYWJlbFZpc2libGVBdFNjYWxlKGVsZSwgc2NhbGVkTGFiZWxTaG93bikge1xuICAgIHJldHVybiBzY2FsZWRMYWJlbFNob3duO1xuICB9O1xuXG4gIHZhciBnZXRFbGVtZW50Um90YXRpb25Qb2ludCA9IGZ1bmN0aW9uIGdldEVsZW1lbnRSb3RhdGlvblBvaW50KGVsZSkge1xuICAgIHJldHVybiBnZXRCb3hDZW50ZXIoZ2V0RWxlbWVudEJveChlbGUpKTtcbiAgfTtcblxuICB2YXIgYWRkVGV4dE1hcmdpbiA9IGZ1bmN0aW9uIGFkZFRleHRNYXJnaW4ocHJlZml4LCBwdCwgZWxlKSB7XG4gICAgdmFyIHByZSA9IHByZWZpeCA/IHByZWZpeCArICctJyA6ICcnO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBwdC54ICsgZWxlLnBzdHlsZShwcmUgKyAndGV4dC1tYXJnaW4teCcpLnBmVmFsdWUsXG4gICAgICB5OiBwdC55ICsgZWxlLnBzdHlsZShwcmUgKyAndGV4dC1tYXJnaW4teScpLnBmVmFsdWVcbiAgICB9O1xuICB9O1xuXG4gIHZhciBnZXRSc1B0ID0gZnVuY3Rpb24gZ2V0UnNQdChlbGUsIHgsIHkpIHtcbiAgICB2YXIgcnMgPSBlbGVbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHJzW3hdLFxuICAgICAgeTogcnNbeV1cbiAgICB9O1xuICB9O1xuXG4gIHZhciBnZXRMYWJlbFJvdGF0aW9uUG9pbnQgPSBmdW5jdGlvbiBnZXRMYWJlbFJvdGF0aW9uUG9pbnQoZWxlKSB7XG4gICAgcmV0dXJuIGFkZFRleHRNYXJnaW4oJycsIGdldFJzUHQoZWxlLCAnbGFiZWxYJywgJ2xhYmVsWScpLCBlbGUpO1xuICB9O1xuXG4gIHZhciBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uUG9pbnQgPSBmdW5jdGlvbiBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uUG9pbnQoZWxlKSB7XG4gICAgcmV0dXJuIGFkZFRleHRNYXJnaW4oJ3NvdXJjZScsIGdldFJzUHQoZWxlLCAnc291cmNlTGFiZWxYJywgJ3NvdXJjZUxhYmVsWScpLCBlbGUpO1xuICB9O1xuXG4gIHZhciBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uUG9pbnQgPSBmdW5jdGlvbiBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uUG9pbnQoZWxlKSB7XG4gICAgcmV0dXJuIGFkZFRleHRNYXJnaW4oJ3RhcmdldCcsIGdldFJzUHQoZWxlLCAndGFyZ2V0TGFiZWxYJywgJ3RhcmdldExhYmVsWScpLCBlbGUpO1xuICB9O1xuXG4gIHZhciBnZXRFbGVtZW50Um90YXRpb25PZmZzZXQgPSBmdW5jdGlvbiBnZXRFbGVtZW50Um90YXRpb25PZmZzZXQoZWxlKSB7XG4gICAgcmV0dXJuIGdldENlbnRlck9mZnNldChnZXRFbGVtZW50Qm94KGVsZSkpO1xuICB9O1xuXG4gIHZhciBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uT2Zmc2V0ID0gZnVuY3Rpb24gZ2V0U291cmNlTGFiZWxSb3RhdGlvbk9mZnNldChlbGUpIHtcbiAgICByZXR1cm4gZ2V0Q2VudGVyT2Zmc2V0KGdldFNvdXJjZUxhYmVsQm94KGVsZSkpO1xuICB9O1xuXG4gIHZhciBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvbk9mZnNldChlbGUpIHtcbiAgICByZXR1cm4gZ2V0Q2VudGVyT2Zmc2V0KGdldFRhcmdldExhYmVsQm94KGVsZSkpO1xuICB9O1xuXG4gIHZhciBnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0ID0gZnVuY3Rpb24gZ2V0TGFiZWxSb3RhdGlvbk9mZnNldChlbGUpIHtcbiAgICB2YXIgYmIgPSBnZXRMYWJlbEJveChlbGUpO1xuICAgIHZhciBwID0gZ2V0Q2VudGVyT2Zmc2V0KGdldExhYmVsQm94KGVsZSkpO1xuXG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgc3dpdGNoIChlbGUucHN0eWxlKCd0ZXh0LWhhbGlnbicpLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgIHAueCA9IC1iYi53O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBwLnggPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGVsZS5wc3R5bGUoJ3RleHQtdmFsaWduJykudmFsdWUpIHtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICBwLnkgPSAtYmIuaDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIHAueSA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHA7XG4gIH07XG5cbiAgdmFyIGVsZVR4ckNhY2hlID0gci5kYXRhLmVsZVR4ckNhY2hlID0gbmV3IEVsZW1lbnRUZXh0dXJlQ2FjaGUociwge1xuICAgIGdldEtleTogZ2V0U3R5bGVLZXksXG4gICAgZG9lc0VsZUludmFsaWRhdGVLZXk6IGJhY2tncm91bmRUaW1lc3RhbXBIYXNDaGFuZ2VkLFxuICAgIGRyYXdFbGVtZW50OiBkcmF3RWxlbWVudCxcbiAgICBnZXRCb3VuZGluZ0JveDogZ2V0RWxlbWVudEJveCxcbiAgICBnZXRSb3RhdGlvblBvaW50OiBnZXRFbGVtZW50Um90YXRpb25Qb2ludCxcbiAgICBnZXRSb3RhdGlvbk9mZnNldDogZ2V0RWxlbWVudFJvdGF0aW9uT2Zmc2V0LFxuICAgIGFsbG93RWRnZVR4ckNhY2hpbmc6IGZhbHNlLFxuICAgIGFsbG93UGFyZW50VHhyQ2FjaGluZzogZmFsc2VcbiAgfSk7XG4gIHZhciBsYmxUeHJDYWNoZSA9IHIuZGF0YS5sYmxUeHJDYWNoZSA9IG5ldyBFbGVtZW50VGV4dHVyZUNhY2hlKHIsIHtcbiAgICBnZXRLZXk6IGdldExhYmVsS2V5LFxuICAgIGRyYXdFbGVtZW50OiBkcmF3TGFiZWwsXG4gICAgZ2V0Qm91bmRpbmdCb3g6IGdldExhYmVsQm94LFxuICAgIGdldFJvdGF0aW9uUG9pbnQ6IGdldExhYmVsUm90YXRpb25Qb2ludCxcbiAgICBnZXRSb3RhdGlvbk9mZnNldDogZ2V0TGFiZWxSb3RhdGlvbk9mZnNldCxcbiAgICBpc1Zpc2libGU6IGlzTGFiZWxWaXNpYmxlQXRTY2FsZVxuICB9KTtcbiAgdmFyIHNsYlR4ckNhY2hlID0gci5kYXRhLnNsYlR4ckNhY2hlID0gbmV3IEVsZW1lbnRUZXh0dXJlQ2FjaGUociwge1xuICAgIGdldEtleTogZ2V0U291cmNlTGFiZWxLZXksXG4gICAgZHJhd0VsZW1lbnQ6IGRyYXdTb3VyY2VMYWJlbCxcbiAgICBnZXRCb3VuZGluZ0JveDogZ2V0U291cmNlTGFiZWxCb3gsXG4gICAgZ2V0Um90YXRpb25Qb2ludDogZ2V0U291cmNlTGFiZWxSb3RhdGlvblBvaW50LFxuICAgIGdldFJvdGF0aW9uT2Zmc2V0OiBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uT2Zmc2V0LFxuICAgIGlzVmlzaWJsZTogaXNMYWJlbFZpc2libGVBdFNjYWxlXG4gIH0pO1xuICB2YXIgdGxiVHhyQ2FjaGUgPSByLmRhdGEudGxiVHhyQ2FjaGUgPSBuZXcgRWxlbWVudFRleHR1cmVDYWNoZShyLCB7XG4gICAgZ2V0S2V5OiBnZXRUYXJnZXRMYWJlbEtleSxcbiAgICBkcmF3RWxlbWVudDogZHJhd1RhcmdldExhYmVsLFxuICAgIGdldEJvdW5kaW5nQm94OiBnZXRUYXJnZXRMYWJlbEJveCxcbiAgICBnZXRSb3RhdGlvblBvaW50OiBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uUG9pbnQsXG4gICAgZ2V0Um90YXRpb25PZmZzZXQ6IGdldFRhcmdldExhYmVsUm90YXRpb25PZmZzZXQsXG4gICAgaXNWaXNpYmxlOiBpc0xhYmVsVmlzaWJsZUF0U2NhbGVcbiAgfSk7XG4gIHZhciBseXJUeHJDYWNoZSA9IHIuZGF0YS5seXJUeHJDYWNoZSA9IG5ldyBMYXllcmVkVGV4dHVyZUNhY2hlKHIpO1xuICByLm9uVXBkYXRlRWxlQ2FsY3MoZnVuY3Rpb24gaW52YWxpZGF0ZVRleHR1cmVDYWNoZXMod2lsbERyYXcsIGVsZXMpIHtcbiAgICAvLyBlYWNoIGNhY2hlIHNob3VsZCBjaGVjayBmb3Igc3ViLWtleSBkaWZmIHRvIHNlZSB0aGF0IHRoZSB1cGRhdGUgYWZmZWN0cyB0aGF0IGNhY2hlIHBhcnRpY3VsYXJseVxuICAgIGVsZVR4ckNhY2hlLmludmFsaWRhdGVFbGVtZW50cyhlbGVzKTtcbiAgICBsYmxUeHJDYWNoZS5pbnZhbGlkYXRlRWxlbWVudHMoZWxlcyk7XG4gICAgc2xiVHhyQ2FjaGUuaW52YWxpZGF0ZUVsZW1lbnRzKGVsZXMpO1xuICAgIHRsYlR4ckNhY2hlLmludmFsaWRhdGVFbGVtZW50cyhlbGVzKTsgLy8gYW55IGNoYW5nZSBpbnZhbGlkYXRlcyB0aGUgbGF5ZXJzXG5cbiAgICBseXJUeHJDYWNoZS5pbnZhbGlkYXRlRWxlbWVudHMoZWxlcyk7IC8vIHVwZGF0ZSB0aGUgb2xkIGJnIHRpbWVzdGFtcCBzbyBkaWZmcyBjYW4gYmUgZG9uZSBpbiB0aGUgZWxlIHR4ciBjYWNoZXNcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBlbGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9wID0gZWxlc1tfaV0uX3ByaXZhdGU7XG4gICAgICBfcC5vbGRCYWNrZ3JvdW5kVGltZXN0YW1wID0gX3AuYmFja2dyb3VuZFRpbWVzdGFtcDtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciByZWZpbmVJbkxheWVycyA9IGZ1bmN0aW9uIHJlZmluZUluTGF5ZXJzKHJlcXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGx5clR4ckNhY2hlLmVucXVldWVFbGVtZW50UmVmaW5lbWVudChyZXFzW2ldLmVsZSk7XG4gICAgfVxuICB9O1xuXG4gIGVsZVR4ckNhY2hlLm9uRGVxdWV1ZShyZWZpbmVJbkxheWVycyk7XG4gIGxibFR4ckNhY2hlLm9uRGVxdWV1ZShyZWZpbmVJbkxheWVycyk7XG4gIHNsYlR4ckNhY2hlLm9uRGVxdWV1ZShyZWZpbmVJbkxheWVycyk7XG4gIHRsYlR4ckNhY2hlLm9uRGVxdWV1ZShyZWZpbmVJbkxheWVycyk7XG59XG5cbkNScC5yZWRyYXdIaW50ID0gZnVuY3Rpb24gKGdyb3VwLCBib29sKSB7XG4gIHZhciByID0gdGhpcztcblxuICBzd2l0Y2ggKGdyb3VwKSB7XG4gICAgY2FzZSAnZWxlcyc6XG4gICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ1JwLk5PREVdID0gYm9vbDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnZHJhZyc6XG4gICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ1JwLkRSQUddID0gYm9vbDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDUnAuU0VMRUNUX0JPWF0gPSBib29sO1xuICAgICAgYnJlYWs7XG4gIH1cbn07IC8vIHdoZXRoZXIgdG8gdXNlIFBhdGgyRCBjYWNoaW5nIGZvciBkcmF3aW5nXG5cblxudmFyIHBhdGhzSW1wbGQgPSB0eXBlb2YgUGF0aDJEICE9PSAndW5kZWZpbmVkJztcblxuQ1JwLnBhdGgyZEVuYWJsZWQgPSBmdW5jdGlvbiAob24pIHtcbiAgaWYgKG9uID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdGhpcy5wYXRoc0VuYWJsZWQ7XG4gIH1cblxuICB0aGlzLnBhdGhzRW5hYmxlZCA9IG9uID8gdHJ1ZSA6IGZhbHNlO1xufTtcblxuQ1JwLnVzZVBhdGhzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcGF0aHNJbXBsZCAmJiB0aGlzLnBhdGhzRW5hYmxlZDtcbn07XG5cbkNScC5zZXRJbWdTbW9vdGhpbmcgPSBmdW5jdGlvbiAoY29udGV4dCwgYm9vbCkge1xuICBpZiAoY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgIT0gbnVsbCkge1xuICAgIGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gYm9vbDtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGJvb2w7XG4gICAgY29udGV4dC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBib29sO1xuICAgIGNvbnRleHQubXNJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBib29sO1xuICB9XG59O1xuXG5DUnAuZ2V0SW1nU21vb3RoaW5nID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgaWYgKGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkICE9IG51bGwpIHtcbiAgICByZXR1cm4gY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRleHQud2Via2l0SW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8IGNvbnRleHQubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8IGNvbnRleHQubXNJbWFnZVNtb290aGluZ0VuYWJsZWQ7XG4gIH1cbn07XG5cbkNScC5tYWtlT2Zmc2NyZWVuQ2FudmFzID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIGNhbnZhcztcblxuICBpZiAoKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihPZmZzY3JlZW5DYW52YXMpKSAhPT0gKFwidW5kZWZpbmVkXCIgKSkge1xuICAgIGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gIH0gZWxzZSB7XG4gICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cblxuICByZXR1cm4gY2FudmFzO1xufTtcblxuW0NScCRhLCBDUnAkOSwgQ1JwJDgsIENScCQ3LCBDUnAkNiwgQ1JwJDUsIENScCQ0LCBDUnAkMywgQ1JwJDIsIENScCQxXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICBleHRlbmQoQ1JwLCBwcm9wcyk7XG59KTtcblxudmFyIHJlbmRlcmVyID0gW3tcbiAgbmFtZTogJ251bGwnLFxuICBpbXBsOiBOdWxsUmVuZGVyZXJcbn0sIHtcbiAgbmFtZTogJ2Jhc2UnLFxuICBpbXBsOiBCUlxufSwge1xuICBuYW1lOiAnY2FudmFzJyxcbiAgaW1wbDogQ1Jcbn1dO1xuXG52YXIgaW5jRXh0cyA9IFt7XG4gIHR5cGU6ICdsYXlvdXQnLFxuICBleHRlbnNpb25zOiBsYXlvdXRcbn0sIHtcbiAgdHlwZTogJ3JlbmRlcmVyJyxcbiAgZXh0ZW5zaW9uczogcmVuZGVyZXJcbn1dO1xuXG52YXIgZXh0ZW5zaW9ucyA9IHt9OyAvLyByZWdpc3RlcmVkIG1vZHVsZXMgZm9yIGV4dGVuc2lvbnMsIGluZGV4ZWQgYnkgbmFtZVxuXG52YXIgbW9kdWxlcyA9IHt9O1xuXG5mdW5jdGlvbiBzZXRFeHRlbnNpb24odHlwZSwgbmFtZSwgcmVnaXN0cmFudCkge1xuICB2YXIgZXh0ID0gcmVnaXN0cmFudDtcblxuICB2YXIgb3ZlcnJpZGVFcnIgPSBmdW5jdGlvbiBvdmVycmlkZUVycihmaWVsZCkge1xuICAgIHdhcm4oJ0NhbiBub3QgcmVnaXN0ZXIgYCcgKyBuYW1lICsgJ2AgZm9yIGAnICsgdHlwZSArICdgIHNpbmNlIGAnICsgZmllbGQgKyAnYCBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgcHJvdG90eXBlIGFuZCBjYW4gbm90IGJlIG92ZXJyaWRkZW4nKTtcbiAgfTtcblxuICBpZiAodHlwZSA9PT0gJ2NvcmUnKSB7XG4gICAgaWYgKENvcmUucHJvdG90eXBlW25hbWVdKSB7XG4gICAgICByZXR1cm4gb3ZlcnJpZGVFcnIobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIENvcmUucHJvdG90eXBlW25hbWVdID0gcmVnaXN0cmFudDtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NvbGxlY3Rpb24nKSB7XG4gICAgaWYgKENvbGxlY3Rpb24ucHJvdG90eXBlW25hbWVdKSB7XG4gICAgICByZXR1cm4gb3ZlcnJpZGVFcnIobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlW25hbWVdID0gcmVnaXN0cmFudDtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2xheW91dCcpIHtcbiAgICAvLyBmaWxsIGluIG1pc3NpbmcgbGF5b3V0IGZ1bmN0aW9ucyBpbiB0aGUgcHJvdG90eXBlXG4gICAgdmFyIExheW91dCA9IGZ1bmN0aW9uIExheW91dChvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgcmVnaXN0cmFudC5jYWxsKHRoaXMsIG9wdGlvbnMpOyAvLyBtYWtlIHN1cmUgbGF5b3V0IGhhcyBfcHJpdmF0ZSBmb3IgdXNlIHcvIHN0ZCBhcGlzIGxpa2UgLm9uKClcblxuICAgICAgaWYgKCFwbGFpbk9iamVjdCh0aGlzLl9wcml2YXRlKSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlID0ge307XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3ByaXZhdGUuY3kgPSBvcHRpb25zLmN5O1xuICAgICAgdGhpcy5fcHJpdmF0ZS5saXN0ZW5lcnMgPSBbXTtcbiAgICAgIHRoaXMuY3JlYXRlRW1pdHRlcigpO1xuICAgIH07XG5cbiAgICB2YXIgbGF5b3V0UHJvdG8gPSBMYXlvdXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShyZWdpc3RyYW50LnByb3RvdHlwZSk7XG4gICAgdmFyIG9wdExheW91dEZucyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRMYXlvdXRGbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBmbk5hbWUgPSBvcHRMYXlvdXRGbnNbaV07XG5cbiAgICAgIGxheW91dFByb3RvW2ZuTmFtZV0gPSBsYXlvdXRQcm90b1tmbk5hbWVdIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH0gLy8gZWl0aGVyIC5zdGFydCgpIG9yIC5ydW4oKSBpcyBkZWZpbmVkLCBzbyBhdXRvZ2VuIHRoZSBvdGhlclxuXG5cbiAgICBpZiAobGF5b3V0UHJvdG8uc3RhcnQgJiYgIWxheW91dFByb3RvLnJ1bikge1xuICAgICAgbGF5b3V0UHJvdG8ucnVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCFsYXlvdXRQcm90by5zdGFydCAmJiBsYXlvdXRQcm90by5ydW4pIHtcbiAgICAgIGxheW91dFByb3RvLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJ1bigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHJlZ1N0b3AgPSByZWdpc3RyYW50LnByb3RvdHlwZS5zdG9wO1xuXG4gICAgbGF5b3V0UHJvdG8uc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICBpZiAob3B0cyAmJiBvcHRzLmFuaW1hdGUpIHtcbiAgICAgICAgdmFyIGFuaXMgPSB0aGlzLmFuaW1hdGlvbnM7XG5cbiAgICAgICAgaWYgKGFuaXMpIHtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYW5pcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFuaXNbX2ldLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlZ1N0b3ApIHtcbiAgICAgICAgcmVnU3RvcC5jYWxsKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbWl0KCdsYXlvdXRzdG9wJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBpZiAoIWxheW91dFByb3RvLmRlc3Ryb3kpIHtcbiAgICAgIGxheW91dFByb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBsYXlvdXRQcm90by5jeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmN5O1xuICAgIH07XG5cbiAgICB2YXIgZ2V0Q3kgPSBmdW5jdGlvbiBnZXRDeShsYXlvdXQpIHtcbiAgICAgIHJldHVybiBsYXlvdXQuX3ByaXZhdGUuY3k7XG4gICAgfTtcblxuICAgIHZhciBlbWl0dGVyT3B0cyA9IHtcbiAgICAgIGFkZEV2ZW50RmllbGRzOiBmdW5jdGlvbiBhZGRFdmVudEZpZWxkcyhsYXlvdXQsIGV2dCkge1xuICAgICAgICBldnQubGF5b3V0ID0gbGF5b3V0O1xuICAgICAgICBldnQuY3kgPSBnZXRDeShsYXlvdXQpO1xuICAgICAgICBldnQudGFyZ2V0ID0gbGF5b3V0O1xuICAgICAgfSxcbiAgICAgIGJ1YmJsZTogZnVuY3Rpb24gYnViYmxlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChsYXlvdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldEN5KGxheW91dCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHRlbmQobGF5b3V0UHJvdG8sIHtcbiAgICAgIGNyZWF0ZUVtaXR0ZXI6IGZ1bmN0aW9uIGNyZWF0ZUVtaXR0ZXIoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUuZW1pdHRlciA9IG5ldyBFbWl0dGVyKGVtaXR0ZXJPcHRzLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgZW1pdHRlcjogZnVuY3Rpb24gZW1pdHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZW1pdHRlcjtcbiAgICAgIH0sXG4gICAgICBvbjogZnVuY3Rpb24gb24oZXZ0LCBjYikge1xuICAgICAgICB0aGlzLmVtaXR0ZXIoKS5vbihldnQsIGNiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgb25lOiBmdW5jdGlvbiBvbmUoZXZ0LCBjYikge1xuICAgICAgICB0aGlzLmVtaXR0ZXIoKS5vbmUoZXZ0LCBjYik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG9uY2U6IGZ1bmN0aW9uIG9uY2UoZXZ0LCBjYikge1xuICAgICAgICB0aGlzLmVtaXR0ZXIoKS5vbmUoZXZ0LCBjYik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZUxpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldnQsIGNiKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlcigpLnJlbW92ZUxpc3RlbmVyKGV2dCwgY2IpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICByZW1vdmVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyKCkucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGVtaXQ6IGZ1bmN0aW9uIGVtaXQoZXZ0LCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyKCkuZW1pdChldnQsIHBhcmFtcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRlZmluZS5ldmVudEFsaWFzZXNPbihsYXlvdXRQcm90byk7XG4gICAgZXh0ID0gTGF5b3V0OyAvLyByZXBsYWNlIHdpdGggb3VyIHdyYXBwZWQgbGF5b3V0XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3JlbmRlcmVyJyAmJiBuYW1lICE9PSAnbnVsbCcgJiYgbmFtZSAhPT0gJ2Jhc2UnKSB7XG4gICAgLy8gdXNlciByZWdpc3RlcmVkIHJlbmRlcmVycyBpbmhlcml0IGZyb20gYmFzZVxuICAgIHZhciBCYXNlUmVuZGVyZXIgPSBnZXRFeHRlbnNpb24oJ3JlbmRlcmVyJywgJ2Jhc2UnKTtcbiAgICB2YXIgYlByb3RvID0gQmFzZVJlbmRlcmVyLnByb3RvdHlwZTtcbiAgICB2YXIgUmVnaXN0cmFudFJlbmRlcmVyID0gcmVnaXN0cmFudDtcbiAgICB2YXIgclByb3RvID0gcmVnaXN0cmFudC5wcm90b3R5cGU7XG5cbiAgICB2YXIgUmVuZGVyZXIgPSBmdW5jdGlvbiBSZW5kZXJlcigpIHtcbiAgICAgIEJhc2VSZW5kZXJlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgUmVnaXN0cmFudFJlbmRlcmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIHZhciBwcm90byA9IFJlbmRlcmVyLnByb3RvdHlwZTtcblxuICAgIGZvciAodmFyIHBOYW1lIGluIGJQcm90bykge1xuICAgICAgdmFyIHBWYWwgPSBiUHJvdG9bcE5hbWVdO1xuICAgICAgdmFyIGV4aXN0c0luUiA9IHJQcm90b1twTmFtZV0gIT0gbnVsbDtcblxuICAgICAgaWYgKGV4aXN0c0luUikge1xuICAgICAgICByZXR1cm4gb3ZlcnJpZGVFcnIocE5hbWUpO1xuICAgICAgfVxuXG4gICAgICBwcm90b1twTmFtZV0gPSBwVmFsOyAvLyB0YWtlIGltcGwgZnJvbSBiYXNlXG4gICAgfVxuXG4gICAgZm9yICh2YXIgX3BOYW1lIGluIHJQcm90bykge1xuICAgICAgcHJvdG9bX3BOYW1lXSA9IHJQcm90b1tfcE5hbWVdOyAvLyB0YWtlIGltcGwgZnJvbSByZWdpc3RyYW50XG4gICAgfVxuXG4gICAgYlByb3RvLmNsaWVudEZ1bmN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBwcm90b1tuYW1lXSA9IHByb3RvW25hbWVdIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZXJyb3IoJ1JlbmRlcmVyIGRvZXMgbm90IGltcGxlbWVudCBgcmVuZGVyZXIuJyArIG5hbWUgKyAnKClgIG9uIGl0cyBwcm90b3R5cGUnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgZXh0ID0gUmVuZGVyZXI7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ19fcHJvdG9fXycgfHwgdHlwZSA9PT0gJ2NvbnN0cnVjdG9yJyB8fCB0eXBlID09PSAncHJvdG90eXBlJykge1xuICAgIC8vIHRvIGF2b2lkIHBvdGVudGlhbCBwcm90b3R5cGUgcG9sbHV0aW9uXG4gICAgcmV0dXJuIGVycm9yKHR5cGUgKyAnIGlzIGFuIGlsbGVnYWwgdHlwZSB0byBiZSByZWdpc3RlcmVkLCBwb3NzaWJseSBsZWFkIHRvIHByb3RvdHlwZSBwb2xsdXRpb25zJyk7XG4gIH1cblxuICByZXR1cm4gc2V0TWFwKHtcbiAgICBtYXA6IGV4dGVuc2lvbnMsXG4gICAga2V5czogW3R5cGUsIG5hbWVdLFxuICAgIHZhbHVlOiBleHRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEV4dGVuc2lvbih0eXBlLCBuYW1lKSB7XG4gIHJldHVybiBnZXRNYXAoe1xuICAgIG1hcDogZXh0ZW5zaW9ucyxcbiAgICBrZXlzOiBbdHlwZSwgbmFtZV1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNldE1vZHVsZSh0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lLCByZWdpc3RyYW50KSB7XG4gIHJldHVybiBzZXRNYXAoe1xuICAgIG1hcDogbW9kdWxlcyxcbiAgICBrZXlzOiBbdHlwZSwgbmFtZSwgbW9kdWxlVHlwZSwgbW9kdWxlTmFtZV0sXG4gICAgdmFsdWU6IHJlZ2lzdHJhbnRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldE1vZHVsZSh0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lKSB7XG4gIHJldHVybiBnZXRNYXAoe1xuICAgIG1hcDogbW9kdWxlcyxcbiAgICBrZXlzOiBbdHlwZSwgbmFtZSwgbW9kdWxlVHlwZSwgbW9kdWxlTmFtZV1cbiAgfSk7XG59XG5cbnZhciBleHRlbnNpb24gPSBmdW5jdGlvbiBleHRlbnNpb24oKSB7XG4gIC8vIGUuZy4gZXh0ZW5zaW9uKCdyZW5kZXJlcicsICdzdmcnKVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHJldHVybiBnZXRFeHRlbnNpb24uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfSAvLyBlLmcuIGV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJywgeyAuLi4gfSlcbiAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHJldHVybiBzZXRFeHRlbnNpb24uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfSAvLyBlLmcuIGV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJywgJ25vZGVTaGFwZScsICdlbGxpcHNlJylcbiAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgIHJldHVybiBnZXRNb2R1bGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfSAvLyBlLmcuIGV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJywgJ25vZGVTaGFwZScsICdlbGxpcHNlJywgeyAuLi4gfSlcbiAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNSkge1xuICAgIHJldHVybiBzZXRNb2R1bGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICBlcnJvcignSW52YWxpZCBleHRlbnNpb24gYWNjZXNzIHN5bnRheCcpO1xuICB9XG59OyAvLyBhbGxvd3MgYSBjb3JlIGluc3RhbmNlIHRvIGFjY2VzcyBleHRlbnNpb25zIGludGVybmFsbHlcblxuXG5Db3JlLnByb3RvdHlwZS5leHRlbnNpb24gPSBleHRlbnNpb247IC8vIGluY2x1ZGVkIGV4dGVuc2lvbnNcblxuaW5jRXh0cy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCkge1xuICBncm91cC5leHRlbnNpb25zLmZvckVhY2goZnVuY3Rpb24gKGV4dCkge1xuICAgIHNldEV4dGVuc2lvbihncm91cC50eXBlLCBleHQubmFtZSwgZXh0LmltcGwpO1xuICB9KTtcbn0pO1xuXG4vLyAodXNlZnVsIGZvciBpbml0KVxuXG52YXIgU3R5bGVzaGVldCA9IGZ1bmN0aW9uIFN0eWxlc2hlZXQoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdHlsZXNoZWV0KSkge1xuICAgIHJldHVybiBuZXcgU3R5bGVzaGVldCgpO1xuICB9XG5cbiAgdGhpcy5sZW5ndGggPSAwO1xufTtcblxudmFyIHNoZWV0Zm4gPSBTdHlsZXNoZWV0LnByb3RvdHlwZTtcblxuc2hlZXRmbi5pbnN0YW5jZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICdzdHlsZXNoZWV0Jztcbn07IC8vIGp1c3Qgc3RvcmUgdGhlIHNlbGVjdG9yIHRvIGJlIHBhcnNlZCBsYXRlclxuXG5cbnNoZWV0Zm4uc2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgdmFyIGkgPSB0aGlzLmxlbmd0aCsrO1xuICB0aGlzW2ldID0ge1xuICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICBwcm9wZXJ0aWVzOiBbXVxuICB9O1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07IC8vIGp1c3Qgc3RvcmUgdGhlIHByb3BlcnR5IHRvIGJlIHBhcnNlZCBsYXRlclxuXG5cbnNoZWV0Zm4uY3NzID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpID0gdGhpcy5sZW5ndGggLSAxO1xuXG4gIGlmIChzdHJpbmcobmFtZSkpIHtcbiAgICB0aGlzW2ldLnByb3BlcnRpZXMucHVzaCh7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocGxhaW5PYmplY3QobmFtZSkpIHtcbiAgICB2YXIgbWFwID0gbmFtZTtcbiAgICB2YXIgcHJvcE5hbWVzID0gT2JqZWN0LmtleXMobWFwKTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJvcE5hbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcE5hbWVzW2pdO1xuICAgICAgdmFyIG1hcFZhbCA9IG1hcFtrZXldO1xuXG4gICAgICBpZiAobWFwVmFsID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wID0gU3R5bGUucHJvcGVydGllc1trZXldIHx8IFN0eWxlLnByb3BlcnRpZXNbZGFzaDJjYW1lbChrZXkpXTtcblxuICAgICAgaWYgKHByb3AgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9uYW1lID0gcHJvcC5uYW1lO1xuICAgICAgdmFyIF92YWx1ZSA9IG1hcFZhbDtcbiAgICAgIHRoaXNbaV0ucHJvcGVydGllcy5wdXNoKHtcbiAgICAgICAgbmFtZTogX25hbWUsXG4gICAgICAgIHZhbHVlOiBfdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuc2hlZXRmbi5zdHlsZSA9IHNoZWV0Zm4uY3NzOyAvLyBnZW5lcmF0ZSBhIHJlYWwgc3R5bGUgb2JqZWN0IGZyb20gdGhlIGR1bW15IHN0eWxlc2hlZXRcblxuc2hlZXRmbi5nZW5lcmF0ZVN0eWxlID0gZnVuY3Rpb24gKGN5KSB7XG4gIHZhciBzdHlsZSA9IG5ldyBTdHlsZShjeSk7XG4gIHJldHVybiB0aGlzLmFwcGVuZFRvU3R5bGUoc3R5bGUpO1xufTsgLy8gYXBwZW5kIGEgZHVtbXkgc3R5bGVzaGVldCBvYmplY3Qgb24gYSByZWFsIHN0eWxlIG9iamVjdFxuXG5cbnNoZWV0Zm4uYXBwZW5kVG9TdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXNbaV07XG4gICAgdmFyIHNlbGVjdG9yID0gY29udGV4dC5zZWxlY3RvcjtcbiAgICB2YXIgcHJvcHMgPSBjb250ZXh0LnByb3BlcnRpZXM7XG4gICAgc3R5bGUuc2VsZWN0b3Ioc2VsZWN0b3IpOyAvLyBhcHBseSBzZWxlY3RvclxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcbiAgICAgIHN0eWxlLmNzcyhwcm9wLm5hbWUsIHByb3AudmFsdWUpOyAvLyBhcHBseSBwcm9wZXJ0eVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn07XG5cbnZhciB2ZXJzaW9uID0gXCIzLjI2LjBcIjtcblxudmFyIGN5dG9zY2FwZSA9IGZ1bmN0aW9uIGN5dG9zY2FwZShvcHRpb25zKSB7XG4gIC8vIGlmIG5vIG9wdGlvbnMgc3BlY2lmaWVkLCB1c2UgZGVmYXVsdFxuICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9IC8vIGNyZWF0ZSBpbnN0YW5jZVxuXG5cbiAgaWYgKHBsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIG5ldyBDb3JlKG9wdGlvbnMpO1xuICB9IC8vIGFsbG93IGZvciByZWdpc3RyYXRpb24gb2YgZXh0ZW5zaW9uc1xuICBlbHNlIGlmIChzdHJpbmcob3B0aW9ucykpIHtcbiAgICByZXR1cm4gZXh0ZW5zaW9uLmFwcGx5KGV4dGVuc2lvbiwgYXJndW1lbnRzKTtcbiAgfVxufTsgLy8gZS5nLiBjeXRvc2NhcGUudXNlKCByZXF1aXJlKCdjeXRvc2NhcGUtZm9vJyksIGJhciApXG5cblxuY3l0b3NjYXBlLnVzZSA9IGZ1bmN0aW9uIChleHQpIHtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyAvLyBhcmdzIHRvIHBhc3MgdG8gZXh0XG5cbiAgYXJncy51bnNoaWZ0KGN5dG9zY2FwZSk7IC8vIGN5dG9zY2FwZSBpcyBmaXJzdCBhcmcgdG8gZXh0XG5cbiAgZXh0LmFwcGx5KG51bGwsIGFyZ3MpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmN5dG9zY2FwZS53YXJuaW5ncyA9IGZ1bmN0aW9uIChib29sKSB7XG4gIHJldHVybiB3YXJuaW5ncyhib29sKTtcbn07IC8vIHJlcGxhY2VkIGJ5IGJ1aWxkIHN5c3RlbVxuXG5cbmN5dG9zY2FwZS52ZXJzaW9uID0gdmVyc2lvbjsgLy8gZXhwb3NlIHB1YmxpYyBhcGlzIChtb3N0bHkgZm9yIGV4dGVuc2lvbnMpXG5cbmN5dG9zY2FwZS5zdHlsZXNoZWV0ID0gY3l0b3NjYXBlLlN0eWxlc2hlZXQgPSBTdHlsZXNoZWV0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGN5dG9zY2FwZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/cytoscape/dist/cytoscape.cjs.js\n");

/***/ }),

/***/ "../node_modules/heap/index.js":
/*!*************************************!*\
  !*** ../node_modules/heap/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./lib/heap */ \"../node_modules/heap/lib/heap.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2hlYXAvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsMEZBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oZWFwL2luZGV4LmpzPzgxMWUiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9oZWFwJyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/heap/index.js\n");

/***/ }),

/***/ "../node_modules/heap/lib/heap.js":
/*!****************************************!*\
  !*** ../node_modules/heap/lib/heap.js ***!
  \****************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (true) {\n      return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2hlYXAvbGliL2hlYXAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsbUNBQW1DLDBCQUEwQjtBQUNwSDtBQUNBLEtBQUs7QUFDTDtBQUNBLHNDQUFzQyxXQUFXO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsV0FBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxzQ0FBc0M7QUFDekY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0EsUUFBUSxJQUEwQztBQUNsRCxhQUFhLGlDQUFPLEVBQUUsb0NBQUUsT0FBTztBQUFBO0FBQUE7QUFBQSxrR0FBQztBQUNoQyxNQUFNLEtBQUssRUFJTjtBQUNMLEdBQUc7QUFDSDtBQUNBLEdBQUc7O0FBRUgsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaGVhcC9saWIvaGVhcC5qcz9iZTdjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS44LjBcbihmdW5jdGlvbigpIHtcbiAgdmFyIEhlYXAsIGRlZmF1bHRDbXAsIGZsb29yLCBoZWFwaWZ5LCBoZWFwcG9wLCBoZWFwcHVzaCwgaGVhcHB1c2hwb3AsIGhlYXByZXBsYWNlLCBpbnNvcnQsIG1pbiwgbmxhcmdlc3QsIG5zbWFsbGVzdCwgdXBkYXRlSXRlbSwgX3NpZnRkb3duLCBfc2lmdHVwO1xuXG4gIGZsb29yID0gTWF0aC5mbG9vciwgbWluID0gTWF0aC5taW47XG5cblxuICAvKlxuICBEZWZhdWx0IGNvbXBhcmlzb24gZnVuY3Rpb24gdG8gYmUgdXNlZFxuICAgKi9cblxuICBkZWZhdWx0Q21wID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIGlmICh4IDwgeSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoeCA+IHkpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcblxuXG4gIC8qXG4gIEluc2VydCBpdGVtIHggaW4gbGlzdCBhLCBhbmQga2VlcCBpdCBzb3J0ZWQgYXNzdW1pbmcgYSBpcyBzb3J0ZWQuXG4gIFxuICBJZiB4IGlzIGFscmVhZHkgaW4gYSwgaW5zZXJ0IGl0IHRvIHRoZSByaWdodCBvZiB0aGUgcmlnaHRtb3N0IHguXG4gIFxuICBPcHRpb25hbCBhcmdzIGxvIChkZWZhdWx0IDApIGFuZCBoaSAoZGVmYXVsdCBhLmxlbmd0aCkgYm91bmQgdGhlIHNsaWNlXG4gIG9mIGEgdG8gYmUgc2VhcmNoZWQuXG4gICAqL1xuXG4gIGluc29ydCA9IGZ1bmN0aW9uKGEsIHgsIGxvLCBoaSwgY21wKSB7XG4gICAgdmFyIG1pZDtcbiAgICBpZiAobG8gPT0gbnVsbCkge1xuICAgICAgbG8gPSAwO1xuICAgIH1cbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGlmIChsbyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbG8gbXVzdCBiZSBub24tbmVnYXRpdmUnKTtcbiAgICB9XG4gICAgaWYgKGhpID09IG51bGwpIHtcbiAgICAgIGhpID0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICBtaWQgPSBmbG9vcigobG8gKyBoaSkgLyAyKTtcbiAgICAgIGlmIChjbXAoeCwgYVttaWRdKSA8IDApIHtcbiAgICAgICAgaGkgPSBtaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsbyA9IG1pZCArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoW10uc3BsaWNlLmFwcGx5KGEsIFtsbywgbG8gLSBsb10uY29uY2F0KHgpKSwgeCk7XG4gIH07XG5cblxuICAvKlxuICBQdXNoIGl0ZW0gb250byBoZWFwLCBtYWludGFpbmluZyB0aGUgaGVhcCBpbnZhcmlhbnQuXG4gICAqL1xuXG4gIGhlYXBwdXNoID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgYXJyYXkucHVzaChpdGVtKTtcbiAgICByZXR1cm4gX3NpZnRkb3duKGFycmF5LCAwLCBhcnJheS5sZW5ndGggLSAxLCBjbXApO1xuICB9O1xuXG5cbiAgLypcbiAgUG9wIHRoZSBzbWFsbGVzdCBpdGVtIG9mZiB0aGUgaGVhcCwgbWFpbnRhaW5pbmcgdGhlIGhlYXAgaW52YXJpYW50LlxuICAgKi9cblxuICBoZWFwcG9wID0gZnVuY3Rpb24oYXJyYXksIGNtcCkge1xuICAgIHZhciBsYXN0ZWx0LCByZXR1cm5pdGVtO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgbGFzdGVsdCA9IGFycmF5LnBvcCgpO1xuICAgIGlmIChhcnJheS5sZW5ndGgpIHtcbiAgICAgIHJldHVybml0ZW0gPSBhcnJheVswXTtcbiAgICAgIGFycmF5WzBdID0gbGFzdGVsdDtcbiAgICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybml0ZW0gPSBsYXN0ZWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuaXRlbTtcbiAgfTtcblxuXG4gIC8qXG4gIFBvcCBhbmQgcmV0dXJuIHRoZSBjdXJyZW50IHNtYWxsZXN0IHZhbHVlLCBhbmQgYWRkIHRoZSBuZXcgaXRlbS5cbiAgXG4gIFRoaXMgaXMgbW9yZSBlZmZpY2llbnQgdGhhbiBoZWFwcG9wKCkgZm9sbG93ZWQgYnkgaGVhcHB1c2goKSwgYW5kIGNhbiBiZVxuICBtb3JlIGFwcHJvcHJpYXRlIHdoZW4gdXNpbmcgYSBmaXhlZCBzaXplIGhlYXAuIE5vdGUgdGhhdCB0aGUgdmFsdWVcbiAgcmV0dXJuZWQgbWF5IGJlIGxhcmdlciB0aGFuIGl0ZW0hIFRoYXQgY29uc3RyYWlucyByZWFzb25hYmxlIHVzZSBvZlxuICB0aGlzIHJvdXRpbmUgdW5sZXNzIHdyaXR0ZW4gYXMgcGFydCBvZiBhIGNvbmRpdGlvbmFsIHJlcGxhY2VtZW50OlxuICAgICAgaWYgaXRlbSA+IGFycmF5WzBdXG4gICAgICAgIGl0ZW0gPSBoZWFwcmVwbGFjZShhcnJheSwgaXRlbSlcbiAgICovXG5cbiAgaGVhcHJlcGxhY2UgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgdmFyIHJldHVybml0ZW07XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICByZXR1cm5pdGVtID0gYXJyYXlbMF07XG4gICAgYXJyYXlbMF0gPSBpdGVtO1xuICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgcmV0dXJuIHJldHVybml0ZW07XG4gIH07XG5cblxuICAvKlxuICBGYXN0IHZlcnNpb24gb2YgYSBoZWFwcHVzaCBmb2xsb3dlZCBieSBhIGhlYXBwb3AuXG4gICAqL1xuXG4gIGhlYXBwdXNocG9wID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIHZhciBfcmVmO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgaWYgKGFycmF5Lmxlbmd0aCAmJiBjbXAoYXJyYXlbMF0sIGl0ZW0pIDwgMCkge1xuICAgICAgX3JlZiA9IFthcnJheVswXSwgaXRlbV0sIGl0ZW0gPSBfcmVmWzBdLCBhcnJheVswXSA9IF9yZWZbMV07XG4gICAgICBfc2lmdHVwKGFycmF5LCAwLCBjbXApO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbiAgfTtcblxuXG4gIC8qXG4gIFRyYW5zZm9ybSBsaXN0IGludG8gYSBoZWFwLCBpbi1wbGFjZSwgaW4gTyhhcnJheS5sZW5ndGgpIHRpbWUuXG4gICAqL1xuXG4gIGhlYXBpZnkgPSBmdW5jdGlvbihhcnJheSwgY21wKSB7XG4gICAgdmFyIGksIF9pLCBfaiwgX2xlbiwgX3JlZiwgX3JlZjEsIF9yZXN1bHRzLCBfcmVzdWx0czE7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBfcmVmMSA9IChmdW5jdGlvbigpIHtcbiAgICAgIF9yZXN1bHRzMSA9IFtdO1xuICAgICAgZm9yICh2YXIgX2ogPSAwLCBfcmVmID0gZmxvb3IoYXJyYXkubGVuZ3RoIC8gMik7IDAgPD0gX3JlZiA/IF9qIDwgX3JlZiA6IF9qID4gX3JlZjsgMCA8PSBfcmVmID8gX2orKyA6IF9qLS0peyBfcmVzdWx0czEucHVzaChfaik7IH1cbiAgICAgIHJldHVybiBfcmVzdWx0czE7XG4gICAgfSkuYXBwbHkodGhpcykucmV2ZXJzZSgpO1xuICAgIF9yZXN1bHRzID0gW107XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgaSA9IF9yZWYxW19pXTtcbiAgICAgIF9yZXN1bHRzLnB1c2goX3NpZnR1cChhcnJheSwgaSwgY21wKSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfTtcblxuXG4gIC8qXG4gIFVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGdpdmVuIGl0ZW0gaW4gdGhlIGhlYXAuXG4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBpdGVtIGlzIGJlaW5nIG1vZGlmaWVkLlxuICAgKi9cblxuICB1cGRhdGVJdGVtID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIHZhciBwb3M7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBwb3MgPSBhcnJheS5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIF9zaWZ0ZG93bihhcnJheSwgMCwgcG9zLCBjbXApO1xuICAgIHJldHVybiBfc2lmdHVwKGFycmF5LCBwb3MsIGNtcCk7XG4gIH07XG5cblxuICAvKlxuICBGaW5kIHRoZSBuIGxhcmdlc3QgZWxlbWVudHMgaW4gYSBkYXRhc2V0LlxuICAgKi9cblxuICBubGFyZ2VzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBjbXApIHtcbiAgICB2YXIgZWxlbSwgcmVzdWx0LCBfaSwgX2xlbiwgX3JlZjtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIHJlc3VsdCA9IGFycmF5LnNsaWNlKDAsIG4pO1xuICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaGVhcGlmeShyZXN1bHQsIGNtcCk7XG4gICAgX3JlZiA9IGFycmF5LnNsaWNlKG4pO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgZWxlbSA9IF9yZWZbX2ldO1xuICAgICAgaGVhcHB1c2hwb3AocmVzdWx0LCBlbGVtLCBjbXApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnNvcnQoY21wKS5yZXZlcnNlKCk7XG4gIH07XG5cblxuICAvKlxuICBGaW5kIHRoZSBuIHNtYWxsZXN0IGVsZW1lbnRzIGluIGEgZGF0YXNldC5cbiAgICovXG5cbiAgbnNtYWxsZXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGNtcCkge1xuICAgIHZhciBlbGVtLCBpLCBsb3MsIHJlc3VsdCwgX2ksIF9qLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBpZiAobiAqIDEwIDw9IGFycmF5Lmxlbmd0aCkge1xuICAgICAgcmVzdWx0ID0gYXJyYXkuc2xpY2UoMCwgbikuc29ydChjbXApO1xuICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBsb3MgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgX3JlZiA9IGFycmF5LnNsaWNlKG4pO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGVsZW0gPSBfcmVmW19pXTtcbiAgICAgICAgaWYgKGNtcChlbGVtLCBsb3MpIDwgMCkge1xuICAgICAgICAgIGluc29ydChyZXN1bHQsIGVsZW0sIDAsIG51bGwsIGNtcCk7XG4gICAgICAgICAgcmVzdWx0LnBvcCgpO1xuICAgICAgICAgIGxvcyA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGhlYXBpZnkoYXJyYXksIGNtcCk7XG4gICAgX3Jlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGkgPSBfaiA9IDAsIF9yZWYxID0gbWluKG4sIGFycmF5Lmxlbmd0aCk7IDAgPD0gX3JlZjEgPyBfaiA8IF9yZWYxIDogX2ogPiBfcmVmMTsgaSA9IDAgPD0gX3JlZjEgPyArK19qIDogLS1faikge1xuICAgICAgX3Jlc3VsdHMucHVzaChoZWFwcG9wKGFycmF5LCBjbXApKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZXN1bHRzO1xuICB9O1xuXG4gIF9zaWZ0ZG93biA9IGZ1bmN0aW9uKGFycmF5LCBzdGFydHBvcywgcG9zLCBjbXApIHtcbiAgICB2YXIgbmV3aXRlbSwgcGFyZW50LCBwYXJlbnRwb3M7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBuZXdpdGVtID0gYXJyYXlbcG9zXTtcbiAgICB3aGlsZSAocG9zID4gc3RhcnRwb3MpIHtcbiAgICAgIHBhcmVudHBvcyA9IChwb3MgLSAxKSA+PiAxO1xuICAgICAgcGFyZW50ID0gYXJyYXlbcGFyZW50cG9zXTtcbiAgICAgIGlmIChjbXAobmV3aXRlbSwgcGFyZW50KSA8IDApIHtcbiAgICAgICAgYXJyYXlbcG9zXSA9IHBhcmVudDtcbiAgICAgICAgcG9zID0gcGFyZW50cG9zO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlbcG9zXSA9IG5ld2l0ZW07XG4gIH07XG5cbiAgX3NpZnR1cCA9IGZ1bmN0aW9uKGFycmF5LCBwb3MsIGNtcCkge1xuICAgIHZhciBjaGlsZHBvcywgZW5kcG9zLCBuZXdpdGVtLCByaWdodHBvcywgc3RhcnRwb3M7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBlbmRwb3MgPSBhcnJheS5sZW5ndGg7XG4gICAgc3RhcnRwb3MgPSBwb3M7XG4gICAgbmV3aXRlbSA9IGFycmF5W3Bvc107XG4gICAgY2hpbGRwb3MgPSAyICogcG9zICsgMTtcbiAgICB3aGlsZSAoY2hpbGRwb3MgPCBlbmRwb3MpIHtcbiAgICAgIHJpZ2h0cG9zID0gY2hpbGRwb3MgKyAxO1xuICAgICAgaWYgKHJpZ2h0cG9zIDwgZW5kcG9zICYmICEoY21wKGFycmF5W2NoaWxkcG9zXSwgYXJyYXlbcmlnaHRwb3NdKSA8IDApKSB7XG4gICAgICAgIGNoaWxkcG9zID0gcmlnaHRwb3M7XG4gICAgICB9XG4gICAgICBhcnJheVtwb3NdID0gYXJyYXlbY2hpbGRwb3NdO1xuICAgICAgcG9zID0gY2hpbGRwb3M7XG4gICAgICBjaGlsZHBvcyA9IDIgKiBwb3MgKyAxO1xuICAgIH1cbiAgICBhcnJheVtwb3NdID0gbmV3aXRlbTtcbiAgICByZXR1cm4gX3NpZnRkb3duKGFycmF5LCBzdGFydHBvcywgcG9zLCBjbXApO1xuICB9O1xuXG4gIEhlYXAgPSAoZnVuY3Rpb24oKSB7XG4gICAgSGVhcC5wdXNoID0gaGVhcHB1c2g7XG5cbiAgICBIZWFwLnBvcCA9IGhlYXBwb3A7XG5cbiAgICBIZWFwLnJlcGxhY2UgPSBoZWFwcmVwbGFjZTtcblxuICAgIEhlYXAucHVzaHBvcCA9IGhlYXBwdXNocG9wO1xuXG4gICAgSGVhcC5oZWFwaWZ5ID0gaGVhcGlmeTtcblxuICAgIEhlYXAudXBkYXRlSXRlbSA9IHVwZGF0ZUl0ZW07XG5cbiAgICBIZWFwLm5sYXJnZXN0ID0gbmxhcmdlc3Q7XG5cbiAgICBIZWFwLm5zbWFsbGVzdCA9IG5zbWFsbGVzdDtcblxuICAgIGZ1bmN0aW9uIEhlYXAoY21wKSB7XG4gICAgICB0aGlzLmNtcCA9IGNtcCAhPSBudWxsID8gY21wIDogZGVmYXVsdENtcDtcbiAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICB9XG5cbiAgICBIZWFwLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGhlYXBwdXNoKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaGVhcHBvcCh0aGlzLm5vZGVzLCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzWzBdO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLmluZGV4T2YoeCkgIT09IC0xO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGhlYXByZXBsYWNlKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucHVzaHBvcCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBoZWFwcHVzaHBvcCh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmhlYXBpZnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBoZWFwaWZ5KHRoaXMubm9kZXMsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUudXBkYXRlSXRlbSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB1cGRhdGVJdGVtKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzID0gW107XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGggPT09IDA7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBoZWFwO1xuICAgICAgaGVhcCA9IG5ldyBIZWFwKCk7XG4gICAgICBoZWFwLm5vZGVzID0gdGhpcy5ub2Rlcy5zbGljZSgwKTtcbiAgICAgIHJldHVybiBoZWFwO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5zbGljZSgwKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuaW5zZXJ0ID0gSGVhcC5wcm90b3R5cGUucHVzaDtcblxuICAgIEhlYXAucHJvdG90eXBlLnRvcCA9IEhlYXAucHJvdG90eXBlLnBlZWs7XG5cbiAgICBIZWFwLnByb3RvdHlwZS5mcm9udCA9IEhlYXAucHJvdG90eXBlLnBlZWs7XG5cbiAgICBIZWFwLnByb3RvdHlwZS5oYXMgPSBIZWFwLnByb3RvdHlwZS5jb250YWlucztcblxuICAgIEhlYXAucHJvdG90eXBlLmNvcHkgPSBIZWFwLnByb3RvdHlwZS5jbG9uZTtcblxuICAgIHJldHVybiBIZWFwO1xuXG4gIH0pKCk7XG5cbiAgKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICByZXR1cm4gZGVmaW5lKFtdLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcm9vdC5IZWFwID0gZmFjdG9yeSgpO1xuICAgIH1cbiAgfSkodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEhlYXA7XG4gIH0pO1xuXG59KS5jYWxsKHRoaXMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/heap/lib/heap.js\n");

/***/ }),

/***/ "../node_modules/lodash/_Hash.js":
/*!***************************************!*\
  !*** ../node_modules/lodash/_Hash.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var hashClear = __webpack_require__(/*! ./_hashClear */ \"../node_modules/lodash/_hashClear.js\"),\n    hashDelete = __webpack_require__(/*! ./_hashDelete */ \"../node_modules/lodash/_hashDelete.js\"),\n    hashGet = __webpack_require__(/*! ./_hashGet */ \"../node_modules/lodash/_hashGet.js\"),\n    hashHas = __webpack_require__(/*! ./_hashHas */ \"../node_modules/lodash/_hashHas.js\"),\n    hashSet = __webpack_require__(/*! ./_hashSet */ \"../node_modules/lodash/_hashSet.js\");\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQywwREFBYztBQUN0QyxpQkFBaUIsbUJBQU8sQ0FBQyw0REFBZTtBQUN4QyxjQUFjLG1CQUFPLENBQUMsc0RBQVk7QUFDbEMsY0FBYyxtQkFBTyxDQUFDLHNEQUFZO0FBQ2xDLGNBQWMsbUJBQU8sQ0FBQyxzREFBWTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0hhc2guanM/YzM5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaGFzaENsZWFyID0gcmVxdWlyZSgnLi9faGFzaENsZWFyJyksXG4gICAgaGFzaERlbGV0ZSA9IHJlcXVpcmUoJy4vX2hhc2hEZWxldGUnKSxcbiAgICBoYXNoR2V0ID0gcmVxdWlyZSgnLi9faGFzaEdldCcpLFxuICAgIGhhc2hIYXMgPSByZXF1aXJlKCcuL19oYXNoSGFzJyksXG4gICAgaGFzaFNldCA9IHJlcXVpcmUoJy4vX2hhc2hTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lodash/_Hash.js\n");

/***/ }),

/***/ "../node_modules/lodash/_ListCache.js":
/*!********************************************!*\
  !*** ../node_modules/lodash/_ListCache.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var listCacheClear = __webpack_require__(/*! ./_listCacheClear */ \"../node_modules/lodash/_listCacheClear.js\"),\n    listCacheDelete = __webpack_require__(/*! ./_listCacheDelete */ \"../node_modules/lodash/_listCacheDelete.js\"),\n    listCacheGet = __webpack_require__(/*! ./_listCacheGet */ \"../node_modules/lodash/_listCacheGet.js\"),\n    listCacheHas = __webpack_require__(/*! ./_listCacheHas */ \"../node_modules/lodash/_listCacheHas.js\"),\n    listCacheSet = __webpack_require__(/*! ./_listCacheSet */ \"../node_modules/lodash/_listCacheSet.js\");\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTGlzdENhY2hlLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFCQUFxQixtQkFBTyxDQUFDLG9FQUFtQjtBQUNoRCxzQkFBc0IsbUJBQU8sQ0FBQyxzRUFBb0I7QUFDbEQsbUJBQW1CLG1CQUFPLENBQUMsZ0VBQWlCO0FBQzVDLG1CQUFtQixtQkFBTyxDQUFDLGdFQUFpQjtBQUM1QyxtQkFBbUIsbUJBQU8sQ0FBQyxnRUFBaUI7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19MaXN0Q2FjaGUuanM/NDU2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbGlzdENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVDbGVhcicpLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZURlbGV0ZScpLFxuICAgIGxpc3RDYWNoZUdldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUdldCcpLFxuICAgIGxpc3RDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUhhcycpLFxuICAgIGxpc3RDYWNoZVNldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdENhY2hlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lodash/_ListCache.js\n");

/***/ }),

/***/ "../node_modules/lodash/_Map.js":
/*!**************************************!*\
  !*** ../node_modules/lodash/_Map.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var getNative = __webpack_require__(/*! ./_getNative */ \"../node_modules/lodash/_getNative.js\"),\n    root = __webpack_require__(/*! ./_root */ \"../node_modules/lodash/_root.js\");\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwLmpzIiwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLDBEQUFjO0FBQ3RDLFdBQVcsbUJBQU8sQ0FBQyxnREFBUzs7QUFFNUI7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXAuanM/ZDBhNCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lodash/_Map.js\n");

/***/ }),

/***/ "../node_modules/lodash/_MapCache.js":
/*!*******************************************!*\
  !*** ../node_modules/lodash/_MapCache.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var mapCacheClear = __webpack_require__(/*! ./_mapCacheClear */ \"../node_modules/lodash/_mapCacheClear.js\"),\n    mapCacheDelete = __webpack_require__(/*! ./_mapCacheDelete */ \"../node_modules/lodash/_mapCacheDelete.js\"),\n    mapCacheGet = __webpack_require__(/*! ./_mapCacheGet */ \"../node_modules/lodash/_mapCacheGet.js\"),\n    mapCacheHas = __webpack_require__(/*! ./_mapCacheHas */ \"../node_modules/lodash/_mapCacheHas.js\"),\n    mapCacheSet = __webpack_require__(/*! ./_mapCacheSet */ \"../node_modules/lodash/_mapCacheSet.js\");\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwQ2FjaGUuanMiLCJtYXBwaW5ncyI6IkFBQUEsb0JBQW9CLG1CQUFPLENBQUMsa0VBQWtCO0FBQzlDLHFCQUFxQixtQkFBTyxDQUFDLG9FQUFtQjtBQUNoRCxrQkFBa0IsbUJBQU8sQ0FBQyw4REFBZ0I7QUFDMUMsa0JBQWtCLG1CQUFPLENBQUMsOERBQWdCO0FBQzFDLGtCQUFrQixtQkFBTyxDQUFDLDhEQUFnQjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcENhY2hlLmpzP2M2NDEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIG1hcENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19tYXBDYWNoZUNsZWFyJyksXG4gICAgbWFwQ2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19tYXBDYWNoZURlbGV0ZScpLFxuICAgIG1hcENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVHZXQnKSxcbiAgICBtYXBDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX21hcENhY2hlSGFzJyksXG4gICAgbWFwQ2FjaGVTZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDYWNoZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lodash/_MapCache.js\n");

/***/ }),

/***/ "../node_modules/lodash/_Symbol.js":
/*!*****************************************!*\
  !*** ../node_modules/lodash/_Symbol.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var root = __webpack_require__(/*! ./_root */ \"../node_modules/lodash/_root.js\");\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzIiwibWFwcGluZ3MiOiJBQUFBLFdBQVcsbUJBQU8sQ0FBQyxnREFBUzs7QUFFNUI7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanM/OGUwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lodash/_Symbol.js\n");

/***/ }),

/***/ "../node_modules/lodash/_arrayMap.js":
/*!*******************************************!*\
  !*** ../node_modules/lodash/_arrayMap.js ***!
  \*******************************************/
/***/ ((module) => {

eval("/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlNYXAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFVBQVU7QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheU1hcC5qcz8zNjYzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lodash/_arrayMap.js\n");

/***/ }),

/***/ "../node_modules/lodash/_assignValue.js":
/*!**********************************************!*\
  !*** ../node_modules/lodash/_assignValue.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ \"../node_modules/lodash/_baseAssignValue.js\"),\n    eq = __webpack_require__(/*! ./eq */ \"../node_modules/lodash/eq.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignValue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzaWduVmFsdWUuanMiLCJtYXBwaW5ncyI6IkFBQUEsc0JBQXNCLG1CQUFPLENBQUMsc0VBQW9CO0FBQ2xELFNBQVMsbUJBQU8sQ0FBQywwQ0FBTTs7QUFFdkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25WYWx1ZS5qcz8xNzcwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25WYWx1ZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lodash/_assignValue.js\n");

/***/ }),

/***/ "../node_modules/lodash/_assocIndexOf.js":
/*!***********************************************!*\
  !*** ../node_modules/lodash/_assocIndexOf.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var eq = __webpack_require__(/*! ./eq */ \"../node_modules/lodash/eq.js\");\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzb2NJbmRleE9mLmpzIiwibWFwcGluZ3MiOiJBQUFBLFNBQVMsbUJBQU8sQ0FBQywwQ0FBTTs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxHQUFHO0FBQ2QsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcz83MjZlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NvY0luZGV4T2Y7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lodash/_assocIndexOf.js\n");

/***/ }),

/***/ "../node_modules/lodash/_baseAssignValue.js":
/*!**************************************************!*\
  !*** ../node_modules/lodash/_baseAssignValue.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var defineProperty = __webpack_require__(/*! ./_defineProperty */ \"../node_modules/lodash/_defineProperty.js\");\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nmodule.exports = baseAssignValue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnblZhbHVlLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFCQUFxQixtQkFBTyxDQUFDLG9FQUFtQjs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ25WYWx1ZS5qcz8wZTFkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnblZhbHVlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lodash/_baseAssignValue.js\n");

/***/ }),

/***/ "../node_modules/lodash/_baseGet.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/_baseGet.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var castPath = __webpack_require__(/*! ./_castPath */ \"../node_modules/lodash/_castPath.js\"),\n    toKey = __webpack_require__(/*! ./_toKey */ \"../node_modules/lodash/_toKey.js\");\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsd0RBQWE7QUFDcEMsWUFBWSxtQkFBTyxDQUFDLGtEQUFVOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGNBQWM7QUFDekIsYUFBYSxHQUFHO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldC5qcz8xMzFiIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lodash/_baseGet.js\n");

/***/ }),

/***/ "../node_modules/lodash/_baseGetTag.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/_baseGetTag.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Symbol = __webpack_require__(/*! ./_Symbol */ \"../node_modules/lodash/_Symbol.js\"),\n    getRawTag = __webpack_require__(/*! ./_getRawTag */ \"../node_modules/lodash/_getRawTag.js\"),\n    objectToString = __webpack_require__(/*! ./_objectToString */ \"../node_modules/lodash/_objectToString.js\");\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldFRhZy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsb0RBQVc7QUFDaEMsZ0JBQWdCLG1CQUFPLENBQUMsMERBQWM7QUFDdEMscUJBQXFCLG1CQUFPLENBQUMsb0VBQW1COztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldFRhZy5qcz8xODhkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBnZXRSYXdUYWcgPSByZXF1aXJlKCcuL19nZXRSYXdUYWcnKSxcbiAgICBvYmplY3RUb1N0cmluZyA9IHJlcXVpcmUoJy4vX29iamVjdFRvU3RyaW5nJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRUYWc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lodash/_baseGetTag.js\n");

/***/ }),

/***/ "../node_modules/lodash/_baseIsNative.js":
/*!***********************************************!*\
  !*** ../node_modules/lodash/_baseIsNative.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var isFunction = __webpack_require__(/*! ./isFunction */ \"../node_modules/lodash/isFunction.js\"),\n    isMasked = __webpack_require__(/*! ./_isMasked */ \"../node_modules/lodash/_isMasked.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"../node_modules/lodash/isObject.js\"),\n    toSource = __webpack_require__(/*! ./_toSource */ \"../node_modules/lodash/_toSource.js\");\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixtQkFBTyxDQUFDLDBEQUFjO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQyx3REFBYTtBQUNwQyxlQUFlLG1CQUFPLENBQUMsc0RBQVk7QUFDbkMsZUFBZSxtQkFBTyxDQUFDLHdEQUFhOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qcz82MzM4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lodash/_baseIsNative.js\n");

/***/ }),

/***/ "../node_modules/lodash/_baseSet.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/_baseSet.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var assignValue = __webpack_require__(/*! ./_assignValue */ \"../node_modules/lodash/_assignValue.js\"),\n    castPath = __webpack_require__(/*! ./_castPath */ \"../node_modules/lodash/_castPath.js\"),\n    isIndex = __webpack_require__(/*! ./_isIndex */ \"../node_modules/lodash/_isIndex.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"../node_modules/lodash/isObject.js\"),\n    toKey = __webpack_require__(/*! ./_toKey */ \"../node_modules/lodash/_toKey.js\");\n\n/**\n * The base implementation of `_.set`.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {Array|string} path The path of the property to set.\n * @param {*} value The value to set.\n * @param {Function} [customizer] The function to customize path creation.\n * @returns {Object} Returns `object`.\n */\nfunction baseSet(object, path, value, customizer) {\n  if (!isObject(object)) {\n    return object;\n  }\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      lastIndex = length - 1,\n      nested = object;\n\n  while (nested != null && ++index < length) {\n    var key = toKey(path[index]),\n        newValue = value;\n\n    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n      return object;\n    }\n\n    if (index != lastIndex) {\n      var objValue = nested[key];\n      newValue = customizer ? customizer(objValue, key, nested) : undefined;\n      if (newValue === undefined) {\n        newValue = isObject(objValue)\n          ? objValue\n          : (isIndex(path[index + 1]) ? [] : {});\n      }\n    }\n    assignValue(nested, key, newValue);\n    nested = nested[key];\n  }\n  return object;\n}\n\nmodule.exports = baseSet;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNldC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsbUJBQU8sQ0FBQyw4REFBZ0I7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLHdEQUFhO0FBQ3BDLGNBQWMsbUJBQU8sQ0FBQyxzREFBWTtBQUNsQyxlQUFlLG1CQUFPLENBQUMsc0RBQVk7QUFDbkMsWUFBWSxtQkFBTyxDQUFDLGtEQUFVOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGNBQWM7QUFDekIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNldC5qcz8zOWY1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgICAgbmVzdGVkID0gb2JqZWN0O1xuXG4gIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKSxcbiAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nIHx8IGtleSA9PT0gJ2NvbnN0cnVjdG9yJyB8fCBrZXkgPT09ICdwcm90b3R5cGUnKSB7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIGlmIChpbmRleCAhPSBsYXN0SW5kZXgpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSlcbiAgICAgICAgICA/IG9ialZhbHVlXG4gICAgICAgICAgOiAoaXNJbmRleChwYXRoW2luZGV4ICsgMV0pID8gW10gOiB7fSk7XG4gICAgICB9XG4gICAgfVxuICAgIGFzc2lnblZhbHVlKG5lc3RlZCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2V0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lodash/_baseSet.js\n");

/***/ }),

/***/ "../node_modules/lodash/_baseToString.js":
/*!***********************************************!*\
  !*** ../node_modules/lodash/_baseToString.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Symbol = __webpack_require__(/*! ./_Symbol */ \"../node_modules/lodash/_Symbol.js\"),\n    arrayMap = __webpack_require__(/*! ./_arrayMap */ \"../node_modules/lodash/_arrayMap.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"../node_modules/lodash/isArray.js\"),\n    isSymbol = __webpack_require__(/*! ./isSymbol */ \"../node_modules/lodash/isSymbol.js\");\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRvU3RyaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQyxvREFBVztBQUNoQyxlQUFlLG1CQUFPLENBQUMsd0RBQWE7QUFDcEMsY0FBYyxtQkFBTyxDQUFDLG9EQUFXO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxzREFBWTs7QUFFbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVG9TdHJpbmcuanM/MzFmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVG9TdHJpbmc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lodash/_baseToString.js\n");

/***/ }),

/***/ "../node_modules/lodash/_baseTrim.js":
/*!*******************************************!*\
  !*** ../node_modules/lodash/_baseTrim.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var trimmedEndIndex = __webpack_require__(/*! ./_trimmedEndIndex */ \"../node_modules/lodash/_trimmedEndIndex.js\");\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nmodule.exports = baseTrim;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRyaW0uanMiLCJtYXBwaW5ncyI6IkFBQUEsc0JBQXNCLG1CQUFPLENBQUMsc0VBQW9COztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRyaW0uanM/NDg0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdHJpbW1lZEVuZEluZGV4ID0gcmVxdWlyZSgnLi9fdHJpbW1lZEVuZEluZGV4Jyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW1TdGFydCA9IC9eXFxzKy87XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udHJpbWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byB0cmltLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUcmltKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nXG4gICAgPyBzdHJpbmcuc2xpY2UoMCwgdHJpbW1lZEVuZEluZGV4KHN0cmluZykgKyAxKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJylcbiAgICA6IHN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVHJpbTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lodash/_baseTrim.js\n");

/***/ }),

/***/ "../node_modules/lodash/_castPath.js":
/*!*******************************************!*\
  !*** ../node_modules/lodash/_castPath.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var isArray = __webpack_require__(/*! ./isArray */ \"../node_modules/lodash/isArray.js\"),\n    isKey = __webpack_require__(/*! ./_isKey */ \"../node_modules/lodash/_isKey.js\"),\n    stringToPath = __webpack_require__(/*! ./_stringToPath */ \"../node_modules/lodash/_stringToPath.js\"),\n    toString = __webpack_require__(/*! ./toString */ \"../node_modules/lodash/toString.js\");\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdFBhdGguanMiLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxtQkFBTyxDQUFDLG9EQUFXO0FBQ2pDLFlBQVksbUJBQU8sQ0FBQyxrREFBVTtBQUM5QixtQkFBbUIsbUJBQU8sQ0FBQyxnRUFBaUI7QUFDNUMsZUFBZSxtQkFBTyxDQUFDLHNEQUFZOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdFBhdGguanM/YjE2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBzdHJpbmdUb1BhdGggPSByZXF1aXJlKCcuL19zdHJpbmdUb1BhdGgnKSxcbiAgICB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0UGF0aDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lodash/_castPath.js\n");

/***/ }),

/***/ "../node_modules/lodash/_copyArray.js":
/*!********************************************!*\
  !*** ../node_modules/lodash/_copyArray.js ***!
  \********************************************/
/***/ ((module) => {

eval("/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nmodule.exports = copyArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weUFycmF5LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlBcnJheS5qcz83YmJlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlBcnJheTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lodash/_copyArray.js\n");

/***/ }),

/***/ "../node_modules/lodash/_coreJsData.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/_coreJsData.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var root = __webpack_require__(/*! ./_root */ \"../node_modules/lodash/_root.js\");\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29yZUpzRGF0YS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxXQUFXLG1CQUFPLENBQUMsZ0RBQVM7O0FBRTVCO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29yZUpzRGF0YS5qcz83N2E1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVKc0RhdGE7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lodash/_coreJsData.js\n");

/***/ }),

/***/ "../node_modules/lodash/_defineProperty.js":
/*!*************************************************!*\
  !*** ../node_modules/lodash/_defineProperty.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var getNative = __webpack_require__(/*! ./_getNative */ \"../node_modules/lodash/_getNative.js\");\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZGVmaW5lUHJvcGVydHkuanMiLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFPLENBQUMsMERBQWM7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLElBQUk7QUFDSixDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzPzYxYTIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0eTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lodash/_defineProperty.js\n");

/***/ }),

/***/ "../node_modules/lodash/_freeGlobal.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/_freeGlobal.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;\n\nmodule.exports = freeGlobal;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLHdCQUF3QixxQkFBTSxnQkFBZ0IscUJBQU0sSUFBSSxxQkFBTSxzQkFBc0IscUJBQU07O0FBRTFGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZyZWVHbG9iYWwuanM/MTVmNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lodash/_freeGlobal.js\n");

/***/ }),

/***/ "../node_modules/lodash/_getMapData.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/_getMapData.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var isKeyable = __webpack_require__(/*! ./_isKeyable */ \"../node_modules/lodash/_isKeyable.js\");\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWFwRGF0YS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQywwREFBYzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzP2NkY2IiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lodash/_getMapData.js\n");

/***/ }),

/***/ "../node_modules/lodash/_getNative.js":
/*!********************************************!*\
  !*** ../node_modules/lodash/_getNative.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var baseIsNative = __webpack_require__(/*! ./_baseIsNative */ \"../node_modules/lodash/_baseIsNative.js\"),\n    getValue = __webpack_require__(/*! ./_getValue */ \"../node_modules/lodash/_getValue.js\");\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwibWFwcGluZ3MiOiJBQUFBLG1CQUFtQixtQkFBTyxDQUFDLGdFQUFpQjtBQUM1QyxlQUFlLG1CQUFPLENBQUMsd0RBQWE7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXROYXRpdmUuanM/MmQyMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnLi9fYmFzZUlzTmF0aXZlJyksXG4gICAgZ2V0VmFsdWUgPSByZXF1aXJlKCcuL19nZXRWYWx1ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lodash/_getNative.js\n");

/***/ }),

/***/ "../node_modules/lodash/_getRawTag.js":
/*!********************************************!*\
  !*** ../node_modules/lodash/_getRawTag.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Symbol = __webpack_require__(/*! ./_Symbol */ \"../node_modules/lodash/_Symbol.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UmF3VGFnLmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQyxvREFBVzs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanM/YmNjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lodash/_getRawTag.js\n");

/***/ }),

/***/ "../node_modules/lodash/_getValue.js":
/*!*******************************************!*\
  !*** ../node_modules/lodash/_getValue.js ***!
  \*******************************************/
/***/ ((module) => {

eval("/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VmFsdWUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRWYWx1ZS5qcz81ZmZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lodash/_getValue.js\n");

/***/ }),

/***/ "../node_modules/lodash/_hashClear.js":
/*!********************************************!*\
  !*** ../node_modules/lodash/_hashClear.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ \"../node_modules/lodash/_nativeCreate.js\");\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaENsZWFyLmpzIiwibWFwcGluZ3MiOiJBQUFBLG1CQUFtQixtQkFBTyxDQUFDLGdFQUFpQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoQ2xlYXIuanM/M2Q4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lodash/_hashClear.js\n");

/***/ }),

/***/ "../node_modules/lodash/_hashDelete.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/_hashDelete.js ***!
  \*********************************************/
/***/ ((module) => {

eval("/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaERlbGV0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaERlbGV0ZS5qcz81ZDcwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lodash/_hashDelete.js\n");

/***/ }),

/***/ "../node_modules/lodash/_hashGet.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/_hashGet.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ \"../node_modules/lodash/_nativeCreate.js\");\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEdldC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBbUIsbUJBQU8sQ0FBQyxnRUFBaUI7O0FBRTVDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hHZXQuanM/MGQ5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lodash/_hashGet.js\n");

/***/ }),

/***/ "../node_modules/lodash/_hashHas.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/_hashHas.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ \"../node_modules/lodash/_nativeCreate.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEhhcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBbUIsbUJBQU8sQ0FBQyxnRUFBaUI7O0FBRTVDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEhhcy5qcz84YjQyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hIYXM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lodash/_hashHas.js\n");

/***/ }),

/***/ "../node_modules/lodash/_hashSet.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/_hashSet.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ \"../node_modules/lodash/_nativeCreate.js\");\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBbUIsbUJBQU8sQ0FBQyxnRUFBaUI7O0FBRTVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsR0FBRztBQUNkLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoU2V0LmpzP2M0YTMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lodash/_hashSet.js\n");

/***/ }),

/***/ "../node_modules/lodash/_isIndex.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/_isIndex.js ***!
  \******************************************/
/***/ ((module) => {

eval("/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJbmRleC5qcz9hYmUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lodash/_isIndex.js\n");

/***/ }),

/***/ "../node_modules/lodash/_isKey.js":
/*!****************************************!*\
  !*** ../node_modules/lodash/_isKey.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var isArray = __webpack_require__(/*! ./isArray */ \"../node_modules/lodash/isArray.js\"),\n    isSymbol = __webpack_require__(/*! ./isSymbol */ \"../node_modules/lodash/isSymbol.js\");\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXkuanMiLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxtQkFBTyxDQUFDLG9EQUFXO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxzREFBWTs7QUFFbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleS5qcz8wNzA2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lodash/_isKey.js\n");

/***/ }),

/***/ "../node_modules/lodash/_isKeyable.js":
/*!********************************************!*\
  !*** ../node_modules/lodash/_isKeyable.js ***!
  \********************************************/
/***/ ((module) => {

eval("/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXlhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5YWJsZS5qcz9lZThmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleWFibGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lodash/_isKeyable.js\n");

/***/ }),

/***/ "../node_modules/lodash/_isMasked.js":
/*!*******************************************!*\
  !*** ../node_modules/lodash/_isMasked.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var coreJsData = __webpack_require__(/*! ./_coreJsData */ \"../node_modules/lodash/_coreJsData.js\");\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNNYXNrZWQuanMiLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLG1CQUFPLENBQUMsNERBQWU7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNNYXNrZWQuanM/Y2RjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY29yZUpzRGF0YSA9IHJlcXVpcmUoJy4vX2NvcmVKc0RhdGEnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lodash/_isMasked.js\n");

/***/ }),

/***/ "../node_modules/lodash/_listCacheClear.js":
/*!*************************************************!*\
  !*** ../node_modules/lodash/_listCacheClear.js ***!
  \*************************************************/
/***/ ((module) => {

eval("/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVDbGVhci5qcz84OGVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVDbGVhcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lodash/_listCacheClear.js\n");

/***/ }),

/***/ "../node_modules/lodash/_listCacheDelete.js":
/*!**************************************************!*\
  !*** ../node_modules/lodash/_listCacheDelete.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ \"../node_modules/lodash/_assocIndexOf.js\");\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzIiwibWFwcGluZ3MiOiJBQUFBLG1CQUFtQixtQkFBTyxDQUFDLGdFQUFpQjs7QUFFNUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzPzFjNGQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlRGVsZXRlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lodash/_listCacheDelete.js\n");

/***/ }),

/***/ "../node_modules/lodash/_listCacheGet.js":
/*!***********************************************!*\
  !*** ../node_modules/lodash/_listCacheGet.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ \"../node_modules/lodash/_assocIndexOf.js\");\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlR2V0LmpzIiwibWFwcGluZ3MiOiJBQUFBLG1CQUFtQixtQkFBTyxDQUFDLGdFQUFpQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcz81NTkyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lodash/_listCacheGet.js\n");

/***/ }),

/***/ "../node_modules/lodash/_listCacheHas.js":
/*!***********************************************!*\
  !*** ../node_modules/lodash/_listCacheHas.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ \"../node_modules/lodash/_assocIndexOf.js\");\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwibWFwcGluZ3MiOiJBQUFBLG1CQUFtQixtQkFBTyxDQUFDLGdFQUFpQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVIYXMuanM/MjdkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lodash/_listCacheHas.js\n");

/***/ }),

/***/ "../node_modules/lodash/_listCacheSet.js":
/*!***********************************************!*\
  !*** ../node_modules/lodash/_listCacheSet.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ \"../node_modules/lodash/_assocIndexOf.js\");\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzIiwibWFwcGluZ3MiOiJBQUFBLG1CQUFtQixtQkFBTyxDQUFDLGdFQUFpQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsR0FBRztBQUNkLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzPzNjN2MiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lodash/_listCacheSet.js\n");

/***/ }),

/***/ "../node_modules/lodash/_mapCacheClear.js":
/*!************************************************!*\
  !*** ../node_modules/lodash/_mapCacheClear.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Hash = __webpack_require__(/*! ./_Hash */ \"../node_modules/lodash/_Hash.js\"),\n    ListCache = __webpack_require__(/*! ./_ListCache */ \"../node_modules/lodash/_ListCache.js\"),\n    Map = __webpack_require__(/*! ./_Map */ \"../node_modules/lodash/_Map.js\");\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVDbGVhci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxXQUFXLG1CQUFPLENBQUMsZ0RBQVM7QUFDNUIsZ0JBQWdCLG1CQUFPLENBQUMsMERBQWM7QUFDdEMsVUFBVSxtQkFBTyxDQUFDLDhDQUFROztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVDbGVhci5qcz8wYjMwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBIYXNoID0gcmVxdWlyZSgnLi9fSGFzaCcpLFxuICAgIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVDbGVhcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lodash/_mapCacheClear.js\n");

/***/ }),

/***/ "../node_modules/lodash/_mapCacheDelete.js":
/*!*************************************************!*\
  !*** ../node_modules/lodash/_mapCacheDelete.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var getMapData = __webpack_require__(/*! ./_getMapData */ \"../node_modules/lodash/_getMapData.js\");\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMiLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLG1CQUFPLENBQUMsNERBQWU7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzPzVhMzMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lodash/_mapCacheDelete.js\n");

/***/ }),

/***/ "../node_modules/lodash/_mapCacheGet.js":
/*!**********************************************!*\
  !*** ../node_modules/lodash/_mapCacheGet.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var getMapData = __webpack_require__(/*! ./_getMapData */ \"../node_modules/lodash/_getMapData.js\");\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVHZXQuanMiLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLG1CQUFPLENBQUMsNERBQWU7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVHZXQuanM/NjgxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlR2V0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lodash/_mapCacheGet.js\n");

/***/ }),

/***/ "../node_modules/lodash/_mapCacheHas.js":
/*!**********************************************!*\
  !*** ../node_modules/lodash/_mapCacheHas.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var getMapData = __webpack_require__(/*! ./_getMapData */ \"../node_modules/lodash/_getMapData.js\");\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLG1CQUFPLENBQUMsNERBQWU7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanM/Yzk1YyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lodash/_mapCacheHas.js\n");

/***/ }),

/***/ "../node_modules/lodash/_mapCacheSet.js":
/*!**********************************************!*\
  !*** ../node_modules/lodash/_mapCacheSet.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var getMapData = __webpack_require__(/*! ./_getMapData */ \"../node_modules/lodash/_getMapData.js\");\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLG1CQUFPLENBQUMsNERBQWU7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEdBQUc7QUFDZCxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanM/YzRmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlU2V0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lodash/_mapCacheSet.js\n");

/***/ }),

/***/ "../node_modules/lodash/_memoizeCapped.js":
/*!************************************************!*\
  !*** ../node_modules/lodash/_memoizeCapped.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var memoize = __webpack_require__(/*! ./memoize */ \"../node_modules/lodash/memoize.js\");\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsb0RBQVc7O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tZW1vaXplQ2FwcGVkLmpzPzRjNDYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIG1lbW9pemUgPSByZXF1aXJlKCcuL21lbW9pemUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemVDYXBwZWQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lodash/_memoizeCapped.js\n");

/***/ }),

/***/ "../node_modules/lodash/_nativeCreate.js":
/*!***********************************************!*\
  !*** ../node_modules/lodash/_nativeCreate.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var getNative = __webpack_require__(/*! ./_getNative */ \"../node_modules/lodash/_getNative.js\");\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLDBEQUFjOztBQUV0QztBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qcz8xNDQ4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVDcmVhdGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lodash/_nativeCreate.js\n");

/***/ }),

/***/ "../node_modules/lodash/_objectToString.js":
/*!*************************************************!*\
  !*** ../node_modules/lodash/_objectToString.js ***!
  \*************************************************/
/***/ ((module) => {

eval("/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanM/MWNiNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lodash/_objectToString.js\n");

/***/ }),

/***/ "../node_modules/lodash/_root.js":
/*!***************************************!*\
  !*** ../node_modules/lodash/_root.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ \"../node_modules/lodash/_freeGlobal.js\");\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsbUJBQU8sQ0FBQyw0REFBZTs7QUFFeEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanM/YjM3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lodash/_root.js\n");

/***/ }),

/***/ "../node_modules/lodash/_stringToPath.js":
/*!***********************************************!*\
  !*** ../node_modules/lodash/_stringToPath.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var memoizeCapped = __webpack_require__(/*! ./_memoizeCapped */ \"../node_modules/lodash/_memoizeCapped.js\");\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nVG9QYXRoLmpzIiwibWFwcGluZ3MiOiJBQUFBLG9CQUFvQixtQkFBTyxDQUFDLGtFQUFrQjs7QUFFOUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpbmdUb1BhdGguanM/NTBiMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbWVtb2l6ZUNhcHBlZCA9IHJlcXVpcmUoJy4vX21lbW9pemVDYXBwZWQnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ1RvUGF0aDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lodash/_stringToPath.js\n");

/***/ }),

/***/ "../node_modules/lodash/_toKey.js":
/*!****************************************!*\
  !*** ../node_modules/lodash/_toKey.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var isSymbol = __webpack_require__(/*! ./isSymbol */ \"../node_modules/lodash/isSymbol.js\");\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9LZXkuanMiLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxtQkFBTyxDQUFDLHNEQUFZOztBQUVuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9LZXkuanM/NzEzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lodash/_toKey.js\n");

/***/ }),

/***/ "../node_modules/lodash/_toSource.js":
/*!*******************************************!*\
  !*** ../node_modules/lodash/_toSource.js ***!
  \*******************************************/
/***/ ((module) => {

eval("/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvU291cmNlLmpzPzZjNGUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lodash/_toSource.js\n");

/***/ }),

/***/ "../node_modules/lodash/_trimmedEndIndex.js":
/*!**************************************************!*\
  !*** ../node_modules/lodash/_trimmedEndIndex.js ***!
  \**************************************************/
/***/ ((module) => {

eval("/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nmodule.exports = trimmedEndIndex;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdHJpbW1lZEVuZEluZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL190cmltbWVkRW5kSW5kZXguanM/MTdiYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogVXNlZCB0byBtYXRjaCBhIHNpbmdsZSB3aGl0ZXNwYWNlIGNoYXJhY3Rlci4gKi9cbnZhciByZVdoaXRlc3BhY2UgPSAvXFxzLztcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltRW5kYCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlXG4gKiBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuICovXG5mdW5jdGlvbiB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSB7XG4gIHZhciBpbmRleCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgd2hpbGUgKGluZGV4LS0gJiYgcmVXaGl0ZXNwYWNlLnRlc3Qoc3RyaW5nLmNoYXJBdChpbmRleCkpKSB7fVxuICByZXR1cm4gaW5kZXg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJpbW1lZEVuZEluZGV4O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lodash/_trimmedEndIndex.js\n");

/***/ }),

/***/ "../node_modules/lodash/debounce.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/debounce.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var isObject = __webpack_require__(/*! ./isObject */ \"../node_modules/lodash/isObject.js\"),\n    now = __webpack_require__(/*! ./now */ \"../node_modules/lodash/now.js\"),\n    toNumber = __webpack_require__(/*! ./toNumber */ \"../node_modules/lodash/toNumber.js\");\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nmodule.exports = debounce;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9kZWJvdW5jZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsc0RBQVk7QUFDbkMsVUFBVSxtQkFBTyxDQUFDLDRDQUFPO0FBQ3pCLGVBQWUsbUJBQU8sQ0FBQyxzREFBWTs7QUFFbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUSxXQUFXO0FBQzlCLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLCtDQUErQyxpQkFBaUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL2RlYm91bmNlLmpzP2U1OWMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIG5vdyA9IHJlcXVpcmUoJy4vbm93JyksXG4gICAgdG9OdW1iZXIgPSByZXF1aXJlKCcuL3RvTnVtYmVyJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gKiBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICogICAndHJhaWxpbmcnOiBmYWxzZVxuICogfSkpO1xuICpcbiAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxhc3RBcmdzLFxuICAgICAgbGFzdFRoaXMsXG4gICAgICBtYXhXYWl0LFxuICAgICAgcmVzdWx0LFxuICAgICAgdGltZXJJZCxcbiAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICB0aW1lV2FpdGluZyA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmdcbiAgICAgID8gbmF0aXZlTWluKHRpbWVXYWl0aW5nLCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSlcbiAgICAgIDogdGltZVdhaXRpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYm91bmNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lodash/debounce.js\n");

/***/ }),

/***/ "../node_modules/lodash/eq.js":
/*!************************************!*\
  !*** ../node_modules/lodash/eq.js ***!
  \************************************/
/***/ ((module) => {

eval("/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9lcS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9lcS5qcz83NDg2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lodash/eq.js\n");

/***/ }),

/***/ "../node_modules/lodash/get.js":
/*!*************************************!*\
  !*** ../node_modules/lodash/get.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var baseGet = __webpack_require__(/*! ./_baseGet */ \"../node_modules/lodash/_baseGet.js\");\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9nZXQuanMiLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxtQkFBTyxDQUFDLHNEQUFZOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsY0FBYztBQUN6QixXQUFXLEdBQUc7QUFDZCxhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBLGtCQUFrQixRQUFRLE9BQU8sVUFBVTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZ2V0LmpzPzc5ZDQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lodash/get.js\n");

/***/ }),

/***/ "../node_modules/lodash/isArray.js":
/*!*****************************************!*\
  !*** ../node_modules/lodash/isArray.js ***!
  \*****************************************/
/***/ ((module) => {

eval("/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanM/M2VhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lodash/isArray.js\n");

/***/ }),

/***/ "../node_modules/lodash/isFunction.js":
/*!********************************************!*\
  !*** ../node_modules/lodash/isFunction.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ \"../node_modules/lodash/_baseGetTag.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"../node_modules/lodash/isObject.js\");\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0Z1bmN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixtQkFBTyxDQUFDLDREQUFlO0FBQ3hDLGVBQWUsbUJBQU8sQ0FBQyxzREFBWTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNGdW5jdGlvbi5qcz80NmEzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lodash/isFunction.js\n");

/***/ }),

/***/ "../node_modules/lodash/isObject.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/isObject.js ***!
  \******************************************/
/***/ ((module) => {

eval("/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdC5qcz9mNWE1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lodash/isObject.js\n");

/***/ }),

/***/ "../node_modules/lodash/isObjectLike.js":
/*!**********************************************!*\
  !*** ../node_modules/lodash/isObjectLike.js ***!
  \**********************************************/
/***/ ((module) => {

eval("/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanM/NGZkNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lodash/isObjectLike.js\n");

/***/ }),

/***/ "../node_modules/lodash/isSymbol.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/isSymbol.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ \"../node_modules/lodash/_baseGetTag.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"../node_modules/lodash/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsbUJBQU8sQ0FBQyw0REFBZTtBQUN4QyxtQkFBbUIsbUJBQU8sQ0FBQyw4REFBZ0I7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTeW1ib2wuanM/Y2Q3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lodash/isSymbol.js\n");

/***/ }),

/***/ "../node_modules/lodash/memoize.js":
/*!*****************************************!*\
  !*** ../node_modules/lodash/memoize.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var MapCache = __webpack_require__(/*! ./_MapCache */ \"../node_modules/lodash/_MapCache.js\");\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tZW1vaXplLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQyx3REFBYTs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL21lbW9pemUuanM/NDI3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lodash/memoize.js\n");

/***/ }),

/***/ "../node_modules/lodash/now.js":
/*!*************************************!*\
  !*** ../node_modules/lodash/now.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var root = __webpack_require__(/*! ./_root */ \"../node_modules/lodash/_root.js\");\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nmodule.exports = now;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9ub3cuanMiLCJtYXBwaW5ncyI6IkFBQUEsV0FBVyxtQkFBTyxDQUFDLGdEQUFTOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9ub3cuanM/ODVmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcbiAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBEYXRlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAqIH0sIF8ubm93KCkpO1xuICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAqL1xudmFyIG5vdyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBub3c7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lodash/now.js\n");

/***/ }),

/***/ "../node_modules/lodash/set.js":
/*!*************************************!*\
  !*** ../node_modules/lodash/set.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var baseSet = __webpack_require__(/*! ./_baseSet */ \"../node_modules/lodash/_baseSet.js\");\n\n/**\n * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n * it's created. Arrays are created for missing index properties while objects\n * are created for all other missing properties. Use `_.setWith` to customize\n * `path` creation.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to modify.\n * @param {Array|string} path The path of the property to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.set(object, 'a[0].b.c', 4);\n * console.log(object.a[0].b.c);\n * // => 4\n *\n * _.set(object, ['x', '0', 'y', 'z'], 5);\n * console.log(object.x[0].y.z);\n * // => 5\n */\nfunction set(object, path, value) {\n  return object == null ? object : baseSet(object, path, value);\n}\n\nmodule.exports = set;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zZXQuanMiLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxtQkFBTyxDQUFDLHNEQUFZOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsR0FBRztBQUNkLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0Esa0JBQWtCLFFBQVEsT0FBTyxVQUFVO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL3NldC5qcz8xZjRkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBiYXNlU2V0ID0gcmVxdWlyZSgnLi9fYmFzZVNldCcpO1xuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgYSBwb3J0aW9uIG9mIGBwYXRoYCBkb2Vzbid0IGV4aXN0LFxuICogaXQncyBjcmVhdGVkLiBBcnJheXMgYXJlIGNyZWF0ZWQgZm9yIG1pc3NpbmcgaW5kZXggcHJvcGVydGllcyB3aGlsZSBvYmplY3RzXG4gKiBhcmUgY3JlYXRlZCBmb3IgYWxsIG90aGVyIG1pc3NpbmcgcHJvcGVydGllcy4gVXNlIGBfLnNldFdpdGhgIHRvIGN1c3RvbWl6ZVxuICogYHBhdGhgIGNyZWF0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLnNldChvYmplY3QsICdhWzBdLmIuYycsIDQpO1xuICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcbiAqIC8vID0+IDRcbiAqXG4gKiBfLnNldChvYmplY3QsIFsneCcsICcwJywgJ3knLCAneiddLCA1KTtcbiAqIGNvbnNvbGUubG9nKG9iamVjdC54WzBdLnkueik7XG4gKiAvLyA9PiA1XG4gKi9cbmZ1bmN0aW9uIHNldChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lodash/set.js\n");

/***/ }),

/***/ "../node_modules/lodash/toNumber.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/toNumber.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var baseTrim = __webpack_require__(/*! ./_baseTrim */ \"../node_modules/lodash/_baseTrim.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"../node_modules/lodash/isObject.js\"),\n    isSymbol = __webpack_require__(/*! ./isSymbol */ \"../node_modules/lodash/isSymbol.js\");\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b051bWJlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsd0RBQWE7QUFDcEMsZUFBZSxtQkFBTyxDQUFDLHNEQUFZO0FBQ25DLGVBQWUsbUJBQU8sQ0FBQyxzREFBWTs7QUFFbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9OdW1iZXIuanM/OGZhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYmFzZVRyaW0gPSByZXF1aXJlKCcuL19iYXNlVHJpbScpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBOQU4gPSAwIC8gMDtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gYmFzZVRyaW0odmFsdWUpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b051bWJlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lodash/toNumber.js\n");

/***/ }),

/***/ "../node_modules/lodash/toPath.js":
/*!****************************************!*\
  !*** ../node_modules/lodash/toPath.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var arrayMap = __webpack_require__(/*! ./_arrayMap */ \"../node_modules/lodash/_arrayMap.js\"),\n    copyArray = __webpack_require__(/*! ./_copyArray */ \"../node_modules/lodash/_copyArray.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"../node_modules/lodash/isArray.js\"),\n    isSymbol = __webpack_require__(/*! ./isSymbol */ \"../node_modules/lodash/isSymbol.js\"),\n    stringToPath = __webpack_require__(/*! ./_stringToPath */ \"../node_modules/lodash/_stringToPath.js\"),\n    toKey = __webpack_require__(/*! ./_toKey */ \"../node_modules/lodash/_toKey.js\"),\n    toString = __webpack_require__(/*! ./toString */ \"../node_modules/lodash/toString.js\");\n\n/**\n * Converts `value` to a property path array.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Util\n * @param {*} value The value to convert.\n * @returns {Array} Returns the new property path array.\n * @example\n *\n * _.toPath('a.b.c');\n * // => ['a', 'b', 'c']\n *\n * _.toPath('a[0].b.c');\n * // => ['a', '0', 'b', 'c']\n */\nfunction toPath(value) {\n  if (isArray(value)) {\n    return arrayMap(value, toKey);\n  }\n  return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));\n}\n\nmodule.exports = toPath;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b1BhdGguanMiLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxtQkFBTyxDQUFDLHdEQUFhO0FBQ3BDLGdCQUFnQixtQkFBTyxDQUFDLDBEQUFjO0FBQ3RDLGNBQWMsbUJBQU8sQ0FBQyxvREFBVztBQUNqQyxlQUFlLG1CQUFPLENBQUMsc0RBQVk7QUFDbkMsbUJBQW1CLG1CQUFPLENBQUMsZ0VBQWlCO0FBQzVDLFlBQVksbUJBQU8sQ0FBQyxrREFBVTtBQUM5QixlQUFlLG1CQUFPLENBQUMsc0RBQVk7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b1BhdGguanM/OGEyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKSxcbiAgICBzdHJpbmdUb1BhdGggPSByZXF1aXJlKCcuL19zdHJpbmdUb1BhdGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5JyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvUGF0aCgnYS5iLmMnKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICpcbiAqIF8udG9QYXRoKCdhWzBdLmIuYycpO1xuICogLy8gPT4gWydhJywgJzAnLCAnYicsICdjJ11cbiAqL1xuZnVuY3Rpb24gdG9QYXRoKHZhbHVlKSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgdG9LZXkpO1xuICB9XG4gIHJldHVybiBpc1N5bWJvbCh2YWx1ZSkgPyBbdmFsdWVdIDogY29weUFycmF5KHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1BhdGg7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lodash/toPath.js\n");

/***/ }),

/***/ "../node_modules/lodash/toString.js":
/*!******************************************!*\
  !*** ../node_modules/lodash/toString.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var baseToString = __webpack_require__(/*! ./_baseToString */ \"../node_modules/lodash/_baseToString.js\");\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b1N0cmluZy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBbUIsbUJBQU8sQ0FBQyxnRUFBaUI7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzP2NkODYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGJhc2VUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VUb1N0cmluZycpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9TdHJpbmc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lodash/toString.js\n");

/***/ })

}]);